<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Clipped Voronoi Tessellations · DelaunayTriangulation.jl</title><meta name="title" content="Clipped Voronoi Tessellations · DelaunayTriangulation.jl"/><meta property="og:title" content="Clipped Voronoi Tessellations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Clipped Voronoi Tessellations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/clipped/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/clipped/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/clipped/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li class="is-active"><a class="tocitem" href>Clipped Voronoi Tessellations</a><ul class="internal"><li><a class="tocitem" href="#Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull"><span>Computing intersections of the Voronoi polygons and the convex hull</span></a></li><li><a class="tocitem" href="#Clipping-a-Voronoi-polygon-to-a-rectangle"><span>Clipping a Voronoi polygon to a rectangle</span></a></li></ul></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Clipped Voronoi Tessellations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Clipped Voronoi Tessellations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/clipped.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Clipped-Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Clipped-Voronoi-Tessellations">Clipped Voronoi Tessellations</a><a id="Clipped-Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Clipped-Voronoi-Tessellations" title="Permalink"></a></h1><p>Now we consider a variant of the Voronoi tessellation called the <em>clipped Voronoi tessellation</em>. In the clipped Voronoi tessellation, the Voronoi polygons are clipped to the convex hull of the point set. This is useful when we want to ensure that the Voronoi polygons are bounded and do not extend to infinity. The computation of this tessellation is much more involved than the standard Voronoi tessellation. To be exact, we are interested in computing <span>$\tilde{\mathcal V}(\mathcal P) \equiv \mathcal V(\mathcal P) \cap \mathcal C\mathcal H(\mathcal P)$</span>. An example of a clipped Voronoi tessellation is shown below. We will revisit this example throughout the discussion of the algorithm.</p><img src="0aeac925.png" alt="Example block output"/><p>At the end of this section, we also discuss the intersection of <span>$\mathcal V(\mathcal P)$</span> with a rectangle.</p><h2 id="Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull"><a class="docs-heading-anchor" href="#Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull">Computing intersections of the Voronoi polygons and the convex hull</a><a id="Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull" title="Permalink"></a></h2><p>The main complication with clipping the Voronoi polygons to the convex hull is in computing all the intersections of the polygons with the convex hull. For this step, we use an iterative approach. The steps are described below. We will start by describing the algorithm in words, and then provide a clearer example.</p><h3 id="Initialising-the-queue"><a class="docs-heading-anchor" href="#Initialising-the-queue">Initialising the queue</a><a id="Initialising-the-queue-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-queue" title="Permalink"></a></h3><p>We maintain a queue of edges to determine where we need to process the intersections. First, we initialise a set <span>$\mathcal E$</span> containing all boundary edges. We take a random edge <span>$e \in \mathcal E$</span> and use it to initialise a queue <span>$\mathcal Q$</span> of polygon edges. To be specific, into <span>$\mathcal Q$</span> we enqueue <span>$(e, \mathcal V)$</span>, where <span>$\mathcal V_i$</span> is the polygon incident to the boundary edge <span>$e$</span>; we find this incident polygon by finding the nearest neighbour to the edge&#39;s midpoint.</p><h3 id="Processing-an-edge"><a class="docs-heading-anchor" href="#Processing-an-edge">Processing an edge</a><a id="Processing-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-an-edge" title="Permalink"></a></h3><p>If either of <span>$\mathcal Q$</span> or <span>$\mathcal E$</span> are not empty, we can consider processing an edge for intersections. If <span>$\mathcal Q = \emptyset$</span>, we take the next edge in <span>$\mathcal E$</span> and enqueue it and its incident polygon into <span>$\mathcal Q$</span>. Now, dequeue a pair <span>$(e, \mathcal V)$</span> from <span>$\mathcal Q$</span>. If the pair <span>$(e, \mathcal V)$</span> has already been processed, we skip this step and dequeue the next pair from <span>$\mathcal Q$</span>.</p><p>For the first step of this processing, we need to find any intersections of <span>$e$</span> with the polygon <span>$\mathcal V$</span>. To do this, we first find the edges <span>$e_\ell$</span> and <span>$e_r$</span> left and right of <span>$e$</span>, respectively. We then need to consider each edge of <span>$\mathcal V$</span>. Let <span>$s$</span> be an edge of <span>$\mathcal V$</span>. How <span>$s$</span> intersects the edges depends on whether (1) it is an unbounded ray oriented so that it is going out to infinity, (2) it is an unbounded ray oriented so that it is coming in from infinity, or (3) it is a bounded edge. The first two cases are reasonably straightforward - just compute the intersection of the edge with the unbounded rays. For the third case, we compute all the intersections of <span>$e$</span>, <span>$e_\ell$</span>, and <span>$e_r$</span> with <span>$s$</span>. The reason for needing to check all of <span>$e$</span>, <span>$e_\ell$</span>, and <span>$e_r$</span> rather than <span>$e$</span> alone is that there may be issues finding intersections when considering Voronoi polygons near corners of the convex hull.</p><p>Once we have processed all of the edges of <span>$\mathcal V$</span>, we store the intersections of the edges with <span>$e$</span>, <span>$e_\ell$</span>, and <span>$e_r$</span> into the sets <span>$\mathcal E(\mathcal V)$</span>, <span>$\mathcal L(\mathcal V)$</span>, and <span>$\mathcal R(\mathcal V)$</span>, respectively. We use these intersections to determine what edges need to be enqueued into <span>$\mathcal Q$</span>, taking care that we do not miss any corner points. Consider some intersection point <span>$p \in \mathcal L(\mathcal V)$</span>; the cases for the other sets are similar. If <span>$(e_\ell, \mathcal V)$</span> has not been processed, then we enqueue <span>$(e_\ell, \mathcal V_i)$</span> and <span>$(e_\ell, \mathcal V_j)$</span> into <span>$\mathcal Q$</span>, where <span>$v_i$</span> and <span>$v_j$</span> are the vertices of <span>$e_\ell$</span>. This ensures that we will find the intersections next to this polygon. After enqueueing these pairs, we still need to protect against corner points. To do this, we note that a corner point only needs to be checked if the incident polygon <span>$\mathcal V$</span> belongs to the boundary of the convex hull. If it is, then let <span>$v_u$</span> be the shared vertex between <span>$e_i$</span> and <span>$e_\ell$</span>. If <span>$v_u$</span> is exactly the generator of <span>$\mathcal V$</span>, then we have a corner point, and so we need to add this corner point into the set of intersections since it will necessarily be included in the clipped Voronoi tessellation. Once we have processed all the intersections for <span>$e$</span>, <span>$e_\ell$</span>, and <span>$e_r$</span> as above, we need to then also enqueue all of the edges and their adjacent incident poygons into <span>$\mathcal Q$</span>, provided that these pairs have not already been processed.</p><p>Let us give an example that illustrates this part of the procedure clearly.</p><img src="2fbb62b2.png" alt="Example block output"/><p>In the first figure above, we are considering the processing of an edge <span>$e$</span>. The Voronoi polygon <span>$\mathcal V$</span> we consider incident to <span>$e$</span> is shown, obtained by finding that the midpoint of <span>$e$</span> is contained in <span>$\mathcal V$</span>. By just processing the intersections of <span>$\mathcal V$</span>, we find the intersections with <span>$\mathcal C\mathcal H(\mathcal P)$</span> (shown in magenta) shown in orange. This alone is not enough, though, as we can see that we don&#39;t identify that the black dot between <span>$e_\ell$</span> and <span>$e$</span> should be included in this intersection. This dot is an example of a corner point we were discussing previously, showing the need for this extra processing step. Note also from the above figure that  unbounded polygons <span>$\mathcal V$</span> alone are not sufficient for checking all intersections, as we can see that some of the bounded polygons also intersect with the convex hull. Eventually, after processing all edges in this way, we obtain the set of orange points shown in the second figure.</p><h3 id="Clipping-the-polygons"><a class="docs-heading-anchor" href="#Clipping-the-polygons">Clipping the polygons</a><a id="Clipping-the-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping-the-polygons" title="Permalink"></a></h3><p>Once all the intersections have been computed, clipping the polygons is straightforward. For each <span>$\mathcal V$</span> for which intersections were found, we store with it all intersections found between it and the convex hull. We then remove all vertices from <span>$\mathcal V$</span> that are outside of the domain and then add in these intersection points, sorting <span>$\mathcal V$</span> as needed so that it remains a convex polygon. Doing this for all <span>$\mathcal V$</span> completes the clipping, giving the tessellation shown at the start of this section.</p><h2 id="Clipping-a-Voronoi-polygon-to-a-rectangle"><a class="docs-heading-anchor" href="#Clipping-a-Voronoi-polygon-to-a-rectangle">Clipping a Voronoi polygon to a rectangle</a><a id="Clipping-a-Voronoi-polygon-to-a-rectangle-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping-a-Voronoi-polygon-to-a-rectangle" title="Permalink"></a></h2><p>Now let us describe clipping to some rectangle <span>$\mathcal R = [a, b] \times [c, d]$</span> rather than to the convex hull. The procedure here is very different, and rather than processing the entire tessellation at once we apply the procedure to individual polygons. Before we discuss this procedure in general, we need to discuss two algorithms: The Sutherland-Hodgman algorithm and the Liang-Barsky algorithm.</p><h3 id="The-Sutherland-Hodgman-algorithm"><a class="docs-heading-anchor" href="#The-Sutherland-Hodgman-algorithm">The Sutherland-Hodgman algorithm</a><a id="The-Sutherland-Hodgman-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Sutherland-Hodgman-algorithm" title="Permalink"></a></h3><p>The Sutherland-Hodgman algorithm is an algorithm for clipping a polygon (called the subject polygon) to a convex polygon (called the clip polygon). The algorithm works by essentially extending each edge of the clip polygon to infinity and then iteratively clipping the subject polygon to each edge of the clip polygon. Let us give an example of this.</p><img src="10908dca.png" alt="Example block output"/><p>In the figure above, the black polygon shows the subject polygon and the red polygon is the clip polygon. Our aim is to clip the subject polygon to the clip polygon to obtain the blue polygon shown. Letting <span>$\mathcal P_S = \{p_1, \ldots, p_n\}$</span> and <span>$\mathcal P_C = \{q_1, \ldots, q_m\}$</span> be the subject and clip polygons listed in counter-clockwise order with <span>$p_1 \neq p_n$</span> and <span>$q_1 \neq q_m$</span>, respectively, the procedure for this clipping as follows:</p><ol><li>Define <span>$\mathcal O = \mathcal P_S$</span> and let <span>$q = q_n$</span>. For each <span>$p \in \mathcal P_C$</span>, we first let <span>$\mathcal I = \mathcal O$</span> and then reset <span>$\mathcal O = \emptyset$</span>.</li><li>With this <span>$p$</span>, let <span>$s = \mathcal I_r$</span>, where <span>$|\mathcal I| = r$</span> and <span>$\mathcal I_j$</span> denotes the <span>$j$</span>th element of <span>$\mathcal I$</span>. For <span>$i=1,2,\ldots,r$</span>, we consider the edge <span>$e = (s, \mathcal I_i)$</span>. If <span>$\mathcal I_i$</span> is left of <span>$\overrightarrow{qp}$</span>, then it is outside of <span>$\mathcal P_S$</span>, and so we need to check if there is any intersection, i.e. if <span>$e$</span> intersects <span>$\overrightarrow{qp}$</span>, which can be easily checked by considering the position of <span>$s$</span> relative to <span>$\overrightarrow{qp}$</span>. If  <span>$\mathcal I_i$</span> is not left of <span>$\overrightarrow{qp}$</span> but <span>$s$</span> is left, then there must be an intersection of <span>$e$</span> with <span>$\overrightarrow{qp}$</span> since <span>$s$</span> and <span>$\mathcal I_i$</span> are on opposite sides of <span>$\overrightarrow{qp}$</span>. In either of these cases, the intersection that we find gets pushed into <span>$\mathcal O$</span>, and we then set <span>$s = \mathcal I_i$</span> and continue onto the next <span>$i$</span>.</li><li>Once we have processed each <span>$\mathcal I_i$</span>, we set <span>$q = p$</span> and then continue onto the next <span>$p$</span> in <span>$\mathcal P_C$</span>.</li><li>Finally, once each vertex in <span>$\mathcal P_C$</span> has been processed, the final polygon is defined by the points in <span>$\mathcal O$</span>.</li></ol><p>Let&#39;s visualise this procedure.</p><img src="c500263f.png" alt="Example block output"/><p>In the figure above, we show the individual steps of this algorithm. In the second panel, the blue line shows the extended edge of the clip polygon that we use to slice the subject polygon, clipping it onto the edge. For the next four panels, the blue line never touches the subject polygon, and so nothing happens. The last two panels show the last two clips needed to obtain the final polygon.</p><h3 id="The-Liang-Barsky-algorithm"><a class="docs-heading-anchor" href="#The-Liang-Barsky-algorithm">The Liang-Barsky algorithm</a><a id="The-Liang-Barsky-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Liang-Barsky-algorithm" title="Permalink"></a></h3><p>Now we describe the Liang-Barsky algorithm, an algorithm for clipping a line segment to a rectangle. Let us take a line <span>$\vb p(t) = \vb p_0 + t\vb d$</span>, where <span>$\vb p_0 = (x_0, y_0)$</span>, <span>$\vb d = (\Delta x, \Delta y)$</span>, and <span>$0 \leq t \leq 1$</span>. A point <span>$(x, y) = \vb p(t)$</span> is in the rectangle if (1) <span>$a \leq x_0 + t \Delta x \leq b$</span> and (2) <span>$c \leq y_0 = t \Delta y \leq d$</span>, or equivalently <span>$tp_i \leq q_i$</span> for <span>$i=1,2,3,4$</span>, where:</p><ol><li><em>Left edge</em>: <span>$p_1 = -\Delta x$</span>, <span>$q_1 = x_0 - a$</span>.</li><li><em>Right edge</em>: <span>$p_2 = \Delta x$</span>, <span>$q_2 = b - x_0$</span>.</li><li><em>Bottom edge</em>: <span>$p_3 = -\Delta y$</span>, <span>$q_3 = y_0 - c$</span>.</li><li><em>Top edge</em>: <span>$p_4 = \Delta y$</span>, <span>$q_4 = d - y_0$</span>.</li></ol><p>Using these inequalities, we can efficiently compute the intersections by processing each side of the rectangle at a time. Starting with <span>$t_1 = 0$</span> and <span>$t_2 = 1$</span> defining the current interval for the intersections, for each edge we do the following: Compute the <span>$p_i$</span> and <span>$q_i$</span> associated with the edge, and then <span>$r_i = q_i / p_i$</span>. This <span>$r_i$</span> gives the parameter value for the intersection point of the line and the current edge (possibly extended outside of <span>$0 \leq t \leq 1$</span>). There are three cases to consider:</p><ol><li>If <span>$p_i = 0$</span> and <span>$q_i &lt; 0$</span>, then the line is parallel with the edge but outside of the rectangle, and so there are no intersections of the line with the rectangle.</li><li>If <span>$p_i &gt; 0$</span> and <span>$r &lt; t_1$</span>, then the the line enters the rectangle earlier than what is proposed by the current interval <span>$[t_1, t_2]$</span>, and so the line is outside of the rectangle and we have no intersections to consider. If <span>$r &lt; t_2$</span>, then we update the intersection interval and let <span>$t_2 = r$</span>.</li><li>If <span>$p_i &lt; 0$</span> and <span>$r &gt; t_2$</span>, then just like above we see that the line is outside of the rectangle and so we return no intersections. If <span>$r &gt; t_1$</span>, set <span>$t_1 = r$</span>.</li></ol><p>Applying these cases to each edge one at a time, updating <span>$t_1$</span> and <span>$t_2$</span> as required, gives the intersection parameters <span>$t_1$</span> and <span>$t_2$</span> defining the intersection of the line with the rectangle. If we ever did exit early, then we do not return any intersections.</p><h3 id="Clipping-a-bounded-Voronoi-polygon"><a class="docs-heading-anchor" href="#Clipping-a-bounded-Voronoi-polygon">Clipping a bounded Voronoi polygon</a><a id="Clipping-a-bounded-Voronoi-polygon-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping-a-bounded-Voronoi-polygon" title="Permalink"></a></h3><p>Now that we have two important algorithms for clipping, let us begin our discussion on clipping the Voronoi polygons in particular, starting with bounded Voronoi polygons. This case is simple - simply apply the Sutherland-Hodgman algorithm to the polygon, using the clip polygon as the rectangle.</p><h3 id="Clipping-an-unbounded-Voronoi-polygon"><a class="docs-heading-anchor" href="#Clipping-an-unbounded-Voronoi-polygon">Clipping an unbounded Voronoi polygon</a><a id="Clipping-an-unbounded-Voronoi-polygon-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping-an-unbounded-Voronoi-polygon" title="Permalink"></a></h3><p>The case of clipping an unbounded Voronoi polygon is more complicated. Rather than trying to come up with an effective way to clip the unbounded rays of the polygon to a rectangle and taking care of all the possible edge cases, we use a more direct approach. Our aim is to convert the unbounded polygon into a finite polygon such that its intersection with the rectangle is the same as the intersection of the unbounded polygon with the rectangle. We do this in steps.</p><ol><li><p>First, for the two unbounded edges, we let <span>$u_m$</span> and <span>$v_m$</span> be the two midpoints of the edges of the convex hull that the unbounded edges go through.</p></li><li><p>Next, we compute the maximum distance of the box to <span>$u_m$</span> and <span>$v_m$</span>, letting <span>$m = \max\{\operatorname{dist}(u_m, \mathcal R), \operatorname{dist}(v_m, \mathcal R)\}$</span>.</p><p>Now, starting with <code>inside = true</code> and <span>$t = 1$</span>, we do the following until <code>inside = false</code>.</p></li><li><p>Replace <span>$t$</span> by <span>$2t$</span>, and compute <span>$p = u_m + td_1$</span>, where <span>$d_1$</span> is a unit vector in the direction of the unbounded edge associated with <span>$u_m$</span>, and similarly <span>$q = v_m + td_2$</span>. </p></li><li><p>Apply the Liang-Barsky algorithm to <span>$\mathcal R$</span> and the line segment through <span>$p$</span> and <span>$q$</span>, and check if the line segment is completely outside of <span>$\mathcal R$</span>. If it is, then set <code>outside = true</code>.</p></li><li><p>We then need to be careful about the case where the generator associated with the polygon is outside of <span>$\mathcal R$</span>. In this case, the unbounded edge might start outside of the rectangle and eventually find its way inside. To avoid this, we be conservative and check that the length of each ray is greater than the maximum distance from <span>$u_m$</span> and <span>$v_m$</span> to the clip rectangle. In particular, compute <span>$\delta_1 = \|p - u_m\|$</span> and <span>$\delta_2 = \|q - v_m\|$</span>. If <span>$\min\{\delta_1, \delta_2\} &lt; m$</span>, then the edge might possibly be inside <span>$\mathcal R$</span>. If this is the case, we let <code>inside = true</code> and continue, and otherwise we let <code>inside = false</code>.</p></li><li><p>Once we stop iterating, the final values of <span>$p$</span> and <span>$q$</span> are the points that the unbounded edges will now stop at, thus defining a bounded polygon.</p></li></ol><p>The reason we start with <span>$t = 1$</span> instead of, say, <span>$t = 1$</span> is so that we start at <span>$t = 2$</span> in the loop and avoid any possibility of duplicated vertices for polygons completely outside of the box. Note also that an important reason that we need to apply the Liang-Barsky algorithm to the line segment through <span>$p$</span> and <span>$q$</span> is so that we can join the two unbounded edges together and be confident that this line is completely outside of this rectangle.  Let&#39;s make this polygon growing procedure clearer with an example, where we also pick a complicated example that demonstrates the need for the conservative check in the fifth step.</p><img src="2d0e8ff4.png" alt="Example block output"/><p>In the figure above, the polygon we are interested is the one corresponding to the black dot, and we want to clip this polygon to the red rectangle. The following figures show how we grow the polygon&#39;s unbounded edges to begin.</p><img src="02513d5c.png" alt="Example block output"/><p>In these figures, the blue polygon shows the Voronoi polygon, and the green edges show the approximations to the unbounded rays; the top-most ray starts away from the polygon since the midpoint is further behind the associated circumcenter in this case. The magenta line shows the line segment joining the two approximations - the aim is to grow the green edges long enough such that the magenta line is completely outside of the red rectangle. Let&#39;s analyse each figure.</p><ol><li>At <span>$t = 1$</span>, the line segment is outside of the rectangle, but there is still room to grow the green edges such that they go through the clip rectangle (in particular, the right-most edge). Since the maximum distance of the green edges is not larger than the maximum distance from the green edge&#39;s origins to the clip rectangle, our procedure will continue to grow the edges.</li><li>At <span>$t = 2$</span>, we have the same problem as at <span>$t=1$</span> in that the magenta edge is still outside of the clip rectangle but the green edges can still grow into the clip rectangle.</li><li>At <span>$t = 4$</span>, the magenta edge is finally inside of the clip rectangle, but since it intersects it we need to keep growing the green edges until the magenta edge leaves again.</li><li>The situation at <span>$t=8$</span> is the same as at <span>$t=4$</span>.</li><li>Finally, at <span>$t=18$</span>, the magenta edge is completely outside of the clip rectangle, and the length of the two green edges is now greater than the maximum distance from the green edge&#39;s origins to the clip rectangle. Thus, we can stop growing the unbounded edges here.</li><li>The final figure shows the bounded polygon obtained by growing the unbounded edges (with the left side of it out of frame).</li></ol><p>Once a bounded polygon representing the unbounded polygon has been obtained, we apply the Sutherland-Hodgman algorithm as before to clip it to the rectangle. For the example above, the polygon we obtain is shown below.</p><img width=332 height=332 style='object-fit: contain; height: auto;' src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAApgAAAKYCAIAAABYUx+eAAAABmJLR0QA/wD/AP+gvaeTAAALtUlEQVR4nO3cIY7VUBSA4RbGo3AkJCgMGXaEAoNiCzgMGxg1moxAA5vAIdgAjmBIEEVAQiADJJPX3vlfv8+/9rj/3ZuTzsuyTABA043RAwAAVyfkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQJuQAECbkABAm5AAQdrLq0+d5XvX5AHD9Lcuy3sOdyAEgbN0T+Q+r/hMBgGtrg5tpJ3IACBNyAAgTcgAIE3IACBNyAAgTcgAIE3IACBNyAAgTcgAI2+LLbgCMdH4+ffo0eojNPXky3bo1eogtzKt+P/XHp+l8ohVgpNPT6f370UNs7uPH6d690UNs0UFX6wAQ5modYDcePZpu3x49xMrOzqbPn0cPsSkhB9iNZ8+m09PRQ6zs4mJvIXe1DgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOAGFCDgBhQg4AYUIOsBcPnz8cPQKHJ+QAECbkABAm5AAQJuQAECbkABAm5AA7Mj+eR4/AgQk5AIQJOQCECTkAhAk5AIQJOQCECTnAvlhcPzJCDgBhQg4AYUIOAGFCDgBhQg4AYUIOsDsW14+JkANAmJADQJiQA0CYkANAmJADQJiQA+yRxfWjIeQAECbkABAm5AAQJuQAECbkADtl3+04CDkAhAk5AIQJOQCECTkAhAk5AIQJOcB+WVw/AkIOAGFCDgBhQg4AYUIOAGFCDgBhQg6waxbX64QcAMKEHADChBwAwoQcAMKEHADChBxg7yyupwk5AIQJOQCECTkAhAk5AIQJOQCECTkAFtfDhBwAwoQcAMKEHADChBwAwoQcgGmy75Yl5AAQJuQAECbkABAm5AAQJuQAECbkAPxkcb1IyAEgTMgBIEzIASBMyAEgTMgB+MW+W46QA0CYkANAmJADQJiQA0CYkANAmJAD8BuL6y1CDgBhQg4AYUIOAGFCDgBhQg4AYUIOwJ8srocIOQCECTkAhAk5AIQJOQCECTkAhAk5AJewuF4h5AAQJuQAECbkABAm5AAQJuQAECbkAFzO4nqCkANAmJADQJiQA0CYkANAmJAD8Ff23a4/IQeAMCEHgDAhB4AwIQeAMCEHgDAhB+BfLK5fc0IOAGFCDgBhQg4AYSejBwBgI3e/TF9vXumXHz4ceJT1fPs2eoKtCTnAXrx+c9Vfvrp/yDk4KFfrAMfuxYuXD0bPwGrmZVlWfPo8T9O06isA+L+3b6enT0cPsa1376Y7d0YPsUUHhRwA1rJBB12tA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQJiQA0CYkANAmJADQNjJBu+Y53mDtwDADjmRA0DYvCzL6BkAgCtyIgeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4AwIQeAMCEHgDAhB4Cw7yLaUo06UP0AAAAAAElFTkSuQmCC"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../voronoi/">« Voronoi Tessellations</a><a class="docs-footer-nextpage" href="../centroidal/">Centroidal Voronoi Tessellations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 8 May 2024 12:46">Wednesday 8 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
