<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pole of Inaccessibility and Polygons · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/other_features/pole_of_inaccessibility/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../point_location/">Point Location</a></li><li class="is-active"><a class="tocitem" href>Pole of Inaccessibility and Polygons</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Other Features</a></li><li class="is-active"><a href>Pole of Inaccessibility and Polygons</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Pole of Inaccessibility and Polygons</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/other_features/pole_of_inaccessibility.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Pole-of-Inaccessibility-and-Polygons"><a class="docs-heading-anchor" href="#Pole-of-Inaccessibility-and-Polygons">Pole of Inaccessibility and Polygons</a><a id="Pole-of-Inaccessibility-and-Polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Pole-of-Inaccessibility-and-Polygons" title="Permalink"></a></h1><p>We provide a function for computing the pole of inaccessibility of a given polygon, namely the point inside the polygon that is furthest from the boundary. Our method is primarily based on <a href="https://blog.mapbox.com/a-new-algorithm-for-finding-a-visual-center-of-a-polygon-7c77e6492fbc">this blogpost</a>, recursively subdividing the polygon using quadtree partitioning. The function for this is <code>pole_of_inaccessibility</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.pole_of_inaccessibility" href="#DelaunayTriangulation.pole_of_inaccessibility"><code>DelaunayTriangulation.pole_of_inaccessibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_of_inaccessibility(pts, boundary_nodes; precision = one(number_type(pts)))</code></pre><p>Given a collection of points <code>pts</code> and a set of <code>boundary_nodes</code> defining  a polygon, finds the pole of inaccessibility. Works with holes, provided  <code>boundary_nodes</code> represents these as described in <a href="../../interface/interface/#DelaunayTriangulation.Interfaces"><code>Interfaces</code></a>.</p><p>The pole of inaccessibility is a point within a polygon that is further from an  edge. It is useful for our purposes since it is a representative point that is  guaranteed to be inside the polygon, in contrast to for example a centroid which  is not always inside the polygon.</p><p>You can control the tolerance of the method using <code>atol</code> and <code>rtol</code>,  so that results are compared to <code>atol + rtol * w</code>, where <code>w</code> is half the  extent of the polygon.</p><p>See https://blog.mapbox.com/a-new-algorithm-for-finding-a-visual-center-of-a-polygon-7c77e6492fbc or https://github.com/mapbox/polylabel for more information. This implementation was partially based  on https://github.com/Twista/python-polylabel and https://github.com/asinghvi17/Polylabel.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/polygon_utils.jl#L253-L272">source</a></section></article><p>We needed this method since the point we need to associate ghost vertices with must be inside the domain, and so other representative points like centroids or arithmetic averages would not be sufficient if the domain is non-convex.</p><p>Below we also list some other relevant docstrings.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.polygon_features" href="#DelaunayTriangulation.polygon_features"><code>DelaunayTriangulation.polygon_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polygon_features(pts, boundary_nodes)</code></pre><p>Given some points <code>pts</code> and a collection of boundary nodes, returns <code>(a, (cx, cy))</code>,  where <code>a</code> is the area of the polygon represented by the nodes and <code>(cx, cy)</code> is the centroid.  Works with holes, provided <code>boundary_nodes</code> represents these as described in <a href="../../interface/interface/#DelaunayTriangulation.Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/polygon_utils.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.squared_distance_to_segment" href="#DelaunayTriangulation.squared_distance_to_segment"><code>DelaunayTriangulation.squared_distance_to_segment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">squared_distance_to_segment(x₁, y₁, x₂, y₂, x, y)</code></pre><p>Given a line segment <code>(x₁, y₁) → (x₂, y₂)</code> and a query point  <code>(x, y)</code>, returns the squared distance from <code>(x, y)</code> to the  line segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/polygon_utils.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.distance_to_polygon" href="#DelaunayTriangulation.distance_to_polygon"><code>DelaunayTriangulation.distance_to_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance_to_polygon(q, pts, boundary_nodes)</code></pre><p>Given a query point <code>q</code>, a collection of points <code>pts</code>, and a set of <code>boundary_nodes</code>,  returns the distance from <code>q</code> to the combined polygon. If <code>q</code> is outside of the polygon,  then the returned distance is negative, and if it is inside then the distance  is positive. Works with holes, provided <code>boundary_nodes</code>  represents these as described in <a href="../../interface/interface/#DelaunayTriangulation.Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/polygon_utils.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.polygon_bounds" href="#DelaunayTriangulation.polygon_bounds"><code>DelaunayTriangulation.polygon_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polygon_bounds(pts, boundary_nodes)</code></pre><p>Given a collection of points <code>pts</code> and <code>boundary_nodes</code>, to be interpreted as a polygon, returns  the coordinates for a bounding box of the polygon, in the order <code>(xmin, xmax, ymin, ymax)</code>.  Works with holes, provided <code>boundary_nodes</code> represents these as described in <a href="../../interface/interface/#DelaunayTriangulation.Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/polygon_utils.jl#L201-L207">source</a></section></article><p>If you need to compute this for multiple boundaries, meaning multiple poles, use <code>compute_representative_points!</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.compute_representative_points!" href="#DelaunayTriangulation.compute_representative_points!"><code>DelaunayTriangulation.compute_representative_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) &amp;&amp; num_boundary_edges(get_boundary_nodes(tri)) == 0))</code></pre><p>Given a triangulation <code>tri</code>, computes representative points for each region using  <a href="#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>. If you only want to update the point for the convex hull, set <code>use_convex_hull = true</code> - this will only update <code>RepresentativePointList[1]</code>.</p><p>See also <a href="../../data_structures/representative/#DelaunayTriangulation.RepresentativePointList"><code>RepresentativePointList</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like <code>update_centroid_after_addition</code>  and <code>update_centroid_after_deletion</code> treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of <a href="../../triangulations/unconstrained/#DelaunayTriangulation.triangulate"><code>triangulate</code></a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1206-L1222">source</a></section><section><div><pre><code class="language-julia hljs">compute_representative_points!(points, boundary_nodes; precision = 1.0)</code></pre><p>Given a list of <code>points</code> and a list of <code>boundary_nodes</code>, computes visual centers for  the polygons represented by these curves using <a href="#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>. The  keyword argument <code>precision</code> is the precision used in <a href="#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>.</p><p>See also <a href="../../data_structures/representative/#DelaunayTriangulation.RepresentativePointList"><code>RepresentativePointList</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like <code>update_centroid_after_addition</code>  and <code>update_centroid_after_deletion</code> treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of <a href="../../triangulations/unconstrained/#DelaunayTriangulation.triangulate"><code>triangulate</code></a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/representative.jl#L159-L175">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Below is a simple example of computing this pole of inaccessibility.</p><pre><code class="language-julia hljs">pts = [0.0 8.0
      2.0 5.0
      3.0 7.0
      1.81907 8.13422
      3.22963 8.865
      4.24931 7.74335
      4.50423 5.87393
      3.67149 4.3784
      2.73678 2.62795
      5.50691 1.38734
      8.43 2.74691
      9.7046 5.53404
      8.56595 7.79433
      6.71353 9.03494
      4.13034 9.66375
      2.75378 10.3775
      1.0883 10.4965
      -1.138 9.83369
      -2.25965 8.45712
      -2.78649 5.94191
      -1.39292 3.64763
      0.323538 4.97322
      -0.900078 6.6217
      0.98633 9.68074
      0.153591 9.54478
      0.272554 8.66106
      2.90673 8.18521
      2.12497 9.42582
      7.27436 2.7979
      3.0 4.0
      5.33697 1.88019]&#39;
boundary_nodes = [
      [[1, 4, 3, 2], [2, 9, 10, 11, 8, 7, 12], [12, 6, 13, 5, 14, 15, 16, 17, 16], [16, 17, 18, 19, 20, 21, 22, 23, 1]],
      [[26, 25, 24], [24, 28, 27, 26]],
      [[29, 30, 31, 29]]
]
x, y = DT.pole_of_inaccessibility(pts, boundary_nodes)

fig = Figure()
ax = Axis(fig[1, 1], xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;)
bn1 = pts[:, unique(reduce(vcat, boundary_nodes[1]))] |&gt; x -&gt; hcat(x, x[:, begin])
bn2 = pts[:, unique(reduce(vcat, boundary_nodes[2]))] |&gt; x -&gt; hcat(x, x[:, begin])
bn3 = pts[:, unique(reduce(vcat, boundary_nodes[3]))] |&gt; x -&gt; hcat(x, x[:, begin])
lines!(ax, bn1, color=:red, linewidth=4)
lines!(ax, bn2, color=:red, linewidth=4)
lines!(ax, bn3, color=:red, linewidth=4)
scatter!(ax, [x], [y], color=:blue, markersize=23)</code></pre><figure>
    <img src='../figs/pole_of_inaccessibility.png', alt='Pole of inaccessibility'><br>
</figure></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../point_location/">« Point Location</a><a class="docs-footer-nextpage" href="../convex_hull/">Convex Hull »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 24 February 2023 21:59">Friday 24 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
