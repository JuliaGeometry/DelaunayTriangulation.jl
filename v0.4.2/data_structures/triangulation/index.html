<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Triangulation · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/data_structures/triangulation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../adjacent/">Adjacent</a></li><li><a class="tocitem" href="../adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../graph/">Graph</a></li><li><a class="tocitem" href="../representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li class="is-active"><a class="tocitem" href>Triangulation</a><ul class="internal"><li><a class="tocitem" href="#Useful-Methods"><span>Useful Methods</span></a></li></ul></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Data Structures</a></li><li class="is-active"><a href>Triangulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Triangulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/data_structures/triangulation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Triangulation"><a class="docs-heading-anchor" href="#Triangulation">Triangulation</a><a id="Triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulation" title="Permalink"></a></h1><p>The most important structure of the package is the Triangulation data structure. Its complete definition is given below, and then afterwards we give all the docstrings for methods that are useful for working with triangulations.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.Triangulation" href="#DelaunayTriangulation.Triangulation"><code>DelaunayTriangulation.Triangulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Triangulation{P,Ts,I,E,Es,BN,B,BIR}</code></pre><p>Struct for a triangulation.</p><p>See also <a href="../../triangulations/unconstrained/#DelaunayTriangulation.triangulate"><code>triangulate</code></a> and <a href="../../triangulations/gmsh/#DelaunayTriangulation.generate_mesh"><code>generate_mesh</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>points::P</code></li></ul><p>The nodes in the triangulation.</p><ul><li><code>triangles::Ts</code></li></ul><p>The triangles in the triangulation. All triangles are positively oriented.</p><ul><li><code>adjacent::Adjacent{I, E}</code></li></ul><p>The <a href="../adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map, mapping edges to vertices that together form a  positively oriented triangle in <code>triangles</code>. See also <a href="../adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a>.</p><ul><li><code>adjacent2vertex::Adjacent2Vertex{I,Es,E}</code></li></ul><p>The <a href="../adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map, mapping vertices to all edges that together  form a positively oriented triangle in <code>triangles</code>. See also <a href="../adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a>.</p><ul><li><code>graph::Graph{I}</code></li></ul><p>The <a href="../graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>, mapping vertices to all other vertices that are connected with  that vertex via an edge of a triangle in <code>triangles</code>. See also <a href="../graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</p><ul><li><code>boundary_nodes::BN</code></li></ul><p>The boundary nodes, with the outer boundary given in counter-clockwise order and the inner boundaries given in clockwise order. The default  (default because you could customise it if you wish, see  <a href="../../interface/interface/#DelaunayTriangulation.Interfaces"><code>Interfaces</code></a>) form of this field depends on your domain:</p><p>– <code>Vector{Int64}</code></p><p>If you provide no boundary curves or provide a single connected boundary curve, this  will be a counter-clockwise vector of boundary nodes with <code>boundary_nodes[begin] ==  boundary_nodes[end]</code>. Note that if no boundary curve was provided, this gives the  convex hull of <code>points</code>.</p><p>– <code>Vector{Vector{Int64}}</code></p><p>In this case, you have provided a single boundary curve but separated into different parts.  In this case, <code>boundary_nodes[n]</code> gives the boundary nodes for the <code>n</code>th segment. Additionally, <code>boundary_nodes[n][end] == boundary_nodes[n+1][begin]</code> and <code>boundary_nodes[end][end] == boundary_nodes[begin][begin]</code>. The nodes should be counter-clockwise in this case also.</p><p>– <code>Vector{Vector{Vector{Int64}}}</code></p><p>In this case, you have provided multiple boundary curves each separated into different parts,  e.g. an annulus with each circle split into its lower and upper halves. The component  <code>boundary_nodes[m][n]</code> gives the boundary nodes for the <code>n</code>th segment of the <code>m</code>th  boundary curve, with <code>boundary_nodes[begin]</code> the outer-most boundary and <code>boundary_nodes[i]</code> the  inner boundaries (<code>i &gt; 1</code>). As in the previous case, <code>boundary_nodes[m][n][end] == boundary_nodes[m][n+1][begin]</code> and <code>boundary_nodes[m][end][end] == boundary_nodes[m][begin][begin]</code>.  With this form, <code>boundary_nodes[m]</code> should be a counter-clockwise list of nodes for <code>m == 1</code>, while for <code>m &gt; 1</code> it` should be a clockwise list of nodes.</p><ul><li><code>boundary_map::B</code></li></ul><p>This is an <code>OrderedDict</code> that maps a given boundary index to its position in <code>boundary_nodes</code>. For example, if <code>boundary_map[-4] = (2, 3)</code>, this means that the boundary index <code>-4</code>  corresponds to the nodes in <code>get_boundary_nodes(boundary_nodes, 2, 3)</code>. If there is just a  single continuous curve, so that <code>boundary_nodes</code> acts like a vector of integers, then  <code>boundary_map[-1]</code> simply returns <code>boundary_nodes</code>. See also  <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> and <a href="#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}"><code>map_boundary_index</code></a>. The ordering is so that  the lowest magnitude boundary index comes first.</p><ul><li><code>boundary_index_ranges::BIR</code></li></ul><p>This is an <code>OrderedDict</code> that maps a boundary index to a range of all other boundary indices  that the corresponding boundary curve could correspond to. For example, for a curve with four  segments, there are four possible boundary indices that a segment could correspond to - this  <code>Dict</code> will extract this range. See also <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</p><ul><li><code>constrained_edges::Es</code></li></ul><p>This is the set of extra edges added into the triangulation that you have provided. Note that  this will not included any of the other constrained edges from <code>boundary_nodes</code>.</p><ul><li><code>convex_hull::ConvexHull{P,Vector{I}}</code></li></ul><p>This will be a vector of integers corresponding to indices in the points that  together give the convex hull of the set of points, with <code>convex_hull[begin] == convex_hull[end]</code>.</p><p><strong>Constructors</strong></p><p>There are several ways to construct this struct directly (though you should probably  be using <a href="../../triangulations/unconstrained/#DelaunayTriangulation.triangulate"><code>triangulate</code></a> or <a href="../../triangulations/gmsh/#DelaunayTriangulation.generate_mesh"><code>generate_mesh</code></a>).</p><p><strong>Default Constructor</strong></p><p>The default constructor is available, i.e. </p><pre><code class="nohighlight hljs">Triangulation(points, triangles, adjacent, adjacent2vertex, graph, boundary_nodes, constrained_edges, boundary_map, convex_hull)</code></pre><p><strong>Empty Triangulation</strong></p><p>If you want to initialise the triangulation, you can use </p><pre><code class="nohighlight hljs">Triangulation(points::P;
    IntegerType::Type{I}=Int64,
    EdgeType::Type{E}=NTuple{2,IntegerType},
    TriangleType::Type{V}=NTuple{3,IntegerType},
    EdgesType::Type{Es}=Set{EdgeType},
    TrianglesType::Type{Ts}=Set{TriangleType},
    boundary_nodes::BN=IntegerType[],
    constrained_edges=initialise_edges(EdgesType)) where {P,Ts,I,E,Es,BN,V}</code></pre><p><strong>Existing Triangulation Objects</strong></p><p>The second constructor, mainly existing so that <a href="../../triangulations/gmsh/#DelaunayTriangulation.generate_mesh"><code>generate_mesh</code></a> can convert  its results into a <code>Triangulation</code>, takes in existing <code>triangles</code>, <code>points</code>, and  <code>boundary_nodes</code> and creates a <code>Triangulation</code>:</p><pre><code class="nohighlight hljs">Triangulation(points::P, triangles::T, boundary_nodes::BN;
    IntegerType::Type{I}=Int64,
    EdgeType::Type{E}=NTuple{2,IntegerType},
    TriangleType::Type{V}=NTuple{3,IntegerType},
    EdgesType::Type{Es}=Set{EdgeType},
    TrianglesType::Type{Ts}=Set{TriangleType},
    add_ghost_triangles=false) where {I, E, V, Es, Ts, T}</code></pre><p>You can set <code>add_ghost_triangles = true</code> to add ghost triangles into the structure. </p><p><strong>Extended help</strong></p><p>There are many functions available for working with a <code>Triangulation</code>, some of which  we list below. </p><p><strong>Accessors:</strong></p><ul><li><a href="#DelaunayTriangulation.get_points-Tuple{Triangulation}"><code>get_points</code></a></li><li><a href="#DelaunayTriangulation.get_triangles-Tuple{Triangulation}"><code>get_triangles</code></a></li><li><a href="../adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a></li><li><a href="../adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}"><code>get_adjacent2vertex</code></a></li><li><a href="../graph/#DelaunayTriangulation.get_graph-Tuple{DelaunayTriangulation.Graph}"><code>get_graph</code></a></li><li><a href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}"><code>get_boundary_nodes</code></a></li><li><a href="#DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}"><code>get_boundary_map</code></a></li><li><a href="#DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}"><code>get_boundary_index_ranges</code></a></li><li><a href="#DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}"><code>get_constrained_edges</code></a></li><li><a href="#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}"><code>get_convex_hull</code></a></li></ul><p><strong>Operations:</strong></p><ul><li><a href="../adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>add_triangle!</code></a></li><li><a href="../adjacent/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>delete_triangle!</code></a></li><li><a href="../../operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}"><code>add_ghost_triangles!</code></a></li><li><a href="../../operations/#DelaunayTriangulation.delete_ghost_triangles!-Tuple{Triangulation}"><code>delete_ghost_triangles!</code></a></li><li><a href="../../operations/#DelaunayTriangulation.add_boundary_information!-Tuple{Triangulation}"><code>add_boundary_information!</code></a></li></ul><p><strong>Point location:</strong></p><ul><li><a href="../../other_features/point_location/#DelaunayTriangulation.brute_force_search"><code>brute_force_search</code></a></li><li><a href="../../other_features/point_location/#DelaunayTriangulation.jump_and_march"><code>jump_and_march</code></a></li></ul><p><strong>Working with the <a href="../adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> field:</strong></p><ul><li><a href="../adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a></li><li><a href="../adjacent/#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}"><code>add_adjacent!</code></a></li><li><a href="../adjacent/#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}"><code>delete_adjacent!</code></a></li></ul><p><strong>Working with the <a href="../adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> field:</strong></p><ul><li><a href="../adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}"><code>get_adjacent2vertex</code></a></li><li><a href="../adjacent2vertex/#DelaunayTriangulation.add_adjacent2vertex!-Union{Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent2Vertex{I, Es, E}, Any, Any}} where {I, Es, E}"><code>add_adjacent2vertex!</code></a></li><li><a href="../adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any, Any}"><code>delete_adjacent2vertex!</code></a></li></ul><p><strong>Working with the <a href="../graph/#DelaunayTriangulation.Graph"><code>Graph</code></a> field:</strong></p><ul><li><a href="../graph/#DelaunayTriangulation.get_edges-Tuple{DelaunayTriangulation.Graph}"><code>get_edges</code></a></li><li><a href="../graph/#DelaunayTriangulation.get_vertices-Tuple{DelaunayTriangulation.Graph}"><code>get_vertices</code></a></li><li><a href="../graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph}"><code>get_neighbours</code></a></li><li><a href="../graph/#DelaunayTriangulation.add_vertex!-Union{Tuple{N}, Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Vararg{I, N}}} where {I, N}"><code>add_vertex!</code></a></li><li><a href="../graph/#DelaunayTriangulation.add_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, I, I}} where I"><code>add_neighbour!</code></a></li><li><a href="../graph/#DelaunayTriangulation.delete_neighbour!-Tuple{DelaunayTriangulation.Graph, Any, Any}"><code>delete_neighbour!</code></a></li><li><a href="../graph/#DelaunayTriangulation.delete_vertex!-Tuple{DelaunayTriangulation.Graph, Any}"><code>delete_vertex!</code></a></li><li><a href="../graph/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Union{Tuple{DelaunayTriangulation.Graph{I}}, Tuple{I}} where I"><code>delete_boundary_vertices_from_graph!</code></a></li></ul><p><strong>Working with the <code>boundary_nodes</code> field:</strong></p><ul><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.has_multiple_curves"><code>has_multiple_curves</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.has_multiple_segments"><code>has_multiple_segments</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.num_curves"><code>num_curves</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.num_segments"><code>num_segments</code></a></li><li><a href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}"><code>get_boundary_nodes</code></a></li><li><a href="#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}"><code>map_boundary_index</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.get_curve_index"><code>get_curve_index</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.get_segment_index"><code>get_segment_index</code></a></li><li><a href="../../interface/boundary_nodes/#DelaunayTriangulation.num_outer_boundary_segments"><code>num_outer_boundary_segments</code></a></li><li><a href="#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_right_boundary_node</code></a></li><li><a href="#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_left_boundary_node</code></a></li></ul><p><strong>Working with the <code>convex_hull</code> field:</strong></p><ul><li><a href="#DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}"><code>get_convex_hull_indices</code></a></li><li><a href="#DelaunayTriangulation.convex_hull!-Tuple{Triangulation}"><code>convex_hull!</code></a></li></ul><p><strong>Working with the <code>triangles</code> field:</strong></p><ul><li><a href="../../interface/triangles/#DelaunayTriangulation.triangle_type"><code>triangle_type</code></a></li><li><a href="../../interface/triangles/#DelaunayTriangulation.num_triangles"><code>num_triangles</code></a></li><li><a href="../../interface/triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a></li><li><a href="#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}"><code>each_solid_triangle</code></a></li><li><a href="#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}"><code>each_ghost_triangle</code></a></li><li><a href="../../interface/triangles/#DelaunayTriangulation.contains_triangle"><code>contains_triangle</code></a></li></ul><p><strong>Working with edges:</strong></p><ul><li><a href="../../interface/edges/#DelaunayTriangulation.edge_type"><code>edge_type</code></a></li><li><a href="../../interface/edges/#DelaunayTriangulation.num_edges"><code>num_edges</code></a></li><li><a href="../../interface/edges/#DelaunayTriangulation.each_edge"><code>each_edge</code></a></li></ul><p><strong>Working with the <code>points</code> field:</strong></p><ul><li><a href="../../interface/points/#DelaunayTriangulation.get_point"><code>get_point</code></a></li><li><a href="../../interface/points/#DelaunayTriangulation.each_point_index"><code>each_point_index</code></a></li><li><a href="../../interface/points/#DelaunayTriangulation.each_point"><code>each_point</code></a></li><li><a href="../../interface/points/#DelaunayTriangulation.num_points"><code>num_points</code></a></li></ul><p><strong>Predicates:</strong></p><ul><li><a href="#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}"><code>is_boundary_edge</code></a></li><li><a href="#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any}"><code>is_boundary_triangle</code></a></li><li><a href="#DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any}"><code>triangle_orientation</code></a></li><li><a href="#DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Any, Any}"><code>point_position_relative_to_circumcircle</code></a></li><li><a href="#DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}"><code>point_position_relative_to_line</code></a></li><li><a href="#DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}"><code>point_position_on_line_segment</code></a></li><li><a href="#DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Any, Any, Any, Any}"><code>line_segment_intersection_type</code></a></li><li><a href="#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Any, Any}"><code>point_position_relative_to_triangle</code></a></li><li><a href="#DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}"><code>is_outer_boundary_index</code></a></li><li><a href="#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}"><code>is_outer_boundary_node</code></a></li><li><a href="#DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any}"><code>edge_exists</code></a></li><li><a href="#DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}"><code>has_ghost_triangles</code></a></li><li><a href="#DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}"><code>has_boundary_nodes</code></a></li></ul><p><strong>Miscellaneous:</strong></p><ul><li><a href="../../interface/triangles/#DelaunayTriangulation.integer_type"><code>integer_type</code></a></li><li><a href="../../interface/points/#DelaunayTriangulation.number_type"><code>number_type</code></a></li><li><a href="../../other_features/pole_of_inaccessibility/#DelaunayTriangulation.compute_representative_points!"><code>compute_representative_points!</code></a></li><li><a href="#DelaunayTriangulation.clear_empty_features!-Tuple{Triangulation}"><code>clear_empty_features!</code></a></li><li><a href="#DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}"><code>find_edge</code></a></li><li><a href="#DelaunayTriangulation.is_constrained-Tuple{Triangulation}"><code>is_constrained</code></a></li><li><a href="#DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}"><code>all_boundary_indices</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1-L242">source</a></section></article><h2 id="Useful-Methods"><a class="docs-heading-anchor" href="#Useful-Methods">Useful Methods</a><a id="Useful-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent-Tuple{Triangulation}" href="#DelaunayTriangulation.get_adjacent-Tuple{Triangulation}"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(tri::Triangulation)</code></pre><p>Returns the adjacent field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(tri::Triangulation, uv; check_existence::V=Val(false)) where {V}
get_adjacent(tri::Triangulation, u, v; check_existence::V=Val(false)) where {V}</code></pre><p>Given the edge <code>(u, v)</code>, gets the vertex <code>w</code> such that <code>(u, v, w)</code> is a positively oriented triangle in the triangulation <code>tri</code>.</p><p>Use <code>check_existence=Val(true)</code> to be safe against ghost edges corresponding to  neighbouring boundary indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L631-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.add_adjacent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_adjacent!(tri::Triangulation, uv, w)
add_adjacent!(tri::Triangulation, u, v, w)</code></pre><p>Given the edge <code>(u, v)</code>, adds the vertex <code>w</code> into the adjacent map  of the triangulation <code>tri</code>, so that <code>(u, v, w)</code> is a positively  oriented triangle in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L642-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_adjacent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_adjacent!(tri::Triangulation, uv)
delete_adjacent!(tri::Triangulation, u, v)</code></pre><p>Given the edge <code>(u, v)</code>, deletes the key <code>(u, v)</code> from the adjacent map  of the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L651-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}" href="#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}"><code>DelaunayTriangulation.get_adjacent2vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(tri::Triangulation)</code></pre><p>Returns the adjacent2vertex field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_adjacent2vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(tri::Triangulation, w)</code></pre><p>Given the vertex <code>w</code>, returns the set of edges <code>(u, v)</code> from  the adjacent2vertex map such that <code>(u, v, w)</code> is a positively oriented  triangle in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L659-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.add_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_adjacent2vertex!(tri::Triangulation, w, uv)
add_adjacent2vertex!(tri::Triangulation, w, u, v)</code></pre><p>Given the vertex <code>w</code> and an edge <code>(u, v)</code>, pushes the edge <code>(u, v)</code>  into the set of edges defined by the key <code>w</code> in the adjacent2vertex map  of the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L667-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.delete_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_adjacent2vertex!(tri::Triangulation, w, uv)
delete_adjacent2vertex!(tri::Triangulation, w, u, v)</code></pre><p>Given the vertex <code>w</code> and an edge <code>(u, v)</code>, deletes the edge <code>(u, v)</code> from the set of edges defined by the key <code>w</code> in the adjacent2vertex map  of the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L676-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_adjacent2vertex!(tri::Triangulation, w)</code></pre><p>Given the vertex <code>w</code>, deletes the set of edges <code>(u, v)</code> that define positively  oriented triangles <code>(u, v, w)</code> from the adjacent2vertex map of the triangulation  <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L685-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_graph-Tuple{Triangulation}" href="#DelaunayTriangulation.get_graph-Tuple{Triangulation}"><code>DelaunayTriangulation.get_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_graph(tri::Triangulation)</code></pre><p>Returns the graph field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.get_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.get_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_edges(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the set of edges in <code>tri</code>. These edges will  not be oriented, i.e. if <code>(i, j)</code> is in the set then <code>(j, i)</code> will not be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L693-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.get_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.get_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vertices(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the set of vertices in <code>tri</code>. Note that this  will include any ghost vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L700-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_neighbours-Tuple{Triangulation}" href="#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}"><code>DelaunayTriangulation.get_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the set of neighbourhoods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L707-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation, u)</code></pre><p>Given a vertex <code>u</code> and a triangulation <code>tri</code>, returns the set of vertices <code>v</code> such that <code>(u, v)</code> is an edge of the triangulation for each <code>v</code> in the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L713-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg}" href="#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg}"><code>DelaunayTriangulation.add_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_vertex!(tri::Triangulation, u...)</code></pre><p>Given vertices <code>u...</code> and a triangulation <code>tri</code>, adds all the vertices <code>u...</code>  into the graph <code>tri.graph</code>. </p><p>Note that this does not insert the vertex into the triangulation -  see <a href="../../operations/#DelaunayTriangulation.add_point!-Tuple{Triangulation, Any}"><code>add_point!</code></a> for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L720-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg}" href="#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg}"><code>DelaunayTriangulation.add_neighbour!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_neighbour!(tri::Triangulation, u, v...)</code></pre><p>Given a vertex <code>u</code> and other vertices <code>v...</code>, adds all the vertices <code>v...</code>  into the neighbourhood of <code>u</code> from the triangulation <code>tri</code>, i.e. into <code>tri.graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L730-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg}" href="#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg}"><code>DelaunayTriangulation.delete_neighbour!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_neighbour!(tri::Triangulation, u, v...)</code></pre><p>Given a vertex <code>u</code> and other vertices <code>v...</code>, deletes all the vertices <code>v...</code> from the neighbourhood of <code>u</code> from the triangulation <code>tri</code>, i.e. from <code>tri.graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L737-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg}" href="#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg}"><code>DelaunayTriangulation.delete_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_vertex!(tri::Triangulation, u...)</code></pre><p>Given vertices <code>u...</code> and a triangulation <code>tri</code>, deletes all the vertices  <code>u...</code> from the graph <code>tri.graph</code>.</p><p>Note that this does not remove the vertex from the triangulation -  see <a href="data_structures/@ref"><code>remove_point!</code></a> for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L744-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_boundary_vertices_from_graph!-Tuple{Triangulation}" href="#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Tuple{Triangulation}"><code>DelaunayTriangulation.delete_boundary_vertices_from_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_boundary_vertices_from_graph!(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, removes all boundary vertices from the  triangulation <code>tri</code>, i.e. all those with index less than -1 ( see <a href="../../predicates/#DelaunayTriangulation.is_boundary_index"><code>is_boundary_index</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L754-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}" href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}"><code>DelaunayTriangulation.get_boundary_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_nodes(tri::Triangulation)</code></pre><p>Returns the boundary_nodes field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_curves-Tuple{Triangulation}" href="#DelaunayTriangulation.has_multiple_curves-Tuple{Triangulation}"><code>DelaunayTriangulation.has_multiple_curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_multiple_curves(tri::Triangulation)</code></pre><p>Returns <code>true</code> if the triangulation <code>tri</code> has multiple boundary curves,  and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L762-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_segments-Tuple{Triangulation}" href="#DelaunayTriangulation.has_multiple_segments-Tuple{Triangulation}"><code>DelaunayTriangulation.has_multiple_segments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_multiple_segments(tri::Triangulation)</code></pre><p>Returns <code>true</code> if the boundary curves of the triangulation <code>tri</code>  are broken into multiple segments. Note that if <code>has_multiple_curves(tri)</code>, then <code>has_multiple_segments(tri) == true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L769-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_curves-Tuple{Triangulation}" href="#DelaunayTriangulation.num_curves-Tuple{Triangulation}"><code>DelaunayTriangulation.num_curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_curves(tri::Triangulation)</code></pre><p>Returns the number of boundary curves of the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L777-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_segments-Tuple{Triangulation}" href="#DelaunayTriangulation.num_segments-Tuple{Triangulation}"><code>DelaunayTriangulation.num_segments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_segments(tri::Triangulation)</code></pre><p>Returns the number of segments of the boundary curve of the  triangulation <code>tri</code>. This is only defined if <code>!has_multiple_curves(tri)</code> and <code>has_multiple_segments(tri)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L783-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg}" href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg}"><code>DelaunayTriangulation.get_boundary_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_nodes(tri::Triangulation, mnℓ...)</code></pre><p>Given a triangulation <code>tri</code>, returns the nodes corresponding to the  indices in <code>mnℓ...</code>. For example, if <code>tri</code> has multiple boundary curves,  then <code>get_boundary_nodes(tri, m)</code> returns the set of nodes for the  <code>m</code>th curve, and <code>get_boundary_nodes(tri, m, n)</code> the set of nodes for the  <code>n</code>th segment of the <code>m</code>th curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L791-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.map_boundary_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_boundary_index(tri::Triangulation, i)</code></pre><p>Given a triangulation <code>tri</code>, returns the position in <code>tri.boundary_nodes</code> corresponding to the boundary index <code>i</code>, i.e. returns  <code>tri.boundary_map[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L801-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_curve_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_curve_index(tri::Triangulation, i)</code></pre><p>Given a triangulation <code>tri</code> and a boundary index <code>i</code>, returns the curve number  that <code>i</code> corresponds to. For example, if <code>map_boundary_index(tri, i) = (m, n)</code>, the curve index would be <code>m</code>. If <code>!has_multiple_curves(tri)</code>, this just returns  <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L809-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_segment_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_segment_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_segment_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_segment_index(tri::Triangulation, i)</code></pre><p>Given a triangulation <code>tri</code> and a boundary index <code>i</code>, returns the segment number  that <code>i</code> corresponds to. For example, if <code>map_boundary_index(tri, i) = (m, n)</code>,  the segment index would be <code>m</code>. If <code>!has_multiple_segments(tri)</code>, this just returns  <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L818-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.get_right_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_right_boundary_node(tri::Triangulation, k, boundary_index)</code></pre><p>Given a triangulation <code>tri</code>, a boundary node <code>k</code>, and a <code>boundary_index</code> for the associated  boundary, returns the index of the point to the right of <code>k</code> on the outer boundary.</p><p>See also <a href="#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_left_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L827-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.get_left_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_left_boundary_node(tri::Triangulation, k)</code></pre><p>Given a triangulation <code>tri</code> and an outer boundary node <code>k</code>, returns the index  of the point to the left of <code>k</code> on the outer boundary.</p><p>See also <a href="#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_right_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L836-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}" href="#DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}"><code>DelaunayTriangulation.get_convex_hull_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_convex_hull_indices(tri::Triangulation)</code></pre><p>Returns indices for the <a href="../convex_hull/#DelaunayTriangulation.ConvexHull"><code>ConvexHull</code></a> of the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L845-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}" href="#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}"><code>DelaunayTriangulation.get_convex_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_convex_hull(tri::Triangulation)</code></pre><p>Returns the convex_hull field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.convex_hull!-Tuple{Triangulation}" href="#DelaunayTriangulation.convex_hull!-Tuple{Triangulation}"><code>DelaunayTriangulation.convex_hull!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convex_hull!(tri::Triangulation; reconstruct = is_constrained(tri))</code></pre><p>Computess the convex hull for the points in the triangulation <code>tri</code>, updating  the field <code>tri.convex_hull</code>. Note that this will only be needed if you are e.g.  constructing a convex hull from an existing set of points, triangles, and edges.  If you already have an unconstrained Delaunay triangulation, this field will  have also been updated. </p><p>If <code>!reconstruct</code>, the convex hull is reconstructed using <a href="../convex_hull/#DelaunayTriangulation.convex_hull-Tuple{Any}"><code>convex_hull</code></a>,  otherwise the ghost triangles are used to construct it (if there are no ghost  triangles, they are added and then removed afterwards).</p><p>See also <a href="../convex_hull/#DelaunayTriangulation.convex_hull-Tuple{Any}"><code>convex_hull</code></a> and <a href="../convex_hull/#DelaunayTriangulation.ConvexHull"><code>ConvexHull</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L851-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_type-Tuple{Triangulation}" href="#DelaunayTriangulation.triangle_type-Tuple{Triangulation}"><code>DelaunayTriangulation.triangle_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_type(tri::Triangulation{P,Ts}) where {P,Ts}</code></pre><p>Given a triangulation <code>tri</code>, returns the type used for  representing the triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L867-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.get_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.get_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_triangles(tri::Triangulation)</code></pre><p>Returns the triangles field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.num_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.num_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_triangles(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the number of triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L874-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_triangle-Tuple{Triangulation}" href="#DelaunayTriangulation.each_triangle-Tuple{Triangulation}"><code>DelaunayTriangulation.each_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_triangle(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the triangles. This iterator  will return both the ghost and solid triangles (if there are no ghost triangles,  then those of course are not included and <code>each_triangle(tri) == each_solid_triangle(tri)</code>).</p><p>See also <a href="#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}"><code>each_ghost_triangle</code></a> and <a href="#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}"><code>each_solid_triangle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L880-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}" href="#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}"><code>DelaunayTriangulation.each_solid_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_solid_triangle(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the solid (i.e. non-ghost) triangles.</p><p>See also <a href="#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}"><code>each_ghost_triangle</code></a> and <a href="../../interface/triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L890-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}" href="#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}"><code>DelaunayTriangulation.each_ghost_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_ghost_triangle(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the ghost triangles.</p><p>See also <a href="../../interface/triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a> and <a href="#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}"><code>each_solid_triangle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L898-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.contains_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains_triangle(tri::Triangulation, T) = contains_triangle(T, get_triangles(tri))
contains_triangle(tri::Triangulation, i, j, k) = contains_triangle(i, j, k, get_triangles(tri))</code></pre><p>Given a triangulation <code>tri</code>, tests if the triangle <code>T = (i, j, k)</code> is in the triangulation (at least, in <code>triangles</code>).  The returned value is a tuple, with the first result being the form of <code>T</code> that is actually in  the triangulation (e.g., if <code>T = (i, j, k)</code> but the form of <code>T</code> in <code>tri</code> is <code>(k, i, j)</code>, <code>(k, i, j)</code> is  returned). The second argument is a <code>Bool</code>, with <code>true</code> if <code>T</code> is contained in <code>tri</code>  and <code>false</code> otherwise. If <code>false</code>, the first output is <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L906-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}" href="#DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}"><code>DelaunayTriangulation.construct_positively_oriented_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_positively_oriented_triangle(tri::Triangulation, i, j, k)</code></pre><p>Given a triangulation <code>tri</code> and indices <code>i, j, k</code> for a proposed triangle, returns a triangle  with the indices ordered such that <code>(i, j, k)</code> is not negatively oriented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L917-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_type-Tuple{Triangulation}" href="#DelaunayTriangulation.edge_type-Tuple{Triangulation}"><code>DelaunayTriangulation.edge_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_type(tri::Triangulation{P,Ts,I,E}) where {P,Ts,I,E}</code></pre><p>Given a triangulation <code>tri</code>, returns the type used for  representing individual edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L924-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.num_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.num_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_edges(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the number of edges. Note  that this does not double count edges, e.g. <code>(i, j)</code> and <code>(j, i)</code> do not count as two edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L931-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_edge-Tuple{Triangulation}" href="#DelaunayTriangulation.each_edge-Tuple{Triangulation}"><code>DelaunayTriangulation.each_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_edge(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the edges  in the triangulation. Note that e.g. <code>(i, j)</code> and <code>(j, i)</code> will not  be iterated over twice, only one of them would be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L939-L945">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_points-Tuple{Triangulation}" href="#DelaunayTriangulation.get_points-Tuple{Triangulation}"><code>DelaunayTriangulation.get_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_points(tri::Triangulation)</code></pre><p>Returns the points field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_point-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_point(tri::Triangulation, i...)</code></pre><p>Given a triangulation <code>tri</code> and some indices <code>i...</code>, returns  the <code>i</code>th point from the triangulation. If <code>i</code> is just a single integer,  the result is a <code>Tuple</code> of the coordinates, but if there are multiple  integers provided then a <code>Tuple</code> of <code>Tuples</code> of these coordinates  is returned, with the <code>j</code>th <code>Tuple</code> the coordinates for the <code>i[j]</code>th  point. </p><p>It is assumed that whenever <code>i</code> is not an integer, <code>i</code> is meant to be  a point, so <code>(getx(i), gety(i))</code> would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.</p><p>If <code>is_boundary_index(i)</code>, then instead of returning the <code>i</code>th point of the triangulation, the centroid for the boundary curve corresponding to the  boundary index <code>i</code> is returned. See also <a href="../representative/#DelaunayTriangulation.get_representative_point_coordinates"><code>get_representative_point_coordinates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L947-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point_index-Tuple{Triangulation}" href="#DelaunayTriangulation.each_point_index-Tuple{Triangulation}"><code>DelaunayTriangulation.each_point_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_point_index(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the indices  of the points in <code>tri</code>. This iterator does not include the boundary  indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L967-L973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point-Tuple{Triangulation}" href="#DelaunayTriangulation.each_point-Tuple{Triangulation}"><code>DelaunayTriangulation.each_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_point(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns an iterator over the coordinates  of the points in <code>tri</code>. This iterator does not include the centroids  of the boundary curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L975-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_points-Tuple{Triangulation}" href="#DelaunayTriangulation.num_points-Tuple{Triangulation}"><code>DelaunayTriangulation.num_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_points(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, returns the number of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L983-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_boundary_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_edge(tri::Triangulation, ij)
is_boundary_edge(tri::Triangulation, i, j)</code></pre><p>Given a triangulation <code>tri</code> and an edge <code>(i, j)</code>, returns <code>true</code>  if <code>(i, j)</code> is a boundary edge or <code>false</code> if not. </p><p>This predicate takes care for the orientation of the edge: a boundary edge  is one that has only two solid vretices, so that <code>get_adjacent(tri, ij) ≤ I(BoundaryIndex)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L989-L998">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}" href="#DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}"><code>DelaunayTriangulation.get_boundary_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_map(tri::Triangulation)</code></pre><p>Returns the boundary_map field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}" href="#DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}"><code>DelaunayTriangulation.get_boundary_index_ranges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_index_ranges(tri::Triangulation)</code></pre><p>Returns the boundary<em>index</em>ranges field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_boundary_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_triangle(tri::Triangulation, i, j, k)
is_boundary_triangle(tri::Triangulation, T)</code></pre><p>Given a triangulation <code>tri</code> and a triangle <code>T</code>, returns <code>true</code>  if <code>T</code> is a boundary triangle or <code>false</code> if not.</p><p>Note that this is different from testing if <code>T</code> is a ghost  triangle - it is assumed that <code>T</code> is a solid triangle.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1000-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation(tri::Triangulation, i, j, k)
triangle_orientation(tri::Triangulation, T)</code></pre><p>Given a triangle <code>T = (i, j, k)</code> and a triangulation <code>tri</code>,  computes the orientation of the triangle. In particular, returns:</p><ul><li><code>Certificate.PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Certificate.Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear. </li><li><code>Certificate.NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><p>A test is also made for the case that <code>is_ghost_triangle(T)</code>: If  <code>T</code>  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly. In case the boundary  index corresponds to an interior curve, this flip is not necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1011-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_circumcircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circumcircle(tri::Triangulation, i, j, k, ℓ)
point_position_relative_to_circumcircle(tri::Triangulation, T, ℓ)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, a triangulation <code>tri</code>, and a point  with index <code>ℓ</code>, <code>pₗ</code>, computes the position this point <code>pₗ</code> relative to the  triangle&#39;s circumcircle, making use of <a href="../../predicates/#DelaunayTriangulation.point_position_relative_to_circle"><code>point_position_relative_to_circle</code></a>.</p><p>The returned values are:</p><ul><li><code>Certificate.Outside</code>: <code>pₗ</code> is outside of the circumcircle.</li><li><code>Certificate.On</code>: <code>pₗ</code> is on the circumcircle.</li><li><code>Certificate.Inside</code>: <code>pₗ</code> is inside the circumcircle.</li></ul><p>A test is also made for the case that <code>is_ghost_triangle(T)</code>: When <code>T</code> is a ghost triangle, one of its indices is a boundary index, say <code>i</code>.  Since this vertex is treated as being out at infinity, the circumcircle  degenerates into the line through the other two vertices. Thus, we test  that <code>pₗ</code> is inside this circumcircle by seeing if it is in the oriented  outer halfplane defined by the two other vertices. See also  <a href="../../predicates/#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>point_position_relative_to_oriented_outer_halfplane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1029-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line(tri::Triangulation, i, j, u)</code></pre><p>Given indices <code>i</code>, <code>j</code>, and <code>u</code> corresponding to indices  of points in the triangulation <code>tri</code>, corresponding to  coordinates say <code>a</code>, <code>b</code>, and <code>p</code>, respectively, computes the  position of <code>p</code> relative to the oriented line <code>(a, b)</code>. </p><p>The returned values are:</p><ul><li><code>Certificate.Left</code>: <code>p</code> is to the left of the line. </li><li><code>Certificate.Collinear</code>: <code>p</code> is on the line.</li><li><code>Certificate.Right</code>: <code>p</code> is to the right of the line.</li></ul><p>If <code>is_ghost_edge(i, j)</code>, the oriented line <code>(a, b)</code> is flipped  since the point corresponding to the boundary index will be a  centroid which swaps the orientation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1052-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}" href="#DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(tri::Triangulation, i, j, u)</code></pre><p>Given indices <code>i</code>, <code>j</code>, and <code>u</code> corresponding to indices  of points in the triangulation <code>tri</code>, corresponding to  coordinates say <code>a</code>, <code>b</code>, and <code>p</code>, respectively, computes the  position of <code>p</code> relative to the oriented line segment <code>(a, b)</code>, assuming that the three points are collinear.</p><p>The returned values are:</p><ul><li><code>Certificate.On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Certificate.Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints. </li><li><code>Certificate.Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Certificate.Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1071-L1086">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Any, Any, Any, Any}" href="#DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Any, Any, Any, Any}"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type(tri::Triangulation, u, v, i, j)</code></pre><p>Given two pairs of indices <code>(u, v)</code> and <code>(i, j)</code>, with  all indices corresponding to points in the triangulation <code>tri</code>, tests  the number of intersections between the two line segments  associated with these indices.</p><p>Letting <code>p</code>, <code>q</code>, <code>a</code>, and <code>b</code> be the points referred to by  <code>u</code>, <code>v</code>, <code>i</code>, and <code>j</code>, respectively, we return:</p><ul><li><code>Certificate.None</code>: The line segments do not meet at any points. </li><li><code>Certificate.Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>Certificate.Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point.</li><li><code>Certificate.On</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1088-L1103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(tri::Triangulation, i, j, k, u)
point_position_relative_to_triangle(tri::Triangulation, T, u)</code></pre><p>Given a triangle <code>T = (i, j, k)</code> and another index <code>u</code>,  with indices referring to points in the triangulation <code>tri</code>, computes  the position of <code>u</code> relative to the triangle.</p><p>Letting <code>p</code>, <code>q</code>, <code>a</code>, and <code>b</code> be the points referred to by  <code>i</code>, <code>j</code>, <code>k</code>, and <code>u</code>, respectively, we return:</p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul><p>If <code>T</code> is a ghost triangle, <code>Certificate.Inside</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1105-L1121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_outer_boundary_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_index(tri::Triangulation, i)</code></pre><p>Given a triangulation <code>tri</code> and an index <code>i</code>, tests if <code>i</code> is the index of a boundary  corresponding to the outermost boundary of the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1123-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_outer_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_node(tri::Triangulation, i)</code></pre><p>Given a triangulation <code>tri</code> and an index <code>i</code>, tests if <code>i</code> is the index of a node  on the outermost boundary of the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1130-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_exists(tri::Triangulation, i, j)
edge_exists(tri::Triangulation, ij)</code></pre><p>Given a triangulation <code>tri</code> and an edge <code>(i, j)</code>, tests if the edge <code>(i, j)</code> is  in the triangulation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1137-L1143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.has_ghost_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_ghost_triangles(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, tests if the triangulation has ghost triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1145-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}" href="#DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}"><code>DelaunayTriangulation.has_boundary_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_boundary_nodes(tri::Triangulation)</code></pre><p>Given a triangulation <code>tri</code>, tests if the triangulation has boundary nodes -  these are nodes that are constrained to be there, not those on the convex hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1151-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.brute_force_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">brute_force_search(tri::Triangulation, q)</code></pre><p>Given a point <code>q</code>, finds the triangle in the triangulation <code>tri</code> containing it by  searching over all triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1158-L1163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.jump_and_march-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.jump_and_march-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.jump_and_march</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jump_and_march(tri::Triangulation, q;
    m=default_num_samples(num_points(tri)),
    point_indices=each_point_index(tri),
    try_points=(),
    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),
    check_existence::C=Val(has_multiple_segments(tri)),
    rng::AbstractRNG=Random.default_rng())</code></pre><p>Using the jump and march algorithm, finds the triangle in the triangulation <code>tri</code> containing the  query point <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/triangulation/#DelaunayTriangulation.Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m=default_num_samples(num_points(pts))</code>: The number of samples to use when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>point_indices</code>: The indices for the points. Only relevant if <code>k</code> is not specified. </li><li><code>try_points=()</code>: Extra points to try when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>k=select_initial_point(pts, q; m, point_indices, try_points)</code>: Where to start the algorithm.</li><li><code>check_existence::C=Val(has_multiple_segments(tri))</code>: Whether to check that the edge exists when using <a href="../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See <a href="../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns the triangle <code>V</code> containing the query point <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1165-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.integer_type-Tuple{Triangulation}" href="#DelaunayTriangulation.integer_type-Tuple{Triangulation}"><code>DelaunayTriangulation.integer_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integer_type(tri::Triangulation{P,Ts,I}) where {P,Ts,I}</code></pre><p>Given a triangulation <code>tri</code>, returns the type used for representing  the integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1192-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.number_type-Tuple{Triangulation}" href="#DelaunayTriangulation.number_type-Tuple{Triangulation}"><code>DelaunayTriangulation.number_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_type(::Triangulation{P}) where {P}</code></pre><p>Given a triangulation <code>tri</code>, returns the type used for representing  individual coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1199-L1204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}" href="#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}"><code>DelaunayTriangulation.compute_representative_points!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) &amp;&amp; num_boundary_edges(get_boundary_nodes(tri)) == 0))</code></pre><p>Given a triangulation <code>tri</code>, computes representative points for each region using  <a href="#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>. If you only want to update the point for the convex hull, set <code>use_convex_hull = true</code> - this will only update <code>RepresentativePointList[1]</code>.</p><p>See also <a href="../data_structures/representative/#DelaunayTriangulation.RepresentativePointList"><code>RepresentativePointList</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like <code>update_centroid_after_addition</code>  and <code>update_centroid_after_deletion</code> treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of <a href="../triangulations/unconstrained/#DelaunayTriangulation.triangulate"><code>triangulate</code></a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1206-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.clear_empty_features!-Tuple{Triangulation}" href="#DelaunayTriangulation.clear_empty_features!-Tuple{Triangulation}"><code>DelaunayTriangulation.clear_empty_features!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_empty_features!(tri::Triangulation)</code></pre><p>Removes empty keys from the <a href="../adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> and <a href="../adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> maps from the triangulation <code>tri</code>, and all points with empty neighbourhoods  from the <a href="../graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>. </p><p>See also <a href="../adjacent/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent}"><code>clear_empty_keys!</code></a> and <a href="../graph/#DelaunayTriangulation.clear_empty_points!-Tuple{DelaunayTriangulation.Graph}"><code>clear_empty_points!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1224-L1232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.find_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_edge(tri::Triangulation, T, ℓ)</code></pre><p>Given a triangle <code>T</code>, a triangulation <code>tri</code>, and a point index  <code>ℓ</code> which is assumed to correspond to some point on an edge of <code>T</code>,  returns the edge <code>(u, v)</code> that the point is on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1234-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.get_constrained_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_constrained_edges(tri::Triangulation)</code></pre><p>Returns the constrained_edges field from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_constrained-Tuple{Triangulation}" href="#DelaunayTriangulation.is_constrained-Tuple{Triangulation}"><code>DelaunayTriangulation.is_constrained</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_constrained(tri::Triangulation)</code></pre><p>Returns <code>true</code> if <code>tri</code> has any constrained edges, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1242-L1246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}" href="#DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}"><code>DelaunayTriangulation.all_boundary_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_boundary_indices(tri::Triangulation)</code></pre><p>Returns an iterator over all boundary indices in the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/418d7a180dd0f6c63b51de7e18eb20b911e4d010/src/data_structures/triangulation.jl#L1248-L1252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convex_hull/">« Convex Hull</a><a class="docs-footer-nextpage" href="../../interface/interface/">General and Defaults »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 24 February 2023 21:59">Friday 24 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
