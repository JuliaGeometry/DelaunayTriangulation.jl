<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constrained Delaunay Triangulations · DelaunayTriangulation.jl</title><meta name="title" content="Constrained Delaunay Triangulations · DelaunayTriangulation.jl"/><meta property="og:title" content="Constrained Delaunay Triangulations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Constrained Delaunay Triangulations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/constrained/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/constrained/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/constrained/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../delaunay/">Delaunay Triangulations</a></li><li class="is-active"><a class="tocitem" href>Constrained Delaunay Triangulations</a><ul class="internal"><li><a class="tocitem" href="#Incremental-Insertion-Algorithm"><span>Incremental Insertion Algorithm</span></a></li><li><a class="tocitem" href="#Boundaries"><span>Boundaries</span></a></li><li><a class="tocitem" href="#Adding-Points-into-a-Constrained-Delaunay-Triangulation"><span>Adding Points into a Constrained Delaunay Triangulation</span></a></li></ul></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Constrained Delaunay Triangulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constrained Delaunay Triangulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/constrained.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Constrained-Delaunay-Triangulations"><a class="docs-heading-anchor" href="#Constrained-Delaunay-Triangulations">Constrained Delaunay Triangulations</a><a id="Constrained-Delaunay-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Delaunay-Triangulations" title="Permalink"></a></h1><p>Now we introduce constrained Delaunay triangulations. Constrained Delaunay triangulations are similar to Delaunay triangulations <span>$\mathcal D\mathcal T(\mathcal P)$</span>, except with the additional requirement that a provided set of segments <span>$\mathcal S$</span> are constrained to be part of the triangulation, giving a triangulation denoted <span>$\mathcal D\mathcal T(\mathcal P, \mathcal S)$</span>.</p><p>An important concept for defining constrained Delaunay triangulations is that of <em>visibility</em>. We say that two points <span>$p$</span> and <span>$q$</span> are visible to each other if the open line segment <span>$pq$</span> does not intersect any other segment in <span>$\mathcal D\mathcal T(\mathcal P, \mathcal S)$</span>. We see that a triangle <span>$T \in \mathcal D\mathcal T(\mathcal P, \mathcal S)$</span> is <em>constrained Delaunay</em> if its open circumcircle contains no point in <span>$\mathcal P$</span> that is visible from any point inside <span>$T$</span>. Using this definition, we can thus define the <em>constrained Delaunay triangulation</em> of <span>$\mathcal P$</span> with respect to <span>$\mathcal S$</span> as the triangulation in which every triangle is constrained Delaunay. There is a corresponding constrained Delaunay lemma just as for unconstrained Delaunay triangulations, but we do not list it here.</p><h2 id="Incremental-Insertion-Algorithm"><a class="docs-heading-anchor" href="#Incremental-Insertion-Algorithm">Incremental Insertion Algorithm</a><a id="Incremental-Insertion-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Incremental-Insertion-Algorithm" title="Permalink"></a></h2><p>The algorithm for constructing constrained Delaunay triangulations is incremental and reasonably simply to describe. To compute <span>$\mathcal D\mathcal T(\mathcal P, \mathcal S)$</span>, we:</p><ol><li>Compute <span>$\mathcal D\mathcal T(\mathcal P)$</span>, the unconstrained Delaunay triangulation.</li><li>Insert each segment <span>$s \in \mathcal S$</span> into <span>$\mathcal D\mathcal T(\mathcal P)$</span> one by one.</li></ol><p>Of course, this second step is where all the complication lies. Most of the discussion in this section will be about the problem of inserting segments into a triangulation.</p><h3 id="Inserting-a-Segment-into-a-Triangulation"><a class="docs-heading-anchor" href="#Inserting-a-Segment-into-a-Triangulation">Inserting a Segment into a Triangulation</a><a id="Inserting-a-Segment-into-a-Triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-a-Segment-into-a-Triangulation" title="Permalink"></a></h3><p>Let&#39;s now discuss how we can add a segment into a triangulation. To understand the algorithm, let&#39;s first look at an example. Consider the figure below.</p><img src="f94da800.png" alt="Example block output"/><p>To develop an algorithm, we need to notice one important thing from this figure: Since the blue segment will occlude visibility between any points on either side of the segment, the blue segment effectively divides, locally, the triangulation into two parts that no longer interact with each other. In the figure above, this means that any changes to the triangles bounded between the red curve and the blue segment will not interact those in the region bounded between the green curve and the bkue segment. This is a key observation that will allow us to develop an algorithm for inserting segments: we can handle the two sides separately.</p><p>We need to also understand what we are showing in this figure. The highlighted triangles show all triangles intersected by the blue segment. The red boundary shows the chain of vertices intersected by the blue segment above the segment. There is a clear problem with this boundary though: there is a dangling edge, caused by the segment intersecting through two triangles that share an edge, except they are not hit right after each other. The main problem with this is that the object defined by the union of the blue segment and the red boundary is not technically a polygon. We treat it as if it were a polygon, though, by imagining an ant walking around the boundary of this object and splitting the dangling vertex into two copies of itself, so that the ant walking around the boundary essentially sees two different vertices. (It is possible for a vertex to be repeated three or more times, but this is much more rare.) The green boundary is defined similarly.</p><p>What can we do now with this information? We have now established that the blue segment defines two polygonal cavities <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span> that are adjacent to each other, sharing only the blue segment, and any changes to the triangulation within <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span> will have no affect on the other cavity. We thus devise the following algorithm:</p><ol><li>Given a segment <span>$e_{ij}$</span> to be inserted, find the triangles intersected by the segment.</li><li>Delete all triangles intersected by the segment from the triangulation and add <span>$e_{ij}$</span>.</li><li>Identify the two polygonal cavities <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span> on each side of <span>$e_{ij}$</span>, taking care for any danling edges by repeating the vertices as needed.</li><li>Retriangulate <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span> separately.</li><li>Add the triangles from the triangulated polygonal cavities into the original triangulation.</li></ol><p>Once step five is complete, the triangulation has now successfully added <span>$e_{ij}$</span> into the constrained triangulation. We are of course skipping over some key facts, like demonstrating why there are no other changes to the triangulation away from <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>; for these details, see the original paper by <a href="https://www.sciencedirect.com/science/article/pii/S0925772115000322">Shewchuk and Brown (2015)</a>.</p><p>To actually implement this algorithm, there are some key details that need to be worked out:</p><ol><li>How can we find all triangles intersected by <span>$e_{ij}$</span>?</li><li>How can we identify the polygonal cavities <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>?</li><li>How can we efficiently retriangulate <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>?</li></ol><p>Let&#39;s address these one at a time.</p><h3 id="Finding-Triangles-Intersected-by-a-Segment"><a class="docs-heading-anchor" href="#Finding-Triangles-Intersected-by-a-Segment">Finding Triangles Intersected by a Segment</a><a id="Finding-Triangles-Intersected-by-a-Segment-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Triangles-Intersected-by-a-Segment" title="Permalink"></a></h3><p>The problem is: Given a segment <span>$e_{ij}$</span>, find the set of all triangles intersected by the segment. This is exactly the problem that is solved by our point location algorithm - remember that our algorithm marches along all triangles from <span>$p_i$</span> to <span>$p_j$</span> until it finds the triangle containing <span>$p_j$</span>. Thus, by keeping track of all triangles visited during a point location algorithm jumping from <span>$p_i$</span> to <span>$p_j$</span>, we can find all the triangles intersected by the segment.</p><h3 id="Finding-the-Polygonal-Cavities"><a class="docs-heading-anchor" href="#Finding-the-Polygonal-Cavities">Finding the Polygonal Cavities</a><a id="Finding-the-Polygonal-Cavities-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-Polygonal-Cavities" title="Permalink"></a></h3><p>Now we need to consider the problem of finding the two polygonal cavities <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>. These can also be found by the point location algorithm. In addition to keeping track of all triangles visited, whenever an edge <span>$e_{k\ell}$</span> is stepped over we keep track of the vertices <span>$k$</span> and <span>$\ell$</span> and put them into the list of vertices for either <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>, depending on which side of the segment <span>$e_{ij}$</span> they are on. There are some important details here to consider for e.g. collinear edges, but we do not address this here.</p><h3 id="Efficiency-Triangulating-the-Polygonal-Cavities"><a class="docs-heading-anchor" href="#Efficiency-Triangulating-the-Polygonal-Cavities">Efficiency Triangulating the Polygonal Cavities</a><a id="Efficiency-Triangulating-the-Polygonal-Cavities-1"></a><a class="docs-heading-anchor-permalink" href="#Efficiency-Triangulating-the-Polygonal-Cavities" title="Permalink"></a></h3><p>Now we must address the problem of retriangulating the polygonal cavities. This issue is the same for both <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>, so we discuss this problem in general for a given polygonal cavity <span>$\mathcal C$</span> which could be either <span>$\mathcal C_1$</span> or <span>$\mathcal C_2$</span>. While we could just simply triangulate <span>$\mathcal C$</span> using a Bowyer-Watson algorithm, there is a better approach. It turns out that Chew&#39;s algorithm for triangulating convex polygons, as described in the <a href="../convex/">convex triangulation section</a>, also works for the polygonal cavity <span>$\mathcal C$</span>. This is what we use for triangulating <span>$\mathcal C$</span>. </p><h3 id="Putting-Everything-Together"><a class="docs-heading-anchor" href="#Putting-Everything-Together">Putting Everything Together</a><a id="Putting-Everything-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-Everything-Together" title="Permalink"></a></h3><p>Now understanding all these details, the algorithm for inserting a segment into a triangulation follows the same procedure as outlined above. We first find all triangles intersected by the segment, then find the polygonal cavities <span>$\mathcal C_1$</span> and <span>$\mathcal C_2$</span>, and then retriangulate these polygonal cavities using Chew&#39;s algorithm. Once this is done, we have successfully inserted the segment into the triangulation.</p><h2 id="Boundaries"><a class="docs-heading-anchor" href="#Boundaries">Boundaries</a><a id="Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries" title="Permalink"></a></h2><p>One other important part of a constrained Delaunay triangulation is the enforcement of boundaries and holes in a triangulation. This part of the algorithm comes after all segments have been computed. The problem is as follows: Given a set of boundaries defined by segments, delete all triangles that fall outside of the boundaries. The approach we take for this follows the description given by Shewchuk in his <a href="https://link.springer.com/chapter/10.1007/BFb0014497">Triangle paper</a>:</p><ol><li>First, we find all points that will be deleted. To do this, we go across each boundary edge (from the user-provided boundary, not necessarily of the triangulation) and identify the triangle adjacent to the edge away from the interior. The vertex of this triangle away from the boundary is used to find further points, checking all neighbours of this vertex and so on, deleting all vertices that are not in the boundary.</li><li>Using the set of points identified for deletion, we then identify all triangles to delete. This is done by looking all triangles that have a vertex in the set of points to delete, using the <code>Adjacent2Vertex</code> map to do so. We also need to assess the boundary edges once again. Safety is important here since, for example, a triangle might be comprised of vertices that all lie on the boundary but the triangle&#39;s interior is outside of the boundary. So, we check each triangle and ensure that those we&#39;ve identified for deletion have a centroid that appear outside of the boundary. If this is not the case, we remove it from the set of triangles marked for deletion.</li><li>Now having all the triangles to delete, we delete them all from the triangulation.</li></ol><p>With these steps complete, we will have our complete triangulation. To make these steps clear, the figure below shows an example.</p><img src="5c79c022.png" alt="Example block output"/><h2 id="Adding-Points-into-a-Constrained-Delaunay-Triangulation"><a class="docs-heading-anchor" href="#Adding-Points-into-a-Constrained-Delaunay-Triangulation">Adding Points into a Constrained Delaunay Triangulation</a><a id="Adding-Points-into-a-Constrained-Delaunay-Triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Points-into-a-Constrained-Delaunay-Triangulation" title="Permalink"></a></h2><p>Adding points into a constrained Delaunay triangulation is similar to the unconstrained case. The Bowyer-Watson algorithm is again used, except that, when we are excavating the cavity for the new point, we avoid stepping across any segments. If a point is inserted onto a segment, we dig cavities separately on each side of the segment.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../delaunay/">« Delaunay Triangulations</a><a class="docs-footer-nextpage" href="../convex/">Triangulating Convex Polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 19 October 2024 09:21">Saturday 19 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
