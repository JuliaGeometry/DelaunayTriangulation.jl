<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Voronoi Tessellations · DelaunayTriangulation.jl</title><meta name="title" content="Voronoi Tessellations · DelaunayTriangulation.jl"/><meta property="og:title" content="Voronoi Tessellations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Voronoi Tessellations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/tutorials/voronoi/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/tutorials/voronoi/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/tutorials/voronoi/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../weighted/">Weighted Triangulations</a></li><li class="is-active"><a class="tocitem" href>Voronoi Tessellations</a><ul class="internal"><li><a class="tocitem" href="#Iterating-over-generators"><span>Iterating over generators</span></a></li><li><a class="tocitem" href="#Iterating-over-polygon-and-polygon-vertices"><span>Iterating over polygon and polygon vertices</span></a></li><li><a class="tocitem" href="#Getting-polygons-adjacent-to-an-edge"><span>Getting polygons adjacent to an edge</span></a></li><li><a class="tocitem" href="#Just-the-code"><span>Just the code</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li><li><a class="tocitem" href="../point_location/">Point Location</a></li><li><a class="tocitem" href="../nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Voronoi Tessellations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Voronoi Tessellations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/tree/main/docs/src/literate_tutorials/voronoi.jl" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Voronoi-Tessellations">Voronoi Tessellations</a><a id="Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi-Tessellations" title="Permalink"></a></h1><p>In this tutorial, we demonstrate how we can construct Voronoi tessellations and work with them. Voronoi tessellations are built from a dual Delaunay triangulation using <a href="../../api/voronoi/#DelaunayTriangulation.voronoi"><code>voronoi</code></a>. To start, let us load in the packages.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
using CairoMakie
using StableRNGs</code></pre><p>We build the tessellation by constructing the triangulation, and then passing that triangulation into <code>voronoi</code>.</p><pre><code class="language-julia hljs">points = [
    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),
    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),
    (-4.0, -3.0), (3.0, 8.0),
]
rng = StableRNG(123)
tri = triangulate(points; rng)
vorn = voronoi(tri)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Voronoi Tessellation.
    Number of generators: 8
    Number of polygon vertices: 9
    Number of polygons: 8
    Weighted: false</code></pre><p>To visualise the tessellation, you can use <code>voronoiplot</code>. Here, we also compare the tessellation with its dual triangulation.</p><pre><code class="language-julia hljs">fig, ax, sc = voronoiplot(vorn, markersize = 13, colormap = :matter, strokecolor = :white, strokewidth = 5)
triplot!(ax, tri)
fig</code></pre><img src="b2111674.png" alt="Example block output"/><p>The polygons each correspond to a <em>generator</em>, which is the black point inside it coming from <code>points</code>, i.e. the vertices of the triangulation. The polygons are all convex. Note also that the unbounded polygons, those coming from generators on the convex hull of the point set, are clipped in the above plot but in reality they go on to infinity. In the <a href="../clipped_rectangle/">clipping to rectangular regions tutorial</a>, we discuss how these polygons are clipped to a rectangle in more detail.</p><p>Let us now demonstrate in more detail how we can work with <code>vorn</code>.</p><h2 id="Iterating-over-generators"><a class="docs-heading-anchor" href="#Iterating-over-generators">Iterating over generators</a><a id="Iterating-over-generators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-over-generators" title="Permalink"></a></h2><p>The generators are stored in a <code>Dict</code>, mapping vertices to coordinates; this is a <code>Dict</code> rather than a <code>Vector</code> because the original triangulation may not contain all the points, noting that <a href="../../api/voronoi/#DelaunayTriangulation.get_generators"><code>get_generators(vorn)</code></a> is just a repackaged version of <code>get_points(tri)</code>. (A separate field is needed so that clipped and centroidal tessellations can add new generators without affecting the points in <code>tri</code>.) These generators can be accessed using <code>get_generators(vorn)</code>:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_generators(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Tuple{Float64, Float64}} with 8 entries:
  5 =&gt; (3.0, -2.0)
  4 =&gt; (-2.0, 4.0)
  6 =&gt; (5.0, 5.0)
  7 =&gt; (-4.0, -3.0)
  2 =&gt; (1.0, 6.0)
  8 =&gt; (3.0, 8.0)
  3 =&gt; (-1.0, 3.0)
  1 =&gt; (-3.0, 7.0)</code></pre><p>It is preferred that you use <a href="../../api/iterators/#DelaunayTriangulation.each_generator"><code>each_generator(vorn)</code></a>, though, which is an iterator over the generators:</p><pre><code class="language-julia hljs">each_generator(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KeySet for a Dict{Int64, Tuple{Float64, Float64}} with 8 entries. Keys:
  5
  4
  6
  7
  2
  8
  3
  1</code></pre><p>Note that this is just the keys of the above <code>Dict</code>. To access specific generators, you use <a href="../../api/voronoi/#DelaunayTriangulation.get_generator"><code>get_generator</code></a>. For example,</p><pre><code class="language-julia hljs">get_generator(vorn, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-1.0, 3.0)</code></pre><p>To give an example, here is how we can compute the average generator position.</p><pre><code class="language-julia hljs">function average_generator(vorn)
    cx, cy = 0.0, 0.0
    for i in each_generator(vorn)
        p = get_generator(vorn, i)
        px, py = getxy(p)
        cx += px
        cy += py
    end
    n = num_polygons(vorn) # same as DelaunayTriangulation.num_generators(vorn)
    cx /= n
    cy /= n
    return cx, cy
end
cx, cy = average_generator(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.25, 3.5)</code></pre><h2 id="Iterating-over-polygon-and-polygon-vertices"><a class="docs-heading-anchor" href="#Iterating-over-polygon-and-polygon-vertices">Iterating over polygon and polygon vertices</a><a id="Iterating-over-polygon-and-polygon-vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-over-polygon-and-polygon-vertices" title="Permalink"></a></h2><p>You can also look at the individual polygons, and all their vertices. These polygons and their vertices are stored as below:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Vector{Int64}} with 8 entries:
  5 =&gt; [4, 8, -2, -1, 4]
  4 =&gt; [1, 9, 3, 7, 1]
  6 =&gt; [-1, -3, 6, 5, 4, -1]
  7 =&gt; [8, 1, 7, -5, -2, 8]
  2 =&gt; [9, 5, 6, 2, 3, 9]
  8 =&gt; [-3, -4, 2, 6, -3]
  3 =&gt; [4, 5, 9, 1, 8, 4]
  1 =&gt; [3, 2, -4, -5, 7, 3]</code></pre><pre><code class="language-julia hljs">DelaunayTriangulation.get_polygon_points(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Tuple{Float64, Float64}}:
 (-4.166666666666666, 0.8333333333333335)
 (-0.2999999999999998, 9.3)
 (-1.1363636363636365, 5.954545454545455)
 (2.710526315789474, 1.868421052631579)
 (2.357142857142857, 2.9285714285714284)
 (3.1, 5.9)
 (-10.807692307692307, 2.730769230769231)
 (-0.7307692307692308, -0.8846153846153846)
 (-0.30000000000000004, 4.7)</code></pre><p>You should not work with these fields directly, though. If you want to look at a specific polygon, you should use <a href="../../api/voronoi/#DelaunayTriangulation.get_polygon"><code>get_polygon</code></a>. For example,</p><pre><code class="language-julia hljs">get_polygon(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
  3
  2
 -4
 -5
  7
  3</code></pre><p>This is a <code>Vector</code> of the vertices of the polygon, in counter-clockwise order, and such that the first and last vertices are the same. The vertices refer to points in the <code>polygon_points</code> field, which you could then obtain using <a href="../../api/voronoi/#DelaunayTriangulation.get_polygon_point"><code>get_polygon_point</code></a>. For example, the first vertex corresponds to the coordinates:</p><pre><code class="language-julia hljs">get_polygon_point(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-4.166666666666666, 0.8333333333333335)</code></pre><p>In <code>get_polygon(vorn, 1)</code>, notice that there are two negative indices. These negative indices correspond to vertices out at infinity; their actual values do not matter, just that they are negative. Thus, this polygon is actually an unbounded polygon. This can be checked in two ways:</p><pre><code class="language-julia hljs">1 ∈ DelaunayTriangulation.get_unbounded_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">get_area(vorn, 1) == Inf</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>There are several ways that you can iterate over the polygons. If you want each polygon, then you can use <a href="../../api/iterators/#DelaunayTriangulation.each_polygon"><code>each_polygon</code></a>:</p><pre><code class="language-julia hljs">each_polygon(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ValueIterator for a Dict{Int64, Vector{Int64}} with 8 entries. Values:
  [4, 8, -2, -1, 4]
  [1, 9, 3, 7, 1]
  [-1, -3, 6, 5, 4, -1]
  [8, 1, 7, -5, -2, 8]
  [9, 5, 6, 2, 3, 9]
  [-3, -4, 2, 6, -3]
  [4, 5, 9, 1, 8, 4]
  [3, 2, -4, -5, 7, 3]</code></pre><p>This is an iterator over all the polygon vertices, but you do not get the associated polygon index. If you want an iterator that is over the polygon indices, you use <a href="../../api/iterators/#DelaunayTriangulation.each_polygon_index"><code>each_polygon_index</code></a>:</p><pre><code class="language-julia hljs">each_polygon_index(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KeySet for a Dict{Int64, Vector{Int64}} with 8 entries. Keys:
  5
  4
  6
  7
  2
  8
  3
  1</code></pre><p>If you did want to have both the indices and the vertices together, you can use <code>zip</code> on these two iterators. This would be the same as iterating over the internal <code>polygons</code> field, but this could be subject to change in the future. To get an iterator over the polygon vertices rather than caring about a specific polygon, you use <a href="../../api/iterators/#DelaunayTriangulation.each_polygon_vertex"><code>each_polygon_vertex</code></a>:</p><pre><code class="language-julia hljs">each_polygon_vertex(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Base.OneTo(9)</code></pre><p>This is just an iterator of the indices to pass into <code>get_polygon_point</code>. You can also query the number of polygons and polygon vertices as follows:</p><pre><code class="language-julia hljs">num_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><pre><code class="language-julia hljs">num_polygon_vertices(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9</code></pre><p>To give an example of how we might use these iterators, here we compute the area of all polygons.</p><pre><code class="language-julia hljs">function get_polygon_area(vorn, i)
    i ∈ DelaunayTriangulation.get_unbounded_polygons(vorn) &amp;&amp; return Inf
    area = 0.0
    vertices = get_polygon(vorn, i)
    vⱼ = vertices[begin]
    pⱼ = get_polygon_point(vorn, vⱼ)
    xⱼ, yⱼ = getxy(pⱼ)
    for j in (firstindex(vertices) + 1):lastindex(vertices) # same as 2:length(vertices)
        vⱼ₊₁ = vertices[j]
        pⱼ₊₁ = get_polygon_point(vorn, vⱼ₊₁)
        xⱼ₊₁, yⱼ₊₁ = getxy(pⱼ₊₁)
        area += xⱼ * yⱼ₊₁ - xⱼ₊₁ * yⱼ
        vⱼ, pⱼ, xⱼ, yⱼ = vⱼ₊₁, pⱼ₊₁, xⱼ₊₁, yⱼ₊₁
    end
    return area / 2
end
function get_polygon_areas(vorn)
    areas = zeros(num_polygons(vorn))
    for i in each_polygon_index(vorn)
        areas[i] = get_polygon_area(vorn, i)
    end
    return areas
end
vorn_areas = get_polygon_areas(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Float64}:
 Inf
 14.34935064935065
 20.07578561789088
 23.92237762237762
 Inf
 Inf
 Inf
 Inf</code></pre><p>Note that this could have also been obtained using <a href="../../api/triangulation/#DelaunayTriangulation.get_area"><code>get_area</code></a>:</p><pre><code class="language-julia hljs">function direct_polygon_areas(vorn)
    areas = zeros(num_polygons(vorn))
    for i in each_polygon_index(vorn)
        areas[i] = get_area(vorn, i)
    end
    return areas
end
vorn_areas ≈ direct_polygon_areas(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Moreover, note that the following is false:</p><pre><code class="language-julia hljs">vorn_areas ≈ [get_area(vorn, i) for i in each_polygon_index(vorn)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>because <code>each_polygon_index</code> does not return the polygons in a sorted order.</p><p>Before we move on, we emphasise that it is not guaranteed that the values of the vertices for a given polygon are the same if you were to recompute the tessellation. The actual coordinates will all be the same, but they just might correspond to different vertex values. The indices of the polygons will be the same, though, as they are derived from the point indices.</p><h2 id="Getting-polygons-adjacent-to-an-edge"><a class="docs-heading-anchor" href="#Getting-polygons-adjacent-to-an-edge">Getting polygons adjacent to an edge</a><a id="Getting-polygons-adjacent-to-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-polygons-adjacent-to-an-edge" title="Permalink"></a></h2><p>Given an edge in the tessellation, you can use <a href="../../api/triangulation/#DelaunayTriangulation.get_adjacent"><code>get_adjacent</code></a> to get the polygon that it is a part of (taking care of order). For example,</p><pre><code class="language-julia hljs">get_adjacent(vorn, 1, 8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><p>means that the edge <code>(1, 8)</code> belongs to the third polygon, as we can easily verify:</p><pre><code class="language-julia hljs">get_polygon(vorn, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
 4
 5
 9
 1
 8
 4</code></pre><p>see that <code>(1, 8)</code> at the end. The order is important here, since</p><pre><code class="language-julia hljs">get_adjacent(vorn, 8, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7</code></pre><p>means that the edge <code>(8, 1)</code> belongs to the seventh polygon:</p><pre><code class="language-julia hljs">get_polygon(vorn, 7)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
  8
  1
  7
 -5
 -2
  8</code></pre><h2 id="Just-the-code"><a class="docs-heading-anchor" href="#Just-the-code">Just the code</a><a id="Just-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Just-the-code" title="Permalink"></a></h2><p>An uncommented version of this example is given below. You can view the source code for this file <a href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/tree/main/docs/src/literate_tutorials/voronoi.jl">here</a>.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
using CairoMakie
using StableRNGs

points = [
    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),
    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),
    (-4.0, -3.0), (3.0, 8.0),
]
rng = StableRNG(123)
tri = triangulate(points; rng)
vorn = voronoi(tri)

fig, ax, sc = voronoiplot(vorn, markersize = 13, colormap = :matter, strokecolor = :white, strokewidth = 5)
triplot!(ax, tri)
fig

DelaunayTriangulation.get_generators(vorn)

each_generator(vorn)

get_generator(vorn, 3)

function average_generator(vorn)
    cx, cy = 0.0, 0.0
    for i in each_generator(vorn)
        p = get_generator(vorn, i)
        px, py = getxy(p)
        cx += px
        cy += py
    end
    n = num_polygons(vorn) # same as DelaunayTriangulation.num_generators(vorn)
    cx /= n
    cy /= n
    return cx, cy
end
cx, cy = average_generator(vorn)

DelaunayTriangulation.get_polygons(vorn)

DelaunayTriangulation.get_polygon_points(vorn)

get_polygon(vorn, 1)

get_polygon_point(vorn, 1)

1 ∈ DelaunayTriangulation.get_unbounded_polygons(vorn)

get_area(vorn, 1) == Inf

each_polygon(vorn)

each_polygon_index(vorn)

each_polygon_vertex(vorn)

num_polygons(vorn)

num_polygon_vertices(vorn)

function get_polygon_area(vorn, i)
    i ∈ DelaunayTriangulation.get_unbounded_polygons(vorn) &amp;&amp; return Inf
    area = 0.0
    vertices = get_polygon(vorn, i)
    vⱼ = vertices[begin]
    pⱼ = get_polygon_point(vorn, vⱼ)
    xⱼ, yⱼ = getxy(pⱼ)
    for j in (firstindex(vertices) + 1):lastindex(vertices) # same as 2:length(vertices)
        vⱼ₊₁ = vertices[j]
        pⱼ₊₁ = get_polygon_point(vorn, vⱼ₊₁)
        xⱼ₊₁, yⱼ₊₁ = getxy(pⱼ₊₁)
        area += xⱼ * yⱼ₊₁ - xⱼ₊₁ * yⱼ
        vⱼ, pⱼ, xⱼ, yⱼ = vⱼ₊₁, pⱼ₊₁, xⱼ₊₁, yⱼ₊₁
    end
    return area / 2
end
function get_polygon_areas(vorn)
    areas = zeros(num_polygons(vorn))
    for i in each_polygon_index(vorn)
        areas[i] = get_polygon_area(vorn, i)
    end
    return areas
end
vorn_areas = get_polygon_areas(vorn)

function direct_polygon_areas(vorn)
    areas = zeros(num_polygons(vorn))
    for i in each_polygon_index(vorn)
        areas[i] = get_area(vorn, i)
    end
    return areas
end
vorn_areas ≈ direct_polygon_areas(vorn)

vorn_areas ≈ [get_area(vorn, i) for i in each_polygon_index(vorn)]

get_adjacent(vorn, 1, 8)

get_polygon(vorn, 3)

get_adjacent(vorn, 8, 1)

get_polygon(vorn, 7)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../weighted/">« Weighted Triangulations</a><a class="docs-footer-nextpage" href="../clipped/">Clipping to the Convex Hull »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 19 October 2024 09:21">Saturday 19 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
