<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Triangulation Operations · DelaunayTriangulation.jl</title><meta name="title" content="Triangulation Operations · DelaunayTriangulation.jl"/><meta property="og:title" content="Triangulation Operations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Triangulation Operations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/operations/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/operations/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/operations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../triangulation/">Triangulations</a></li><li class="is-active"><a class="tocitem" href>Triangulation Operations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li><li><a class="tocitem" href="../point_location/">Point Location</a></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li><a class="tocitem" href="../statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Triangulation Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Triangulation Operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/api/operations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Triangulation-Operations"><a class="docs-heading-anchor" href="#Triangulation-Operations">Triangulation Operations</a><a id="Triangulation-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulation-Operations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_boundary_information!" href="#DelaunayTriangulation.add_boundary_information!"><code>DelaunayTriangulation.add_boundary_information!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_boundary_information!(tri::Triangulation)</code></pre><p>Updates <code>tri</code> so that the ghost triangle information defined by the boundary nodes in <code>tri</code> is added to the triangulation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/add_boundary_information.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_ghost_triangles!" href="#DelaunayTriangulation.add_ghost_triangles!"><code>DelaunayTriangulation.add_ghost_triangles!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_ghost_triangles!(tri::Triangulation)</code></pre><p>Adds all the ghost triangles to <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/add_ghost_triangles.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_point!" href="#DelaunayTriangulation.add_point!"><code>DelaunayTriangulation.add_point!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point!(c::RepresentativeCoordinates, p)</code></pre><p>Treating <code>c</code> as an arithmetic average, updates the coordinates of <code>c</code> to include <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/representative_coordinates/representative_coordinates.jl#L68-L72">source</a></section><section><div><pre><code class="language-julia hljs">add_point!(tri::Triangulation, new_point; kwargs...) -&gt; Triangle
add_point!(tri::Triangulation, x, y; kwargs...) -&gt; Triangle</code></pre><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>new_point</code>: The point to be added to the triangulation. The second method uses <code>(x, y)</code> to represent the new point instead. If <code>new_point</code> is an integer, then the point added is <code>get_point(tri, new_point)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>point_indices=each_solid_vertex(tri)</code>: The indices of the points to be used in the <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> algorithm for selecting the initial point.</li><li><code>m=default_num_samples(length(point_indices))</code>: The number of samples (without replacement) to be used in the <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> algorithm for selecting the initial point.</li><li><code>try_points=()</code>: Additional points to try for selecting the initial point, in addition to the <code>m</code> sampled.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to be used in <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</li><li><code>initial_search_point=integer_type(tri)(select_initial_point(tri, new_point; point_indices, m, try_points, rng))</code>: The initial point to be used in <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</li><li><code>update_representative_point=false</code>: Whether to update the representative point of the triangulation after adding the new point. </li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the triangulation from adding the new point. </li><li><code>event_history=nothing</code>: The event history of the triangulation from adding the new point. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li><li><code>concavity_protection=false</code>: Whether to use concavity protection for finding <code>V</code> below. See <a href="../../extended/algorithms/#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex. </li><li><code>V=find_triangle(tri, get_point(tri, new_point); m=nothing, point_indices=nothing, try_points=nothing, k=initial_search_point, concavity_protection, rng)</code>: The positively oriented triangle containing the point being added.</li></ul><div class="admonition is-warning"><header class="admonition-header">Non-convex domains</header><div class="admonition-body"><p>In cases where your triangulation is not convex and <code>!concavity_protection</code>, this <code>V</code> may not be correct, and you may encounter errors - errors either during <code>add_point!</code> or separately when  you try to use the triangulation. In such cases, you should set <code>concavity_protection=true</code> to ensure that <code>V</code> is correct.</p></div></div><ul><li><code>peek=Val(false)</code>: Whether the point should actually be added into the triangulation, or just &#39;peeked&#39; at so that the events that would occur from its addition can be added into <code>event_history</code>.</li></ul><p><strong>Outputs</strong></p><p>The triangulation is updated in-place, but we do return </p><ul><li><code>V</code>: The triangle containing the point being added.</li></ul><div class="admonition is-category-warn"><header class="admonition-header">Convex hull</header><div class="admonition-body"><p>In cases where <code>(x, y)</code> is outside of the triangulation, it will be added successfully but note that  the <code>convex_hull</code> field of <code>tri</code> will no longer be accurate. You can use <a href="../convex_hull/#DelaunayTriangulation.convex_hull!"><code>convex_hull!</code></a> to fix it.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/add_point.jl#L1-L37">source</a></section><section><div><pre><code class="language-julia hljs">add_point!(tri::Triangulation, x, y, w; kwargs...)</code></pre><p>Adds the point <code>(x, y)</code> into <code>tri</code> with weight <code>w</code>. This function requires that <a href="../triangulation/#DelaunayTriangulation.add_weight!"><code>add_weight!</code></a> is defined on the weights stored in <code>tri</code>. The <code>kwargs</code> match those from <a href="#DelaunayTriangulation.add_point!"><code>add_point!(tri::Triangulation, ::Any)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/add_point.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_segment!" href="#DelaunayTriangulation.add_segment!"><code>DelaunayTriangulation.add_segment!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_segment!(tri::Triangulation, segment; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())
add_segment!(tri::Triangulation, i, j; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())</code></pre><p>Adds <code>segment = (i, j)</code> to <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segment</code>: The segment to add. The second method uses <code>(i, j)</code> to represent the segment instead.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: The RNG object.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that it now contains <code>segment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/add_segment.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_triangle!" href="#DelaunayTriangulation.add_triangle!"><code>DelaunayTriangulation.add_triangle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_triangle!(T, V...)
add_triangle!(T, i, j, k)</code></pre><p>Add the triangles <code>V...</code> or <code>V = (i, j, k)</code> to the collection of triangles <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; T = Set(((1, 2, 3), (4, 5, 6)))
Set{Tuple{Int64, Int64, Int64}} with 2 elements:
  (4, 5, 6)
  (1, 2, 3)

julia&gt; add_triangle!(T, (7, 8, 9));

julia&gt; add_triangle!(T, (10, 11, 12), (13, 14, 15));

julia&gt; add_triangle!(T, 16, 17, 18);

julia&gt; T
Set{Tuple{Int64, Int64, Int64}} with 6 elements:
  (7, 8, 9)
  (10, 11, 12)
  (4, 5, 6)
  (13, 14, 15)
  (16, 17, 18)
  (1, 2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/geometric_primitives/triangles.jl#L446-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clear_empty_features!" href="#DelaunayTriangulation.clear_empty_features!"><code>DelaunayTriangulation.clear_empty_features!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear_empty_features!(tri::Triangulation)</code></pre><p>Clears all empty features from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/clear_empty_features.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_ghost_triangles!" href="#DelaunayTriangulation.delete_ghost_triangles!"><code>DelaunayTriangulation.delete_ghost_triangles!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_ghost_triangles!(tri::Triangulation)</code></pre><p>Deletes all the ghost triangles from <code>tri</code>.</p><div class="admonition is-warning"><header class="admonition-header">Ghost vertices</header><div class="admonition-body"><p>Ghost vertices are still used in the <code>keys</code> of the <a href="../../extended/data_structures/#Adjacent2Vertex"><code>Adjacent2Vertex</code></a>  of <code>tri</code>, and are still present in the <a href="../../extended/data_structures/#Graph"><code>Graph</code></a>. If you want to delete the  ghost vertex <code>keys</code> from the <a href="../../extended/data_structures/#Adjacent2Vertex"><code>Adjacent2Vertex</code></a>, you need to use  <a href="../../extended/algorithms/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}"><code>delete_adjacent2vertex!</code></a>. For deleting the ghost vertices from the  <a href="../../extended/data_structures/#Graph"><code>Graph</code></a>, you need <a href="../triangulation/#DelaunayTriangulation.delete_ghost_vertices_from_graph!"><code>delete_ghost_vertices_from_graph!</code></a>. Additionally,  edges in <a href="../../extended/data_structures/#Adjacent"><code>Adjacent</code></a> can still map to ghost vertices. If you also want to delete  those, you need to filter through the <code>values</code> of the <a href="../../extended/data_structures/#Adjacent"><code>Adjacent</code></a> map  that are ghost vertices, and use <a href="../../extended/algorithms/#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}"><code>delete_adjacent!</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/delete_ghost_triangles.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_holes!" href="#DelaunayTriangulation.delete_holes!"><code>DelaunayTriangulation.delete_holes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_holes!(tri::Triangulation)</code></pre><p>Deletes all the exterior faces to the boundary nodes specified in the triangulation <code>tri</code>.</p><p><strong>Extended help</strong></p><p>This function works in several stages:</p><ol><li>First, <a href="../../extended/algorithms/#DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}"><code>find_all_points_to_delete</code></a> is used to identify all points in the exterior faces.</li><li>Once all the points to delete have been found, all the associated triangles are found using <a href="../../extended/algorithms/#DelaunayTriangulation.find_all_triangles_to_delete-Tuple{Triangulation, Any}"><code>find_all_triangles_to_delete</code></a>, taking care for any incorrectly identified triangles and points. </li><li>Once the correct set of triangles to delete has been found, they are deleted using <a href="../../extended/algorithms/#DelaunayTriangulation.delete_all_exterior_triangles!-Tuple{Triangulation, Any}"><code>delete_all_exterior_triangles!</code></a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/delete_holes.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_surrounding_polygon" href="#DelaunayTriangulation.get_surrounding_polygon"><code>DelaunayTriangulation.get_surrounding_polygon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(cache::TriangulationCache) -&gt; Vector{Vertex}</code></pre><p>Returns the polygon surrounding the triangulation stored in <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/triangulation/triangulation_cache.jl#L83-L87">source</a></section><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(vor::VoronoiTessellation, i) -&gt; Vector{Vertex}</code></pre><p>Gets the polygon surrounding the generator with index <code>i</code> in <code>vor</code>. </p><p>You shouldn&#39;t need to use this, see <a href="../voronoi/#DelaunayTriangulation.get_polygon"><code>get_polygon</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/voronoi.jl#L462-L468">source</a></section><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(tri::Triangulation, u; skip_ghost_vertices=false) -&gt; Vector</code></pre><p>Returns the counter-clockwise sequence of neighbours of <code>u</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>: The vertex.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>skip_ghost_vertices=false</code>: Whether to skip ghost vertices in the returned polygon. </li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: The surrounding polygon. This will not be circular, meaning <code>S[begin] ≠ S[end]</code>.  In case <code>u</code> is an exterior ghost vertex, the returned polygon is a clockwise list of vertices for   the associated boundary curve. If you do not have ghost triangles and you try to get the surrounding polygon  of a ghost vertex, then this function may return an invalid polygon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/delete_point.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_point!" href="#DelaunayTriangulation.delete_point!"><code>DelaunayTriangulation.delete_point!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_point!(c::RepresentativeCoordinates, p)</code></pre><p>Treating <code>c</code> as an arithmetic average, updates the coordinates of <code>c</code> to exclude <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/representative_coordinates/representative_coordinates.jl#L81-L85">source</a></section><section><div><pre><code class="language-julia hljs">delete_point!(tri::Triangulation, vertex; kwargs...)</code></pre><p>Deletes the <code>vertex</code> of <code>tri</code>, retriangulating the cavity formed by the surrounding polygon of <code>vertex</code> using  <a href="../triangulation/#DelaunayTriangulation.triangulate_convex"><code>triangulate_convex</code></a>.</p><p>It is not possible to delete vertices that are on the boundary, are ghost vertices, or adjoin a segment of <code>tri</code>.  See also <a href="../../extended/algorithms/#DelaunayTriangulation.check_delete_point_args-Tuple{Triangulation, Any, Any}"><code>check_delete_point_args</code></a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Point deletion</header><div class="admonition-body"><p>This function will not actually delete the corresponding coordinates from <code>get_points(tri)</code>, nor will it remove  the associated weight from <code>get_weights(tri)</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>vertex</code>: The vertex to delete.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the triangulation from deleting the point. </li><li><code>event_history=nothing</code>: The event history of the triangulation from deleting the point. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use for the triangulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/delete_point.jl#L112-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_triangle!" href="#DelaunayTriangulation.delete_triangle!"><code>DelaunayTriangulation.delete_triangle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_triangle!(V, T...)
delete_triangle!(V, i, j, k)</code></pre><p>Delete the triangles <code>T...</code> from the collection of triangles <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)))
Set{Tuple{Int64, Int64, Int64}} with 5 elements:
  (7, 8, 9)
  (10, 11, 12)
  (4, 5, 6)
  (13, 14, 15)
  (1, 2, 3)

julia&gt; delete_triangle!(V, (6, 4, 5))
Set{Tuple{Int64, Int64, Int64}} with 4 elements:
  (7, 8, 9)
  (10, 11, 12)
  (13, 14, 15)
  (1, 2, 3)

julia&gt; delete_triangle!(V, (10, 11, 12), (1, 2, 3))
Set{Tuple{Int64, Int64, Int64}} with 2 elements:
  (7, 8, 9)
  (13, 14, 15)

julia&gt; delete_triangle!(V, 8, 9, 7)
Set{Tuple{Int64, Int64, Int64}} with 1 element:
  (13, 14, 15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/geometric_primitives/triangles.jl#L523-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.flip_edge!" href="#DelaunayTriangulation.flip_edge!"><code>DelaunayTriangulation.flip_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip_edge!(tri::Triangulation, i, j, store_event_history=Val(false), event_history=nothing)
flip_edge!(tri::Triangulation, i, j, k, ℓ, store_event_history=Val(false), event_history=nothing)</code></pre><p>Flips the edge between vertices <code>i</code> and <code>j</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the edge to flip.</li><li><code>j</code>: The second vertex of the edge to flip.</li><li><code>k</code>: The vertex <code>k = get_adjacent(tri, j, i)</code>. This is only used in the second method.</li><li><code>ℓ</code>: The vertex <code>ℓ = get_adjacent(tri, i, j)</code>. This is only used in the second method.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip. </li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object. This storage is done using <code>store_flip_edge_history!</code>.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p><div class="admonition is-warning"><header class="admonition-header">Invalid flips</header><div class="admonition-body"><p>If <code>(i, j, k, ℓ)</code>, where <code>ℓ = get_adjacent(tri, i, j)</code> and <code>k = get_adjacent(tri, j, i)</code>, is not a convex quadrilateral, then this edge flip will make the triangulation non-planar.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/flip_edge.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.legalise_edge!" href="#DelaunayTriangulation.legalise_edge!"><code>DelaunayTriangulation.legalise_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legalise_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Legalises the edge <code>(i, j)</code> and other neighbouring edges in <code>tri</code> if they are illegal, assuming the vertex <code>r</code>  was just added into a triangle that contains <code>(i, j)</code>. <a href="#DelaunayTriangulation.flip_edge!"><code>flip_edge!</code></a> is used.</p><p>See also <a href="../predicates/#DelaunayTriangulation.is_legal"><code>is_legal</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the edge to legalise.</li><li><code>j</code>: The second vertex of the edge to legalise.</li><li><code>r</code>: The vertex that was just added into a triangle that contains <code>(i, j)</code>.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p><div class="admonition is-warning"><header class="admonition-header">Invalid event histories</header><div class="admonition-body"><p>Edge flipping can lead to <code>event_history</code> having triangles both in <code>event_history.added_triangles</code> and <code>event_history.deleted_triangles</code>. To get around this, we only store in these fields the triangles necessary to allow <a href="../../extended/data_structures/#DelaunayTriangulation.undo_insertion!"><code>undo_insertion!</code></a> to work, so that at a triangle that might have appeared in both will only appear in one.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/legalise_edge.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.lock_convex_hull!" href="#DelaunayTriangulation.lock_convex_hull!"><code>DelaunayTriangulation.lock_convex_hull!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lock_convex_hull!(tri::Triangulation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Locks the convex hull of the unconstrained triangulation <code>tri</code> so that it is now treated as a constrained triangulation  with boundary given by its convex hull.</p><p>The random number generator (used inside <a href="#DelaunayTriangulation.add_segment!"><code>add_segment!</code></a> can be provided with the <code>rng</code> keyword argument, and similarly for <code>predicates</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If an edge is encountered along the convex hull that contains a segment from <code>tri.interior_segments</code>, then this edge will be deleted from <code>tri.interior_segments</code>; this will be undone from <code>unlock_convex_hull!</code>,  possibly splitting the segments in case they were split before unlocking.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/lock_convex_hull.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.unlock_convex_hull!" href="#DelaunayTriangulation.unlock_convex_hull!"><code>DelaunayTriangulation.unlock_convex_hull!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unlock_convex_hull!(tri::Triangulation; reconstruct=false)</code></pre><p>Unlocks the convex hull of the constrained triangulation <code>tri</code> so that it is now treated as an unconstrained triangulation, assuming that it was locked using <a href="#DelaunayTriangulation.lock_convex_hull!"><code>lock_convex_hull!</code></a>. If <code>reconstruct = true</code>, then the  convex hull of <code>tri</code> will be reconstructed from the boundary nodes of <code>tri</code>. This is useful if, for example,  you have split some of the boundary edges during mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/unlock_convex_hull.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_edge!" href="#DelaunayTriangulation.split_edge!"><code>DelaunayTriangulation.split_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_edge!(tree::BoundaryRTree, i, j, r)</code></pre><p>Splits the diametral bounding box associated with <code>(i, j)</code> into two new boxes associated  with the diametral circles of <code>(i, r)</code> and <code>(j, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/trees/rtree.jl#L1111-L1116">source</a></section><section><div><pre><code class="language-julia hljs">split_edge!(enricher::BoundaryEnricher, i, j, r, update_boundary_nodes = Val(true), update_segments = Val(true), is_interior = is_segment(enricher, i, j))</code></pre><p>Updates the fields of <code>enricher</code> after splitting an edge <code>(i, j)</code> at the <code>r</code>th vertex. The <code>update_boundary_nodes</code> argument  can be used to avoid inserting an additional boundary node when <code>boundary_nodes</code> was already updated somewhere else (e.g., we need this for mesh refinement which already updates the <code>boundary_nodes</code> which is aliased with the same field in the enricher). The same  point goes for <code>update_segments</code> which can be used to avoid inserting an additional segment when <code>segments</code> was already updated somewhere else. The <code>is_interior</code> argument can be used to specify whether the edge is an interior segment or a boundary edge. </p><p>See also <a href="../../extended/algorithms/#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>split_boundary_edge!</code></a> and <a href="../../extended/data_structures/#DelaunayTriangulation.split_interior_segment!"><code>split_interior_segment!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/data_structures/mesh_refinement/boundary_enricher.jl#L949-L959">source</a></section><section><div><pre><code class="language-julia hljs">split_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)</code></pre><p>Splits the edge <code>(i, j)</code> in <code>tri</code> at the vertex <code>r</code>. For the triangulation to be valid after this splitting, it is assumed that <code>r</code> is collinear with,  or at least very close to collinear with, the edge <code>(i, j)</code>.</p><p>See also <a href="../../extended/algorithms/#DelaunayTriangulation.legalise_split_edge!"><code>legalise_split_edge!</code></a> and <a href="#DelaunayTriangulation.complete_split_edge_and_legalise!"><code>complete_split_edge_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.    </li><li><code>i</code>: The first vertex of the edge to split.</li><li><code>j</code>: The second vertex of the edge to split.</li><li><code>r</code>: The vertex to split the edge at.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p><div class="admonition is-warning"><header class="admonition-header">Handling unoriented edges</header><div class="admonition-body"><p>The triangulation will only be updated as if <code>(i, j)</code> has been split rather than also <code>(j, i)</code>. You will need to call <code>split_edge!</code> again with <code>(j, i)</code> if you want to split that edge as well.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/split_edge.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.complete_split_edge_and_legalise!" href="#DelaunayTriangulation.complete_split_edge_and_legalise!"><code>DelaunayTriangulation.complete_split_edge_and_legalise!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Given a triangulation <code>tri</code>, an edge <code>(i, j)</code>, and a point <code>r</code>, splits both <code>(i, j)</code> and <code>(j, i)</code> at <code>r</code> using <a href="#DelaunayTriangulation.split_edge!"><code>split_edge!</code></a> and then subsequently legalises the new edges with <a href="../../extended/algorithms/#DelaunayTriangulation.legalise_split_edge!"><code>legalise_split_edge!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the edge to split.</li><li><code>j</code>: The second vertex of the edge to split.</li><li><code>r</code>: The vertex to split the edge at.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../../extended/data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/split_edge.jl#L125-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_triangle!" href="#DelaunayTriangulation.split_triangle!"><code>DelaunayTriangulation.split_triangle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_triangle!(tri::Triangulation, args::RefinementArguments, T) -&gt; Certificate</code></pre><p>Splits a bad triangle <code>T</code> of <code>tri</code> to improve its quality.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> to split a triangle of.</li><li><code>args::RefinementArguments</code>: The <a href="../../extended/data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>T</code>: The triangle to split.</li></ul><p><strong>Output</strong></p><ul><li><code>cert</code>: A <a href="../predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> indicating whether the split was successful or not. In particular, returns one of:<ul><li><code>Cert.SuccessfulInsertion</code>: The triangle was split successfully.</li><li><code>Cert.EncroachmentFailure</code>: The triangle was not split successfully as the newly inserted point encroached upon a segment.</li><li><code>Cert.PrecisionFailure</code>: The triangle was not split successfully due to precision issues.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/mesh_refinement.jl#L131-L146">source</a></section><section><div><pre><code class="language-julia hljs">split_triangle!(tri::Triangulation, i, j, k, r)</code></pre><p>Splits the triangle <code>(i, j, k)</code> at the vertex <code>r</code>, assumed to be inside the triangle. </p><p>See also <a href="../../extended/algorithms/#DelaunayTriangulation.legalise_split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}"><code>legalise_split_triangle!</code></a> and <a href="#DelaunayTriangulation.complete_split_triangle_and_legalise!"><code>complete_split_triangle_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the triangle.</li><li><code>j</code>: The second vertex of the triangle.</li><li><code>k</code>: The third vertex of the triangle.</li><li><code>r</code>: The vertex to split the triangle at.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that it now contains the triangles <code>(i, j, r)</code>, <code>(j, k, r)</code>, and <code>(k, i, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/split_triangle.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.complete_split_triangle_and_legalise!" href="#DelaunayTriangulation.complete_split_triangle_and_legalise!"><code>DelaunayTriangulation.complete_split_triangle_and_legalise!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)</code></pre><p>Splits the triangle <code>(i, j, k)</code> at the vertex <code>r</code>, assumed to be inside the triangle, and legalises the newly added edges in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the triangle.</li><li><code>j</code>: The second vertex of the triangle.</li><li><code>k</code>: The third vertex of the triangle.</li><li><code>r</code>: The vertex to split the triangle at.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/885cf55266aae671d200e0e887edaa9d72ca0e9f/src/algorithms/triangulation/basic_operations/split_triangle.jl#L53-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../triangulation/">« Triangulations</a><a class="docs-footer-nextpage" href="../voronoi/">Voronoi Tessellations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 28 September 2024 08:07">Saturday 28 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
