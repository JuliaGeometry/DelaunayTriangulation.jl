<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Application: Counting Function Calls · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/counting/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li><a class="tocitem" href="../edges/">Edges</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li><li class="is-active"><a class="tocitem" href>Application: Counting Function Calls</a><ul class="internal"><li><a class="tocitem" href="#Application:-Counting-Function-Calls"><span>Application: Counting Function Calls</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Application: Counting Function Calls</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Application: Counting Function Calls</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/counting.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Application:-Counting-Function-Calls"><a class="docs-heading-anchor" href="#Application:-Counting-Function-Calls">Application: Counting Function Calls</a><a id="Application:-Counting-Function-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Application:-Counting-Function-Calls" title="Permalink"></a></h2><p>The ability to customise the primitive interfaces completely has many advantages. In the previous section we gave a complete example for how to setup and define all the functions required. Here, we will show an actual example where customisation can be really useful.</p><p>The application in mind is to study how many times a function is being called during the construction of a triangulation. By defining custom definitions for points and triangles, we can estimate how many times we compute predicates and how many times we add and remove triangles. </p><h3 id="Setting-Up"><a class="docs-heading-anchor" href="#Setting-Up">Setting Up</a><a id="Setting-Up-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up" title="Permalink"></a></h3><p>To start the application, we first load in the packages.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
using CairoMakie
using StatsBase
const DT = DelaunayTriangulation</code></pre><p>We then need to define the custom primitves and the required definitions. First, the structs and basic definitions:</p><pre><code class="language-julia hljs">struct CustomPoint
    x::Float64
    y::Float64
end
struct CustomTriangle
    i::Int
    j::Int
    k::Int
end
DT.getx(p::CustomPoint) = p.x
DT.gety(p::CustomPoint) = p.y
DT.number_type(::Type{CustomPoint}) = Float64
DT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)
DT.geti(tri::CustomTriangle) = tri.i
DT.getj(tri::CustomTriangle) = tri.j
DT.getk(tri::CustomTriangle) = tri.k
DT.integer_type(::Type{CustomTriangle}) = Int32
DT.getpoint(pts::Vector{CustomPoint}, i::Int) = pts[i]</code></pre><p>Next, we define the actual counter. This will be a mutable struct.</p><pre><code class="language-julia hljs">mutable struct AlgorithmStats
    orient_calls::Int
    incircle_calls::Int
    parallelorder_calls::Int
    sameside_calls::Int
    meet_calls::Int
    added_triangles::Int
    deleted_triangles::Int
end
AlgorithmStats() = AlgorithmStats(0, 0, 0, 0, 0, 0, 0)
AlgorithmStats(opstats::AlgorithmStats) = AlgorithmStats(opstats.orient_calls, opstats.incircle_calls, opstats.parallelorder_calls, opstats.sameside_calls, opstats.meet_calls, opstats.added_triangles, opstats.deleted_triangles)
nt = Base.Threads.nthreads()
const opstats = [AlgorithmStats() for _ in 1:nt]
reset_opstats!(id=Base.Threads.threadid()) = (opstats[id] = AlgorithmStats())</code></pre><p>The constant <code>opstats</code> is a vector of counters so that we can use multithreading. The methods we need to overwrite for this counter are:</p><pre><code class="language-julia hljs">function DT.add_to_triangles!(tri::Set{CustomTriangle}, triangle::CustomTriangle)
    push!(tri, triangle)
    opstats[Base.Threads.threadid()].added_triangles += 1
    return nothing
end
function DT.delete_from_triangles!(tri::Set{CustomTriangle}, triangle::CustomTriangle)
    delete!(tri, triangle)
    opstats[Base.Threads.threadid()].deleted_triangles += 1
    return nothing
end
function DT.orient_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint)
    o = DT.orient_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r))
    opstats[Base.Threads.threadid()].orient_calls += 1
    return o
end
function DT.incircle_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)
    o = DT.incircle_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))
    opstats[Base.Threads.threadid()].incircle_calls += 1
    return o
end
function DT.parallelorder_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)
    o = DT.parallelorder_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))
    opstats[Base.Threads.threadid()].parallelorder_calls += 1
    return o
end
function DT.sameside_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint)
    o = DT.sameside_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r))
    opstats[Base.Threads.threadid()].sameside_calls += 1
    return o
end
function DT.meet_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)
    o = DT.meet_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))
    opstats[Base.Threads.threadid()].meet_calls += 1
    return o
end</code></pre><p>Next, let&#39;s define the functions for summarising the simulations we&#39;ll perform, the simulation functions themselves, and a function for plotting results.</p><pre><code class="language-julia hljs">## Summary functions 
struct AlgorithmStatsSummary
    orient_calls::NTuple{2,Float64}
    incircle_calls::NTuple{2,Float64}
    parallelorder_calls::NTuple{2,Float64}
    sameside_calls::NTuple{2,Float64}
    meet_calls::NTuple{2,Float64}
    added_triangles::NTuple{2,Float64}
    deleted_triangles::NTuple{2,Float64}
    function AlgorithmStatsSummary(sims::Vector{AlgorithmStats})
        orient_calls = quantile([sim.orient_calls for sim in sims], (0.025, 0.975))
        incircle_calls = quantile([sim.incircle_calls for sim in sims], (0.025, 0.975))
        parallelorder_calls = quantile([sim.parallelorder_calls for sim in sims], (0.025, 0.975))
        sameside_calls = quantile([sim.sameside_calls for sim in sims], (0.025, 0.975))
        meet_calls = quantile([sim.meet_calls for sim in sims], (0.025, 0.975))
        added_triangles = quantile([sim.added_triangles for sim in sims], (0.025, 0.975))
        deleted_triangles = quantile([sim.deleted_triangles for sim in sims], (0.025, 0.975))
        return new(orient_calls, incircle_calls, parallelorder_calls, sameside_calls, meet_calls, added_triangles, deleted_triangles)
    end
end
summarise_simulations(sims) = AlgorithmStatsSummary(sims)

## Point generators 
function generate_random_points(npts)
    pts = [CustomPoint(rand(), rand()) for _ in 1:npts]
    return pts
end
function generate_structured_points(npts)
    nx = isqrt(npts)
    ny = isqrt(npts)
    points = CustomPoint[]
    for i in 1:nx
        for j in 1:ny
            x = (i - 1) / (nx - 1)
            y = (j - 1) / (ny - 1)
            push!(points, CustomPoint(x, y))
        end
    end
    while length(points) &lt; npts
        push!(points, CustomPoint(rand(), rand()))
    end
    return points
end

## Simulation functions
function simulate(npts; f=generate_random_points, edges=nothing)
    reset_opstats!()
    if f isa Function
    pts = f(npts)
    else 
        pts=f # later, when we look at constrained triangulations, we&#39;ll pass points and edges but not f as a function 
    end
    triangulate(pts; TriangleType=CustomTriangle, edges=edges)
    return AlgorithmStats(opstats[Base.Threads.threadid()])
end
function simulate(npts, nsims; f=generate_random_points, edges=nothing)
    sim_results = Vector{AlgorithmStats}(undef, nsims)
    for i in 1:nsims
        sim_results[i] = simulate(npts; f, edges)
    end
    return sim_results, summarise_simulations(sim_results)
end
function simulate(npts::AbstractVector{Int}, nsims; f=generate_random_points, edges=nothing)
    sim_results = Vector{Tuple{Vector{AlgorithmStats},AlgorithmStatsSummary}}(undef, length(npts))
    Base.Threads.@threads :static for i in eachindex(npts)
        n = npts[i]
        sim_results[i] = simulate(n, nsims; f, edges)
    end
    return first.(sim_results), last.(sim_results)
end

## Complete plotting function
const alp = join(&#39;a&#39;:&#39;z&#39;)
function plot_fnc!(fig, i, j, statistic, title, simulation_results, simulation_summaries, npts, dolog=false)
    scale = dolog ? log10 : identity
    ax = Axis(fig[i, j], xlabel=L&quot;n&quot;, ylabel=L&quot;$ $Number&quot;, title=title, titlealign=:left, width=600, height=300, xscale=scale, yscale=scale)
    scatters = NTuple{2,Int}[]
    lower = Vector{Float64}(undef, length(npts))
    upper = Vector{Float64}(undef, length(npts))
    for (k, n) in enumerate(npts)
        for sim in simulation_results[k]
            push!(scatters, (n, getfield(sim, statistic)))
        end
        result = getfield(simulation_summaries[k], statistic)
        lower[k] = result[1]
        upper[k] = result[2]
    end
    scatter!(ax, scatters, color=:black, markersize=3)
    band!(ax, npts, lower, upper, color=(:blue, 0.2), strokewidth=2)
end
function plot_fnc(npts, simulation_results, simulation_summaries)
    fig = Figure(fontsize=36)
    dolog = (true, false, false, false, false, false, false)
    for (k, (f, dolog)) in enumerate(zip(fieldnames(AlgorithmStats), dolog))
        title = L&quot;(%$(alp[k])):$ $ %$(f)&quot;
        i, j = ceil(Int, k / 4), mod1(k, 4)
        plot_fnc!(fig, i, j, f, title, simulation_results, simulation_summaries, npts, dolog)
    end
    resize_to_layout!(fig)
    fig
end

## Analysis functions for constrained triangulations: We&#39;ll fix the number of points and vary the number of edges 
function get_random_vertices_and_constrained_edges(nverts1, nverts2, nedges, f)
    ## To generate a random set of constrained edges, we get a random small triangulation, 
    ## and we just take the edges from that triangulation.
    points = f(nverts1)
    tri = triangulate(points)
    edges = Set{NTuple{2,Int}}()
    all_edges = collect(each_solid_edge(tri))
    iter = 0
    while length(edges) &lt; nedges &amp;&amp; iter &lt; 10000
        S = DT.random_edge(all_edges)
        push!(edges, S)
        iter += 1
    end
    ## Now get the rest of the points 
    while length(points) &lt; nverts2
        push!(points, CustomPoint(rand(), rand()))
    end
    return points, edges
end
function simulate_cdt(ne::AbstractVector{Int}, nsims; f=generate_random_points)
    sim_results = Vector{Tuple{Vector{AlgorithmStats},AlgorithmStatsSummary}}(undef, length(ne))
    Base.Threads.@threads :static for i in eachindex(ne)
        points, edges = get_random_vertices_and_constrained_edges(500, 2000, ne[i], f)
        sim_results[i] = simulate(ne[i], nsims; f=points, edges)
    end
    return first.(sim_results), last.(sim_results)
end</code></pre><h3 id="The-Analysis"><a class="docs-heading-anchor" href="#The-Analysis">The Analysis</a><a id="The-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#The-Analysis" title="Permalink"></a></h3><p>Now let&#39;s do the actual analysis and show the actual figures. For this analysis, we compare the results when using randomly distributed points, and when using point sets with many collinearities. It would be interesting to revisit these results when we later have methods for spatial sorting (<a href="https://github.com/DanielVandH/DelaunayTriangulation.jl/issues/34">#34</a>).</p><p>First, let&#39;s look at the unconstrained triangulations.</p><pre><code class="language-julia hljs">npts = [ceil(Int, 10^x) for x in LinRange(1, 4, 250)] |&gt; unique
nsims = 10
simulation_results_random, simulation_summaries_random = simulate(npts, nsims; f=generate_random_points)
simulation_results_structured, simulation_summaries_structured = simulate(npts, nsims; f=generate_structured_points)

fig_random = plot_fnc(npts, simulation_results_random, simulation_summaries_random)
fig_structured = plot_fnc(npts, simulation_results_structured, simulation_summaries_structured)</code></pre><figure>
    <img src='../figs/random.png', alt='Counting random unconstrained triangulation function calls'><br>
</figure><figure>
    <img src='../figs/structured.png', alt='Counting structured unconstrained triangulation function calls'><br>
</figure><p>Of course, <code>parallelorder_predicate</code> is not called at any time as it is only used for computing constrained triangulations. We see that the number of <code>orient_predicate</code> calls grows exponentially with the number of points (note the log scales in (a)). The number of <code>incircle_calls</code> appears linear in <code>n</code>, as do the number of added and deleted triangles (which is probably clear from Euler&#39;s formula). Moreover, we see that there are no <code>sameside_calls</code> for the random point sets, but when we introduce many collinearities we have to spend a lot of time calling <code>sameside_calls</code> to resolve collinearities in the point location steps. The number of <code>meet_calls</code> is pretty similar between the two point set types, although we use call it more often in the structured case. (<code>meet_predicate</code> is used when classifying the type of an intersection when we start the point location step at a point on the boundary, allowing us to distinguish correctly between the exterior and the interior of the domain, and also between the boundary of the domain itself in the structured case.)</p><p>Next, here are the results for the constrained triangulations, keeping the number of points fixed at <span>$2,000$</span> and varying the number of edges (no boundary nodes).</p><pre><code class="language-julia hljs">ne = [ceil(Int, 10^x) for x in LinRange(0.3, 3, 270)] |&gt; unique
simulation_results_random_cdt, simulation_summaries_random_cdt = simulate_cdt(ne, nsims; f=generate_random_points)
simulation_results_structured_cdt, simulation_summaries_structured_cdt = simulate_cdt(ne, nsims; f=generate_structured_points)

fig_random_cdt = plot_fnc(ne, simulation_results_random_cdt, simulation_summaries_random_cdt)
fig_structured_cdt = plot_fnc(ne, simulation_results_structured_cdt, simulation_summaries_structured_cdt)</code></pre><figure>
    <img src='../figs/random_cdt.png', alt='Counting random constrained triangulation function calls'><br>
</figure><figure>
    <img src='../figs/structured_cdt.png', alt='Counting structured constrained triangulation function calls'><br>
</figure><p>Remember that, in these plots, <span>$n$</span> is the number of edges. The results are pretty similar in this case. The number of <code>orient</code> calls is now linear in the number of constrained edges, despite it being exponential in the number of points. The other new result is <code>parallelorder</code> is called very few times, also being roughly linear in <span>$n$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Example</a><a class="docs-footer-nextpage" href="../../predicates/">Predicates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 7 September 2023 12:58">Thursday 7 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
