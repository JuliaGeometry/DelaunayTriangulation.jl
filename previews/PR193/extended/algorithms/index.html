<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Internals · DelaunayTriangulation.jl</title><meta name="title" content="Algorithm Internals · DelaunayTriangulation.jl"/><meta property="og:title" content="Algorithm Internals · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Algorithm Internals · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/extended/algorithms/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/extended/algorithms/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/extended/algorithms/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Algorithm Internals</a><ul class="internal"><li><a class="tocitem" href="#Unconstrained-Triangulations"><span>Unconstrained Triangulations</span></a></li><li><a class="tocitem" href="#Triangulation-Rectangular-Domains"><span>Triangulation Rectangular Domains</span></a></li><li><a class="tocitem" href="#Triangulating-Convex-Polygons"><span>Triangulating Convex Polygons</span></a></li><li><a class="tocitem" href="#Constrained-Triangulations"><span>Constrained Triangulations</span></a></li><li><a class="tocitem" href="#Weighted-Triangulations"><span>Weighted Triangulations</span></a></li><li><a class="tocitem" href="#Mesh-Refinement"><span>Mesh Refinement</span></a></li><li><a class="tocitem" href="#RTree"><span>RTree</span></a></li><li><a class="tocitem" href="#Point-Location"><span>Point Location</span></a></li><li><a class="tocitem" href="#Triangulation-Operations"><span>Triangulation Operations</span></a></li><li><a class="tocitem" href="#Voronoi-Tessellations"><span>Voronoi Tessellations</span></a></li><li><a class="tocitem" href="#Clipped-Voronoi-Tessellations"><span>Clipped Voronoi Tessellations</span></a></li><li><a class="tocitem" href="#Centroidal-Voronoi-Tessellations"><span>Centroidal Voronoi Tessellations</span></a></li><li><a class="tocitem" href="#Triangulating-Curve-Bounded-Domains"><span>Triangulating Curve-Bounded Domains</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extended Reference</a></li><li class="is-active"><a href>Algorithm Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/extended/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-Internals"><a class="docs-heading-anchor" href="#Algorithm-Internals">Algorithm Internals</a><a id="Algorithm-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Internals" title="Permalink"></a></h1><p>Here we give some functions that are used for some of the algorithms in this package.</p><h2 id="Unconstrained-Triangulations"><a class="docs-heading-anchor" href="#Unconstrained-Triangulations">Unconstrained Triangulations</a><a id="Unconstrained-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Unconstrained-Triangulations" title="Permalink"></a></h2><p>Here are some of the internal functions used for the Bowyer-Watson algorithm, i.e. for the computation of an unconstrained triangulation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.postprocess_triangulate!" href="#DelaunayTriangulation.postprocess_triangulate!"><code>DelaunayTriangulation.postprocess_triangulate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">postprocess_triangulate!(tri; delete_ghosts=false, delete_empty_features=true, recompute_representative_points=true)</code></pre><p>Postprocesses the triangulation <code>tri</code> after it has been constructed using <a href="../../api/triangulation/#DelaunayTriangulation.triangulate"><code>triangulate</code></a>. This includes:</p><ul><li>Deleting ghost triangles using <a href="../../api/operations/#DelaunayTriangulation.delete_ghost_triangles!"><code>delete_ghost_triangles!</code></a> if <code>delete_ghosts</code> is <code>true</code>.</li><li>Clearing empty features using <a href="../../api/operations/#DelaunayTriangulation.clear_empty_features!"><code>clear_empty_features!</code></a> if <code>delete_empty_features</code> is <code>true</code>.</li><li>Recomputing the representative points using <a href="../../api/triangulation/#DelaunayTriangulation.compute_representative_points!"><code>compute_representative_points!</code></a> if <code>recompute_representative_points</code> is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/main.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_point_bowyer_watson!-Union{Tuple{P}, Tuple{I}, Tuple{Triangulation, Any, I}, Tuple{Triangulation, Any, I, Random.AbstractRNG}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any, P}} where {I, P}" href="#DelaunayTriangulation.add_point_bowyer_watson!-Union{Tuple{P}, Tuple{I}, Tuple{Triangulation, Any, I}, Tuple{Triangulation, Any, I, Random.AbstractRNG}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any, P}} where {I, P}"><code>DelaunayTriangulation.add_point_bowyer_watson!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point_bowyer_watson!(tri::Triangulation, new_point, initial_search_point::I, rng::Random.AbstractRNG=Random.default_rng(), update_representative_point=true, store_event_history=Val(false), event_history=nothing, peek::P=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Triangle</code></pre><p>Adds <code>new_point</code> into <code>tri</code>. </p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The triangulation.</li><li><code>new_point</code>: The point to insert.</li><li><code>initial_search_point::I</code>: The vertex to start the point location with <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> at. See <a href="#DelaunayTriangulation.get_initial_search_point-Union{Tuple{F}, Tuple{Triangulation, Any, Any, Any, F, Any, Any}} where F"><code>get_initial_search_point</code></a>.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>update_representative_point=true</code>: If <code>true</code>, then the representative point is updated. See <a href="../data_structures/#DelaunayTriangulation.update_centroid_after_addition!"><code>update_centroid_after_addition!</code></a>.</li><li><code>store_event_history=Val(false)</code>: If <code>true</code>, then the event history from the insertion is stored. </li><li><code>event_history=nothing</code>: The event history to store the event history in. Should be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> if <code>store_event_history</code> is <code>true</code>, and <code>false</code> otherwise.</li><li><code>peek=Val(false)</code>: Whether to actually add <code>new_point</code> into <code>tri</code>, or just record into <code>event_history</code> all the changes that would occur from its insertion.</li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle in <code>tri</code> containing <code>new_point</code>.</li></ul><p><strong>Extended help</strong></p><p>This function works as follows:</p><ol><li>First, the triangle containing the new point, <code>V</code>, is found using <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</li><li>Once the triangle is found, we call into <code>add_point_bowyer_watson_and_process_after_found_triangle</code> to properly insert the point. </li><li>Inside <code>add_point_bowyer_watson_and_process_after_found_triangle</code>, we first call into <code>add_point_bowyer_watson_after_found_triangle</code> to add the point into the cavity. We then  call into <code>add_point_bowyer_watson_onto_segment</code> to make any changes necessary incase the triangulation is constrained and <code>new_point</code> lies on a segment, since the depth-first search of the triangles containing <code>new_point</code> in its circumcenter must be performed on each side of the segment that <code>new_point</code> lies on.</li></ol><p>The function <a href="#DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!-Union{Tuple{F}, Tuple{N}, Tuple{Triangulation, N, Any, Any, Any}, Tuple{Triangulation, N, Vararg{Any, 4}}, Tuple{Triangulation, N, Vararg{Any, 5}}, Tuple{Triangulation, N, Vararg{Any, 6}}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where {N, F}"><code>add_point_bowyer_watson_dig_cavities!</code></a> is the main workhorse of this function from <code>add_point_bowyer_watson_after_found_triangle</code>. See its docstring for the details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L121-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!-Union{Tuple{F}, Tuple{N}, Tuple{Triangulation, N, Any, Any, Any}, Tuple{Triangulation, N, Vararg{Any, 4}}, Tuple{Triangulation, N, Vararg{Any, 5}}, Tuple{Triangulation, N, Vararg{Any, 6}}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where {N, F}" href="#DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!-Union{Tuple{F}, Tuple{N}, Tuple{Triangulation, N, Any, Any, Any}, Tuple{Triangulation, N, Vararg{Any, 4}}, Tuple{Triangulation, N, Vararg{Any, 5}}, Tuple{Triangulation, N, Vararg{Any, 6}}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where {N, F}"><code>DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point_bowyer_watson_dig_cavities!(tri::Triangulation, new_point::N, V, q, flag, update_representative_point=true, store_event_history=Val(false), event_history=nothing, peek::F=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) where {N,F}</code></pre><p>Deletes all the triangles in <code>tri</code> whose circumcircle contains <code>new_point</code>. This leaves behind a polygonal cavity, whose boundary edges are then connected to <code>new_point</code>, restoring the Delaunay property from <code>new_point</code>&#39;s insertion.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>new_point::N</code>: The point to insert.</li><li><code>V</code>: The triangle in <code>tri</code> containing <code>new_point</code>.</li><li><code>q</code>: The point to insert.</li><li><code>flag</code>: The position of <code>q</code> relative to <code>V</code>. See <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_triangle"><code>point_position_relative_to_triangle</code></a>.</li><li><code>update_representative_point=true</code>: If <code>true</code>, then the representative point is updated. See <a href="../data_structures/#DelaunayTriangulation.update_centroid_after_addition!"><code>update_centroid_after_addition!</code></a>.</li><li><code>store_event_history=Val(false)</code>: If <code>true</code>, then the event history from the insertion is stored.</li><li><code>event_history=nothing</code>: The event history to store the event history in. Should be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> if <code>store_event_history</code> is <code>true</code>, and <code>false</code> otherwise.</li><li><code>peek=Val(false)</code>: Whether to actually add <code>new_point</code> into <code>tri</code>, or just record into <code>event_history</code> all the changes that would occur from its insertion.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><p>There are no changes, but <code>tri</code> is updated in-place.</p><p><strong>Extended help</strong></p><p>This function works as follows: </p><ol><li>To dig the cavity, we call <a href="#DelaunayTriangulation.dig_cavity!-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 6}}, Tuple{Triangulation, Vararg{Any, 7}}, Tuple{Triangulation, Vararg{Any, 8}}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where F"><code>dig_cavity!</code></a> on each edge of <code>V</code>, stepping towards the adjacent triangles to excavate the cavity recursively.</li><li>Once the cavity has been excavated, extra care is needed in case <code>is_on(flag)</code>, meaning <code>new_point</code> is on one of the edges of <code>V</code>. In particular, extra care is needed if: <code>is_on(flag) &amp;&amp; (is_boundary_triangle(tri, V) || is_ghost_triangle(V) &amp;&amp; !is_boundary_node(tri, new_point)[1])</code>. The need for this check is in case <code>new_point</code> is on a boundary edge already exists, since we need to fix the associated ghost edges. For example, a boundary edge <code>(i, k)</code> might have been  split into the edges <code>(i, j)</code> and <code>(j, k)</code>, which requires that the ghost triangle <code>(k, i, g)</code> be split into <code>(j, i, g)</code> and <code>(k, j, g)</code>, where <code>g</code> is the ghost vertex. This part of the function  will fix this case. The need for <code>is_ghost_triangle(V) &amp;&amp; !is_boundary_node(tri, new_point)[1]</code> is in case the ghost edges were already correctly added. Nothing happens if the edge of <code>V</code> that <code>new_point</code>  is on is not the boundary edge.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L187-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.dig_cavity!-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 6}}, Tuple{Triangulation, Vararg{Any, 7}}, Tuple{Triangulation, Vararg{Any, 8}}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where F" href="#DelaunayTriangulation.dig_cavity!-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 6}}, Tuple{Triangulation, Vararg{Any, 7}}, Tuple{Triangulation, Vararg{Any, 8}}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where F"><code>DelaunayTriangulation.dig_cavity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dig_cavity!(tri::Triangulation, r, i, j, ℓ, flag, V, store_event_history=Val(false), event_history=nothing, peek::F=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) where {F}</code></pre><p>Excavates the cavity in <code>tri</code> through the edge <code>(i, j)</code>, stepping towards the adjacent triangles to excavate the cavity recursively, eliminating all  triangles containing <code>r</code> in their circumcircle. </p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>r</code>: The new point being inserted. </li><li><code>i</code>: The first vertex of the edge <code>(i, j)</code>.</li><li><code>j</code>: The second vertex of the edge <code>(i, j)</code>.</li><li><code>ℓ</code>: The vertex adjacent to <code>(j, i)</code>, so that the triangle being stepped into is <code>(j, i, ℓ)</code>.</li><li><code>flag</code>: The position of <code>r</code> relative to <code>V</code>. See <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_triangle"><code>point_position_relative_to_triangle</code></a>.</li><li><code>V</code>: The triangle in <code>tri</code> containing <code>r</code>.</li><li><code>store_event_history=Val(false)</code>: If <code>true</code>, then the event history from the insertion is stored.</li><li><code>event_history=nothing</code>: The event history to store the event history in. Should be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> if <code>store_event_history</code> is <code>true</code>, and <code>false</code> otherwise.</li><li><code>peek=Val(false)</code>: Whether to actually add <code>new_point</code> into <code>tri</code>, or just record into <code>event_history</code> all the changes that would occur from its insertion.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><p>There are no changes, but <code>tri</code> is updated in-place.</p><p><strong>Extended help</strong></p><p>This function works as follows:</p><ol><li>First, we check if <code>ℓ</code> is 0, which would imply that the triangle <code>(j, i, ℓ)</code> doesn&#39;t exist as it has already been deleted. If this is the check, we return and stop digging. </li><li>If the edge <code>(i, j)</code> is not a segment, <code>r</code> is inside of the circumcenter of <code>(j, i, ℓ)</code>, and <code>ℓ</code> is not a ghost vertex, then we can step forward into the next triangles. In particular,  we delete the triangle <code>(j, i, ℓ)</code> from <code>tri</code> and then call <code>dig_cavity!</code> again on two edges of <code>(j, i, ℓ)</code> other than <code>(j, i)</code>.</li><li>If we did not do step 2, then this means that we are on the edge of the polygonal cavity; this also covers the case that <code>ℓ</code> is a ghost vertex, i.e. we are at the boundary of the triangulation. There are two cases to consider here. Firstly, if <code>(i, j)</code> is not a segment, we just need to add the triangle <code>(r, i, j)</code> into <code>tri</code> to connect <code>r</code> to this edge of the polygonal cavity. If  <code>(i, j)</code> is a segment, then the situation is more complicated. In particular, <code>r</code> being on an edge of <code>V</code> might imply that we are going to add a degenerate triangle <code>(r, i, j)</code> into <code>tri</code>,  and so this needs to be avoided. So, we check if <code>is_on(flag) &amp;&amp; contains_segment(tri, i, j)</code> and, if the edge that <code>r</code> is on is <code>(i, j)</code>, we add the triangle <code>(r, i, j)</code>. Otherwise, we do nothing.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L308-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enter_cavity" href="#DelaunayTriangulation.enter_cavity"><code>DelaunayTriangulation.enter_cavity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enter_cavity(tri::Triangulation, r, i, j, ℓ, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Bool</code></pre><p>Determines whether to enter the cavity in <code>tri</code> through the edge <code>(i, j)</code> when inserting <code>r</code> into the triangulation.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>r</code>: The new point being inserted.</li><li><code>i</code>: The first vertex of the edge <code>(i, j)</code>.</li><li><code>j</code>: The second vertex of the edge <code>(i, j)</code>.</li><li><code>ℓ</code>: The vertex adjacent to <code>(j, i)</code>, so that the triangle being stepped into is <code>(j, i, ℓ)</code>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><ul><li><code>true</code> if the cavity should be entered, and <code>false</code> otherwise. See also <a href="#DelaunayTriangulation.dig_cavity!-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 6}}, Tuple{Triangulation, Vararg{Any, 7}}, Tuple{Triangulation, Vararg{Any, 8}}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where F"><code>dig_cavity!</code></a> and <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_circumcircle"><code>point_position_relative_to_circumcircle</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L282-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_initial_search_point-Union{Tuple{F}, Tuple{Triangulation, Any, Any, Any, F, Any, Any}} where F" href="#DelaunayTriangulation.get_initial_search_point-Union{Tuple{F}, Tuple{Triangulation, Any, Any, Any, F, Any, Any}} where F"><code>DelaunayTriangulation.get_initial_search_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_initial_search_point(tri::Triangulation, num_points, new_point, insertion_order, num_sample_rule::F, rng, try_last_inserted_point) where {F} -&gt; Vertex</code></pre><p>For a given iteration of the Bowyer-Watson algorithm, finds the point to start the point location with <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> at.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The triangulation.</li><li><code>num_points</code>: The number of points currently in the triangulation.</li><li><code>new_point</code>: The point to insert.</li><li><code>insertion_order</code>: The insertion order of the points. See <a href="../../api/triangulation/#DelaunayTriangulation.get_insertion_order"><code>get_insertion_order</code></a>.</li><li><code>num_sample_rule::F</code>: The rule to use to determine the number of points to sample. See <a href="#DelaunayTriangulation.default_num_samples-Tuple{I} where I"><code>default_num_samples</code></a> for the default. </li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li><li><code>try_last_inserted_point</code>: If <code>true</code>, then the last inserted point is also considered as the start point. </li></ul><p><strong>Output</strong></p><ul><li><code>initial_search_point</code>: The vertex to start the point location with <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> at.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L94-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_initial_triangle" href="#DelaunayTriangulation.get_initial_triangle"><code>DelaunayTriangulation.get_initial_triangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_initial_triangle(tri::Triangulation, insertion_order, itr=0) -&gt; Triangle</code></pre><p>Gets the initial triangle for the Bowyer-Watson algorithm. </p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The triangulation.</li><li><code>insertion_order</code>: The insertion order of the points. See <a href="../../api/triangulation/#DelaunayTriangulation.get_insertion_order"><code>get_insertion_order</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>itr=0</code>: To avoid issues with degenerate triangles and infinite loops, this counts the number of times <code>insertion_order</code> had to be shifted using <code>circshift!</code> to find an initial non-degenerate triangle.</li></ul><p><strong>Output</strong></p><ul><li><code>initial_triangle</code>: The initial triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_insertion_order-Union{Tuple{I}, Tuple{Any, Any, Any, Type{I}, Any}} where I" href="#DelaunayTriangulation.get_insertion_order-Union{Tuple{I}, Tuple{Any, Any, Any, Type{I}, Any}} where I"><code>DelaunayTriangulation.get_insertion_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_insertion_order(points, randomise, skip_points, ::Type{I}, rng) where {I} -&gt; Vector{I}
get_insertion_order(tri::Triangulation, randomise, skip_points, rng) -&gt; Vector{I}</code></pre><p>Gets the insertion order for points into a triangulation. </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The points to insert.</li><li><code>randomise</code>: If <code>true</code>, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.</li><li><code>skip_points</code>: The points to skip.</li><li><code>I::Type{I}</code>: The type of the vertices.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li></ul><p><strong>Output</strong></p><ul><li><code>order</code>: The order to insert the points in.</li></ul><div class="admonition is-warning"><header class="admonition-header">Mutation of `order`</header><div class="admonition-body"><p>This <code>order</code> might be mutated (by <code>circshift!</code>) in <a href="#DelaunayTriangulation.get_initial_triangle"><code>get_initial_triangle</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.initialise_bowyer_watson!" href="#DelaunayTriangulation.initialise_bowyer_watson!"><code>DelaunayTriangulation.initialise_bowyer_watson!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_bowyer_watson!(tri::Triangulation, insertion_order, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Triangulation</code></pre><p>Initialises the Bowyer-Watson algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The triangulation.</li><li><code>insertion_order</code>: The insertion order of the points. See <a href="../../api/triangulation/#DelaunayTriangulation.get_insertion_order"><code>get_insertion_order</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><p><code>tri</code> is updated in place to contain the initial triangle from which the Bowyer-Watson algorithm starts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L64-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.unconstrained_triangulation!-Union{Tuple{Triangulation}, Tuple{M}} where M" href="#DelaunayTriangulation.unconstrained_triangulation!-Union{Tuple{Triangulation}, Tuple{M}} where M"><code>DelaunayTriangulation.unconstrained_triangulation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unconstrained_triangulation!(tri::Triangulation; kwargs...)</code></pre><p>Computes the unconstrained Delaunay triangulation of the points in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The triangulation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>randomise=true</code>: If <code>true</code>, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.</li><li><code>skip_points=()</code>: The vertices to skip. </li><li><code>num_sample_rule::M=default_num_samples</code>: The rule to use to determine the number of points to sample. See <a href="#DelaunayTriangulation.default_num_samples-Tuple{I} where I"><code>default_num_samples</code></a> for the default.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>insertion_order=get_insertion_order(tri, randomise, skip_points, rng)</code>: The insertion order of the points. See <a href="../../api/triangulation/#DelaunayTriangulation.get_insertion_order"><code>get_insertion_order</code></a>.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/unconstrained_triangulation.jl#L429-L447">source</a></section></article><h2 id="Triangulation-Rectangular-Domains"><a class="docs-heading-anchor" href="#Triangulation-Rectangular-Domains">Triangulation Rectangular Domains</a><a id="Triangulation-Rectangular-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulation-Rectangular-Domains" title="Permalink"></a></h2><p>Here are some of the internal functions used for <code>triangulate_rectangle</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_lattice_triangles" href="#DelaunayTriangulation.get_lattice_triangles"><code>DelaunayTriangulation.get_lattice_triangles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lattice_triangles(nx, ny, Ts, V)</code></pre><p>Computes the triangles defining a lattice with <code>nx</code> and <code>ny</code> points in the <code>x</code>- and <code>y</code>-directions, respectively.</p><p>See <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_rectangle"><code>triangulate_rectangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>nx</code>: The number of <code>x</code> points in the lattice.</li><li><code>ny</code>: The number of <code>y</code> points in the lattice.</li><li><code>Ts</code>: The type to use for representing a collection of triangles.</li><li><code>V</code>: The type to use for representing an individual triangle.</li></ul><p><strong>Outputs</strong></p><ul><li><code>T</code>: The collection of triangles.</li><li><code>sub2ind</code>: A map that takes cartesian indices <code>(i, j)</code> into the associated linear index along the lattice. See <code>LinearIndices</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_rectangle.jl#L54-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_lattice_points" href="#DelaunayTriangulation.get_lattice_points"><code>DelaunayTriangulation.get_lattice_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lattice_points(a, b, c, d, nx, ny, sub2ind)</code></pre><p>Returns the points on a lattice <code>[a, b] × [c, d]</code>.</p><p>See <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_rectangle"><code>triangulate_rectangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The minimum <code>x</code>-coordinate. </li><li><code>b</code>: The maximum <code>x</code>-coordinate.</li><li><code>c</code>: The minimum <code>y</code>-coordinate.</li><li><code>d</code>: The maximum <code>y</code>-coordinate.</li><li><code>nx</code>: The number of points in the <code>x</code>-direction.</li><li><code>ny</code>: The number of points in the <code>y</code>-direction.</li><li><code>sub2ind</code>: The map returned from <a href="#DelaunayTriangulation.get_lattice_triangles"><code>get_lattice_triangles</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>points</code>: The points on the lattice, where <code>points[sub2ind[CartesianIndex(i, j)]]</code> is the point at the <code>i</code>th <code>x</code> point and the <code>j</code>th <code>y</code> point,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_rectangle.jl#L92-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_lattice_boundary" href="#DelaunayTriangulation.get_lattice_boundary"><code>DelaunayTriangulation.get_lattice_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lattice_boundary(nx, ny, sub2ind, single_boundary, IntegerType)</code></pre><p>Returns the boundary nodes defining a lattice. </p><p>See <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_rectangle"><code>triangulate_rectangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>nx</code>: The number of <code>x</code> points in the lattice.</li><li><code>ny</code>: The number of <code>y</code> points in the lattice.</li><li><code>sub2ind</code>: The map returned from <a href="#DelaunayTriangulation.get_lattice_triangles"><code>get_lattice_triangles</code></a>.</li><li><code>single_boundary</code>: If <code>true</code>, then the boundary nodes are stored as a contiguous section. Otherwise, the boundary is split into four sections, in the order   bottom, right, top, left.</li><li><code>IntegerType</code>: The type used for representing vertices. </li></ul><p><strong>Outputs</strong></p><ul><li><code>boundary_nodes</code>: The boundary nodes, returned according to <code>single_boundary</code> as described above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_rectangle.jl#L126-L143">source</a></section></article><h2 id="Triangulating-Convex-Polygons"><a class="docs-heading-anchor" href="#Triangulating-Convex-Polygons">Triangulating Convex Polygons</a><a id="Triangulating-Convex-Polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulating-Convex-Polygons" title="Permalink"></a></h2><p>Here are some functions used in <code>triangulate_convex</code> for triangulating a convex polygon.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_point_convex_triangulation!" href="#DelaunayTriangulation.add_point_convex_triangulation!"><code>DelaunayTriangulation.add_point_convex_triangulation!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point_convex_triangulation!(tri::Triangulation, u, v, w, S, predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Adds the point <code>u</code> into the triangulation <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>: The vertex to add.</li><li><code>v</code>: The vertex next to <code>u</code>.</li><li><code>w</code>: The vertex previous to <code>u</code>.</li><li><code>S</code>: The set of vertices of the polygon.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is modified in-place.</p><p><strong>Extended help</strong></p><p>This function forms part of Chew&#39;s algorithm for triangulating a convex polygon. There are some important points  to make.</p><ol><li>Firstly, checking that <code>x = get_adjacent(tri, w, v)</code> is needed to prevent the algorithm from exiting the polygon.</li></ol><p>This is important in case this algorithm is used as part of <a href="../../api/operations/#DelaunayTriangulation.delete_point!"><code>delete_point!</code></a>. When you are just triangulating   a convex polygon by itself, this checked is the same as checking <code>edge_exists(tri, w, v)</code>.</p><ol><li>For this method to be efficient, the set <code>x ∈ S</code> must be <code>O(1)</code> time. This is why we use a <code>Set</code> type for <code>S</code>.</li><li>The algorithm is recursive, recursively digging further through the polygon to find non-Delaunay edges to adjoins with <code>u</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_convex.jl#L96-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}" href="#DelaunayTriangulation.delete_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}"><code>DelaunayTriangulation.delete_vertices_in_random_order!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_vertices_in_random_order!(list::Triangulation, tri::ShuffledPolygonLinkedList, rng, predicates::AbstractPredicateKernel)</code></pre><p>Deletes the vertices of the polygon represented by <code>list</code> in random order, done by switching  the pointers of the linked list. Only three vertices will survive. If these these three vertices are  collinear, then the deletion is attempted again after reshuffling the vertices.</p><p><strong>Arguments</strong></p><ul><li><code>list::ShuffledPolygonLinkedList</code>: The linked list representing the polygon to be deleted.</li><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>. </li><li><code>rng::Random.AbstractRNG</code>: The random number generator used to shuffle the vertices of <code>S</code>. </li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>list</code> is modified in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_convex.jl#L63-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.postprocess_triangulate_convex!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.postprocess_triangulate_convex!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.postprocess_triangulate_convex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">postprocess_triangulate_convex!(tri::Triangulation, S; delete_ghosts, delete_empty_features)</code></pre><p>Postprocesses the completed triangulation <code>tri</code> of the convex polygon <code>S</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>S</code>: The vertices of the convex polygon, as in <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_convex"><code>triangulate_convex</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>delete_ghosts=false</code>: If <code>true</code>, the ghost triangles are deleted after triangulation.</li><li><code>delete_empty_features=true</code>: If <code>true</code>, the empty features are deleted after triangulation.</li></ul><p><strong>Output</strong></p><p>There are no output, as <code>tri</code> is modified in-place. The postprocessing that is done is:</p><ol><li>The convex hull of <code>tri</code> is set to <code>S</code>.</li><li>The ghost triangles are deleted if <code>delete_ghosts=true</code>.</li><li>The empty features are deleted if <code>delete_empty_features=true</code>.</li><li>The representative points are set to the centroid of <code>S</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_convex.jl#L136-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_convex!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.triangulate_convex!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.triangulate_convex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_convex!(tri::Triangulation, S; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Triangulates the convex polygon <code>S</code> in-place into <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation to be modified.</li><li><code>S</code>: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that <code>S[begin] ≠ S[end]</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng=Random.default_rng()</code>: The random number generator used to shuffle the vertices of <code>S</code> before triangulation.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place. This function does not do any post-processing, e.g. deleting any ghost triangles. This is done by  <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_convex"><code>triangulate_convex</code></a> or <a href="#DelaunayTriangulation.postprocess_triangulate_convex!-Tuple{Triangulation, Any}"><code>postprocess_triangulate_convex!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_convex.jl#L34-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_convex-Tuple{Any, Any}" href="#DelaunayTriangulation.triangulate_convex-Tuple{Any, Any}"><code>DelaunayTriangulation.triangulate_convex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_convex(points, S; delete_ghosts=false, delete_empty_features=true, rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -&gt; Triangulation</code></pre><p>Triangulates the convex polygon <code>S</code>.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The point set corresponding to the vertices in <code>S</code>.</li><li><code>S</code>: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that <code>S[begin] ≠ S[end]</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>delete_ghosts=false</code>: If <code>true</code>, the ghost triangles are deleted after triangulation. </li><li><code>delete_empty_features=true</code>: If <code>true</code>, the empty features are deleted after triangulation.</li><li><code>rng=Random.default_rng()</code>: The random number generator used to shuffle the vertices of <code>S</code> before triangulation.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>Triangulation</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>tri::Triangulation</code>: The triangulated polygon. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_convex.jl#L1-L19">source</a></section></article><h2 id="Constrained-Triangulations"><a class="docs-heading-anchor" href="#Constrained-Triangulations">Constrained Triangulations</a><a id="Constrained-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Triangulations" title="Permalink"></a></h2><p>There are many functions to list for the computation of a constrained triangulation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_segment!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.add_segment!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.add_segment!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_segment!(tri::Triangulation, segment; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())
add_segment!(tri::Triangulation, i, j; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())</code></pre><p>Adds <code>segment = (i, j)</code> to <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segment</code>: The segment to add. The second method uses <code>(i, j)</code> to represent the segment instead.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: The RNG object.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that it now contains <code>segment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/add_segment.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_segment_to_list!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.add_segment_to_list!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.add_segment_to_list!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_segment_to_list!(tri::Triangulation, e)</code></pre><p>Adds <code>e</code> to <code>get_interior_segments(tri)</code> and <code>get_all_segments(tri)</code> if it, or <code>reverse_edge(e)</code>, is not already in the sets.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>e</code>: The edge to add.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that <code>e</code> is in <code>get_interior_segments(tri)</code> and <code>get_all_segments(tri)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/add_segment.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.fix_edge_order_after_rotation!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.fix_edge_order_after_rotation!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.fix_edge_order_after_rotation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_edge_order_after_rotation!(tri::Triangulation, segment, e)</code></pre><p>Fixes the edge order in <code>get_interior_segments(tri)</code> after <code>segment</code> was rotated by <a href="#DelaunayTriangulation.optimise_edge_order-Tuple{Triangulation, Any}"><code>optimise_edge_order</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segment</code>: The segment that was arranged.</li><li><code>e</code>: The arranged segment from <a href="#DelaunayTriangulation.optimise_edge_order-Tuple{Triangulation, Any}"><code>optimise_edge_order</code></a>.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that <code>e</code> is in <code>get_interior_segments(tri)</code> instead of <code>segment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/add_segment.jl#L15-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.optimise_edge_order-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.optimise_edge_order-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.optimise_edge_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimise_edge_order(tri::Triangulation, segment) -&gt; Edge</code></pre><p>Optimises the orientation of <code>segment</code> for inserting it into the triangulation. </p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segment</code>: The segment to arrange. </li></ul><p><strong>Outputs</strong></p><ul><li><code>e</code>: If <code>segment</code> is a boundary edge, then <code>e = segment</code>, Otherwise, <code>e = sort_edge_by_degree(tri, segment)</code> so that <code>initial(e)</code> has the smaller degree of the two vertices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/add_segment.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_new_triangles!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.add_new_triangles!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.add_new_triangles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_new_triangles!(tri_original::Triangulation, tris)</code></pre><p>Adds the triangles from <code>tris</code> to <code>tri_original</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L672-L676">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_point_cavity_cdt!" href="#DelaunayTriangulation.add_point_cavity_cdt!"><code>DelaunayTriangulation.add_point_cavity_cdt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point_cavity_cdt!(tri::Triangulation, u, v, w, marked_vertices)</code></pre><p>Adds a point to the cavity <code>V</code> left behind when deleting triangles intersected in a triangulation by an edge, updating <code>tri</code> to do so.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to update.</li><li><code>u</code>: The vertex to add.</li><li><code>v</code>: The vertex along the polygon that is next to <code>u</code>.</li><li><code>w</code>: The vertex along the polygon that is previous to <code>u</code>.</li><li><code>marked_vertices</code>: Cache for marking vertices to re-triangulate during the triangulation. This gets mutated.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> is updated in-place, as is <code>marked_vertices</code> if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L633-L647">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E" href="#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E"><code>DelaunayTriangulation.connect_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect_segments!(segments)</code></pre><p>Connects the ordered vector of <code>segments</code> so that the endpoints all connect, preserving order.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; segments = [(7, 12), (12, 17), (17, 22), (32, 37), (37, 42), (42, 47)];

julia&gt; DelaunayTriangulation.connect_segments!(segments)
7-element Vector{Tuple{Int64, Int64}}:
 (7, 12)
 (12, 17)
 (17, 22)
 (22, 32)
 (32, 37)
 (37, 42)
 (42, 47)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L63-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.constrained_triangulation!-Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, Any}" href="#DelaunayTriangulation.constrained_triangulation!-Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, Any}"><code>DelaunayTriangulation.constrained_triangulation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constrained_triangulation!(tri::Triangulation, segments, boundary_nodes, predicates::AbstractPredicateKernel, full_polygon_hierarchy; rng=Random.default_rng(), delete_holes=true) -&gt; Triangulation</code></pre><p>Creates a constrained triangulation from <code>tri</code> by adding <code>segments</code> and <code>boundary_nodes</code> to it. This will be in-place, but a new triangulation is returned  to accommodate the changed types.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segments</code>: The interior segments to add to the triangulation.</li><li><code>boundary_nodes</code>: The boundary nodes to add to the triangulation.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>full_polygon_hierarchy</code>: The <a href="../data_structures/#PolygonHierarchy"><code>PolygonHierarchy</code></a> defining the boundary. This will get copied into the existing polygon hierarchy.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng=Random.default_rng()</code>: The random number generator to use.</li><li><code>delete_holes=true</code>: Whether to delete holes in the triangulation. See <a href="../../api/operations/#DelaunayTriangulation.delete_holes!"><code>delete_holes!</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>new_tri</code>: The new triangulation, now containing <code>segments</code> in the <code>interior_segments</code> field and <code>boundary_nodes</code> in the <code>boundary_nodes</code> field, and with the updated <a href="../data_structures/#PolygonHierarchy"><code>PolygonHierarchy</code></a>. See also <a href="#DelaunayTriangulation.remake_triangulation_with_constraints-Tuple{Triangulation, Any, Any}"><code>remake_triangulation_with_constraints</code></a> and <a href="#DelaunayTriangulation.replace_ghost_vertex_information-Tuple{Triangulation, Any, Any}"><code>replace_ghost_vertex_information</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L805-L824">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_intersected_triangles!-Tuple{Any, Any}" href="#DelaunayTriangulation.delete_intersected_triangles!-Tuple{Any, Any}"><code>DelaunayTriangulation.delete_intersected_triangles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_intersected_triangles!(tri, triangles)</code></pre><p>Deletes the triangles in <code>triangles</code> from <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L732-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_polygon_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}" href="#DelaunayTriangulation.delete_polygon_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}"><code>DelaunayTriangulation.delete_polygon_vertices_in_random_order!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_polygon_vertices_in_random_order!(list::ShuffledPolygonLinkedList, tri::Triangulation, u, v, rng::Random.AbstractRNG, predicates::AbstractPredicateKernel)</code></pre><p>Deletes vertices from the polygon defined by <code>list</code> in a random order.</p><p><strong>Arguments</strong></p><ul><li><code>list::ShuffledPolygonLinkedList</code>: The linked list of polygon vertices.</li><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>, <code>v</code>: The vertices of the segment <code>(u, v)</code> that was inserted in order to define the polygon <code>V = list.S</code>.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>list</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L488-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E" href="#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E"><code>DelaunayTriangulation.extend_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extend_segments!(segments, segment)</code></pre><p>Given an ordered vector of <code>segments</code>, ensures that they also represent the replacement of <code>segment</code>. In particular,  suppose <code>segments</code> represents the sequence of edges</p><pre><code class="nohighlight hljs">    ---(i₁, i₂)---(i₂, i₃)---(⋯, ⋯)---(iₙ₋₁, iₙ)---</code></pre><p>and <code>segment</code> is <code>(i₀, iₙ₊₁)</code>. Then the extended sequence becomes </p><pre><code class="nohighlight hljs">    ---(i₀, i₁)---(i₁, i₂)---(i₂, i₃)---(⋯, ⋯)---(iₙ₋₁, iₙ)---(iₙ, iₙ₊₁)---</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; segments = [(2, 7), (7, 12), (12, 49)];

julia&gt; segment = (1, 68);

julia&gt; DelaunayTriangulation.extend_segments!(segments, segment)
5-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (2, 7)
 (7, 12)
 (12, 49)
 (49, 68)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L105-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E" href="#DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E"><code>DelaunayTriangulation.fix_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_segments!(segments, bad_indices)</code></pre><p>Fixes the overlapping segments in <code>segments</code>, referred to via <code>bad_indices</code>, by connecting consecutive edges where needed.</p><p><strong>Arguments</strong></p><ul><li><code>segments</code>: The segments to fix.</li><li><code>bad_indices</code>: The indices of the segments to fix.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs as <code>segments</code> is updated in-place.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; segments = [(2, 15), (2, 28), (2, 41)]; # the edges all start with 2, so they are not actual segments in the triangulation, and so must be fixed

julia&gt; bad_indices = [1, 2, 3];

julia&gt; DelaunayTriangulation.fix_segments!(segments, bad_indices)
3-element Vector{Tuple{Int64, Int64}}:
 (2, 15)
 (15, 28)
 (28, 41)

julia&gt; segments = [(2, 7), (2, 12), (12, 17), (2, 22), (2, 27), (2, 32), (32, 37), (2, 42), (42, 47)];

julia&gt; bad_indices = [2, 4, 5, 6, 8]
5-element Vector{Int64}:
 2
 4
 5
 6
 8

julia&gt; DelaunayTriangulation.fix_segments!(segments, bad_indices)
9-element Vector{Tuple{Int64, Int64}}:
 (2, 7)
 (7, 12)
 (12, 17)
 (17, 22)
 (22, 27)
 (27, 32)
 (32, 37)
 (37, 42)
 (42, 47)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_vertex_closer_than_neighbours-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Vararg{Any, 5}}" href="#DelaunayTriangulation.is_vertex_closer_than_neighbours-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Vararg{Any, 5}}"><code>DelaunayTriangulation.is_vertex_closer_than_neighbours</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_vertex_closer_than_neighbours([predicates::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, jᵢ, jᵢ₋₁, jᵢ₊₁) -&gt; Bool
is_vertex_closer_than_neighbours([predicates::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, list::ShuffledPolygonLinkedList, u, v, j) -&gt; Bool</code></pre><p>Tests if the vertex <code>jᵢ</code> is closer to the line <code>(u, v)</code> than its neighbours <code>jᵢ₋₁</code> and <code>jᵢ₊₁</code>, assuming all these  vertices are to the left of the line.</p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.point_closest_to_line"><code>point_closest_to_line</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>, <code>v</code>: The vertices of the line. </li><li><code>jᵢ</code>, <code>jᵢ₋₁</code>, <code>jᵢ₊₁</code>: The vertices to compare. </li></ul><p>The second method extracts these latter two vertices using the doubly-linked <code>list</code> of vertices.</p><p><strong>Outputs</strong></p><ul><li><code>flag</code>: Whether <code>jᵢ</code> is closer to the line than <code>jᵢ₋₁</code> and <code>jᵢ₊₁</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L404-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.locate_intersecting_triangles" href="#DelaunayTriangulation.locate_intersecting_triangles"><code>DelaunayTriangulation.locate_intersecting_triangles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true), rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Vector, Vector, Vector, Vector)</code></pre><p>Find all the triangles intersected by an edge <code>e</code>.</p><p>See also <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>e</code>: The edge going through the triangulation.</li><li><code>rotate=Val(true)</code>: Whether to rotate the edge so that the minimum degree vertex of <code>e</code> is first.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>intersecting_triangles</code>: The intersected triangles. </li><li><code>collinear_segments</code>: Segments that are collinear with <code>e</code>.</li><li><code>left_vertices</code>: The vertices of the intersected triangles that are left of <code>e</code>.</li><li><code>right_vertices</code>: The vertices of the intersected triangles that are right of <code>e</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L684-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.merge_segments-Union{Tuple{Es}, Tuple{Any, Any, Es}} where Es" href="#DelaunayTriangulation.merge_segments-Union{Tuple{Es}, Tuple{Any, Any, Es}} where Es"><code>DelaunayTriangulation.merge_segments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_segments(tri::Triangulation, ghost_vertex_map) -&gt; Edges</code></pre><p>Creates a set of edges that merge all the boundary nodes in <code>tri</code> as well as its interior segments into a single collection. </p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>ghost_vertex_map</code>: The ghost vertex map to use.</li></ul><p><strong>Outputs</strong></p><ul><li><code>all_segments</code>: The set of edges that merge all the boundary nodes in <code>tri</code> as well as its interior segments into a single collection, with type equal to that of <code>get_interior_segments(tri)</code>&#39;s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L771-L782">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.prepare_vertex_linked_list-Union{Tuple{AbstractArray{I}}, Tuple{I}} where I" href="#DelaunayTriangulation.prepare_vertex_linked_list-Union{Tuple{AbstractArray{I}}, Tuple{I}} where I"><code>DelaunayTriangulation.prepare_vertex_linked_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_vertex_linked_list(V) -&gt; ShuffledPolygonLinkedList</code></pre><p>Given a list of polygon vertices <code>V</code>, returns the doubly-linked list of polygon vertices.</p><p><strong>Arguments</strong></p><ul><li><code>V</code>: The list of polygon vertices.</li></ul><p><strong>Outputs</strong></p><ul><li><code>list::ShuffledPolygonLinkedList</code>: A <a href="../data_structures/#ShuffledPolygonLinkedList"><code>ShuffledPolygonLinkedList</code></a>. In <code>list</code>, <code>prev[begin]</code>, <code>prev[end]</code>, <code>next[begin]</code>, and <code>next[end]</code> are all <code>0</code>  as are <code>shuffled_indices[begin]</code> and <code>shuffled_indices[end]</code>. Moreover, <code>shuffled_indices</code> will not have been shuffled yet.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L462-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_collinear_segments!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.process_collinear_segments!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.process_collinear_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_intersecting_triangles!(tri::Triangulation, e, collinear_segments; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng()) -&gt; Bool</code></pre><p>Given segments in <code>collinear_segments</code> that are collinear with an edge <code>e</code>, updates <code>tri</code> so that this edge <code>e</code> is instead  split so that it is instead represented by <code>collinear_segments</code>. These new segments will be placed into the triangulation using  <a href="../../api/operations/#DelaunayTriangulation.add_segment!"><code>add_segment!</code></a>.</p><p>The <code>predicates::AbstractPredicateKernel</code> argument defines the method for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</p><p>See also <a href="#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E"><code>connect_segments!</code></a>, <a href="#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E"><code>extend_segments!</code></a>, <a href="#DelaunayTriangulation.split_segment!-Tuple{Any, Any, Any}"><code>split_segment!</code></a> and <a href="#DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}"><code>split_boundary_edge_at_collinear_segments!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L744-L754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.remake_triangulation_with_constraints-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.remake_triangulation_with_constraints-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.remake_triangulation_with_constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remake_triangulation_with_constraints(tri::Triangulation, segments, boundary_nodes) -&gt; (Dict, Dict, Triangulation)</code></pre><p>Remakes the triangulation <code>tri</code> so that it contains <code>segments</code> and <code>boundary_nodes</code> in its fields.</p><p>See also <a href="#DelaunayTriangulation.replace_ghost_vertex_information-Tuple{Triangulation, Any, Any}"><code>replace_ghost_vertex_information</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation to remake.</li><li><code>segments</code>: The segments to add to the triangulation.</li><li><code>boundary_nodes</code>: The boundary nodes to add to the triangulation.</li></ul><p><strong>Outputs</strong></p><ul><li><code>new_ghost_vertex_map</code>: The new ghost vertex map. This will not yet be added to the triangulation.</li><li><code>new_ghost_vertex_ranges</code>: The new ghost vertex ranges. This will not yet be added to the triangulation.</li><li><code>new_tri::Triangulation</code>: The new triangulation, now containing <code>boundary_nodes</code> in the <code>boundary_nodes</code> field and <code>segments</code> in the <code>interior_segments</code> field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L289-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.replace_ghost_vertex_information-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.replace_ghost_vertex_information-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.replace_ghost_vertex_information</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace_ghost_vertex_information(tri::Triangulation, ghost_vertex_map, ghost_vertex_ranges) -&gt; Triangulation</code></pre><p>Replaces the ghost vertex information in <code>tri</code> with <code>ghost_vertex_map</code> and <code>ghost_vertex_ranges</code>, using the results from  <a href="#DelaunayTriangulation.remake_triangulation_with_constraints-Tuple{Triangulation, Any, Any}"><code>remake_triangulation_with_constraints</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation to remake.</li><li><code>ghost_vertex_map</code>: The ghost vertex map to add to the triangulation.</li><li><code>ghost_vertex_ranges</code>: The ghost vertex ranges to add to the triangulation.</li></ul><p><strong>Outputs</strong></p><ul><li><code>new_tri::Triangulation</code>: The new triangulation, now containing <code>ghost_vertex_map</code> in the <code>ghost_vertex_map</code> field and <code>ghost_vertex_ranges</code> in the <code>ghost_vertex_ranges</code> field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L351-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.retriangulate_fan!-Tuple{Triangulation, Triangulation, Any, Any}" href="#DelaunayTriangulation.retriangulate_fan!-Tuple{Triangulation, Triangulation, Any, Any}"><code>DelaunayTriangulation.retriangulate_fan!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retriangulate_fan!(tri::Triangulation, tri_fan::Triangulation, fan, fan_triangles; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())</code></pre><p>Given a sorted set of vertices <code>fan</code> in a fan of triangles associated with <code>fan_triangles</code>, retriangulates the fan, updating <code>tri</code> to do so and  using <code>tri_fan</code> as a temporary triangulation. (This implements Lines 17–19 and Line 28 of the algorithms in <a href="http://dx.doi.org/10.1016/j.comgeo.2015.04.006">this paper</a>.)</p><p>The <code>predicates</code> argument defines the method for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L578-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.select_random_vertex-Tuple{Triangulation, DelaunayTriangulation.ShuffledPolygonLinkedList, Any, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}" href="#DelaunayTriangulation.select_random_vertex-Tuple{Triangulation, DelaunayTriangulation.ShuffledPolygonLinkedList, Any, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}"><code>DelaunayTriangulation.select_random_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_random_vertex(tri::Triangulation, list::ShuffledPolygonLinkedList, u, v, range, rng) -&gt; Vertex</code></pre><p>Selects a random vertex that is not closer to the line <code>(u, v)</code> than both of its neighbours.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>list::ShuffledPolygonLinkedList</code>: The linked list of polygon vertices.</li><li><code>u</code>, <code>v</code>: The vertices of the line.</li><li><code>range</code>: The range of indices of the vertices to select from.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>j</code>: The selected vertex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L438-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.setup_cavity_cdt-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.setup_cavity_cdt-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.setup_cavity_cdt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setup_cavity_cdt(tri::Triangulation, V; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; ShuffledPolygonLinkedList</code></pre><p>Prepares the linked list required for triangulating a cavity excavated by segment insertion in a constrained triangulation.</p><p>See also <a href="#DelaunayTriangulation.prepare_vertex_linked_list-Union{Tuple{AbstractArray{I}}, Tuple{I}} where I"><code>prepare_vertex_linked_list</code></a> and <a href="#DelaunayTriangulation.delete_polygon_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}"><code>delete_polygon_vertices_in_random_order!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>V</code>: The list of polygon vertices, given as a counter-clockwise list of vertices, defining the cavity. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>list::ShuffledPolygonLinkedList</code>: The linked list of polygon vertices representing the cavity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L513-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.sort_fan!-Tuple{Any, Any, Triangulation}" href="#DelaunayTriangulation.sort_fan!-Tuple{Any, Any, Triangulation}"><code>DelaunayTriangulation.sort_fan!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_fan!(fan, fan_triangles, tri::Triangulation)</code></pre><p>Given a set of triangles in a fan, <code>fan_triangles</code>, associated with some triangulation <code>tri</code>, places all the triangle vertices  and sorts them counter-clockwise, placing the results into <code>fan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L617-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_marked_vertices!-Tuple{Any, Triangulation, Any}" href="#DelaunayTriangulation.split_marked_vertices!-Tuple{Any, Triangulation, Any}"><code>DelaunayTriangulation.split_marked_vertices!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_marked_vertices!(fan_triangles, tri::Triangulation, marked_vertices)</code></pre><p>Given a set of <code>marked_vertices</code> indicating a crossed triangle (like in Figure 9 of <a href="http://dx.doi.org/10.1016/j.comgeo.2015.04.006">this paper</a>), finds all triangles whose three vertices are all in <code>marked_vertices</code> and places them into <code>fan_triangles</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L599-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_segment!-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.split_segment!-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.split_segment!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_segment!(tri::Triangulation, segment, collinear_segments)
split_segment!(segments, segment, collinear_segments)</code></pre><p>Splits <code>segment</code> at the segments in <code>collinear_segments</code>, which are assumed to be collinear with <code>segment</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segments</code>: The underlying set of segments. This is <code>get_interior_segments(tri)</code> if <code>tri</code> is a <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>segment</code>: The segment to split.</li><li><code>collinear_segments</code>: The segments that are collinear with <code>segment</code>.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>segments</code> is updated in-place.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; segments = Set(((2, 3), (3, 5), (10, 12)))
Set{Tuple{Int64, Int64}} with 3 elements:
  (2, 3)
  (3, 5)
  (10, 12)

julia&gt; collinear_segments = [(2, 10), (11, 15), (2, 3)]
3-element Vector{Tuple{Int64, Int64}}:
 (2, 10)
 (11, 15)
 (2, 3)

julia&gt; segment = (3, 5)
(3, 5)

julia&gt; DelaunayTriangulation.split_segment!(segments, segment, collinear_segments)
Set{Tuple{Int64, Int64}} with 4 elements:
  (2, 10)
  (2, 3)
  (11, 15)
  (10, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L147-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_cavity_cdt!-Tuple{Triangulation, Any, Triangulation, Any, Any}" href="#DelaunayTriangulation.triangulate_cavity_cdt!-Tuple{Triangulation, Any, Triangulation, Any, Any}"><code>DelaunayTriangulation.triangulate_cavity_cdt!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_cavity_cdt!(tri::Triangulation, V, marked_vertices; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Triangulates the cavity <code>V</code> left behind when deleting triangles intersected in a triangulation by an edge, updating <code>tri</code> to do so.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to update. This should be an empty triangulation.</li><li><code>V</code>: The list of polygon vertices, given as a counter-clockwise list of vertices, defining the cavity.</li><li><code>tri_fan::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to use for the fan of triangles to be re-triangulated. This should be an empty triangulation.</li><li><code>marked_vertices</code>: Cache for marking vertices to re-triangulate during the triangulation.</li><li><code>fan_triangles</code>: A cache used for sorting and identifying triangles in a fan for retriangulation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use or <a href="#DelaunayTriangulation.setup_cavity_cdt-Tuple{Triangulation, Any}"><code>setup_cavity_cdt</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/constrained_triangulation.jl#L539-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.each_boundary_edge-Tuple{Triangulation}" href="#DelaunayTriangulation.each_boundary_edge-Tuple{Triangulation}"><code>DelaunayTriangulation.each_boundary_edge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_boundary_edge(tri::Triangulation) -&gt; KeySet</code></pre><p>Returns an iterator over the boundary edges of <code>tri</code>, in no specific order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_edge_map.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_boundary_edge_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_boundary_edge_map(tri::Triangulation, ij) 
get_boundary_edge_map(tri::Triangulation, i, j)</code></pre><p>Returns the value from the key <code>(i, j)</code> in the boundary edge map of <code>tri</code>. The returned value is a <code>Tuple</code>  <code>(position, index)</code> so that <code>boundary_nodes = get_boundary_nodes(tri, position)</code> are the boundary nodes associated  with the section that <code>(i, j)</code> resides on, and <code>i = get_boundary_nodes(boundary_nodes, index)</code> and  <code>j = get_boundary_nodes(boundary_nodes, index + 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_edge_map.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_boundary_edge_map!-Union{Tuple{T}, Tuple{E}, Tuple{Dict{E, T}, Vararg{Any, 4}}} where {E, T}" href="#DelaunayTriangulation.split_boundary_edge_map!-Union{Tuple{T}, Tuple{E}, Tuple{Dict{E, T}, Vararg{Any, 4}}} where {E, T}"><code>DelaunayTriangulation.split_boundary_edge_map!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_boundary_edge_map!(boundary_edge_map, boundary_nodes, pos)</code></pre><p>After splitting an edge starting at <code>pos</code> on the boundary, updates the <code>boundary_edge_map</code> to reflect the new boundary edges. See <a href="#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>split_boundary_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_edge_map.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_boundary_edge-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.contains_boundary_edge-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.contains_boundary_edge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contains_boundary_edge(tri::Triangulation, ij) -&gt; Bool 
contains_boundary_edge(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Returns <code>true</code> if the boundary edge <code>(i, j)</code> is in <code>tri</code>, and <code>false</code> otherwise. Orientation matters here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_boundary_node!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_boundary_node!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_boundary_node!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_boundary_node!(tri::Triangulation, pos)</code></pre><p>Deletes the boundary node at the specified position <code>pos</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>pos</code>: The position to delete the node at, given as a <code>Tuple</code> so that <code>delete_boundary_node!(tri, pos)</code> is the same as <code>deleteat!(get_boundary_nodes(tri, pos[1]), pos[2])</code>.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the boundary nodes of <code>tri</code> are updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_all_boundary_nodes-Tuple{Triangulation}" href="#DelaunayTriangulation.get_all_boundary_nodes-Tuple{Triangulation}"><code>DelaunayTriangulation.get_all_boundary_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_all_boundary_nodes(tri::Triangulation) -&gt; Set{Vertex}</code></pre><p>Returns the set of all boundary vertices in <code>tri</code>, in no specific order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg{Any}}" href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg{Any}}"><code>DelaunayTriangulation.get_boundary_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_boundary_nodes(tri, mnℓ...)</code></pre><p>Given a triangulation <code>tri</code>, returns the specified component of the boundary nodes. There are several forms for the methods:</p><ol><li><code>get_boundary_nodes(tri, m)</code>: If <code>tri</code> has multiple curves, this returns the <code>m</code>th curve. If <code>tri</code> has multiple sections, this returns the <code>m</code>th section. Otherwise, this returns the <code>m</code>th boundary node.</li><li><code>get_boundary_nodes(tri, m, n)</code>: If <code>tri</code> has multiple curves, this returns the <code>n</code>th section of the <code>m</code>th curve. Otherwise, if <code>tri</code> has multiple sections, this returns the <code>n</code>th boundary node of the <code>m</code>th section.</li><li><code>get_boundary_nodes(tri, (m, n))</code>: This is equivalent to <code>get_boundary_nodes(tri, m, n)</code>.</li><li><code>get_boundary_nodes(tri::A, ::A)</code>: This just returns <code>boundary_nodes</code>.  </li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.get_left_boundary_node</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_left_boundary_node(tri::Triangulation, k, ghost_vertex) -&gt; Vertex</code></pre><p>Returns the boundary node to the left of the vertex <code>k</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex.</li><li><code>ghost_vertex</code>: The ghost vertex associated with the boundary section that <code>k</code> is on.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ℓ</code>: The vertex left of <code>k</code> on the boundary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.get_right_boundary_node</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_right_boundary_node(tri::Triangulation, k, ghost_vertex) -&gt; Vertex</code></pre><p>Returns the boundary node to the right of the vertex <code>k</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex. </li><li><code>ghost_vertex</code>: The ghost vertex associated with the boundary section that <code>k</code> is on. </li></ul><p><strong>Outputs</strong></p><ul><li><code>r</code>: The vertex right of <code>k</code> on the boundary. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.insert_boundary_node!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.insert_boundary_node!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.insert_boundary_node!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_boundary_node!(tri::Triangulation, pos, node)</code></pre><p>Inserts a boundary node into <code>tri</code> at the specified position.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>pos</code>: The position to insert the node at, given as a <code>Tuple</code> so that <code>insert_boundary_node!(tri, pos, node)</code> is the same as <code>insert!(get_boundary_nodes(tri, pos[1]), pos[2], node)</code>.</li><li><code>node</code>: The node to insert.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the boundary nodes of <code>tri</code> are updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L76-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_positively_oriented-Tuple{Triangulation, Integer}" href="#DelaunayTriangulation.is_positively_oriented-Tuple{Triangulation, Integer}"><code>DelaunayTriangulation.is_positively_oriented</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_positively_oriented(tri::Triangulation, curve_index) -&gt; Bool</code></pre><p>Tests if the <code>curve_index</code>th curve in <code>tri</code> is positively oriented, returning <code>true</code> if so and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.merge_boundary_edge!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.merge_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.merge_boundary_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_boundary_edge!(tri::Triangulation, ij, node)
merge_boundary_edge!(tri::Triangulation, i, j, node)</code></pre><p>Merges the edges <code>(i, node)</code> and <code>(node, j)</code> into a single edge <code>(i, j)</code>, i.e. does the inverse operation to <a href="#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>split_boundary_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_curves-Tuple{Triangulation}" href="#DelaunayTriangulation.num_curves-Tuple{Triangulation}"><code>DelaunayTriangulation.num_curves</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_curves(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of curves in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_sections-Tuple{Triangulation}" href="#DelaunayTriangulation.num_sections-Tuple{Triangulation}"><code>DelaunayTriangulation.num_sections</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_sections(tri::Triangulation) -&gt; Integer</code></pre><p>Assuming <code>tri</code> only has one curve, returns the number of sections in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.split_boundary_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_boundary_edge!(tri::Triangulation, ij, node)
split_boundary_edge!(tri::Triangulation, i, j, node)</code></pre><p>Splits the boundary edge <code>edge</code> in <code>tri</code> at the edge <code>(i, j)</code>.</p><p>See also <a href="#DelaunayTriangulation.merge_boundary_edge!-Tuple{Triangulation, Any, Any}"><code>merge_boundary_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.split_boundary_edge_at_collinear_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_boundary_edge_at_collinear_segments!(tri::Triangulation, collinear_segments)</code></pre><p>Splits a boundary edge into pieces defined by <code>collinear_segments</code>. In particular, if <code>r = collinear_segments</code> and</p><pre><code class="nohighlight hljs">u = initial(r[1])
v = terminal(r[end]),</code></pre><p>then the boundary edge is <code>(u, v)</code> and the edges are split so that all segments in <code>collinear_segments</code> appear instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_nodes.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_disjoint-Tuple{Triangulation}" href="#DelaunayTriangulation.is_disjoint-Tuple{Triangulation}"><code>DelaunayTriangulation.is_disjoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_disjoint(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has disjoint exterior boundary curves, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/exterior_curve_indices.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_exterior_curve-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_exterior_curve-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_exterior_curve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_exterior_curve(tri::Triangulation, curve_index) -&gt; Bool</code></pre><p>Returns <code>true</code> if the <code>curve_index</code>th curve in <code>tri</code> is an exterior curve, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/exterior_curve_indices.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_interior_curve-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_interior_curve-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_interior_curve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_interior_curve(tri::Triangulation, curve_index) -&gt; Bool</code></pre><p>Returns <code>true</code> if the <code>curve_index</code>th curve in <code>tri</code> is an interior curve, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/exterior_curve_indices.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_exterior_curves-Tuple{Triangulation}" href="#DelaunayTriangulation.num_exterior_curves-Tuple{Triangulation}"><code>DelaunayTriangulation.num_exterior_curves</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_exterior_curves(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of exterior curves in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/exterior_curve_indices.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_curve_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_curve_index(tri::Triangulation, ℓ) -&gt; Integer</code></pre><p>Returns the curve index corresponding to the ghost vertex <code>ℓ</code> in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_section_index-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_section_index-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_section_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_section_index(tri::Triangulation, ℓ) -&gt; Integer</code></pre><p>Returns the section index corresponding to the ghost vertex <code>ℓ</code> in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_exterior_ghost_vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_exterior_ghost_vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_exterior_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_exterior_ghost_vertex(tri::Triangulation, i) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ghost vertex <code>i</code> in <code>tri</code> is an exterior ghost vertex, and <code>false</code> otherwise. </p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.is_ghost_vertex"><code>is_ghost_vertex</code></a> and <a href="../../api/triangulation/#DelaunayTriangulation.is_interior_ghost_vertex"><code>is_interior_ghost_vertex</code></a>.</p><p><strong>Extended help</strong></p><p>An exterior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the exterior boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_interior_ghost_vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.is_interior_ghost_vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.is_interior_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_interior_ghost_vertex(tri::Triangulation, i) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ghost vertex <code>i</code> in <code>tri</code> is an interior ghost vertex, and <code>false</code> otherwise.</p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.is_ghost_vertex"><code>is_ghost_vertex</code></a> and <a href="../../api/triangulation/#DelaunayTriangulation.is_exterior_ghost_vertex"><code>is_exterior_ghost_vertex</code></a>.</p><p><strong>Extended help</strong></p><p>An interior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the interior boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.map_ghost_vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.map_ghost_vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.map_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_ghost_vertex(tri::Triangulation, ℓ) -&gt; Vertex</code></pre><p>Given a ghost vertex <code>ℓ</code> in <code>tri</code>, returns the corresponding section in the  <code>boundary_nodes</code> of <code>tri</code>. See also <a href="../../api/triangulation/#DelaunayTriangulation.get_ghost_vertex_map"><code>get_ghost_vertex_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.all_ghost_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.all_ghost_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.all_ghost_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_ghost_vertices(tri::Triangulation) -&gt; KeySet</code></pre><p>Returns the set of all ghost vertices in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_ranges.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_ghost_vertex_range-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_ghost_vertex_range-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_ghost_vertex_range</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ghost_vertex_range(tri::Triangulation, ℓ) -&gt; UnitRange</code></pre><p>Given a ghost vertex <code>ℓ</code> of <code>tri</code>, returns the range of all  ghost vertices corresponding to the same curve or section as <code>ℓ</code> does.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/ghost_vertex_ranges.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}" href="#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}"><code>DelaunayTriangulation.compute_representative_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_representative_points!(tri::Triangulation; use_convex_hull=!has_boundary_nodes(tri), precision=one(number_type(tri)))</code></pre><p>Computes a new set of representative points for <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> for which to compute the representative points.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_convex_hull=!has_boundary_nodes(tri)</code>: If <code>true</code>, then the representative points are computed using the convex hull of the triangulation. Otherwise, the representative points are computed using the boundary nodes of the triangulation.</li><li><code>precision=one(number_type(tri))</code>: The precision to use when computing the representative points via <a href="../../api/other/#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>.</li></ul><p><strong>Output</strong></p><p>There are no outputs as <code>tri</code> is updated in-place, but for each curve the representative point is computed using <a href="../../api/other/#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Exterior curves</header><div class="admonition-body"><p>While <code>get_exterior_curve_indices(tri)</code> does store the curves corresponding to exterior curves, this function still treats the first  curve as the most important exterior curve, computing the representative point so that it is in no holes. In particular, other exterior curves  might have representative points that are in a hole of one of their interior holes. This isn&#39;t much of a problem, indeed it wouldn&#39;t be a significant  problem even if we had the representative point in a hole of the first curve, but it is something to be aware of.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L79-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.empty_representative_points!-Tuple{Triangulation}" href="#DelaunayTriangulation.empty_representative_points!-Tuple{Triangulation}"><code>DelaunayTriangulation.empty_representative_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty_representative_points!(tri::Triangulation)</code></pre><p>Empties the <code>Dict</code> of representative points of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_representative_point_coordinates-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_representative_point_coordinates-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_representative_point_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_representative_point_coordinates(tri::Triangulation, curve_index) -&gt; NTuple{2, Number}</code></pre><p>Returns the coordinates of the representative point of the <code>curve_index</code>th curve in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.new_representative_point!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.new_representative_point!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.new_representative_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">new_representative_point!(tri::Triangulation, curve_index)</code></pre><p>Creates a new representative point for the <code>curve_index</code>th curve in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.reset_representative_points!-Tuple{Triangulation}" href="#DelaunayTriangulation.reset_representative_points!-Tuple{Triangulation}"><code>DelaunayTriangulation.reset_representative_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_representative_points!(tri::Triangulation)</code></pre><p>Resets each representative point of <code>tri</code> to the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.update_centroid_after_addition!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.update_centroid_after_addition!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.update_centroid_after_addition!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_centroid_after_addition!(tri::Triangulation, curve_index, p)</code></pre><p>Updates the centroid of the <code>curve_index</code>th curve in <code>tri</code> after the addition of the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.update_centroid_after_deletion!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.update_centroid_after_deletion!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.update_centroid_after_deletion!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_centroid_after_deletion!(tri::Triangulation, curve_index, p)</code></pre><p>Updates the centroid of the <code>curve_index</code>th curve in <code>tri</code> after the deletion of the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/representative_point_list.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_segment-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.contains_segment-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.contains_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contains_segment(tri::Triangulation, ij) -&gt; Bool 
contains_segment(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>(i, j)</code> is a segment in <code>tri</code>, and <code>false</code> otherwise. Both <code>(i, j)</code> and <code>(j, i)</code> are checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/segments.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.each_segment-Tuple{Triangulation}" href="#DelaunayTriangulation.each_segment-Tuple{Triangulation}"><code>DelaunayTriangulation.each_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_segment(tri::Triangulation) -&gt; Edges</code></pre><p>Returns an iterator over all segments in <code>tri</code>. This includes both interior and boundary segments. If you only want  interior segments, then see <a href="../../api/triangulation/#DelaunayTriangulation.get_interior_segments"><code>get_interior_segments</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/segments.jl#L1-L6">source</a></section></article><h2 id="Weighted-Triangulations"><a class="docs-heading-anchor" href="#Weighted-Triangulations">Weighted Triangulations</a><a id="Weighted-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Triangulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_weight!-Tuple{Any, Any}" href="#DelaunayTriangulation.add_weight!-Tuple{Any, Any}"><code>DelaunayTriangulation.add_weight!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_weight!(weights, w)</code></pre><p>Pushes the weight <code>w</code> into <code>weights</code>. The default definition for this is <code>push!(weights, w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_weight!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.add_weight!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.add_weight!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_weight!(tri::Triangulation, w)</code></pre><p>Pushes the weight <code>w</code> into the weights of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_distance_to_witness_plane-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Any, Any}" href="#DelaunayTriangulation.get_distance_to_witness_plane-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Any, Any}"><code>DelaunayTriangulation.get_distance_to_witness_plane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>&quot;     get<em>distance</em>to<em>witness</em>plane([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i, V; cache = nothing) -&gt; Number</p><p>Computes the distance between the lifted companion of the vertex <code>i</code> and the witness plane to the triangle <code>V</code>. If <code>V</code> is a ghost triangle  and <code>i</code> is not on its solid edge, then the distance is <code>-Inf</code> if it is below the ghost triangle&#39;s witness plane and <code>Inf</code> if it is above. If <code>V</code> is a ghost triangle and <code>i</code>  is on its solid edge, then the distance returned is the distance associated with the solid triangle adjoining <code>V</code>.</p><p>In general, the distance is positive if the lifted vertex is above the witness plane, negative if it is below,  and zero if it is on the plane.</p><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><p>The <code>cache</code> keyword argument is passed to [<code>point_position_relative_to_circumcircle</code>]. Please see the documentation for that function for more information.</p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_witness_plane"><code>point_position_relative_to_witness_plane</code></a> and <a href="../utils/#DelaunayTriangulation.get_distance_to_plane-NTuple{4, Tuple}"><code>get_distance_to_plane</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_lifted_point-Tuple{Any, Any}" href="#DelaunayTriangulation.get_lifted_point-Tuple{Any, Any}"><code>DelaunayTriangulation.get_lifted_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lifted_point(p, w) -&gt; NTuple{3, Number}</code></pre><p>Returns the lifted companion of the point <code>p</code>, in particular <code>(x, y, x^2 + y^2 - w)</code>, where <code>(x, y)</code> is <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_lifted_point-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_lifted_point-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_lifted_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lifted_point(tri::Triangulation, i) -&gt; NTuple{3, Number}</code></pre><p>Returns the lifted companion of the <code>i</code>th vertex of <code>tri</code>, in particular <code>(x, y, x^2 + y^2 - w)</code>, where <code>w</code> is the <code>i</code>th weight of <code>tri</code> and <code>(x, y)</code> is the <code>i</code>th point of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_power_distance-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.get_power_distance-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.get_power_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_power_distance(tri::Triangulation, i, j) -&gt; Number</code></pre><p>Returns the power distance between vertices <code>i</code> and <code>j</code>, defined by  <code>||pᵢ - pⱼ||^2 - wᵢ - wⱼ</code>, where <code>wᵢ</code> and <code>wⱼ</code> are the respective weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_weight-Tuple{Any, Integer}" href="#DelaunayTriangulation.get_weight-Tuple{Any, Integer}"><code>DelaunayTriangulation.get_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_weight(weights, i) -&gt; Number</code></pre><p>Gets the <code>i</code>th weight from <code>weights</code>. The default definition for this is <code>weights[i]</code>, but this can be extended - e.g., <a href="../../api/triangulation/#DelaunayTriangulation.ZeroWeight"><code>ZeroWeight</code></a> uses <code>get_weight(weights, i) = 0.0</code>.</p><p>If <code>i</code> is not an integer, then the default definition is <code>is_point3(i) ? i[3] : zero(number_type(weights))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_weight-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_weight-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_weight(tri::Triangulation, i) -&gt; Number</code></pre><p>Gets the <code>i</code>th weight from <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_weighted_nearest_neighbour" href="#DelaunayTriangulation.get_weighted_nearest_neighbour"><code>DelaunayTriangulation.get_weighted_nearest_neighbour</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_weighted_nearest_neighbour(tri::Triangulation, i, j = rand(each_solid_vertex(tri))) -&gt; Vertex</code></pre><p>Using a greedy search, finds the closest vertex in <code>tri</code> to the vertex <code>i</code> (which might not already be in <code>tri</code>),  measuring distance in lifted space (i.e., using the power distance - see <a href="#DelaunayTriangulation.get_power_distance-Tuple{Triangulation, Any, Any}"><code>get_power_distance</code></a>).  The search starts from the vertex <code>j</code> which should be in <code>tri</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_submerged" href="#DelaunayTriangulation.is_submerged"><code>DelaunayTriangulation.is_submerged</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_submerged([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i; cache = nothing) -&gt; Bool 
is_submerged([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i, V; cache = nothing) -&gt; Bool</code></pre><p>Returns <code>true</code> if the vertex <code>i</code> is submerged in <code>tri</code> and <code>false</code> otherwise. In the  second method, <code>V</code> is a triangle containing <code>tri</code>.</p><p>The <code>kernel</code> argument determines how this result is computed, and should be one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><p>The <code>cache</code> keyword argument is passed to [<code>point_position_relative_to_circumcircle</code>]. Please see the documentation for that function for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L174-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_weighted-Tuple{DelaunayTriangulation.ZeroWeight}" href="#DelaunayTriangulation.is_weighted-Tuple{DelaunayTriangulation.ZeroWeight}"><code>DelaunayTriangulation.is_weighted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_weighted(weights) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>weights</code> represents a set of <code>weights</code> that are not all zero, and <code>false</code> otherwise. Note that even for vectors like <code>zeros(n)</code>, this will return <code>true</code>; by default, <code>false</code> is returned only for  <code>weights = ZeroWeight()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/weights.jl#L55-L61">source</a></section></article><h2 id="Mesh-Refinement"><a class="docs-heading-anchor" href="#Mesh-Refinement">Mesh Refinement</a><a id="Mesh-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-Refinement" title="Permalink"></a></h2><p>Here are some functions involved with mesh refinement.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation._split_subsegment_curve_bounded!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation._split_subsegment_curve_bounded!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation._split_subsegment_curve_bounded!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_split_subsegment_curve_bounded!(tri::Triangulation, args::RefinementArguments, e)</code></pre><p>Splits a subsegment <code>e</code> of <code>tri</code> at a position determined by <a href="#DelaunayTriangulation.split_subcurve!"><code>split_subcurve!</code></a> for curve-bounded domains. See  <a href="#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>split_subsegment!</code></a>. See also <code>_split_subsegment_curve_bounded_standard!</code> and <code>_split_subsegment_curve_bounded_small_angle!</code>, as well as the original functions <code>_split_subsegment_curve_standard!</code> and <code>_split_subcurve_complex!</code>, respectively, used during boundary enrichment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L623-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation._split_subsegment_piecewise_linear!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation._split_subsegment_piecewise_linear!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation._split_subsegment_piecewise_linear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_split_subsegment_piecewise_linear!(tri::Triangulation, args::RefinementArguments, e)</code></pre><p>Splits a subsegment <code>e</code> of <code>tri</code> at a position determined by <a href="#DelaunayTriangulation.compute_split_position-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>compute_split_position</code></a> for piecewise linear domains. See <a href="#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>split_subsegment!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L600-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.assess_added_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}" href="#DelaunayTriangulation.assess_added_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}"><code>DelaunayTriangulation.assess_added_triangles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess_added_triangles!(args::RefinementArguments, tri::Triangulation)</code></pre><p>Assesses the quality of all triangles in <code>args.events.added_triangles</code> according to <a href="#DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>assess_triangle_quality</code></a>, and enqueues any bad quality triangles into <code>args.queue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L878-L882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.assess_triangle_quality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess_triangle_quality(tri::Triangulation, args::RefinementArguments, T) -&gt; Float64, Bool</code></pre><p>Assesses the quality of a triangle <code>T</code> of <code>tri</code> according to the <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</li><li><code>T</code>: The triangle.</li></ul><p><strong>Output</strong></p><ul><li><code>ρ</code>: The radius-edge ratio of the triangle.</li><li><code>flag</code>: Whether the triangle is bad quality.</li></ul><p>A triangle is bad quality if it does not meet the area constraints, violates the custom constraint, or if it is skinny but neither seditious or nestled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L836-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.balanced_power_of_two_quarternary_split-Tuple{Any}" href="#DelaunayTriangulation.balanced_power_of_two_quarternary_split-Tuple{Any}"><code>DelaunayTriangulation.balanced_power_of_two_quarternary_split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">balanced_power_of_two_quarternary_split(ℓ) -&gt; Float</code></pre><p>Returns the value of <code>s ∈ [0, ℓ]</code> that gives the most balanced quarternary split of the segment <code>pq</code>, so <code>s</code> is a power-of-two and <code>s ∈ [ℓ / 4, ℓ / 2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L463-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.balanced_power_of_two_ternary_split-Tuple{Any}" href="#DelaunayTriangulation.balanced_power_of_two_ternary_split-Tuple{Any}"><code>DelaunayTriangulation.balanced_power_of_two_ternary_split</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">balanced_power_of_two_ternary_split(ℓ) -&gt; Float64</code></pre><p>Returns the value of <code>s ∈ [0, ℓ]</code> that gives the most balanced ternary split of the segment <code>pq</code>, so <code>s</code> is a power-of-two  and <code>s ∈ [ℓ / 3, 2ℓ / 3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L444-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_for_invisible_steiner_point-Tuple{Triangulation, Vararg{Any, 4}}" href="#DelaunayTriangulation.check_for_invisible_steiner_point-Tuple{Triangulation, Vararg{Any, 4}}"><code>DelaunayTriangulation.check_for_invisible_steiner_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_for_invisible_steiner_point(tri::Triangulation, V, T, flag, c) -&gt; Point, Triangle</code></pre><p>Determines if the Steiner point <code>c</code>&#39;s insertion will not affect the quality of <code>T</code>, and if so instead changes <code>c</code> to be <code>T</code>&#39;s centroid.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to split a triangle of.</li><li><code>V</code>: The triangle that the Steiner point is in.</li><li><code>T</code>: The triangle that the Steiner point is from.</li><li><code>flag</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is <code>Cert.On</code> if the Steiner point is on the boundary of <code>V</code>, <code>Cert.Outside</code> if the Steiner point is outside of <code>V</code>, and <code>Cert.Inside</code> if the Steiner point is inside of <code>V</code>.</li><li><code>c</code>: The Steiner point.</li></ul><p><strong>Output</strong></p><ul><li><code>c′</code>: The Steiner point to use instead of <code>c</code>, which is <code>T</code>&#39;s centroid if <code>c</code> is not suitable.</li><li><code>V′</code>: The triangle that the Steiner point is in, which is <code>T</code> if <code>c</code> is not suitable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L268-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_for_steiner_point_on_segment-Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}" href="#DelaunayTriangulation.check_for_steiner_point_on_segment-Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>DelaunayTriangulation.check_for_steiner_point_on_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_for_steiner_point_on_segment(tri::Triangulation, V, V′, new_point, flag, predicates::AbstractPredicateKernel) -&gt; Bool</code></pre><p>Checks if the Steiner point with vertex <code>new_point</code> is on a segment. If so, then its vertex is pushed into the offcenter-split list from <code>args</code>, indicating that it should no longer be regarded as a free vertex (see <a href="../data_structures/#DelaunayTriangulation.is_free-Tuple{DelaunayTriangulation.RefinementArguments, Any}"><code>is_free</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>V</code>: The triangle that the Steiner point was originally in prior to <a href="#DelaunayTriangulation.check_for_invisible_steiner_point-Tuple{Triangulation, Vararg{Any, 4}}"><code>check_for_invisible_steiner_point</code></a>.</li><li><code>V′</code>: The triangle that the Steiner point is in.</li><li><code>new_point</code>: The vertex associated with the Steiner point.</li><li><code>flag</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is <code>Cert.On</code> if the Steiner point is on the boundary of <code>V</code>, <code>Cert.Outside</code> if the Steiner point is outside of <code>V</code>, and <code>Cert.Inside</code> if the Steiner point is inside of <code>V</code>.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><ul><li><code>onflag</code>: Whether the Steiner point is on a segment or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L292-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_seditious_precision-Tuple{Any, Any}" href="#DelaunayTriangulation.check_seditious_precision-Tuple{Any, Any}"><code>DelaunayTriangulation.check_seditious_precision</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_seditious_precision(ℓrp, ℓrq) -&gt; Bool</code></pre><p>Checks if there are precision issues related to the seditiousness of a triangle, returning <code>true</code> if so and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L797-L801">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_split_subsegment_precision-NTuple{4, Any}" href="#DelaunayTriangulation.check_split_subsegment_precision-NTuple{4, Any}"><code>DelaunayTriangulation.check_split_subsegment_precision</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_split_subsegment_precision(mx, my, p, q) -&gt; Bool</code></pre><p>Checks if there are precision issues related to the computed split position <code>(mx, my)</code> of a segment <code>(p, q)</code>,  returning <code>true</code> if so and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L569-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_steiner_point_precision-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.check_steiner_point_precision-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.check_steiner_point_precision</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_steiner_point_precision(tri::Triangulation, T, c) -&gt; Bool</code></pre><p>Checks if the Steiner point <code>c</code> of a triangle <code>T</code> of <code>tri</code> can be computed without precision issues, returning <code>true</code> if there are precision issues and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_concentric_shell_quarternary_split_position-Tuple{Any, Any}" href="#DelaunayTriangulation.compute_concentric_shell_quarternary_split_position-Tuple{Any, Any}"><code>DelaunayTriangulation.compute_concentric_shell_quarternary_split_position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_concentric_shell_quarternary_split_position(p, q) -&gt; Float64</code></pre><p>Returns the value of <code>t ∈ [0, 1]</code> that gives the most balanced quarternary split of the segment <code>pq</code>, so that one of the segments has a power-of-two length between 1/4 and 1/2 of the length of <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L431-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_concentric_shell_ternary_split_position-Tuple{Any, Any}" href="#DelaunayTriangulation.compute_concentric_shell_ternary_split_position-Tuple{Any, Any}"><code>DelaunayTriangulation.compute_concentric_shell_ternary_split_position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_concentric_shell_ternary_split_position(p, q) -&gt; Float64</code></pre><p>Returns the value of <code>t ∈ [0, 1]</code> that gives the most balanced ternary split of the segment <code>pq</code>, so that one of the  segments has a power-of-two length and both segments have lengths between 1/3 and 2/3 of the length of <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L418-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_split_position-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.compute_split_position-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.compute_split_position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_split_position(tri::Triangulation, args::RefinementArguments, e) -&gt; NTuple{2, Float}</code></pre><p>Computes the position to split a segment <code>e</code> of <code>tri</code> at in <a href="#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>split_subsegment!</code></a>. </p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to split a segment of.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>e</code>: The segment to split.</li></ul><p><strong>Output</strong></p><ul><li><code>mx, my</code>: The position to split the segment at.</li></ul><p>This point is computed according to a set of rules:</p><ol><li>If <code>e</code> is not a subsegment, meaning it is an input segment, then its midpoint is returned.</li><li>If <code>e</code> is a subsegment and the segment adjoins two other distinct segments (one for each vertex) at an acute angle, as determined by  <a href="#DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle"><code>segment_vertices_adjoin_other_segments_at_acute_angle</code></a>, then the point is returned so that <code>e</code> can be split such that one of the new subsegments has a power-of-two  length between 1/4 and 1/2 of the length of <code>e</code>, computed using <a href="#DelaunayTriangulation.compute_concentric_shell_quarternary_split_position-Tuple{Any, Any}"><code>compute_concentric_shell_quarternary_split_position</code></a>.</li><li>If <code>e</code> is a subsegment and the segment adjoins one other segment at an acute angle, as determined by  <a href="#DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle"><code>segment_vertices_adjoin_other_segments_at_acute_angle</code></a>, then the point is returned so that <code>e</code> can be split such that one of the new subsegments has a power-of-two  length between 1/3 and 2/3 of the length of <code>e</code>, computed using <a href="#DelaunayTriangulation.compute_concentric_shell_ternary_split_position-Tuple{Any, Any}"><code>compute_concentric_shell_ternary_split_position</code></a>.</li><li>Otherwise, the midpoint is returned.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L347-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_free_vertices_around_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.delete_free_vertices_around_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.delete_free_vertices_around_subsegment!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_free_vertices_around_subsegment!(tri::Triangulation, args::RefinementArguments, e)</code></pre><p>Deletes all free vertices (i.e., Steiner points) contained in the diametral circle of <code>e</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</li><li><code>e</code>: The segment.</li></ul><p><strong>Output</strong></p><p>The free vertices are deleted from <code>tri</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L699-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.encroaches_upon-Tuple{Any, Any, Any, DelaunayTriangulation.RefinementArguments}" href="#DelaunayTriangulation.encroaches_upon-Tuple{Any, Any, Any, DelaunayTriangulation.RefinementArguments}"><code>DelaunayTriangulation.encroaches_upon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">encroaches_upon(p, q, r, args::RefinementArguments) -&gt; Bool</code></pre><p>Determines if a point <code>r</code> encroaches upon a segment <code>pq</code> according to the <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_diametral_circle"><code>point_position_relative_to_diametral_circle</code></a> and <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_diametral_lens"><code>point_position_relative_to_diametral_lens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L553-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enqueue_all_bad_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}" href="#DelaunayTriangulation.enqueue_all_bad_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}"><code>DelaunayTriangulation.enqueue_all_bad_triangles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enqueue_all_bad_triangles!(args::RefinementArguments, tri::Triangulation)</code></pre><p>Enqueues all bad triangles in the triangulation into <code>args.queue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enqueue_all_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}" href="#DelaunayTriangulation.enqueue_all_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}"><code>DelaunayTriangulation.enqueue_all_encroached_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enqueue_all_encroached_segments!(args::RefinementArguments, tri::Triangulation)</code></pre><p>Enqueues all encroached segments in the triangulation into <code>args.queue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enqueue_newly_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}" href="#DelaunayTriangulation.enqueue_newly_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}"><code>DelaunayTriangulation.enqueue_newly_encroached_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enqueue_newly_encroached_segments!(args::RefinementArguments, tri::Triangulation) -&gt; Bool</code></pre><p>Enqueues all segments that are newly encroached upon after a point insertion into the triangulation into <code>args.queue</code>.</p><p><strong>Arguments</strong></p><ul><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to enqueue newly encroached segments of.</li></ul><p><strong>Output</strong></p><ul><li><code>any_encroached</code>: Whether any segments were newly encroached upon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L319-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.finalise!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}" href="#DelaunayTriangulation.finalise!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}"><code>DelaunayTriangulation.finalise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finalise!(tri::Triangulation, args::RefinementArguments)</code></pre><p>Finalises the triangulation after refinement, e.g. by deleting ghost triangles and unlocking the convex hull if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_init_for_steiner_point-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_init_for_steiner_point-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_init_for_steiner_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_init_for_steiner_point(tri::Triangulation, T) -&gt; Vertex</code></pre><p>Gets the initial vertex to start the search for the Steiner point of a triangle <code>T</code> of <code>tri</code> in <a href="#DelaunayTriangulation.get_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>get_steiner_point</code></a>. The  initial vertex is chosen so that it is opposite the longest edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.get_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.get_steiner_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_steiner_point(tri::Triangulation, args::RefinementArguments, T) -&gt; Certificate, Point</code></pre><p>Computes the Steiner point for a triangle <code>T</code> of <code>tri</code> to improve its quality in <a href="../../api/operations/#DelaunayTriangulation.split_triangle!"><code>split_triangle!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to split a triangle of.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>T</code>: The triangle to split.</li></ul><p><strong>Output</strong></p><ul><li><code>precision_flag</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is <code>Cert.PrecisionFailure</code> if the Steiner point could not be computed due to precision issues, and <code>Cert.None</code> otherwise.</li><li><code>c</code>: The Steiner point. If <code>is_precision_failure(precision_flag)</code>, then this is just an arbitrary point of <code>T</code> to ensure type stability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L169-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_encroached-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.is_encroached-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.is_encroached</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_encroached(tri::Triangulation, args::RefinementArguments, edge) -&gt; Bool</code></pre><p>Determines if a segment <code>edge</code> of <code>tri</code> is encroached upon.</p><p>See also <a href="#DelaunayTriangulation.encroaches_upon-Tuple{Any, Any, Any, DelaunayTriangulation.RefinementArguments}"><code>encroaches_upon</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L532-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_triangle_nestled-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.is_triangle_nestled-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.is_triangle_nestled</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_triangle_nestled(tri::Triangulation, T, idx) -&gt; Bool</code></pre><p>Determines if a triangle <code>T</code> of <code>tri</code> is nestled in the corner of a small input angle.</p><p>See also <a href="#DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}"><code>is_triangle_seditious</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>T</code>: The triangle.</li><li><code>idx</code>: The index of the smallest edge of the triangle, so that <code>1</code> means <code>uv</code> is the smallest edge, <code>2</code> means <code>vw</code> is the smallest edge, and <code>3</code> means <code>wu</code> is the smallest edge.</li></ul><p><strong>Output</strong></p><ul><li><code>flag</code>: Whether the triangle is nestled in the corner of a small input angle.</li></ul><p>A triangle is nestled in the corner of a small input angle if it is nestled in the corner of a small input angle and the shortest edge is seditious. The size of the angle is not checked by this function, and is instead determined by <a href="#DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>assess_triangle_quality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L810-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}" href="#DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}"><code>DelaunayTriangulation.is_triangle_seditious</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_triangle_seditious(tri::Triangulation, args, u, v, w, smallest_idx) -&gt; Bool</code></pre><p>Determines if a triangle <code>uvw</code> of <code>tri</code> is seditious according to the <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</p><p>See also <a href="#DelaunayTriangulation.is_triangle_nestled-Tuple{Triangulation, Any, Any}"><code>is_triangle_nestled</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>args</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a>.</li><li><code>u, v, w</code>: The vertices of the triangle.</li><li><code>smallest_idx</code>: The index of the smallest edge of the triangle, so that <code>1</code> means <code>uv</code> is the smallest edge, <code>2</code> means <code>vw</code> is the smallest edge, and <code>3</code> means <code>wu</code> is the smallest edge.</li></ul><p><strong>Output</strong></p><ul><li><code>flag</code>: Whether the triangle is seditious.</li></ul><p>A triangle is seditious if it is nestled in the corner of a small input angle, or if it is nestled in the corner of a small input angle and the shortest edge is seditious. Here, &#39;small&#39; is defined by  <code>args.constraints.seditious_angle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L741-L759">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.locate_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any, Any}" href="#DelaunayTriangulation.locate_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any, Any}"><code>DelaunayTriangulation.locate_steiner_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">locate_steiner_point(tri::Triangulation, args::RefinementArguments, T, c) -&gt; Triangle, Cert</code></pre><p>Locates the Steiner point <code>c</code> of a triangle <code>T</code> of <code>tri</code> in <a href="#DelaunayTriangulation.get_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>get_steiner_point</code></a>. The Steiner point is located by walking from the initial vertex <code>init</code> to <code>c</code> using <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to split a triangle of.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>T</code>: The triangle that the Steiner point is from.</li><li><code>c</code>: The Steiner point.</li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle that the Steiner point is in.</li><li><code>flag</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is <code>Cert.On</code> if the Steiner point is on the boundary of <code>V</code>, <code>Cert.Outside</code> if the Steiner point is outside of <code>V</code>, and <code>Cert.Inside</code> if the Steiner point is inside of <code>V</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L236-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.refine!-Tuple{Triangulation}" href="#DelaunayTriangulation.refine!-Tuple{Triangulation}"><code>DelaunayTriangulation.refine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine!(tri::Triangulation; kwargs...)</code></pre><p>Refines the given <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> <code>tri</code> to meet the given quality constraints.</p><p>See the documentation for more information about mesh refinement, e.g. convergence issues and issues with small input-angles.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to refine.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>min_angle=30.0</code>: The minimum angle constraint, in degrees.</li><li><code>max_angle=180.0</code>: The maximum angle constraint, in degrees. </li></ul><div class="admonition is-danger"><header class="admonition-header">Maximum angle constraints</header><div class="admonition-body"><p>Maximum angle constraints are not currently implemented.</p></div></div><ul><li><code>min_area=get_area(tri) / 1e9</code>: The minimum area constraint.</li><li><code>max_area=typemax(number_type(tri))</code>: The maximum area constraint.</li><li><code>max_points=max(1_000, num_solid_vertices(tri))^2</code>: The maximum number of vertices allowed in the triangulation. Note that this refers to <a href="../../api/iterators/#DelaunayTriangulation.num_solid_vertices"><code>num_solid_vertices</code></a>, not the amount returned by <a href="../../api/triangulation/#DelaunayTriangulation.num_points"><code>num_points</code></a>.</li><li><code>seditious_angle=20.0</code>: The angle at which a triangle is considered seditious, in degrees. See <a href="#DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}"><code>is_triangle_seditious</code></a>.</li><li><code>custom_constraint=(tri, T) -&gt; false</code>: A custom constraint function that takes a <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> and a triangle, and returns <code>true</code> if the triangle should be refined and <code>false</code> otherwise.</li><li><code>use_circumcenter=true</code>: Whether to insert circumcenters for refining a triangle or generalised Steiner points.</li></ul><div class="admonition is-danger"><header class="admonition-header">Generalised Steiner points</header><div class="admonition-body"><p>Generalised Steiner points are not yet implemented. Thus, this argument must be <code>true</code> (and the <code>steiner_scale</code> keyword below is ignored).</p></div></div><ul><li><code>use_lens=true</code>: Whether to use the diametral lens or the diametral circle for checking encroachment.</li><li><code>steiner_scale=0.999</code>: The perturbation factor to use for generalised Steiner points if <code>use_circumcenter=false</code>. (Not currently used - see above.)</li><li><code>rng=Random.default_rng()</code>: The random number generator to use in case it is needed during point location.</li><li><code>concavity_protection=false</code>: Whether to use concavity protection or not for <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>. Most likely not needed, but may help in pathological cases.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><p>The triangulation is refined in-place.</p><div class="admonition is-warning"><header class="admonition-header">Duplicate points and unused points</header><div class="admonition-body"><p>During refinement, points are often deleted, which may often lead to points in <code>get_points(tri)</code> that do not  appear anywhere in the triangulation. (This is why we recommend e.g. <a href="../../api/iterators/#DelaunayTriangulation.each_solid_vertex"><code>each_solid_vertex</code></a> over <a href="../../api/iterators/#DelaunayTriangulation.each_point"><code>each_point</code></a>.) Similarly, since points are deleted, when two triangles have a common circumcenter it might happen (if they are near an input segment) that a point is duplicated inside <code>get_points(tri)</code>, in case one circumcenter was deleted previously.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.refine_itr!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}" href="#DelaunayTriangulation.refine_itr!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}"><code>DelaunayTriangulation.refine_itr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine_itr!(tri::Triangulation, args::RefinementArguments)</code></pre><p>Performs a single iteration of the refinement algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to refine.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li></ul><p><strong>Output</strong></p><p>The triangulation is refined in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle" href="#DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle"><code>DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">segment_vertices_adjoin_other_segments_at_acute_angle(tri::Triangulation, e) -&gt; Int, Vertex</code></pre><p>Determines if the vertices of a segment <code>e</code> of <code>tri</code> adjoin other segments at an acute angle.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>e</code>: The segment.</li></ul><p><strong>Output</strong></p><ul><li><code>num_adjoin</code>: The number of vertices of <code>e</code> that adjoin other segments at an acute angle.</li><li><code>adjoin_vert</code>: The vertex of <code>e</code> that adjoins another segment at an acute angle if <code>num_adjoin == 1</code>, and <code>∅</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L480-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_all_encroached_segments!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}" href="#DelaunayTriangulation.split_all_encroached_segments!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}"><code>DelaunayTriangulation.split_all_encroached_segments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_all_encroached_segments!(tri::Triangulation, args::RefinementArguments)</code></pre><p>Splits all encroached segments of <code>tri</code> according to <a href="#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>split_subsegment!</code></a> until no more encroached segments exist in <code>args.queue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L727-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.split_subsegment!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_subsegment!(tri::Triangulation, args::RefinementArguments, e)</code></pre><p>Splits a subsegment <code>e</code> of <code>tri</code> at a position determined by <a href="#DelaunayTriangulation.compute_split_position-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>compute_split_position</code></a>; for curve-bounded domains,  the position is determined by <a href="#DelaunayTriangulation.split_subcurve!"><code>split_subcurve!</code></a>. After the split, <a href="#DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>assess_triangle_quality</code></a> is used to  find any new bad quality triangles. Before splitting, all free vertices in the segment&#39;s diametral circle  are deleted using <a href="#DelaunayTriangulation.delete_free_vertices_around_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>delete_free_vertices_around_subsegment!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L584-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_triangle!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}" href="#DelaunayTriangulation.split_triangle!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}"><code>DelaunayTriangulation.split_triangle!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_triangle!(tri::Triangulation, args::RefinementArguments, T) -&gt; Certificate</code></pre><p>Splits a bad triangle <code>T</code> of <code>tri</code> to improve its quality.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a> to split a triangle of.</li><li><code>args::RefinementArguments</code>: The <a href="../data_structures/#RefinementArguments"><code>RefinementArguments</code></a> for the refinement.</li><li><code>T</code>: The triangle to split.</li></ul><p><strong>Output</strong></p><ul><li><code>cert</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> indicating whether the split was successful or not. In particular, returns one of:<ul><li><code>Cert.SuccessfulInsertion</code>: The triangle was split successfully.</li><li><code>Cert.EncroachmentFailure</code>: The triangle was not split successfully as the newly inserted point encroached upon a segment.</li><li><code>Cert.PrecisionFailure</code>: The triangle was not split successfully due to precision issues.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/mesh_refinement.jl#L131-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_encroachmentfailure" href="#DelaunayTriangulation.is_encroachmentfailure"><code>DelaunayTriangulation.is_encroachmentfailure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_encroachmentfailure(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>EncroachmentFailure</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_successfulinsertion" href="#DelaunayTriangulation.is_successfulinsertion"><code>DelaunayTriangulation.is_successfulinsertion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_successfulinsertion(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>SuccessfulInsertion</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_failedinsertion" href="#DelaunayTriangulation.is_failedinsertion"><code>DelaunayTriangulation.is_failedinsertion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_failedinsertion(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>FailedInsertion</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_precisionfailure" href="#DelaunayTriangulation.is_precisionfailure"><code>DelaunayTriangulation.is_precisionfailure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_precisionfailure(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>PrecisionFailure</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><h2 id="RTree"><a class="docs-heading-anchor" href="#RTree">RTree</a><a id="RTree-1"></a><a class="docs-heading-anchor-permalink" href="#RTree" title="Permalink"></a></h2><p>The RTrees we work with during boundary enrichment have several functions associated with them.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.EnlargementValues" href="#DelaunayTriangulation.EnlargementValues"><code>DelaunayTriangulation.EnlargementValues</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EnlargementValues</code></pre><p>Type for representing the values used in the minimisation of enlargement.</p><p><strong>Fields</strong></p><ul><li><code>enlargement::Float64</code>: The enlargement of the bounding box of the child being compared with.</li><li><code>idx::Int</code>: The index of the child being compared with.</li><li><code>area::Float64</code>: The area of the child being compared with.</li><li><code>bounding_box::BoundingBox</code>: The bounding box being compared with for enlargement.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EnlargementValues(enlargement, idx, area, bounding_box)
EnlargementValues(bounding_box)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L91-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!-Union{Tuple{C}, Tuple{DelaunayTriangulation.AbstractNode, C}} where C" href="#Base.append!-Union{Tuple{C}, Tuple{DelaunayTriangulation.AbstractNode, C}} where C"><code>Base.append!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(node::AbstractNode, child)</code></pre><p>Appends <code>child</code> to <code>node</code>&#39;s children. Also updates <code>node</code>&#39;s bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.delete!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}" href="#Base.delete!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete!(tree::RTree, id_bounding_box::DiametralBoundingBox)</code></pre><p>Deletes <code>id_bounding_box</code> from <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.insert!-Tuple{DelaunayTriangulation.AbstractNode, Any, DelaunayTriangulation.RTree}" href="#Base.insert!-Tuple{DelaunayTriangulation.AbstractNode, Any, DelaunayTriangulation.RTree}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert!(node::AbstractNode, child, tree::RTree) -&gt; Bool</code></pre><p>Inserts <code>child</code> into <code>node</code> in <code>tree</code>. Returns <code>true</code> if the <code>tree</code>&#39;s bounding boxes had to be adjusted and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.insert!-Tuple{DelaunayTriangulation.RTree, Any}" href="#Base.insert!-Tuple{DelaunayTriangulation.RTree, Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert!(tree::RTree, bounding_box[, level = 1]) -&gt; Bool</code></pre><p>Inserts <code>bounding_box</code> into <code>tree</code>. Returns <code>true</code> if the <code>tree</code>&#39;s bounding boxes had to be adjusted and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{DelaunayTriangulation.RTreeIntersectionIterator}" href="#Base.iterate-Tuple{DelaunayTriangulation.RTreeIntersectionIterator}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate(itr::RTreeIntersectionIterator, state...)</code></pre><p>Iterate over the next state of <code>itr</code> to find more intersections with the bounding box in <code>RTreeIntersectionIterator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.collapse_after_deletion!-Tuple{DelaunayTriangulation.AbstractNode, Any, Any}" href="#DelaunayTriangulation.collapse_after_deletion!-Tuple{DelaunayTriangulation.AbstractNode, Any, Any}"><code>DelaunayTriangulation.collapse_after_deletion!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collapse_after_deletion!(node::AbstractNode, tree::RTree, detached)</code></pre><p>Condenses <code>tree</code> after a deletion of one of <code>node</code>&#39;s children. The <code>detached</code> argument will contain the nodes that were detached from <code>tree</code> during the condensing process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L403-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.detach!-Tuple{DelaunayTriangulation.AbstractNode, Any}" href="#DelaunayTriangulation.detach!-Tuple{DelaunayTriangulation.AbstractNode, Any}"><code>DelaunayTriangulation.detach!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detach!(node::AbstractNode, idx) -&gt; Bool</code></pre><p>Detaches the <code>idx</code>th child of <code>node</code>. Returns <code>true</code> if the <code>node</code>&#39;s bounding box had to be adjusted and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_bounding_box-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}" href="#DelaunayTriangulation.find_bounding_box-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}"><code>DelaunayTriangulation.find_bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_bounding_box(tree::RTree, id_bounding_box::DiametralBoundingBox) -&gt; Tuple{Leaf{Branch}, Int}</code></pre><p>Returns the leaf node and the index in the leaf node&#39;s children that <code>id_bounding_box</code> is associated with.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_subtree-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.find_subtree-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.find_subtree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_subtree(tree, bounding_box, level) -&gt; Union{Branch,Leaf{Branch}}</code></pre><p>Returns the subtree of <code>tree</code> at <code>level</code> that <code>bounding_box</code> should be inserted into.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.BoundingBox}" href="#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.BoundingBox}"><code>DelaunayTriangulation.get_intersections</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_intersections(tree::RTree, bounding_box::BoundingBox; cache_id=1) -&gt; RTreeIntersectionIterator</code></pre><p>Returns an <a href="../data_structures/#DelaunayTriangulation.RTreeIntersectionIterator"><code>RTreeIntersectionIterator</code></a> over the elements in <code>tree</code> that intersect with <code>bounding_box</code>. <code>cache_id</code> must be <code>1</code> or <code>2</code>, and determines what cache to use for the intersection query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L464-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, Tuple{var&quot;#s127&quot;, var&quot;#s127&quot;} where var&quot;#s127&quot;&lt;:Number}" href="#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, Tuple{var&quot;#s127&quot;, var&quot;#s127&quot;} where var&quot;#s127&quot;&lt;:Number}"><code>DelaunayTriangulation.get_intersections</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_intersections(tree::RTree, point::NTuple{2,&lt;:Number}; cache_id=1) -&gt; RTreeIntersectionIterator</code></pre><p>Returns an <a href="../data_structures/#DelaunayTriangulation.RTreeIntersectionIterator"><code>RTreeIntersectionIterator</code></a> over the elements in <code>tree</code> that intersect with <code>point</code>, representing <code>point</code>  as a <a href="../data_structures/#DelaunayTriangulation.BoundingBox"><code>BoundingBox</code></a> with zero width and height centered at <code>point</code>. <code>cache_id</code> must be <code>1</code> or <code>2</code>, and determines what cache to use for the intersection query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L474-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_next_child-Tuple{DelaunayTriangulation.AbstractNode, Any, Any, Any}" href="#DelaunayTriangulation.get_next_child-Tuple{DelaunayTriangulation.AbstractNode, Any, Any, Any}"><code>DelaunayTriangulation.get_next_child</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_next_child(node::AbstractNode, start_idx, need_tests, itr::RTreeIntersectionIterator) -&gt; Int, QueryResult</code></pre><p>Returns the index of the next child of <code>node</code> that intersects with the bounding box in <code>itr</code> and the <a href="../data_structures/#DelaunayTriangulation.QueryResult"><code>QueryResult</code></a> of the intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L544-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.insert_detached!-Tuple{DelaunayTriangulation.RTree, Any}" href="#DelaunayTriangulation.insert_detached!-Tuple{DelaunayTriangulation.RTree, Any}"><code>DelaunayTriangulation.insert_detached!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_detached!(tree::RTree, detached)</code></pre><p>Given the <code>detached</code> nodes from <a href="#DelaunayTriangulation.collapse_after_deletion!-Tuple{DelaunayTriangulation.AbstractNode, Any, Any}"><code>collapse_after_deletion!</code></a>, inserts them back into <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L446-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.minimise_enlargement-Tuple{Any, Any}" href="#DelaunayTriangulation.minimise_enlargement-Tuple{Any, Any}"><code>DelaunayTriangulation.minimise_enlargement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimise_enlargement(node, bounding_box) -&gt; EnlargementValues</code></pre><p>Returns the <a href="#DelaunayTriangulation.EnlargementValues"><code>EnlargementValues</code></a> associated with the child of <code>node</code> that minimises the enlargement, where enlargement  is defined as the difference between the area of <code>bounding_box</code> and the area of the child&#39;s bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.overflow_insert!-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.overflow_insert!-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.overflow_insert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">overflow_insert!(node, child, tree) -&gt; Bool</code></pre><p>Inserts <code>child</code> into <code>node</code> in <code>tree</code> when <code>node</code> is full. Returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.replace!-NTuple{5, Any}" href="#DelaunayTriangulation.replace!-NTuple{5, Any}"><code>DelaunayTriangulation.replace!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace!(node::AbstractNode, left, right, original_bounding_box, tree::RTree)</code></pre><p>Replaces the <code>node</code> in <code>tree</code> with <code>left</code> and <code>right</code>. Returns <code>true</code> if the <code>tree</code>&#39;s bounding boxes had to be adjusted and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split!-Union{Tuple{N}, Tuple{N, Any}} where N" href="#DelaunayTriangulation.split!-Union{Tuple{N}, Tuple{N, Any}} where N"><code>DelaunayTriangulation.split!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split!(node::AbstractNode, tree::RTree) -&gt; Branch, Branch</code></pre><p>Splits <code>node</code> into two other nodes using a linear splitting rule. Returns the two new nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_seeds-Tuple{Any}" href="#DelaunayTriangulation.split_seeds-Tuple{Any}"><code>DelaunayTriangulation.split_seeds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_seeds(node::AbstractNode) -&gt; NTuple{2, Int}</code></pre><p>Returns the indices of two children in <code>node</code> used to initiate the split in <a href="#DelaunayTriangulation.split!-Union{Tuple{N}, Tuple{N, Any}} where N"><code>split!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.test_intersection-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.RTreeIntersectionIterator}" href="#DelaunayTriangulation.test_intersection-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.RTreeIntersectionIterator}"><code>DelaunayTriangulation.test_intersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_intersection(node::AbstractNode, itr::RTreeIntersectionIterator) -&gt; QueryResult</code></pre><p>Tests whether <code>node</code> intersects with the bounding box in <code>itr</code>, returning a <a href="../data_structures/#DelaunayTriangulation.QueryResult"><code>QueryResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L519-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.update_bounding_box!-NTuple{4, Any}" href="#DelaunayTriangulation.update_bounding_box!-NTuple{4, Any}"><code>DelaunayTriangulation.update_bounding_box!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_bounding_box!(node, idx, original_bounding_box, tree)</code></pre><p>Updates the bounding box of <code>node</code> to be the union of its children&#39;s bounding boxes. If <code>node</code> has a parent, updates the bounding box of the parent as well if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.update_bounding_box!-Tuple{Any}" href="#DelaunayTriangulation.update_bounding_box!-Tuple{Any}"><code>DelaunayTriangulation.update_bounding_box!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_bounding_box!(node)</code></pre><p>Updates the bounding box of <code>node</code> to be the union of its children&#39;s bounding boxes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.update_enlargement-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.update_enlargement-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.update_enlargement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_enlargement(values::EnlargementValues, child, idx) -&gt; EnlargementValues</code></pre><p>Compare the enlargement state in <code>values</code> with <code>child</code> and return the updated <code>values</code> if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/intersections/rtree.jl#L115-L119">source</a></section></article><h2 id="Point-Location"><a class="docs-heading-anchor" href="#Point-Location">Point Location</a><a id="Point-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Location" title="Permalink"></a></h2><p>Here are some functions related to point location.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.brute_force_search</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">brute_force_search(tri::Triangulation, q; itr = each_triangle(tri), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Searches for the triangle containing the point <code>q</code> by brute force. An exception will be  raised if no triangle contains the point.</p><p>See also <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The point to be located.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>itr = each_triangle(tri)</code>: The iterator over the triangles of the triangulation.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle containing the point <code>q</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/brute_force.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search_enclosing_circumcircle" href="#DelaunayTriangulation.brute_force_search_enclosing_circumcircle"><code>DelaunayTriangulation.brute_force_search_enclosing_circumcircle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">brute_force_search_enclosing_circumcircle(tri::Triangulation, i, predicates::AbstractPredicateKernel=AdaptiveKernel(); cache = nothing) -&gt; Triangle</code></pre><p>Searches for a triangle in <code>tri</code> containing the vertex <code>i</code> in its circumcircle using brute force. If  <code>tri</code> is a weighted Delaunay triangulation, the triangle returned instead has the lifted vertex <code>i</code>  below its witness plane. If no such triangle exists, <code>(0, 0, 0)</code> is returned. You can control  the method used for computing predicates via the <code>predicates</code> argument.</p><p>The <code>cache</code> argument is passed to [<code>point_position_relative_to_circumcircle</code>] and should be one of </p><ul><li><code>nothing</code>: No cache is used.</li><li><code>get_incircle_cache(tri)</code>: The cache stored inside <code>tri</code>.</li><li><code>AdaptivePredicates.incircleadapt_cache(number_type(tri))</code>: Compute a new cache.</li></ul><p>The cache is only needed if an <code>AdaptiveKernel()</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/brute_force.jl#L40-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}" href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_adjacent_boundary_edges(tri::Triangulation, k, q, ghost_vertex=𝒢, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Certificate, Certificate, Vertex, Certificate, Certificate)</code></pre><p>Given a boundary vertex <code>k</code>, find a triangle adjacent to <code>k</code> to locate a triangle or edge containing <code>q</code>.</p><p>See also <a href="#DelaunayTriangulation.search_down_adjacent_boundary_edges-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 5}}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>search_down_adjacent_boundary_edges</code></a>, which uses this function to determine an initial direction to search along a  straight boundary in case <code>q</code> is collinear with it.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex to start from.</li><li><code>q</code>: The query point.</li><li><code>ghost_vertex=𝒢</code>: The ghost vertex corresponding to the boundary that <code>k</code> resides on.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>direction_cert</code>: The direction of <code>q</code> relative to the vertex <code>k</code> along the boundary, given as a <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> <code>Left</code>, <code>Right</code>, or <code>Outside</code>. If <code>is_outside(direction_cert)</code>, then <code>q</code> is not collinear with either of the adjacent boundary edges.</li><li><code>q_pos_cert</code>: The position of <code>q</code> relative to the vertex <code>k</code> along the boundary, given as a <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> <code>Left</code>, <code>Right</code>, <code>On</code>, <code>Outside</code>, or <code>Degenerate</code>. This is similar to <code>direction_cert</code> in that it will be <code>Outside</code> whenever <code>direction_cert</code> is, but this certificate can also be <code>On</code> to indicate that not only is <code>q</code> in the direction given by <code>direction_cert</code>, but it is directly on the edge in that direction. If <code>is_degnerate(q_pos_cert)</code>, then <code>q = get_point(tri, next_vertex)</code>.</li><li><code>next_vertex</code>: The next vertex along the boundary in the direction of <code>q</code>, or <code>k</code> if <code>q</code> is not collinear with either of the adjacent boundary edges.</li><li><code>right_cert</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for the position of <code>q</code> relative to the boundary edge right of <code>k</code>.</li><li><code>left_cert</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for the position of <code>q</code> relative to the boundary edge left of <code>k</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L302-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 4}}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F" href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 4}}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex(tri::Triangulation, k, q, right_cert, left_cert, predicates::AbstractPredicateKernel=AdaptiveKernel(), store_history=Val(false), history=nothing, ghost_vertex=𝒢) -&gt; (Bool, Vertex, Vertex, Certificate, Certificate)</code></pre><p>Checks for intersections between the line <code>pq</code>, where <code>p = get_point(tri, k)</code>, and the edges neighbouring <code>p</code>, assuming <code>k</code> is a boundary node. This function should only be used  after using <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex to start from.</li><li><code>q</code>: The query point.</li><li><code>right_cert</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for the position of <code>q</code> relative to the boundary edge right of <code>k</code>, coming from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>left_cert</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for the position of <code>q</code> relative to the boundary edge left of <code>k</code>, coming from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the algorithm.</li><li><code>history=nothing</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>ghost_vertex=𝒢</code>: The ghost vertex corresponding to the boundary that <code>k</code> resides on.</li></ul><p><strong>Outputs</strong></p><p>The output takes the form <code>(i, j, edge_cert, triangle_cert)</code>. Rather than defining each output individually, here are the possible froms of the output:</p><ul><li><code>(i, j, Single, Outside)</code>: The line <code>pq</code> intersects the edge <code>pᵢpⱼ</code> and <code>(j, i, k)</code> is a positively oriented triangle so that <code>pᵢ</code> is left of <code>pq</code> and <code>pⱼ</code> is right of <code>pq</code>.</li><li><code>(i, j, None, Inside)</code>: The point <code>q</code> is inside the positively oriented triangle <code>(i, j, k)</code>.</li><li><code>(0, 0, None, Outside)</code>: The point <code>q</code> is outside of the triangulation.</li><li><code>(i, j, On, Inside)</code>: The point <code>q</code> is on the edge <code>pᵢpⱼ</code>, and thus inside the positively oriented triangle <code>(i, j, k)</code>.</li><li><code>(i, j, Right, Outside)</code>:<code>The point</code>q<code>is collinear with the edge</code>pᵢpⱼ`, but is off of it and further into the triangulation. </li></ul><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries</header><div class="admonition-body"><p>This function assumes that the geometry is convex.</p></div></div><p><strong>Extended help</strong></p><p>This function works in two stages. Firstly, using <code>check_for_intersections_with_single_interior_edge_adjacent_to_boundary_vertex</code>, we check for the intersection of <code>pq</code> with the edges neighbouring  the vertex <code>k</code>, rotating counter-clockwise until we find an intersection or reach the other side of the boundary, starting from the first edge counter-clockwise away from the boundary edge right of  the vertex <code>k</code>. By keeping track of the positions of <code>pq</code> relative to the current vertex and the previous, we can identify when an intersection is found. If no intersection is found before  reaching the boundary edge left of <code>k</code>, then <code>check_for_intersections_with_triangle_left_to_boundary_vertex</code> is used to check the remaining triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L451-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compare_distance-Union{Tuple{I}, Tuple{Any, I, Vararg{Any, 4}}} where I" href="#DelaunayTriangulation.compare_distance-Union{Tuple{I}, Tuple{Any, I, Vararg{Any, 4}}} where I"><code>DelaunayTriangulation.compare_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_distance(current_dist, current_idx, pts, i, qx, qy) -&gt; (Number, Vertex)</code></pre><p>Computes the minimum of the distance between the <code>i</code>th point of <code>pts</code> and <code>(qx, qy)</code> and <code>current_dist</code>.</p><p><strong>Arguments</strong></p><ul><li><code>current_dist</code>: The current value for the distance to the point <code>(qx, qy)</code>.</li><li><code>current_idx</code>: The point of <code>pts</code> corresponding to the distance <code>current_dist</code>.</li><li><code>pts</code>: The point set. </li><li><code>i</code>: The vertex to compare with <code>current_idx</code>.</li><li><code>qx</code>: The x-coordinate of the query point.</li><li><code>qy</code>: The y-coordinate of the query point.</li></ul><p><strong>Outputs</strong></p><ul><li><code>current_dist</code>: The minimum of the distance between the <code>i</code>th point of <code>pts</code> and <code>(qx, qy)</code> and <code>current_dist</code>.</li><li><code>current_idx</code>: The point of <code>pts</code> corresponding to the distance <code>current_dist</code>, which will be either <code>i</code> or <code>current_idx</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.concavity_protection_check" href="#DelaunayTriangulation.concavity_protection_check"><code>DelaunayTriangulation.concavity_protection_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concavity_protection_check(tri::Triangulation, concavity_protection, V, q, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Bool</code></pre><p>Check whether the <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> algorithm needs to restart. This is only needed if <code>tri</code> is not convex.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>concavity_protection</code>: Whether this check is needed.</li><li><code>V</code>: The triangle that the algorithm has found.</li><li><code>q</code>: The query point.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>need_to_restart</code>: Whether the algorithm needs to restart. Will also be <code>false</code> if <code>concavity_protection</code>.</li></ul><p><strong>Extended help</strong></p><p>This function uses <a href="../../api/triangulation/#DelaunayTriangulation.dist"><code>dist</code></a> to determine whether the query point <code>q</code> is inside or outside of the polygon defined by the triangulation, and also checks the position of <code>q</code> relative to <code>V</code> via <a href="../../api/predicates/#DelaunayTriangulation.point_position_relative_to_triangle"><code>point_position_relative_to_triangle</code></a>. If <code>q</code> is outside of this triangle,  then <code>need_to_restart = true</code>. If <code>q</code> is inside this triangle, then issues can still arise due to overlapping ghost triangles from the non-convexity. Thus,  depending on the result from <a href="../../api/triangulation/#DelaunayTriangulation.dist"><code>dist</code></a> and whether <code>V</code> is a ghost triangle, <code>need_to_restart</code> will be set accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L1216-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.default_num_samples-Tuple{I} where I" href="#DelaunayTriangulation.default_num_samples-Tuple{I} where I"><code>DelaunayTriangulation.default_num_samples</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_num_samples(n) -&gt; Integer</code></pre><p>Given a number of points <code>n</code>, returns <code>∛n</code> rounded up to the nearest integer. This is the default number of samples used in the jump-and-march algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.exterior_find_triangle" href="#DelaunayTriangulation.exterior_find_triangle"><code>DelaunayTriangulation.exterior_find_triangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exterior_find_triangle(tri::Triangulation, k, q, ghost_vertex=𝒢, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Vertex, Vertex)</code></pre><p>Given a query point <code>q</code> outside of the triangulation, find the ghost triangle containing <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The exterior ghost vertex to start from.</li><li><code>q</code>: The query point. </li><li><code>ghost_vertex=𝒢</code>: The ghost vertex corresponding to the boundary that <code>k</code> resides on.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The first vertex of the edge on the boundary adjoining the positively oriented ghost triangle. </li><li><code>j</code>: The second vertex of the edge on the boundary adjoining the positively oriented ghost triangle.</li></ul><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries and internal query points</header><div class="admonition-body"><p>This function assumes that the geometry is convex. If the geometry is not convex, the returned value may not be correct and should be   checked separately. Additionally, if <code>q</code> is actually inside the triangulation, then the result is meaningless.</p></div></div><p><strong>Extended help</strong></p><p>This function works by first finding the position of <code>q</code> relative to <code>pₘp</code>, where <code>pₘ</code> is the representative point for  the <code>ghost_vertex</code> and <code>p = get_point(tri, k)</code>. Depending on this position, we rotate counter-clockwise if <code>q</code> is  left of the line using <code>exterior_find_triangle_rotate_left</code> and clockwise otherwise using <code>exterior_find_triangle_rotate_right</code>. By keeping track of the current position of <code>q</code> and its position relative to the next ghost edge, we can identify when <code>q</code>  resides inside a ghost triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L606-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_triangle-Union{Tuple{U}, Tuple{F}, Tuple{Triangulation, Any}} where {F, U}" href="#DelaunayTriangulation.find_triangle-Union{Tuple{U}, Tuple{F}, Tuple{Triangulation, Any}} where {F, U}"><code>DelaunayTriangulation.find_triangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_triangle(tri, q; kwargs...) -&gt; Triangle[, Bool]</code></pre><p>Find the triangle in the triangulation <code>tri</code> containing the query point <code>q</code> using the jump-and-march algorithm.</p><div class="admonition is-danger"><header class="admonition-header">Ghost triangles</header><div class="admonition-body"><p>For this function to work best, the triangulation should have ghost triangles, which you can add using <code>add_ghost_triangles!</code> in case <code>tri</code> does not already have them.  Without ghost triangles, the function may not be able to find the correct triangle containing <code>q</code>.</p></div></div><p>For the variables defined below, you may want to refer to the extended help which also gives  some warnings and notes.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=ExactKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>point_indices=each_solid_vertex(tri)</code>: The indices of the vertices to consider as possible starting points for the algorithm.</li><li><code>m=default_num_samples(num_vertices(point_indices))</code>: The number of samples to use when selecting the initial point.</li><li><code>try_points=()</code>: A list of points to try as the initial point in addition to the <code>m</code> sampled.</li><li><code>rng=Random.default_rng()</code>: The random number generator to use.</li><li><code>k=select_initial_point(tri, q; point_indices, m, try_points, rng)</code>: The initial point to start the algorithm from. See <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the algorithm.</li><li><code>history=nothing</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>maxiters=2 + num_exterior_curves(tri) - num_solid_vertices(tri) + num_solid_edges(tri)</code>: The maximum number of iterations to perform before restarting the algorithm with <a href="#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>restart_find_triangle</code></a>.</li><li><code>concavity_protection=false</code>: Whether to use concavity protection. See <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex. </li><li><code>use_barriers::Val{U}=Val(false)</code>: Whether to stop searching beyond any segments in the triangulation. </li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle containing <code>q</code>, with type given by <code>triangle_type(tri)</code>.</li></ul><p>If you have <code>use_barriers == Val(true)</code>, then we also return </p><ul><li><code>invisible_flag</code>: <code>false</code> if the triangle was found without hitting a barrier, and <code>true</code> otherwise.</li></ul><p><strong>Extended help</strong></p><p>The algorithm underlying this function is complicated and broken into many parts. Here, we describe a brief overview of the algorithm, but note that the      documentation contains a much more detailed description.</p><ol><li>Firstly, the algorithm is initialised depending on whether <code>k</code> is a boundary or an interior vertex, using    <a href="#DelaunayTriangulation.initialise_find_triangle_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any, Any}} where F"><code>initialise_find_triangle_boundary_vertex</code></a> or <a href="#DelaunayTriangulation.initialise_find_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>initialise_find_triangle_interior_vertex</code></a> respectively.</li><li>From the initial triangle <code>(i, j, k)</code> chosen, we then check if <code>q</code> is one of <code>pᵢ</code>, <code>pⱼ</code>, and <code>p = pₖ</code> and then return according to <a href="#DelaunayTriangulation.find_triangle_return_on_vertex-Tuple{Triangulation, Vararg{Any, 8}}"><code>find_triangle_return_on_vertex</code></a> if needed.</li><li>If we do not return above, we need to step from the initial triangle towards <code>q</code>. Since we put <code>pᵢ</code> and <code>pⱼ</code>   to the left and right of the line <code>pq</code>, respectively, this means that we step until the triangle <code>pᵢpⱼq</code> is no longer    positively oriented. So, while the triangle is positively oriented, we step according to <a href="#DelaunayTriangulation.find_triangle_across_triangle-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 12}}} where F"><code>find_triangle_across_triangle</code></a>.</li><li>If we have not yet returned and the triangle is no longer positively oriented, we check if the triangle is degenerate using <a href="#DelaunayTriangulation.find_triangle_degenerate_arrangement-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 5}}} where F"><code>find_triangle_degenerate_arrangement</code></a>   and reinitialise the algorithm if needed. Otherwise, we have found the triangle containing <code>q</code> and return the triangle.</li></ol><p>Here are some additional warnings and notes for the variables defined in this function.</p><div class="admonition is-info"><header class="admonition-header">Restarting the algorithm</header><div class="admonition-body"><p>If the algorithm restarts, then the initial point <code>k</code> is selected again using <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>, and the algorithm is restarted from there.  This is done if the algorithm gets stuck in a loop, or if the algorithm is not able to find the correct triangle containing <code>q</code> after <code>maxiters</code> iterations. For a convex  geometry, <code>maxiters</code> can be safely ignored, as the sequence of triangles visited is acyclic [see H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251-260.)].</p></div></div><div class="admonition is-warning"><header class="admonition-header">Found triangles with barriers</header><div class="admonition-body"><p>If you are using barriers, it will be your responsibility to verify that any found triangle from this function actually  contains the triangle. This can be verified using the returned <code>flag</code> (see below), although the point might still be on the triangle&#39;s  boundary.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Walking past vertices of barriers</header><div class="admonition-body"><p>If you are using barriers, it is possible that the algorithm can walk past vertices of barriers. One way this can happen is if  the initial search line intersects a vertex, in which case the segment might not be considered. Another way this can happen is if you  start the algorithm directly on a segment vertex, in which case the algorithm can go past it (e.g. this means that it is possible that a  ghost triangle might still be returned if you start the algorithm on a boundary node).</p></div></div><p>Some notes about the output:</p><div class="admonition is-danger"><header class="admonition-header">Hitting barriers</header><div class="admonition-body"><p>If a barrier is hit before any initial triangle is properly identified, the returned triangle is  <code>(0, 0, 0)</code>; this is only possible if <code>use_barriers == Val(true)</code>. Moreover, if <code>use_barriers == Val(true)</code>,  the final triangle may not even be valid if <code>invisible_flag == true</code> (defined below).</p></div></div><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries</header><div class="admonition-body"><p>While this function does still work for non-convex geometries, it may be significantly slower than for convex geometries, as most of the details  of the algorithm assume that the geometry is convex, and so the algorithm may have to restart many times at new initial vertices <code>k</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L669-L752">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_triangle_across_triangle-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 12}}} where F" href="#DelaunayTriangulation.find_triangle_across_triangle-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 12}}} where F"><code>DelaunayTriangulation.find_triangle_across_triangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_triangle_across_triangle(tri::Triangulation, q, k, predicates, store_history, history, maxiters, cur_iter, concavity_protection, arrangement, original_k, last_changed, p, i, j, pᵢ, pⱼ) -&gt; (Bool, Bool, Bool, Triangle, Integer, Certificate, Vertex, Vertex, Vertex, Point, Point, Integer, Integer)</code></pre><p>Walks across the current triangle past the edge <code>(i, j)</code>. progressing the <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>k</code>: The vertex that the algorithm started from.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history</code>: Whether to store the history of the algorithm.</li><li><code>history</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>maxiters</code>: The maximum number of iterations to perform before restarting the algorithm with <a href="#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>restart_find_triangle</code></a>.</li><li><code>cur_iter</code>: The current iteration of the algorithm.</li><li><code>concavity_protection</code>: Whether to use concavity protection. See <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex.</li><li><code>arrangement</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> defining the orientation of the triangle <code>pᵢpⱼq</code>.</li><li><code>original_k</code>: The original vertex that the algorithm started from.</li><li><code>last_changed</code>: The last vertex that was changed in the algorithm.</li><li><code>p</code>: The point corresponding to the vertex <code>original_k</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to step from.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to step from.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>restart_flag</code>: Whether the algorithm needs to be restarted.</li><li><code>return_flag</code>: Whether the algorithm can return immediately, returning <code>V</code>.</li><li><code>reinitialise_flag</code>: Whether the algorithm needs to be reinitialised at a new vertex <code>k</code>. (This would only be needed if <code>!has_ghost_triangles(tri)</code>.)</li><li><code>V</code>: The triangle stepped into. </li><li><code>cur_iter</code>: The new number of iterations of the algorithm.</li><li><code>arrangement</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> defining the orientation of the triangle <code>pᵢpⱼq</code> with the updated values of <code>i</code> and <code>j</code>.</li><li><code>k</code>: The new vertex that the algorithm is at.</li><li><code>last_changed</code>: The last vertex that was changed in the algorithm.</li><li><code>original_k</code>: The original vertex that the algorithm started from.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to step from.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to step from.</li></ul><p><strong>Extended help</strong></p><p>This part of the algorithm is relatively complicated because there are many cases that need to be accounted for. Here we give a brief description of how this step works,  and note that the documentation contains a much more detailed description.</p><ol><li>Firstly, we need to check whether <code>k</code> is an exterior ghost vertex or not. If <code>k</code> is an exterior ghost vertex, then this means that we are stepping outside of the  triangulation. Thus, we use <a href="#DelaunayTriangulation.exterior_find_triangle"><code>exterior_find_triangle</code></a> to find where <code>q</code> is, starting from the <code>last_changed</code> vertex. If <code>concavity_protection = true</code>, then  <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a> is used to determine if a restart is needed, or if we can return safely. If we reach this step but <code>!has_ghost_triangles(tri)</code>, then the algorithm should need to be reinitialised since <code>q</code> should not be outside of the triangulation, and so we return with <code>reinitialise_flag = true</code>.</li><li>Now we consider the case where <code>k</code> is not an exterior ghost vertex. We move forward by updating the value of <code>k</code> so that <code>k = get_adjacent(tri, i, j)</code>, and then consider where <code>pₖ</code> is relative  to the line <code>pq</code>.</li></ol><p>2a. If <code>pₖ</code> is to the right of <code>pq</code>, then we should update <code>j</code> by <code>j = k</code>, ensuring that <code>j</code> is always to the right of <code>pq</code>.</p><p>2b. If <code>pₖ</code> is to the left of <code>pq</code>, then we should update <code>i</code> by <code>i = k</code>, ensuring that <code>i</code> is always to the left of <code>pq</code>.</p><p>2c. The alternative to 2a and 2b is that <code>pₖ</code> is collinear with the edge of <code>pq</code>, which could mean that <code>q</code> is in the current triangle or it is in a triangle further away. We compute a      <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> that determines where <code>q</code> is relative to the triangle <code>pᵢpⱼpₖ</code>. If <code>q</code> is inside or on this triangle, then we return, restarting if necessary according to      <code>concavity_protection</code> and <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. If we do not yet need to return, then we need to make a decision as to which of <code>i</code> and <code>j</code> to update, noting that      we want <code>i</code> to be left of <code>pq</code> and <code>j</code> to be right of <code>pq</code>, but this is no longer unambiguous since <code>pₖ</code> is collinear with <code>pq</code>. We make this decision according to <code>last_changed</code>:     If <code>last_changed = i</code>, then moving left is what caused us to find this collinear edge, and so we send <code>k</code> left by letting <code>i = k</code>. Otherwise, we send <code>k</code> right by letting <code>j = k</code>.</p><ol><li>Now having stepped forward, we recompute the <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for arrangement and return, setting <code>restart_flag = true</code> if <code>cur_iters ≥ maxiters</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L939-L998">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_triangle_degenerate_arrangement-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 5}}} where F" href="#DelaunayTriangulation.find_triangle_degenerate_arrangement-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 5}}} where F"><code>DelaunayTriangulation.find_triangle_degenerate_arrangement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_triangle_degenerate_arrangement(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history::F, history, pᵢ, pⱼ, i, j) -&gt; Bool</code></pre><p>Given a degenerate arrangement <code>pᵢpⱼq</code>, reinitialise the jump and march algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>k</code>: The vertex that the algorithm started from.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history</code>: Whether to store the history of the algorithm.</li><li><code>history</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to step from.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to step from.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Bool</code>: Whether the algorithm needs to be restarted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L1104-L1123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_triangle_return_on_vertex-Tuple{Triangulation, Vararg{Any, 8}}" href="#DelaunayTriangulation.find_triangle_return_on_vertex-Tuple{Triangulation, Vararg{Any, 8}}"><code>DelaunayTriangulation.find_triangle_return_on_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_triangle_return_on_vertex(tri::Triangulation, q, k, p, pᵢ, pⱼ, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Bool, Bool, Triangle)</code></pre><p>Check if <code>q</code> is one of the vertices of the triangle <code>(i, j, k)</code> and return if needed.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>k</code>: The vertex <code>k</code> that the algorithm started from. </li><li><code>p</code>: The point corresponding to the vertex <code>k</code>.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to start from.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to start from.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>restart_flag</code>: Whether the algorithm needs to be restarted.</li><li><code>return_flag</code>: Whether the algorithm can return immediately, returning <code>V</code>.</li><li><code>V</code>: The triangle <code>(i, j, k)</code>.</li></ul><p><strong>Extended help</strong></p><p>An extra check is made in this algorithm for the case that the point that <code>q</code> is equal to is one of the points corresponding to a ghost vertex,  so it may be for example that <code>q == pᵢ</code> but <code>is_ghost_vertex(i)</code>, in which case the algorithm would need to restart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L893-L917">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.initialise_find_triangle_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any, Any}} where F" href="#DelaunayTriangulation.initialise_find_triangle_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any, Any}} where F"><code>DelaunayTriangulation.initialise_find_triangle_boundary_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_find_triangle_boundary_vertex(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history, history, ghost_vertex, concavity_protection) -&gt; (Bool, Bool, Triangle, Point, Vertex, Vertex, Point, Point)</code></pre><p>Initialise the jump-and-march algorithm for a boundary vertex <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>k</code>: The boundary vertex to start from.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history</code>: Whether to store the history of the algorithm.</li><li><code>history</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>ghost_vertex</code>: The ghost vertex corresponding to the boundary that <code>k</code> resides on.</li><li><code>concavity_protection</code>: Whether to use concavity protection. See <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex.</li></ul><p><strong>Outputs</strong></p><ul><li><code>restart_flag</code>: Whether the algorithm needs to be restarted.</li><li><code>return_flag</code>: Whether the algorithm can return immediately, returning <code>V</code>.</li><li><code>V</code>: Either a triangle that can returned if <code>return_flag = true</code>, or some triangle that is used for type stability for this return value.</li><li><code>p</code>: The point corresponding to the vertex <code>k</code>, or it may be <code>q</code> if the algorithm is going to be restarted or <code>return_flag = true</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to start from, or <code>k</code> if the algorithm is going to be restarted or <code>return_flag = true</code>.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to start from, or <code>k</code> if the algorithm is going to be restarted or <code>return_flag = true</code>.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>, or it may be <code>q</code> if the algorithm is going to be restarted or <code>return_flag = true</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>, or it may be <code>q</code> if the algorithm is going to be restarted or <code>return_flag = true</code>.</li></ul><p><strong>Extended help</strong></p><p>There are multiple stages to this initialisation, starting from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>. </p><ul><li><p>If it is found that <code>q</code> is not outside of the triangulation, so that <code>q</code> is collinear with one of the boundary edges, then we use <a href="#DelaunayTriangulation.search_down_adjacent_boundary_edges-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 5}}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>search_down_adjacent_boundary_edges</code></a> to find where to start, noting   that we can return immediately if <code>q</code> is found to be on an adjacent boundary edge. Otherwise, <a href="#DelaunayTriangulation.exterior_find_triangle"><code>exterior_find_triangle</code></a> can then be used to find the ghost triangle containing   <code>q</code>; if <code>concavity_protection = true</code>, then <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a> is used to determine if a restart is needed.</p></li><li><p>If is is not found that <code>q</code> is outside of the triangulation yet based on information from the adjacent boundary edges, then we need to check the neighbouring   interior edges using <a href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 4}}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex</code></a>, returning early if <code>q</code> is found to be inside one of   the neighbouring triangles. If the line <code>pq</code>, where <code>p = get_point(tri, k)</code>, does not intersect any of the neighbouring edges and it is not inside any of   the neighbouring triangles, then it must be outside of the triangulation and so we use <a href="#DelaunayTriangulation.exterior_find_triangle"><code>exterior_find_triangle</code></a> to find the triangle; as before, <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>  is used on the found ghost triangle if needed. If there is an intersection, then we return the triangle containing the intersection point that we can start the algorithm from,   and its associated vertices and points. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L813-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.initialise_find_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F" href="#DelaunayTriangulation.initialise_find_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>DelaunayTriangulation.initialise_find_triangle_interior_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_find_triangle_interior_vertex(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history::F, history, rng) -&gt; (Bool, Point, Vertex, Vertex, Point, Point)</code></pre><p>Initialise the jump-and-march algorithm for an interior vertex <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>k</code>: The interior vertex to start from.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history</code>: Whether to store the history of the algorithm.</li><li><code>history</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>rng</code>: The random number generator to use.</li></ul><p><strong>Outputs</strong></p><ul><li><code>restart_flag</code>: Whether the algorithm needs to be restarted.</li><li><code>p</code>: The point corresponding to the vertex <code>k</code>.</li><li><code>i</code>: The first vertex of the triangle adjoining <code>k</code> to start from.</li><li><code>j</code>: The second vertex of the triangle adjoining <code>k</code> to start from.</li><li><code>pᵢ</code>: The point corresponding to the vertex <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to the vertex <code>j</code>.</li></ul><p><strong>Extended help</strong></p><p>This function works by simply using <a href="#DelaunayTriangulation.select_initial_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Random.AbstractRNG}} where F"><code>select_initial_triangle_interior_vertex</code></a> to find the initial triangle to start from. A check is made  to see if the edge <code>(i, j)</code> refers to a non-existent edge <code>(0, 0)</code>, in which case the algorithm needs to be restarted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L775-L800">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.prepare_initial_edge" href="#DelaunayTriangulation.prepare_initial_edge"><code>DelaunayTriangulation.prepare_initial_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_initial_edge(tri::Triangulation, edges, p, q, rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Vertex, Vertex, Point, Point, Certificate, Certificate)</code></pre><p>Selects a random edge from the set of edges <code>edges</code> and computes the certificates for the points corresponding to the initial and terminal vertices of the edge.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>edges</code>: The set of edges to sample from.</li><li><code>p</code>: The initial point.</li><li><code>q</code>: The query point.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The initial vertex of the edge.</li><li><code>j</code>: The terminal vertex of the edge.</li><li><code>pᵢ</code>: The point corresponding to <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to <code>j</code>.</li><li><code>line_cert_i</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for <code>pᵢ</code>&#39;s position relative to the oriented line <code>pq</code>.</li><li><code>line_cert_j</code>: The <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> for <code>pⱼ</code>&#39;s position relative to the oriented line <code>pq</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L116-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}" href="#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>DelaunayTriangulation.restart_find_triangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">restart_find_triangle(tri::Triangulation, q, store_history, history, rng, maxiters, cur_iter, concavity_protection, num_restarts, use_barriers, predicates::AbstractPredicateKernel) -&gt; Triangle[, Bool]</code></pre><p>Restart the <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> algorithm, or use <a href="../../api/point_location/#DelaunayTriangulation.brute_force_search"><code>brute_force_search</code></a> to find <code>q</code> if <code>num_restarts ≥ 25</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li><li><code>store_history</code>: Whether to store the history of the algorithm.</li><li><code>history</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>rng</code>: The random number generator to use.</li><li><code>maxiters</code>: The maximum number of iterations to perform before restarting the algorithm with <a href="#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>restart_find_triangle</code></a>.</li><li><code>cur_iter</code>: The current iteration of the algorithm.</li><li><code>concavity_protection</code>: Whether to use concavity protection. See <a href="#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex.</li><li><code>num_restarts</code>: The number of times the algorithm has been restarted. </li><li><code>use_barriers</code>: Whether to use barriers, stopping the algorithm at any segment.</li><li><code>predicates::AbstractPredicateKernel</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: The triangle containing <code>q</code>.</li></ul><p>In addition, if <code>use_barriers = Val(true)</code>, then a second output is returned, which is a boolean indicating whether the algorithm reached a barrier (<code>true</code>) or not (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L1248-L1270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.search_down_adjacent_boundary_edges-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 5}}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F" href="#DelaunayTriangulation.search_down_adjacent_boundary_edges-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 5}}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>DelaunayTriangulation.search_down_adjacent_boundary_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">search_down_adjacent_boundary_edges(tri::Triangulation, k, q, direction_cert, q_pos_cert, next_vertex, predicates::AbstractPredicateKernel=AdaptiveKernel(), store_history=Val(false), history=nothing, ghost_vertex=𝒢) -&gt; (Bool, Certificate, Vertex, Vertex, Vertex)</code></pre><p>Starting at the boundary vertex <code>k</code>, walks down the boundary in the direction of <code>q</code> until finding <code>q</code> or finding that it is outside of the triangulation.</p><p>See also <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>, which uses this function to determine an initial direction to search along.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex to start from.</li><li><code>q</code>: The query point.</li><li><code>direction_cert</code>: The direction of <code>q</code> relative to the vertex <code>k</code> along the boundary, defined from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>q_pos_cert</code>: The position of <code>q</code> relative to the vertex <code>k</code> along the boundary, defined from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>next_vertex</code>: The next vertex along the boundary in the direction of <code>q</code>, defined from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the algorithm.</li><li><code>history=nothing</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>ghost_vertex=𝒢</code>: The ghost vertex corresponding to the boundary that <code>k</code> resides on.</li></ul><p><strong>Outputs</strong></p><ul><li><code>return_flag</code>: Whether to return, or throw an exception.</li><li><code>q_pos_cert</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> that is <code>On</code> if <code>q</code> is on the edge <code>(u, v)</code>, and <code>Outside</code> if <code>q</code> is outside of the triangulation.</li><li><code>u</code>: If <code>is_on(q_pos_cert)</code>, this is the first vertex of a positively oriented triangle that <code>q</code> is on, so that <code>q</code> is on the edge <code>(u, v)</code>. Otherwise, <code>(u, v, w)</code> is a ghost triangle close to <code>q</code>.</li><li><code>v</code>: If <code>is_on(q_pos_cert)</code>, this is the second vertex of a positively oriented triangle that <code>q</code> is on, so that <code>q</code> is on the edge <code>(u, v)</code>. Otherwise, <code>(u, v, w)</code> is a ghost triangle close to <code>q</code>.</li><li><code>w</code>: If <code>is_on(q_pos_cert)</code>, this is the third vertex of a positively oriented triangle that <code>q</code> is on, so that <code>q</code> is on the edge <code>(u, v)</code> and <code>w = get_adjacent(tri, u, v)</code>. Otherwise, <code>(u, v, w)</code> is a ghost triangle close to <code>q</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries</header><div class="admonition-body"><p>This function assumes that the geometry is convex. The function will still be able to return, but <code>is_outside(q_pos_cert)</code> may not necessarily mean <code>q</code>  is outside of the triangulation. The main function <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> will have to restart the algorithm if it is found that <code>is_outside(q_pos_cert)</code>  was incorrect.</p></div></div><p><strong>Extended help</strong></p><p>This function works by stepping along vertices on the boundaries in the direction specified by <code>direction_cert</code>, using <code>search_right_down_adjacent_boundary_edges</code> if <code>is_right(direction_cert)</code> and <code>search_left_down_adjacent_boundary_edges</code> otherwise. In these functions, a <code>while</code> loop is used to keep stepping until <code>q_pos_cert</code>, which is updated at each iteration, changes value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L349-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.select_initial_point" href="#DelaunayTriangulation.select_initial_point"><code>DelaunayTriangulation.select_initial_point</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_initial_point(tri::Triangulation, q; kwargs...) -&gt; Vertex</code></pre><p>Selects the initial point for <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> to start from.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point. Can be either a point or a vertex - if it is a vertex, the corresponding point <code>get_point(tri, q)</code> will be used.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>point_indices=each_solid_vertex(tri)</code>: The indices to sample from. </li><li><code>m=default_num_samples(num_vertices(point_indices))</code>: The number of samples to take. Replacement is not used, so there may be duplicates.</li><li><code>try_points=()</code>: A list of points to try in addition to those randomly sampled.</li><li><code>allow_boundary_points=!is_disjoint(tri)</code>: Whether to allow boundary points to be selected.</li><li><code>rng=Random.default_rng()</code>: The random number generator to use.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The index of the point closest to <code>q</code> out of those queried.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.select_initial_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Random.AbstractRNG}} where F" href="#DelaunayTriangulation.select_initial_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Random.AbstractRNG}} where F"><code>DelaunayTriangulation.select_initial_triangle_interior_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_initial_triangle_interior_vertex(tri::Triangulation, 
    k, 
    q, 
    predicates::AbstractPredicateKernel=AdaptiveKernel(),
    store_history=Val(false), 
    history=nothing, 
    rng::Random.AbstractRNG=Random.default_rng()) -&gt; (Point, Vertex, Vertex, Point, Point)</code></pre><p>Selects the initial triangle for <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> to start from, for the case where <code>k</code> is an interior vertex.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The vertex to start from.</li><li><code>q</code>: The query point.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the algorithm.</li><li><code>history=nothing</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The point corresponding to <code>k</code>.</li><li><code>i</code>: The initial vertex of the triangle. </li><li><code>j</code>: The terminal vertex of the triangle.</li><li><code>pᵢ</code>: The point corresponding to <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to <code>j</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries</header><div class="admonition-body"><p>This function assumes that the geometry is convex. To deal with this, when an infinite loop is detected  we return <code>∅</code> for both <code>i</code> and <code>j</code>, and then let <a href="../../api/point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a> handle how to  correct the algorithm from there.    </p></div></div><p><strong>Extended help</strong></p><p>This part of the algorithm works by rotating around the vertex <code>k</code>, looking for a triangle whose edges adjoining <code>k</code>  are to the left and to the right of <code>k</code>. By choosing the initial edge at random via <a href="#DelaunayTriangulation.prepare_initial_edge"><code>prepare_initial_edge</code></a>,  and computing the position of <code>q</code> relative to this initial edge, the rotation will be either clockwise or counter-clockwise,  and the triangle is then found using either <code>select_initial_triangle_clockwise</code> or <code>select_initial_triangle_counterclockwise</code>, respectively. </p><p>In case the initial edge is collinear with the line <code>pq</code>, where <code>p = get_point(tri, q)</code>, then <code>fix_initial_collinear_edge_for_interior_vertex</code> to find a  non-collinear edge resample more edges from <a href="#DelaunayTriangulation.prepare_initial_edge"><code>prepare_initial_edge</code></a> if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L144-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.select_random_edge" href="#DelaunayTriangulation.select_random_edge"><code>DelaunayTriangulation.select_random_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_random_edge(tri::Triangulation, edges, rng::Random.AbstractRNG=Random.default_rng()) -&gt; (Vertex, Vertex, Point, Point)</code></pre><p>Selects a random edge from the set of edges <code>edges</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>edges</code>: The set of edges to sample from.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The initial vertex of the edge.</li><li><code>j</code>: The terminal vertex of the edge.</li><li><code>pᵢ</code>: The point corresponding to <code>i</code>.</li><li><code>pⱼ</code>: The point corresponding to <code>j</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/point_location/jump_and_march.jl#L93-L108">source</a></section></article><h2 id="Triangulation-Operations"><a class="docs-heading-anchor" href="#Triangulation-Operations">Triangulation Operations</a><a id="Triangulation-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulation-Operations" title="Permalink"></a></h2><p>Some of the triangulation operations have internal functions associated with them.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_all_exterior_triangles!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_all_exterior_triangles!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_all_exterior_triangles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_all_exterior_triangles!(tri::Triangulation, triangles)</code></pre><p>Deletes all the triangles in the set <code>triangles</code> from the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_holes.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_holes!-Tuple{Triangulation}" href="#DelaunayTriangulation.delete_holes!-Tuple{Triangulation}"><code>DelaunayTriangulation.delete_holes!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_holes!(tri::Triangulation)</code></pre><p>Deletes all the exterior faces to the boundary nodes specified in the triangulation <code>tri</code>.</p><p><strong>Extended help</strong></p><p>This function works in several stages:</p><ol><li>First, <a href="#DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}"><code>find_all_points_to_delete</code></a> is used to identify all points in the exterior faces.</li><li>Once all the points to delete have been found, all the associated triangles are found using <a href="#DelaunayTriangulation.find_all_triangles_to_delete-Tuple{Triangulation, Any}"><code>find_all_triangles_to_delete</code></a>, taking care for any incorrectly identified triangles and points. </li><li>Once the correct set of triangles to delete has been found, they are deleted using <a href="#DelaunayTriangulation.delete_all_exterior_triangles!-Tuple{Triangulation, Any}"><code>delete_all_exterior_triangles!</code></a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_holes.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_points_to_delete!-Tuple{Any, Triangulation, Any, Any}" href="#DelaunayTriangulation.find_all_points_to_delete!-Tuple{Any, Triangulation, Any, Any}"><code>DelaunayTriangulation.find_all_points_to_delete!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_points_to_delete!(points_to_process, tri::Triangulation, seed, all_bn)</code></pre><p>Starting at <code>seed</code>, finds more points to spread to and mark for deletion. </p><p><strong>Arguments</strong></p><ul><li><code>points_to_process</code>: The current list of points marked for deletion. </li><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>seed</code>: The seed vertex to start spreading from.</li><li><code>all_bn</code>: All the boundary nodes in the triangulation, obtained from <a href="../../api/triangulation/#DelaunayTriangulation.get_all_boundary_nodes"><code>get_all_boundary_nodes</code></a>.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, as <code>points_to_process</code> is updated in-place.</p><p><strong>Extended help</strong></p><p>This function works by considering the neighbours around the vertex <code>seed</code>. For each neighbouring vertex, we designate that as a new seed,  and consider if it needs to be added into <code>points_to_process</code> according to its distance from the triangulation computed from <a href="../../api/other/#DelaunayTriangulation.distance_to_polygon"><code>distance_to_polygon</code></a>. We then call <a href="#DelaunayTriangulation.find_all_points_to_delete!-Tuple{Any, Triangulation, Any, Any}"><code>find_all_points_to_delete!</code></a> recursively again on the new seed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_holes.jl#L101-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}" href="#DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}"><code>DelaunayTriangulation.find_all_points_to_delete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_points_to_delete(tri::Triangulation) -&gt; Set{Int}</code></pre><p>Returns a set of all the points that are in the exterior faces of the triangulation <code>tri</code>.</p><p><strong>Extended help</strong></p><p>This function works by &#39;spreading&#39; from some initial vertex. In particular, starting at each boundary node, we spread outwards towards adjacent vertices, recursively spreading so that all exterior points are identified with the help of <a href="#DelaunayTriangulation.find_all_points_to_delete!-Tuple{Any, Triangulation, Any, Any}"><code>find_all_points_to_delete!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_holes.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_triangles_to_delete-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.find_all_triangles_to_delete-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.find_all_triangles_to_delete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_triangles_to_delete(tri::Triangulation, points_to_process) -&gt; Set{Triangle}</code></pre><p>Returns a set of all the triangles that are in the exterior faces of the triangulation <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>points_to_process</code>: The set of points that are in the exterior faces of the triangulation <code>tri</code>, obtained from <a href="#DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}"><code>find_all_points_to_delete</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>triangles_to_delete</code>: The set of triangles that are in the exterior faces of the triangulation <code>tri</code>.</li></ul><p><strong>Extended help</strong></p><p>This function works in two stages. </p><ol><li>Firstly, all the non-boundary vertices, i.e. those from <code>points_to_process</code>, are processed. For each vertex <code>v</code>, the triangles adjoining it, given by <code>get_adjacent2vertex(tri, v)</code>, aremarked for deletion. </li><li>Next, all the boundary vertices need to be processed and carefully analysed to determine if any other triangles need to be deleted since, for example, a triangle may be adjoining three vertices that are all  boundary vertices, and it might not be obvious if it is inside or outside of the triangulation. By applying <a href="../../api/triangulation/#DelaunayTriangulation.dist"><code>dist</code></a> to compute the distance between the triangle&#39;s centroid and the triangulation,  the triangle can be accurately marked for deletion if it is outside of the triangulation.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_holes.jl#L135-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_delete_point_args-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.check_delete_point_args-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.check_delete_point_args</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_delete_point_args(tri::Triangulation, vertex, S) -&gt; Bool</code></pre><p>Checks that the vertex <code>vertex</code> can be deleted from the triangulation <code>tri</code>. Returns <code>true</code> if so,  and throws an <code>InvalidVertexDeletionError</code> otherwise. This will occur if:</p><ol><li><code>vertex</code> is a boundary node of <code>tri</code>.</li><li><code>vertex</code> is a ghost vertex of <code>tri</code>.</li><li><code>vertex</code> adjoins a segment of <code>tri</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_point.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_point!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_point!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_point!(tri::Triangulation, vertex; kwargs...)</code></pre><p>Deletes the <code>vertex</code> of <code>tri</code>, retriangulating the cavity formed by the surrounding polygon of <code>vertex</code> using  <a href="../../api/triangulation/#DelaunayTriangulation.triangulate_convex"><code>triangulate_convex</code></a>.</p><p>It is not possible to delete vertices that are on the boundary, are ghost vertices, or adjoin a segment of <code>tri</code>.  See also <a href="#DelaunayTriangulation.check_delete_point_args-Tuple{Triangulation, Any, Any}"><code>check_delete_point_args</code></a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Point deletion</header><div class="admonition-body"><p>This function will not actually delete the corresponding coordinates from <code>get_points(tri)</code>, nor will it remove  the associated weight from <code>get_weights(tri)</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>vertex</code>: The vertex to delete.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the triangulation from deleting the point. </li><li><code>event_history=nothing</code>: The event history of the triangulation from deleting the point. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator to use for the triangulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_point.jl#L112-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.fix_edges_after_deletion!-Tuple{Any, Any}" href="#DelaunayTriangulation.fix_edges_after_deletion!-Tuple{Any, Any}"><code>DelaunayTriangulation.fix_edges_after_deletion!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_edges_after_deletion!(tri::Triangulation, S)</code></pre><p>Ensures that the edges in <code>S</code> surrounding a deleted vertex of <code>tri</code> are correctly updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_point.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_surrounding_polygon-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_surrounding_polygon-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_surrounding_polygon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(tri::Triangulation, u; skip_ghost_vertices=false) -&gt; Vector</code></pre><p>Returns the counter-clockwise sequence of neighbours of <code>u</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>: The vertex.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>skip_ghost_vertices=false</code>: Whether to skip ghost vertices in the returned polygon. </li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: The surrounding polygon. This will not be circular, meaning <code>S[begin] ≠ S[end]</code>.  In case <code>u</code> is an exterior ghost vertex, the returned polygon is a clockwise list of vertices for   the associated boundary curve. If you do not have ghost triangles and you try to get the surrounding polygon  of a ghost vertex, then this function may return an invalid polygon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/delete_point.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.complete_split_edge_and_legalise!" href="#DelaunayTriangulation.complete_split_edge_and_legalise!"><code>DelaunayTriangulation.complete_split_edge_and_legalise!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Given a triangulation <code>tri</code>, an edge <code>(i, j)</code>, and a point <code>r</code>, splits both <code>(i, j)</code> and <code>(j, i)</code> at <code>r</code> using <a href="../../api/operations/#DelaunayTriangulation.split_edge!"><code>split_edge!</code></a> and then subsequently legalises the new edges with <a href="#DelaunayTriangulation.legalise_split_edge!"><code>legalise_split_edge!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the edge to split.</li><li><code>j</code>: The second vertex of the edge to split.</li><li><code>r</code>: The vertex to split the edge at.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_edge.jl#L125-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_edges_for_split_edge-Tuple{Triangulation, Any, Any, Any}" href="#DelaunayTriangulation.get_edges_for_split_edge-Tuple{Triangulation, Any, Any, Any}"><code>DelaunayTriangulation.get_edges_for_split_edge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_edges_for_split_edge(tri::Triangulation, i, j, r)</code></pre><p>Returns the edges <code>(i, j)</code>, <code>(j, i)</code>, <code>(i, r)</code>, <code>(r, i)</code>, <code>(r, j)</code>, and <code>(j, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_edge.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.legalise_split_edge!" href="#DelaunayTriangulation.legalise_split_edge!"><code>DelaunayTriangulation.legalise_split_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legalise_split_edge!(tri::Triangulation, i, j, k, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Legalises the newly added edges in <code>tri</code> after the edge <code>(i, j)</code> was split using <a href="../../api/operations/#DelaunayTriangulation.split_edge!"><code>split_edge!</code></a>.</p><p>See also <a href="../../api/operations/#DelaunayTriangulation.complete_split_edge_and_legalise!"><code>complete_split_edge_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the edge that was split.</li><li><code>j</code>: The second vertex of the edge that was split.</li><li><code>k</code>: The vertex that was originally adjacent to <code>(i, j)</code>.</li><li><code>r</code>: The vertex that <code>(i, j)</code> was split at.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_edge.jl#L97-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_edge!" href="#DelaunayTriangulation.split_edge!"><code>DelaunayTriangulation.split_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)</code></pre><p>Splits the edge <code>(i, j)</code> in <code>tri</code> at the vertex <code>r</code>. For the triangulation to be valid after this splitting, it is assumed that <code>r</code> is collinear with,  or at least very close to collinear with, the edge <code>(i, j)</code>.</p><p>See also <a href="#DelaunayTriangulation.legalise_split_edge!"><code>legalise_split_edge!</code></a> and <a href="../../api/operations/#DelaunayTriangulation.complete_split_edge_and_legalise!"><code>complete_split_edge_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.    </li><li><code>i</code>: The first vertex of the edge to split.</li><li><code>j</code>: The second vertex of the edge to split.</li><li><code>r</code>: The vertex to split the edge at.</li><li><code>store_event_history=Val(false)</code>: Whether to store the event history of the flip.</li><li><code>event_history=nothing</code>: The event history. Only updated if <code>store_event_history</code> is true, in which case it needs to be an <a href="../data_structures/#InsertionEventHistory"><code>InsertionEventHistory</code></a> object.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p><div class="admonition is-warning"><header class="admonition-header">Handling unoriented edges</header><div class="admonition-body"><p>The triangulation will only be updated as if <code>(i, j)</code> has been split rather than also <code>(j, i)</code>. You will need to call <code>split_edge!</code> again with <code>(j, i)</code> if you want to split that edge as well.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_edge.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.complete_split_triangle_and_legalise!-Tuple{Triangulation, Vararg{Any, 4}}" href="#DelaunayTriangulation.complete_split_triangle_and_legalise!-Tuple{Triangulation, Vararg{Any, 4}}"><code>DelaunayTriangulation.complete_split_triangle_and_legalise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)</code></pre><p>Splits the triangle <code>(i, j, k)</code> at the vertex <code>r</code>, assumed to be inside the triangle, and legalises the newly added edges in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the triangle.</li><li><code>j</code>: The second vertex of the triangle.</li><li><code>k</code>: The third vertex of the triangle.</li><li><code>r</code>: The vertex to split the triangle at.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_triangle.jl#L53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.legalise_split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}" href="#DelaunayTriangulation.legalise_split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}"><code>DelaunayTriangulation.legalise_split_triangle!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">legalise_split_triangle!(tri::Triangulation, i, j, k, r; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Legalises the newly added edges in <code>tri</code> after the triangle <code>(i, j, k)</code> was split using <a href="../../api/operations/#DelaunayTriangulation.split_triangle!"><code>split_triangle!</code></a>.</p><p>See also <a href="../../api/operations/#DelaunayTriangulation.complete_split_triangle_and_legalise!"><code>complete_split_triangle_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the triangle.</li><li><code>j</code>: The second vertex of the triangle.</li><li><code>k</code>: The third vertex of the triangle.</li><li><code>r</code>: The vertex to split the triangle at.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There is no output, as <code>tri</code> is updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_triangle.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}" href="#DelaunayTriangulation.split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}"><code>DelaunayTriangulation.split_triangle!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_triangle!(tri::Triangulation, i, j, k, r)</code></pre><p>Splits the triangle <code>(i, j, k)</code> at the vertex <code>r</code>, assumed to be inside the triangle. </p><p>See also <a href="#DelaunayTriangulation.legalise_split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}"><code>legalise_split_triangle!</code></a> and <a href="../../api/operations/#DelaunayTriangulation.complete_split_triangle_and_legalise!"><code>complete_split_triangle_and_legalise!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The first vertex of the triangle.</li><li><code>j</code>: The second vertex of the triangle.</li><li><code>k</code>: The third vertex of the triangle.</li><li><code>r</code>: The vertex to split the triangle at.</li></ul><p><strong>Outputs</strong></p><p>There is no output, but <code>tri</code> will be updated so that it now contains the triangles <code>(i, j, r)</code>, <code>(j, k, r)</code>, and <code>(k, i, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/basic_operations/split_triangle.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation._safe_get_adjacent-Tuple{Triangulation, Any}" href="#DelaunayTriangulation._safe_get_adjacent-Tuple{Triangulation, Any}"><code>DelaunayTriangulation._safe_get_adjacent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_safe_get_adjacent(tri::Triangulation, uv) -&gt; Vertex</code></pre><p>This is the safe version of <code>get_adjacent</code>, which is used when the triangulation has multiple sections, ensuring that the correct ghost vertex is returned in case <code>uv</code> is a ghost edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.add_adjacent!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_adjacent!(tri::Triangulation, uv, w)
add_adjacent!(tri::Triangulation, u, v, w)</code></pre><p>Adds the key-value pair <code>(u, v) ⟹ w</code> to the adjacency map of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_adjacent!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_adjacent!(tri::Triangulation, uv)
delete_adjacent!(tri::Triangulation, u, v)</code></pre><p>Deletes the key <code>(u, v)</code> from the adjacency map of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_adjacent(tri::Triangulation, uv) -&gt; Vertex
get_adjacent(tri::Triangulation, u, v) -&gt; Vertex</code></pre><p>Returns the vertex <code>w</code> such that <code>(u, v, w)</code> is a positively oriented triangle in the underlying triangulation, or <code>∅</code> if no such triangle exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.add_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_adjacent2vertex!(tri::Triangulation, w, uv)
add_adjacent2vertex!(tri::Triangulation, w, u, v)</code></pre><p>Adds the edge <code>(u, v)</code> into the set of edges returned by <code>get_adjacent2vertex(tri, w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent2vertex.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.delete_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_adjacent2vertex!(tri::Triangulation, w, uv)
delete_adjacent2vertex!(tri::Triangulation, w, u, v)</code></pre><p>Deletes the edge <code>(u, v)</code> from the set of edges returned by <code>get_adjacent2vertex(tri, w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent2vertex.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.delete_adjacent2vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_adjacent2vertex!(tri::Triangulation, w)</code></pre><p>Deletes the key <code>w</code> from the <a href="../data_structures/#Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent2vertex.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_adjacent2vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(tri::Triangulation, w) -&gt; Edges</code></pre><p>Returns the set of all edges <code>(u, v)</code> in <code>tri</code> such that <code>(u, v, w)</code> is a positively oriented triangle in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/adjacent2vertex.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}" href="#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}"><code>DelaunayTriangulation.add_neighbour!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_neighbour!(tri::Triangulation, u, v...)</code></pre><p>Adds the neighbours <code>v...</code> to <code>u</code> in the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg{Any}}" href="#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg{Any}}"><code>DelaunayTriangulation.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(tri::Triangulation, u...)</code></pre><p>Adds the vertices <code>u...</code> into the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_ghost_vertices_from_graph!-Tuple{Triangulation}" href="#DelaunayTriangulation.delete_ghost_vertices_from_graph!-Tuple{Triangulation}"><code>DelaunayTriangulation.delete_ghost_vertices_from_graph!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_ghost_vertices_from_graph!(tri::Triangulation)</code></pre><p>Deletes all ghost vertices from the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}" href="#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}"><code>DelaunayTriangulation.delete_neighbour!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_neighbour!(tri::Triangulation, u, v...)</code></pre><p>Deletes the neighbours <code>v...</code> from <code>u</code> in the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg{Any}}" href="#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg{Any}}"><code>DelaunayTriangulation.delete_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete_vertex!(tri::Triangulation, u...)</code></pre><p>Deletes the vertices <code>u...</code> from the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_neighbours</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation, u) -&gt; Set{Vertex}</code></pre><p>Returns the set of neighbours of <code>u</code> in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours and vertices will be ghost vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_neighbours-Tuple{Triangulation}" href="#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}"><code>DelaunayTriangulation.get_neighbours</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation) -&gt; Dict{Vertex, Set{Vertex}}</code></pre><p>Returns the <code>neighbours</code> map of <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours and vertices will be ghost vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.has_ghost_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.has_ghost_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ghost_vertices(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has ghost vertices, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.has_vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.has_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_vertex(tri::Triangulation, u) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>u</code> is a vertex in <code>tri</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.num_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.num_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_edges(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of edges in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of these edges will be ghost edges.</p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_solid_edges"><code>num_solid_edges</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_ghost_edges"><code>num_ghost_edges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_ghost_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.num_ghost_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.num_ghost_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_ghost_edges(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of ghost edges in <code>tri</code>.</p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_solid_edges"><code>num_solid_edges</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_edges"><code>num_edges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_ghost_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.num_ghost_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.num_ghost_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_ghost_vertices(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of ghost vertices in <code>tri</code>. </p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_solid_vertices"><code>num_solid_vertices</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_vertices"><code>num_vertices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_neighbours-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.num_neighbours-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.num_neighbours</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_neighbours(tri::Triangulation, u) -&gt; Integer</code></pre><p>Returns the number of neighbours of <code>u</code> in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours counted might be ghost vertices if <code>u</code> is a boundary vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_solid_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.num_solid_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.num_solid_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_solid_edges(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of solid edges in <code>tri</code>.</p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_ghost_edges"><code>num_ghost_edges</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_edges"><code>num_edges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_solid_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.num_solid_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.num_solid_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_solid_vertices(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of solid vertices in <code>tri</code>.</p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_ghost_vertices"><code>num_ghost_vertices</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_vertices"><code>num_vertices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.num_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.num_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_vertices(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of vertices in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of these vertices will be ghost vertices.</p><p>See also <a href="../../api/iterators/#DelaunayTriangulation.num_solid_vertices"><code>num_solid_vertices</code></a> and <a href="../../api/iterators/#DelaunayTriangulation.num_ghost_vertices"><code>num_ghost_vertices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L88-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.sort_edge_by_degree-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.sort_edge_by_degree-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.sort_edge_by_degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_edge_by_degree(tri::Triangulation, e) -&gt; Edge</code></pre><p>Returns the edge <code>e</code> sorted so that <code>initial(e)</code> has the smaller degree of the two vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/graph.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_point-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_point(tri::Triangulation, i) -&gt; NTuple{2, Number}
get_point(tri::Triangulation, i...) -&gt; NTuple{length(i), NTuple{2, Number}}</code></pre><p>Returns the coordinates corresponding to the vertices <code>i...</code> of <code>tri</code>, given as a <code>Tuple</code> of the form <code>(x, y)</code> for each point. If <code>i</code> is a ghost vertex, then the coordinates of the representative point of the curve associated with <code>i</code> are returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/points.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_points-Tuple{Triangulation}" href="#DelaunayTriangulation.num_points-Tuple{Triangulation}"><code>DelaunayTriangulation.num_points</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_points(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of points in <code>tri</code>.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>If <code>tri</code> has vertices that are not yet present in the triangulation, e.g. if you have deleted vertices or have  some submerged vertices in a weighted triangulation, then the corresponding points will still be counted in this  function. It is recommended that you instead consider <a href="../../api/iterators/#DelaunayTriangulation.num_vertices"><code>num_vertices</code></a>, <a href="../../api/iterators/#DelaunayTriangulation.num_solid_vertices"><code>num_solid_vertices</code></a>, or  <a href="../../api/iterators/#DelaunayTriangulation.num_ghost_vertices"><code>num_ghost_vertices</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/points.jl#L22-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.pop_point!-Tuple{Triangulation}" href="#DelaunayTriangulation.pop_point!-Tuple{Triangulation}"><code>DelaunayTriangulation.pop_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop_point!(tri::Triangulation)</code></pre><p>Pops the last point from the points of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/points.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.push_point!-Tuple{Triangulation, Any, Any}" href="#DelaunayTriangulation.push_point!-Tuple{Triangulation, Any, Any}"><code>DelaunayTriangulation.push_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push_point!(tri::Triangulation, x, y)
push_point!(tri::Triangulation, p)</code></pre><p>Pushes the point <code>p = (x, y)</code> into the points of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/points.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.set_point!-Tuple{Triangulation, Any, Any, Any}" href="#DelaunayTriangulation.set_point!-Tuple{Triangulation, Any, Any, Any}"><code>DelaunayTriangulation.set_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_point!(tri::Triangulation, i, x, y)
set_point!(tri::Triangulation, i, p)</code></pre><p>Sets the <code>i</code>th point of <code>tri</code> to <code>p = (x, y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/points.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.construct_positively_oriented_triangle" href="#DelaunayTriangulation.construct_positively_oriented_triangle"><code>DelaunayTriangulation.construct_positively_oriented_triangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_triangle(tri::Triangulation, i, j, k, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Triangle</code></pre><p>Returns a triangle in <code>tri</code> from the vertices <code>i</code>, <code>j</code>, and <code>k</code> such that the triangle is positively oriented.</p><p>You can use the <code>predicates</code> argument to determine how the orientation predicate is computed. Can be one of  <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for more discussion on these  choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/triangles.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.contains_triangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contains_triangle(tri::Triangulation, T) -&gt; (Triangle, Bool)
contains_triangle(tri::Triangulation, i, j, k) -&gt; (Triangle, Bool)</code></pre><p>Tests whether <code>tri</code> contains <code>T = (i, j, k)</code> up to rotation, returning </p><ul><li><code>V</code>: The rotated form of <code>T</code> that is in <code>tri</code>, or simply <code>T</code> if <code>T</code> is not in <code>tri</code>.</li><li><code>flag</code>: <code>true</code> if <code>T</code> is in <code>tri</code>, and <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/triangles.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_ghost_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.num_ghost_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.num_ghost_triangles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_ghost_triangles(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of ghost triangles in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/triangles.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_solid_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.num_solid_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.num_solid_triangles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_solid_triangles(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of solid triangles in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/triangles.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_triangles-Tuple{Triangulation}" href="#DelaunayTriangulation.num_triangles-Tuple{Triangulation}"><code>DelaunayTriangulation.num_triangles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_triangles(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of triangles in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of these triangles will be ghost triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/triangles.jl#L1-L6">source</a></section></article><h2 id="Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Voronoi-Tessellations">Voronoi Tessellations</a><a id="Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi-Tessellations" title="Permalink"></a></h2><p>Here are some functions related to the computation of unbounded Voronoi tessellations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_edge_to_voronoi_polygon!-Tuple{Any, VoronoiTessellation, Vararg{Any, 5}}" href="#DelaunayTriangulation.add_edge_to_voronoi_polygon!-Tuple{Any, VoronoiTessellation, Vararg{Any, 5}}"><code>DelaunayTriangulation.add_edge_to_voronoi_polygon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge_to_voronoi_polygon!(B, vorn::VoronoiTessellation, i, k, S, m, encountered_duplicate_circumcenter) -&gt; (Vertex, Bool, Vertex)</code></pre><p>Add the next edge to the Voronoi polygon for the point <code>i</code> in the <code>VoronoiTessellation</code> <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>B</code>: The vector of circumcenters defining the polygon. </li><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The polygon index.</li><li><code>k</code>: The vertex to add.</li><li><code>S</code>: The surrounding polygon of <code>i</code>. See <a href="../../api/operations/#DelaunayTriangulation.get_surrounding_polygon"><code>get_surrounding_polygon</code></a>.</li><li><code>m</code>: The index of the next vertex in <code>S</code>.</li><li><code>encountered_duplicate_circumcenter</code>: Whether or not a duplicate circumcenter has been encountered.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ci</code>: The index for the circumcenter of the triangle considered.</li><li><code>encountered_duplicate_circumcenter</code>: Whether or not a duplicate circumcenter has been encountered.</li><li><code>k</code>: The next vertex in <code>S</code> after the input <code>k</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L133-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_voronoi_polygon!-Tuple{VoronoiTessellation, Any}" href="#DelaunayTriangulation.add_voronoi_polygon!-Tuple{VoronoiTessellation, Any}"><code>DelaunayTriangulation.add_voronoi_polygon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_voronoi_polygon!(vorn::VoronoiTessellation, i) -&gt; Vector</code></pre><p>Add the Voronoi polygon for the point <code>i</code> to the <code>VoronoiTessellation</code> <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The polygon index.</li></ul><p><strong>Outputs</strong></p><ul><li><code>B</code>: The vector of circumcenters defining the polygon. This is a circular vector, i.e. <code>B[begin] == B[end]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.close_voronoi_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 4}}" href="#DelaunayTriangulation.close_voronoi_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 4}}"><code>DelaunayTriangulation.close_voronoi_polygon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close_voronoi_polygon!(vorn::VoronoiTessellation, B, i, encountered_duplicate_circumcenter, prev_ci)</code></pre><p>Close the Voronoi polygon for the point <code>i</code> in the <code>VoronoiTessellation</code> <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>B</code>: The vector of circumcenters defining the polygon.</li><li><code>i</code>: The polygon index.</li><li><code>encountered_duplicate_circumcenter</code>: Whether or not a duplicate circumcenter has been encountered.</li><li><code>prev_ci</code>: The previous circumcenter index.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, as <code>vorn</code> and <code>B</code> are modified in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L160-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.connect_circumcenters!-Tuple{Any, Any}" href="#DelaunayTriangulation.connect_circumcenters!-Tuple{Any, Any}"><code>DelaunayTriangulation.connect_circumcenters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect_circumcenters!(B, ci)</code></pre><p>Add the circumcenter index <code>ci</code> to the array <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_next_triangle_for_voronoi_polygon-Tuple{VoronoiTessellation, Vararg{Any, 4}}" href="#DelaunayTriangulation.get_next_triangle_for_voronoi_polygon-Tuple{VoronoiTessellation, Vararg{Any, 4}}"><code>DelaunayTriangulation.get_next_triangle_for_voronoi_polygon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_next_triangle_for_voronoi_polygon(vorn::VoronoiTessellation, i, k, S, m) -&gt; (Vertex, Vertex)</code></pre><p>Get the next triangle for the Voronoi polygon for the point <code>i</code> in the <code>VoronoiTessellation</code>. </p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The polygon index.</li><li><code>k</code>: The vertex to add.</li><li><code>S</code>: The surrounding polygon of <code>i</code>. See <a href="../../api/operations/#DelaunayTriangulation.get_surrounding_polygon"><code>get_surrounding_polygon</code></a>.</li><li><code>m</code>: The index of the next vertex in <code>S</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ci</code>: The index for the circumcenter of the next triangle.</li><li><code>k</code>: The next vertex in <code>S</code> after the input <code>k</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L98-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.initialise_voronoi_tessellation-Tuple{Tr} where Tr&lt;:Triangulation" href="#DelaunayTriangulation.initialise_voronoi_tessellation-Tuple{Tr} where Tr&lt;:Triangulation"><code>DelaunayTriangulation.initialise_voronoi_tessellation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_voronoi_tessellation(tri::Triangulation) -&gt; VoronoiTessellation</code></pre><p>Initialise a <code>VoronoiTessellation</code> from the triangulation <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li></ul><p><strong>Output</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>. This tessellation is not yet filled in, as all the polygons and other fields need to be properly defined. This simply defines all the initial objects that will be pushed into.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.prepare_add_voronoi_polygon-Tuple{VoronoiTessellation, Any}" href="#DelaunayTriangulation.prepare_add_voronoi_polygon-Tuple{VoronoiTessellation, Any}"><code>DelaunayTriangulation.prepare_add_voronoi_polygon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_add_voronoi_polygon(vorn::VoronoiTessellation, i) -&gt; (Vector, Vector)</code></pre><p>Prepare to add a Voronoi polygon for the vertex <code>i</code> to the Voronoi tessellation <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The vertex. </li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: The surrounding polygon of <code>i</code>. See <a href="../../api/operations/#DelaunayTriangulation.get_surrounding_polygon"><code>get_surrounding_polygon</code></a>.</li><li><code>B</code>: The buffer for the circumcenters. This is an empty <code>Vector{I}</code>, where <code>I = integer_type(tri)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/unbounded.jl#L77-L89">source</a></section></article><h2 id="Clipped-Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Clipped-Voronoi-Tessellations">Clipped Voronoi Tessellations</a><a id="Clipped-Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Clipped-Voronoi-Tessellations" title="Permalink"></a></h2><p>Here are some functions related to the computation of clipped Voronoi tessellations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_all_boundary_polygons!-Tuple{VoronoiTessellation, Any}" href="#DelaunayTriangulation.add_all_boundary_polygons!-Tuple{VoronoiTessellation, Any}"><code>DelaunayTriangulation.add_all_boundary_polygons!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_all_boundary_polygons!(vorn::VoronoiTessellation, boundary_sites)</code></pre><p>Add all of the boundary polygons to the Voronoi tessellation.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the boundary polygons are added in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L814-L825">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_intersection_points!-Tuple{VoronoiTessellation, Any}" href="#DelaunayTriangulation.add_intersection_points!-Tuple{VoronoiTessellation, Any}"><code>DelaunayTriangulation.add_intersection_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_intersection_points!(vorn::VoronoiTessellation, segment_intersections) -&gt; Integer</code></pre><p>Adds all of the <code>segment_intersections</code> into the polygon vertices of <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>segment_intersections</code>: The intersection points from <a href="#DelaunayTriangulation.find_all_intersections-Tuple{VoronoiTessellation}"><code>find_all_intersections</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>n</code>: The number of polygon vertices before the intersections were added.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L737-L748">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I" href="#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I"><code>DelaunayTriangulation.add_segment_intersection!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_segment_intersection!(segment_intersections, boundary_sites, intersection_point, incident_polygon::I) where {I} -&gt; Integer</code></pre><p>Adds the <code>intersection_point</code> into the list of <code>segment_intersections</code>.</p><p><strong>Arguments</strong></p><ul><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>intersection_point</code>: The intersection point to add.</li><li><code>incident_polygon</code>: The index of the polygon that is incident to the intersection point.</li></ul><p><strong>Outputs</strong></p><ul><li><code>idx</code>: The index of the intersection point in the list of segment intersections. If the intersection point already exists in the list, then the index of the existing point is returned and used instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L83-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V&lt;:Pair{E, E}}" href="#DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V&lt;:Pair{E, E}}"><code>DelaunayTriangulation.add_to_intersected_edge_cache!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_to_intersected_edge_cache!(intersected_edge_cache, u, v, a, b)</code></pre><p>Add the edge <code>uv</code> to the list of intersected edges.</p><p><strong>Arguments</strong></p><ul><li><code>intersected_edge_cache</code>: The list of intersected edges.</li><li><code>u</code>: The first vertex of the edge of the Voronoi polygon intersecting the edge <code>ab</code> of the boundary. </li><li><code>v</code>: The second vertex of the edge of the Voronoi polygon intersecting the edge <code>ab</code> of the boundary.</li><li><code>a</code>: The first vertex of the edge of the boundary.</li><li><code>b</code>: The second vertex of the edge of the boundary.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, as <code>intersected_edge_cache</code> is modified in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L114-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.classify_intersections!-NTuple{7, Any}" href="#DelaunayTriangulation.classify_intersections!-NTuple{7, Any}"><code>DelaunayTriangulation.classify_intersections!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classify_intersections!(intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge)</code></pre><p>Classify the intersections in <code>intersected_edge_cache</code> into <code>left_edge_intersectors</code>, <code>right_edge_intersectors</code>, and <code>current_edge_intersectors</code> based on whether they intersect <code>left_edge</code>, <code>right_edge</code>, or <code>current_edge</code>, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>left_edge_intersectors</code>: The set of sites that intersect the edge to the left of an edge currently being considered.</li><li><code>right_edge_intersectors</code>: The set of sites that intersect the edge to the right of an edge currently being considered.</li><li><code>current_edge_intersectors</code>: The set of sites that intersect the current edge being considered.</li><li><code>left_edge</code>: The edge to the left of <code>e</code> on the boundary.</li><li><code>right_edge</code>: The edge to the right of <code>e</code> on the boundary.</li><li><code>current_edge</code>: The edge on the boundary being considered.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but <code>left_edge_intersectors</code>, <code>right_edge_intersectors</code>, or <code>current_edge_intersectors</code> are updated all in-place depending on the type of intersection for each  edge in <code>intersected_edge_cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L498-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.cleanup_unbounded_polygons!-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.cleanup_unbounded_polygons!-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.cleanup_unbounded_polygons!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cleanup_unbounded_polygons!(vorn::VoronoiTessellation)</code></pre><p>Removes any remaining unbounded polygons from <code>vorn</code> after clipping. This is needed only for power diagrams. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L1033-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_all_polygons!-Tuple{VoronoiTessellation, Vararg{Any, 4}}" href="#DelaunayTriangulation.clip_all_polygons!-Tuple{VoronoiTessellation, Vararg{Any, 4}}"><code>DelaunayTriangulation.clip_all_polygons!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_all_polygons!(vorn::VoronoiTessellation, n, boundary_sites, exterior_circumcenters, equal_circumcenter_mapping)</code></pre><p>Clip all of the polygons in the Voronoi tessellation.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>n</code>: The number of vertices in the tessellation before clipping.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>exterior_circumcenters</code>: Any exterior circumcenters to be filtered out.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the polygons are clipped in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L791-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 6}}" href="#DelaunayTriangulation.clip_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 6}}"><code>DelaunayTriangulation.clip_polygon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_polygon!(vorn::VoronoiTessellation, n, points, polygon, new_verts, exterior_circumcenters, equal_circumcenter_mapping)</code></pre><p>Clip the polygon <code>polygon</code> by removing the vertices that are outside of the domain and adding the new vertices <code>new_verts</code> to the polygon.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>n</code>: The number of vertices in the tessellation before clipping.</li><li><code>points</code>: The polygon points of the tessellation.</li><li><code>polygon</code>: The index of the polygon to be clipped.</li><li><code>new_verts</code>: The indices of the new vertices that are added to the polygon.</li><li><code>exterior_circumcenters</code>: Any exterior circumcenters to be filtered out.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the polygon is clipped in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L757-L773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_voronoi_tessellation!-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.clip_voronoi_tessellation!-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.clip_voronoi_tessellation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_voronoi_tessellation!(vorn::VoronoiTessellation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Clip the Voronoi tessellation <code>vorn</code> to the convex hull of the generators in <code>vorn</code>. </p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>clip_polygon=nothing</code>: If <code>clip=true</code>, then this is the polygon to clip the Voronoi tessellation to. If <code>nothing</code>, the convex hull of the triangulation is used. The polygon should be defined as a <code>Tuple</code> of the form <code>(points, boundary_nodes)</code> where the <code>boundary_nodes</code> are vertices mapping to coordinates in <code>points</code>, adhering to the usual conventions for defining boundaries. Must be a convex polygon.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the Voronoi tessellation is clipped in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L833-L848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_to_edge_adjoining_ghost_vertex(tri::Triangulation, e) -&gt; Edge</code></pre><p>Returns the edge <code>e</code> if it is not a boundary edge, and the edge <code>reverse(e)</code> if it is a boundary edge. </p><p>See also <a href="../../api/predicates/#DelaunayTriangulation.is_boundary_edge"><code>is_boundary_edge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.dequeue_and_process!" href="#DelaunayTriangulation.dequeue_and_process!"><code>DelaunayTriangulation.dequeue_and_process!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dequeue_and_process!(vorn, polygon_edge_queue, edges_to_process,
    intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors,
    processed_pairs, boundary_sites, segment_intersections, exterior_circumcenters, equal_circumcenter_mapping,
    rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Dequeue an edge from <code>polygon_edge_queue</code> and process it. If <code>polygon_edge_queue</code> is empty, then we process the first edge in <code>edges_to_process</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>polygon_edge_queue</code>: The queue of edges that need to be processed.</li><li><code>edges_to_process</code>: The edges that need to be processed.</li><li><code>intersected_edge_cache</code>: A cache of intersected edges.</li><li><code>left_edge_intersectors</code>: The intersection points of <code>left_edge</code> with other edges.</li><li><code>right_edge_intersectors</code>: The intersection points of <code>right_edge</code> with other edges.</li><li><code>current_edge_intersectors</code>: The intersection points of <code>current_edge</code> with other edges.</li><li><code>processed_pairs</code>: A set of pairs of edges and polygons that have already been processed.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>segment_intersections</code>: A dictionary of segment intersections.</li><li><code>exterior_circumcenters</code>: A dictionary of exterior circumcenters.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator. </li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs. Instead, the caches and queues are updated in-place.</p><p><strong>Extended help</strong></p><p>This function works as follows:</p><ol><li>Firstly, if there are no edges queued in <code>polygon_edge_queue</code>, then we enqueue the first in edge in <code>edges_to_process</code> using <a href="#DelaunayTriangulation.enqueue_new_edge!"><code>enqueue_new_edge!</code></a>.</li><li>We then dequeue the next edge to be processed. If the edge has already been processed, then we return early.</li><li>If we&#39;re still here, then we process the <code>(edge, polygon)</code> pair enqueued from <code>polygon_edge_queue</code> using <a href="#DelaunayTriangulation.process_polygon!"><code>process_polygon!</code></a>. This function checks for intersections of the <code>edge</code> with the <code>polygon</code>.</li><li>Once the polygon has been processed, we then needed to classify all of the intersections using <a href="#DelaunayTriangulation.classify_intersections!-NTuple{7, Any}"><code>classify_intersections!</code></a>, which determines, for each intersection, if the intersection is with <code>edge</code>,  or with the edge left of <code>edge</code>, or to the edge right of <code>edge</code>.</li><li>Then, <a href="#DelaunayTriangulation.process_intersection_points!-NTuple{12, Any}"><code>process_intersection_points!</code></a> is used to process the intersection points, enqueueing new edges when needed.</li><li>We then delete the edge from <code>edges_to_process</code> if it is in there and return.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L615-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enqueue_new_edge!" href="#DelaunayTriangulation.enqueue_new_edge!"><code>DelaunayTriangulation.enqueue_new_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enqueue_new_edge!(polygon_edge_queue, vorn::VoronoiTessellation, e)</code></pre><p>Enqueue the edge <code>e</code> of the boundary to be processed.</p><p><strong>Arguments</strong></p><ul><li><code>polygon_edge_queue</code>: The queue of edges that are to be processed.</li><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>e</code>: The edge to be processed.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: Random number generator. Needed for <a href="../../api/point_location/#DelaunayTriangulation.get_nearest_neighbour"><code>get_nearest_neighbour</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods. Needed for <a href="../../api/point_location/#DelaunayTriangulation.get_nearest_neighbour"><code>get_nearest_neighbour</code></a>.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, as <code>polygon_edge_queue</code> is modified in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L311-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_exterior_circumcenters-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.find_all_exterior_circumcenters-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.find_all_exterior_circumcenters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_exterior_circumcenters(vorn::VoronoiTessellation, clip_points, clip_vertices) -&gt; Set{I}</code></pre><p>Finds all the polygon vertices in <code>vorn</code> that are outside of the polygon defined by <code>(clip_points, clip_vertices)</code>. The  return is the set of all exterior vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L1049-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_intersecting_polygons-Tuple{VoronoiTessellation, Any, Any, Any}" href="#DelaunayTriangulation.find_all_intersecting_polygons-Tuple{VoronoiTessellation, Any, Any, Any}"><code>DelaunayTriangulation.find_all_intersecting_polygons</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_intersecting_polygons(vorn::VoronoiTessellation, clip_points, clip_vertices, exterior_circumcenters) -&gt; (Set{I}, Set{I})</code></pre><p>Classifies all polygons in <code>vorn</code> into three sets depending on how they intersect the polygon  defined by <code>(clip_points, clip_vertices)</code>, returning <code>(interior, intersecting, exterior)</code>, where</p><ul><li><code>interior</code> are the polygons that are entirely inside the polygon defined by <code>(clip_points, clip_vertices)</code>,</li><li><code>possibly_intersecting</code> are the polygons that might intersect the polygon defined by <code>(clip_points, clip_vertices)</code>.</li></ul><p>The <code>exterior_circumcenters</code> are the circumcenters that are outside of the domain, see <a href="#DelaunayTriangulation.find_all_exterior_circumcenters-Tuple{VoronoiTessellation, Any, Any}"><code>find_all_exterior_circumcenters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L1066-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_all_intersections-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.find_all_intersections-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.find_all_intersections</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_all_intersections(vorn::VoronoiTessellation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Dict, Vector, Set, Dict)</code></pre><p>Find all intersections between the edges of the Voronoi tessellation and the boundary of the polygon.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>segment_intersections</code>: The intersection points.</li><li><code>exterior_circumcenters</code>: The circumcenters that are outside of the domain.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul><p><strong>Extended help</strong></p><p>This algorithm works as follows:</p><ol><li>First, using <a href="#DelaunayTriangulation.initialise_clipping_arrays-Tuple{VoronoiTessellation}"><code>initialise_clipping_arrays</code></a>, we initialise the arrays that we will use to store the intersections, and queue up all boundary edges for processing.</li><li>Then, starting with the first edge in <code>edges_to_process</code>, we dequeue an edge from <code>polygon_edge_queue</code> and process it via <a href="#DelaunayTriangulation.dequeue_and_process!"><code>dequeue_and_process!</code></a>.</li><li>We repeat step 2 until <code>polygon_edge_queue</code> and <code>edges_to_process</code> are both empty.</li><li>We then return.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L686-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.fix_no_intersections!-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.fix_no_intersections!-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.fix_no_intersections!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_no_intersections!(vorn::VoronoiTessellation; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>In the case that the Voronoi tiles have no intersections at all with the convex hull, this function adds in the missing intersections. <a href="../../api/other/#DelaunayTriangulation.clip_polygon"><code>clip_polygon</code></a> is used for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L965-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_neighbouring_boundary_edges-Tuple{Triangulation, Any}" href="#DelaunayTriangulation.get_neighbouring_boundary_edges-Tuple{Triangulation, Any}"><code>DelaunayTriangulation.get_neighbouring_boundary_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_neighbouring_boundary_edges(tri::Triangulation, e) -&gt; (Edge, Edge)</code></pre><p>Returns the two boundary edges adjacent to the boundary edge <code>e</code> in the triangulation <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: a triangulation</li><li><code>e</code>: The boundary edge.</li></ul><p><strong>Outputs</strong></p><ul><li><code>left_e</code>: The left edge.</li><li><code>right_e</code>: The right edge.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_shared_vertex-Tuple{Any, Any}" href="#DelaunayTriangulation.get_shared_vertex-Tuple{Any, Any}"><code>DelaunayTriangulation.get_shared_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_shared_vertex(e, f) -&gt; Vertex</code></pre><p>Returns the vertex shared by the edges <code>e</code> and <code>f</code>, or <code>∅</code> if they do not share a vertex.</p><p><strong>Arguments</strong></p><ul><li><code>e</code>: The first edge.</li><li><code>f</code>: The second edge.</li></ul><p><strong>Outputs</strong></p><ul><li><code>u</code>: The shared vertex.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.get_shared_vertex((1, 3), (5, 7))
0

julia&gt; DelaunayTriangulation.get_shared_vertex((1, 3), (3, 7))
3

julia&gt; DelaunayTriangulation.get_shared_vertex((10, 3), (10, 5))
10

julia&gt; DelaunayTriangulation.get_shared_vertex((9, 4), (9, 5))
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L41-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.initialise_clipping_arrays-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.initialise_clipping_arrays-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.initialise_clipping_arrays</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialise_clipping_arrays(vorn::VoronoiTessellation) -&gt; (Set{E}, Queue{Tuple{E,I}}, Dict{I,Set{I}}, NTuple{2,F}[], Set{Tuple{E,I}}, Pair{E,E}[], Set{I}, Set{E}, Set{E}, Set{E}, Dict{I,I})</code></pre><p>Initialise the arrays used in the clipping algorithm for the <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a> <code>vorn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>edges_to_process</code>: The set of edges that are to be processed.</li><li><code>polygon_edge_queue</code>: The queue of edges that are to be processed.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>processed_pairs</code>: The set of pairs of edges and polygons that have been processed.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>left_edge_intersectors</code>: The set of sites that intersect the edge to the left of an edge currently being considered.</li><li><code>right_edge_intersectors</code>: The set of sites that intersect the edge to the right of an edge currently being considered.</li><li><code>current_edge_intersectors</code>: The set of sites that intersect the current edge being considered.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L265-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_finite_segment-Tuple{Any, Any}" href="#DelaunayTriangulation.is_finite_segment-Tuple{Any, Any}"><code>DelaunayTriangulation.is_finite_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_finite_segment(u, v) -&gt; Bool</code></pre><p>Returns <code>true</code> if the segment <code>(u, v)</code> is finite, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_ray_going_in-Tuple{Any, Any}" href="#DelaunayTriangulation.is_ray_going_in-Tuple{Any, Any}"><code>DelaunayTriangulation.is_ray_going_in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_ray_going_in(u, v) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ray <code>(u, v)</code> is coming in from infinity, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L342-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_ray_going_out-Tuple{Any, Any}" href="#DelaunayTriangulation.is_ray_going_out-Tuple{Any, Any}"><code>DelaunayTriangulation.is_ray_going_out</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_ray_going_out(u, v) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ray <code>(u, v)</code> is going out to infinity, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_segment_between_two_ghosts-Tuple{Any, Any}" href="#DelaunayTriangulation.is_segment_between_two_ghosts-Tuple{Any, Any}"><code>DelaunayTriangulation.is_segment_between_two_ghosts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_segment_between_two_ghosts(u, v) -&gt; Bool</code></pre><p>Returns <code>true</code> if the segment <code>(u, v)</code> is between two ghost vertices, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_intersection_points!-NTuple{12, Any}" href="#DelaunayTriangulation.process_intersection_points!-NTuple{12, Any}"><code>DelaunayTriangulation.process_intersection_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_intersection_points!(polygon_edge_queue, vorn, current_incident_polygon,
    left_edge_intersectors, right_edge_intersectors, current_edge_intersectors,
    left_edge, right_edge, current_edge, processed_pairs, segment_intersections, boundary_sites)</code></pre><p>Process the intersection points in <code>left_edge_intersectors</code>, <code>right_edge_intersectors</code>, and <code>current_edge_intersectors</code> and add the new edges to <code>polygon_edge_queue</code> if necessary. Special care is taken to not miss any corner points.</p><p><strong>Arguments</strong></p><ul><li><code>polygon_edge_queue</code>: The queue of edges that need to be processed.</li><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>current_incident_polygon</code>: The index of the current polygon being processed.</li><li><code>left_edge_intersectors</code>: The intersection points of <code>left_edge</code> with other edges.</li><li><code>right_edge_intersectors</code>: The intersection points of <code>right_edge</code> with other edges.</li><li><code>current_edge_intersectors</code>: The intersection points of <code>current_edge</code> with other edges.</li><li><code>left_edge</code>: The left edge of the current polygon.</li><li><code>right_edge</code>: The right edge of the current polygon.</li><li><code>current_edge</code>: The current edge of the current polygon.</li><li><code>processed_pairs</code>: A set of pairs of edges and polygons that have already been processed.</li><li><code>segment_intersections</code>: A dictionary of segment intersections.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but the caches and queues are updated in-place.</p><p><strong>Extended help</strong></p><p>The rules are based on the paper &quot;Efficient Computation of Clipped Voronoi Diagram for Mesh Generation&quot; by Yan, Wang, Levy, and Liu. Namely,  an edge that intersects a boundary edge and one adjacent to it has its shared vertex added to the queue together with the current polygon (<code>current_incident_polygon</code>) being  considered, and any intersections have the adjacent polygon added to the queue together with the intersecting edge. (These are not strictly  the rules in the paper.)</p><p>This function works as follows:</p><ol><li>First, assuming that there is more than one triangle in the underlying triangulation of <code>vorn</code>, we need to consider <code>left_edge</code> and <code>right_edge</code> individually. </li><li>The procedure for each edge is the same, so here we just describe the <code>left_edge</code>. If there are any intersectors with the <code>left_edge</code>, and neither of  <code>(left_edge, current_incident_polygon)</code> or <code>(reverse_edge(left_edge), current_incident_polygon)</code> have already been processed (i.e., in <code>processed_pairs</code>), then we enqueue  <code>(left_edge, i)</code> and <code>(left_edge, j)</code> into <code>polygon_edge_queue</code>, where <code>i</code> and <code>j</code> are the vertices of <code>left_edge</code> which correspond to polygons. This will ensure that we can find intersections next to this polygon. </li><li>After enqueueing these pairs, we also need to protect against corner points, which we check for by considering <code>current_incident_polygon ∈ all_indices</code>, where <code>all_indices</code> are the vertices of <code>left_edge</code>,  <code>right_edge</code>, and <code>current_edge</code>. If this is true, and if the shared vertex of <code>current_edge</code> and <code>left_edge</code> is equal to <code>current_incident_polygon</code>, then we need to add the point generator of <code>current_incident_polygon</code> as an intersection. This need comes from having to worry about corners, i.e. points where the two unbounded polygons meet and go directly left and right of a vertex so that that vertex is not considered an intersection; this point needs to be included.</li><li>Once the <code>left_edge</code> and <code>right_edge</code> have been processed as above, we need to then consider all of <code>left_edge</code>, <code>right_edge</code>, and <code>current_edge</code>, and each of the intersections through the respective edge. This step is done  regardless of whether there is a single triangle in the underlying triangulation. The procedure for each edge is the same, so let us just describe the <code>current_edge</code>. For each edge <code>uv</code> in the <code>current_edge_intersectors</code>, we need to get the polygon adjacent to that edge. Then, if <code>(current_edge, adjacent_incident_polygon)</code> or <code>(reverse_edge(current_edge), adjacent_incident_polygon)</code> have not been processed, we enqueue <code>(current_edge, adjacent_incident_polygon)</code>.</li><li>Once the edges have all been processed as above, we return.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L529-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_polygon!" href="#DelaunayTriangulation.process_polygon!"><code>DelaunayTriangulation.process_polygon!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_polygon!(vorn::VoronoiTessellation, e, incident_polygon, boundary_sites, segment_intersections, intersected_edge_cache, exterior_circumcenters, equal_circumcenter_mapping, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Edge, Edge, Edge)</code></pre><p>Processes the polygon <code>incident_polygon</code> for all of its intersections based on the boundary edge <code>e</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn::VoronoiTessellation</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>e</code>: The edge on the boundary being considered.</li><li><code>incident_polygon</code>: The index of the polygon being considered.</li><li><code>boundary_sites</code>: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>intersected_edge_cache</code>: A cache of the edges that have been intersected by the ray from <code>u</code> to <code>v</code>.</li><li><code>exterior_circumcenters</code>: A list of the circumcenters of the sites that are outside the convex hull of the sites on the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>left_edge</code>: The edge to the left of <code>e</code> on the boundary.</li><li><code>right_edge</code>: The edge to the right of <code>e</code> on the boundary.</li><li><code>e</code>: The edge on the boundary being considered.</li></ul><p>In addition to these outputs, the caches are also updated in-place.</p><p><strong>Extended help</strong></p><p>This function works as follows: </p><ol><li>First, for the current edge <code>e</code>, we get the edges <code>left_edge</code> and <code>right_edge</code> that neighbour it via <a href="#DelaunayTriangulation.get_neighbouring_boundary_edges-Tuple{Triangulation, Any}"><code>get_neighbouring_boundary_edges</code></a>.</li><li>For each edge of the <code>incident_polygon</code>, we need to process it depending on whether the edge <code>(u, v)</code> is finite, between two ghosts, going out to infinity, or coming in from infinity.  If the edge is between two ghosts, we skip the edge. For rays that go out or in to infinity, we use <a href="#DelaunayTriangulation.process_ray_intersection!"><code>process_ray_intersection!</code></a> and <a href="#DelaunayTriangulation.process_ray_intersection_with_other_edges!"><code>process_ray_intersection_with_other_edges!</code></a>  to process the intersection of the ray with the boundary edges. The function <a href="#DelaunayTriangulation.process_ray_intersection_with_other_edges!"><code>process_ray_intersection_with_other_edges!</code></a> is needed since rays going out to infinity may have to go  through other boundary edges in order to do so, e.g. at a corner it may be that it crosses two boundary edges. For finite segments, <a href="#DelaunayTriangulation.process_segment_intersection!"><code>process_segment_intersection!</code></a> is used to process the intersection. We apply this function with each of <code>e</code>, <code>left_edge</code>, and <code>right_edge</code> to check for all intersections.</li><li>The function is done once each of the polygon edges has been considered.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L437-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_ray_intersection!" href="#DelaunayTriangulation.process_ray_intersection!"><code>DelaunayTriangulation.process_ray_intersection!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_ray_intersection!(
    vorn::VoronoiTessellation,
    u,
    v,
    incident_polygon,
    intersected_edge_cache,
    segment_intersections,
    boundary_sites,
    exterior_circumcenters,
    equal_circumcenter_mapping,
    predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Point</code></pre><p>Process the intersection of the Voronoi polygon of the site <code>u</code> with the ray emanating from the circumcenter of the site <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>u</code>: The index of the site <code>u</code>, given as a ghost vertex for the associated ghost triangle.</li><li><code>v</code>: The index of the site <code>v</code>.</li><li><code>incident_polygon</code>: The index of the Voronoi polygon of the site <code>u</code> that is incident to the ray emanating from the circumcenter of the site <code>v</code>.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The coordinates of the intersection. </li></ul><p>In addition to the point <code>p</code>, <a href="#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I"><code>add_segment_intersection!</code></a> is also updated to incorporate the new intersection point, as is <a href="#DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V&lt;:Pair{E, E}}"><code>add_to_intersected_edge_cache!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L136-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_ray_intersection_with_other_edges!" href="#DelaunayTriangulation.process_ray_intersection_with_other_edges!"><code>DelaunayTriangulation.process_ray_intersection_with_other_edges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_ray_intersection_with_other_edges!(vorn::VoronoiTessellation,
    u,
    v,
    e,
    left_edge,
    right_edge,
    r,
    segment_intersections,
    boundary_sites,
    incident_polygon,
    equal_circumcenter_mapping,
    intersected_edge_cache,
    predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Process the intersection of the ray from the ghost site <code>u</code> to the site <code>v</code> with the edges <code>e</code>, <code>left_edge</code> and <code>right_edge</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn::VoronoiTessellation</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>u</code>: The index of the ghost site.</li><li><code>v</code>: The index of the site <code>u</code> is going to.</li><li><code>e</code>: The edge on the boundary being considered.</li><li><code>left_edge</code>: The edge to the left of <code>e</code> on the boundary.</li><li><code>right_edge</code>: The edge to the right of <code>e</code> on the boundary.</li><li><code>r</code>: The coordinates of the intersection of the ray from <code>u</code> to <code>v</code> with some edge. If <code>any(isnan, r)</code>, then the ray does not intersect any edge and we skip.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.</li><li><code>incident_polygon</code>: The index of the polygon that contains the intersection of the ray from <code>u</code> to <code>v</code> with the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>intersected_edge_cache</code>: A cache of the edges that have been intersected by the ray from <code>u</code> to <code>v</code>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><p>There are no outputs, but <a href="#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I"><code>add_segment_intersection!</code></a> and <a href="#DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V&lt;:Pair{E, E}}"><code>add_to_intersected_edge_cache!</code></a> are used to update the intersection objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L363-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.process_segment_intersection!" href="#DelaunayTriangulation.process_segment_intersection!"><code>DelaunayTriangulation.process_segment_intersection!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_segment_intersection!(
    vorn::VoronoiTessellation,
    u,
    v,
    e,
    incident_polygon,
    intersected_edge_cache,
    segment_intersections,
    boundary_sites,
    exterior_circumcenters,
    equal_circumcenter_mapping,
    predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Point</code></pre><p>Process the intersection of the Voronoi polygon&#39;s edge <code>(u, v)</code> with the edge <code>e</code> of the boundary, returning the coordinates of the intersection and updating via <a href="#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I"><code>add_segment_intersection!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>u</code>: The index of the site <code>u</code>.</li><li><code>v</code>: The index of the site <code>v</code>.</li><li><code>e</code>: The edge <code>e</code> of the boundary.</li><li><code>incident_polygon</code>: The index of the Voronoi polygon currently being considered.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The coordinates of the intersection. If there is no intersection, this is <code>(NaN, NaN)</code>.</li></ul><p>In addition to the point <code>p</code>, <a href="#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I"><code>add_segment_intersection!</code></a> is also updated to incorporate the new intersection point, as is <a href="#DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V&lt;:Pair{E, E}}"><code>add_to_intersected_edge_cache!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L196-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.single_triangle_clip!-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.single_triangle_clip!-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.single_triangle_clip!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_triangle_clip!(vorn::VoronoiTessellation; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>In the case that <code>vorn</code> is dual to a triangulation with only a single triangle, this function clips the tessellation more efficiently  than the general case with <a href="#DelaunayTriangulation.find_all_intersections-Tuple{VoronoiTessellation}"><code>find_all_intersections</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped.jl#L887-L892">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation._get_ray" href="#DelaunayTriangulation._get_ray"><code>DelaunayTriangulation._get_ray</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_ray(vorn, i, ghost_vertex, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Point, Point)</code></pre><p>Extracts the ray from the <code>i</code>th polygon of <code>vorn</code> corresponding to the <code>ghost_vertex</code>, where <code>ghost_vertex</code> here means that <code>get_polygon(vorn, i)[ghost_vertex]</code> is a ghost vertex.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The index of the polygon.</li><li><code>ghost_vertex</code>: The index of the ghost vertex in the polygon.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The first point of the ray.</li><li><code>q</code>: A second point of the ray, so that <code>pq</code> gives the direction of the ray (which extends to infinity).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L118-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_bounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.clip_bounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.clip_bounded_polygon_to_bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_bounded_polygon_to_bounding_box(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Vector{NTuple{2,Number}}</code></pre><p>Clips the <code>i</code>th polygon of <code>vorn</code> to <code>bounding_box</code>.</p><p>See also <a href="../../api/other/#DelaunayTriangulation.clip_polygon"><code>clip_polygon</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The index of the polygon.</li><li><code>bounding_box</code>: The bounding box to clip the polygon to.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>coords</code>: The coordinates of the clipped polygon. This is a circular vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_unbounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.clip_unbounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.clip_unbounded_polygon_to_bounding_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_unbounded_polygon_to_bounding_box(vorn::VoronoiTessellation, i, bounding_box; predicates::AbsractPredicateType=AdaptiveKernel()) -&gt; Vector{NTuple{2,Number}}</code></pre><p>Clips the <code>i</code>th polygon of <code>vorn</code> to <code>bounding_box</code>. The polygon is assumed to be unbounded. See also <a href="../../api/other/#DelaunayTriangulation.clip_polygon"><code>clip_polygon</code></a>.</p><p>Use the keyword arguments <code>predicates</code> to determine how predicates are computed. Should be one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>. See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_bounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.get_bounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.get_bounded_polygon_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bounded_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Vector{NTuple{2,Number}}</code></pre><p>Returns the coordinates of the <code>i</code>th polygon of <code>vorn</code>, clipped to <code>bounding_box</code>.</p><p>Use the keyword arguments <code>predicates</code> to determine how predicates are computed. Should be one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>. See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_clipping_poly_structs-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.get_clipping_poly_structs-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.get_clipping_poly_structs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_clipping_poly_structs(vorn::VoronoiTessellation, i, bounding_box) -&gt; (Polygon, Polygon)</code></pre><p>Returns the polygons used for clipping the <code>i</code>th polygon of <code>vorn</code> to <code>bounding_box</code>.</p><p>See also <a href="../../api/other/#DelaunayTriangulation.clip_polygon"><code>clip_polygon</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The index of the polygon.</li><li><code>bounding_box</code>: The bounding box to clip the polygon to.</li></ul><p><strong>Outputs</strong></p><ul><li><code>poly</code>: The polygon to clip.</li><li><code>clip_poly</code>: The polygon to clip to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L70-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_new_polygon_indices-Tuple{Any, Any}" href="#DelaunayTriangulation.get_new_polygon_indices-Tuple{Any, Any}"><code>DelaunayTriangulation.get_new_polygon_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_new_polygon_indices(vorn, vertices) -&gt; (Vector{Int}, Vector{NTuple{2,Float64}}, Tuple{Int, Int})</code></pre><p>Returns the new vertices and points of the polygon, as well as the indices of the ghost vertices in the polygon.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>vertices</code>: The vertices of the polygon.</li></ul><p><strong>Outputs</strong></p><ul><li><code>new_vertices</code>: The new vertices of the polygon. This is not a circular vector. The vertices corresponding to a ghost vertex will be given by the ghost vertex itself.</li><li><code>new_points</code>: The new points of the polygon. This is not a circular vector. The points corresponding to a ghost vertex will be given by by <code>(NaN, NaN)</code>.</li><li><code>ghost_vertices</code>: The indices of the ghost vertices in <code>new_vertices</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L264-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_polygon_coordinates" href="#DelaunayTriangulation.get_polygon_coordinates"><code>DelaunayTriangulation.get_polygon_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Vector{NTuple{2,Number}}</code></pre><p>Returns the coordinates of the polygon with index <code>i</code> in <code>vorn</code>. If <code>bounding_box</code> is provided, then the polygon is clipped to the bounding box. If the polygon is unbounded, then <code>bounding_box</code> must be provided.</p><p>See also <a href="#DelaunayTriangulation.get_unbounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}"><code>get_unbounded_polygon_coordinates</code></a> and <a href="#DelaunayTriangulation.get_bounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}"><code>get_bounded_polygon_coordinates</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The index of the polygon.</li><li><code>bounding_box=nothing</code>: The bounding box to clip the polygon to. If <code>nothing</code>, then the polygon is not clipped. If the polygon is unbounded, then <code>bounding_box</code> must be provided.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>coords</code>: The coordinates of the polygon. This is a circular vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_unbounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}" href="#DelaunayTriangulation.get_unbounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}"><code>DelaunayTriangulation.get_unbounded_polygon_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_unbounded_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Vector{NTuple{2,Number}}</code></pre><p>Returns the coordinates of the <code>i</code>th polygon of <code>vorn</code>, clipped to <code>bounding_box</code>. The polygon is assumed to be unbounded.</p><p>Use the keyword arguments <code>predicates</code> to determine how predicates are computed. Should be one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>. See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L325-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.grow_polygon_outside_of_box" href="#DelaunayTriangulation.grow_polygon_outside_of_box"><code>DelaunayTriangulation.grow_polygon_outside_of_box</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grow_polygon_outside_of_box(vorn::VoronoiTessellation, i, bounding_box, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Vector{Int}, Vector{NTuple{2,Number}})</code></pre><p>Truncates the unbounded edges of the <code>i</code>th polygon of <code>vorn</code> so that the line connecting the truncated unbounded edges is entirely outside of <code>bounding_box</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>i</code>: The index of the polygon. The polygon must be unbounded.</li><li><code>bounding_box</code>: The bounding box to clip the polygon to. See also <a href="../../api/voronoi/#DelaunayTriangulation.polygon_bounds"><code>polygon_bounds</code></a>.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>new_vertices</code>: The new vertices of the polygon. This is not a circular vector.</li><li><code>new_points</code>: The new points of the polygon. This is not a circular vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L208-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_first_ghost_vertex-Tuple{Any, Any}" href="#DelaunayTriangulation.is_first_ghost_vertex-Tuple{Any, Any}"><code>DelaunayTriangulation.is_first_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_first_ghost_vertex(cell, i) -&gt; Bool</code></pre><p>Assuming that the circular vector <code>cell</code> is such that ghost vertices only appear next to eachother in <code>cell</code> and there are only two, tests if <code>i</code> is the first ghost vertex in <code>cell</code>.</p><p>See also <a href="#DelaunayTriangulation.is_last_ghost_vertex-Tuple{Any, Any}"><code>is_last_ghost_vertex</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>cell</code>: The circular vector.</li><li><code>i</code>: The index of the vertex in <code>cell</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>flag</code>: <code>true</code> if <code>i</code> is the first ghost vertex in <code>cell</code>, and <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_last_ghost_vertex-Tuple{Any, Any}" href="#DelaunayTriangulation.is_last_ghost_vertex-Tuple{Any, Any}"><code>DelaunayTriangulation.is_last_ghost_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_last_ghost_vertex(cell, i) -&gt; Bool</code></pre><p>Assuming that the circular vector <code>cell</code> is such that ghost vertices only appear next to eachother in <code>cell</code>, tests if <code>i</code> is the last ghost vertex in <code>cell</code>.</p><p>See also <a href="#DelaunayTriangulation.is_first_ghost_vertex-Tuple{Any, Any}"><code>is_first_ghost_vertex</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>cell</code>: The circular vector.</li><li><code>i</code>: The index of the vertex in <code>cell</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>flag</code>: <code>true</code> if <code>i</code> is the last ghost vertex in <code>cell</code>, and <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.maximum_distance_to_box-NTuple{5, Any}" href="#DelaunayTriangulation.maximum_distance_to_box-NTuple{5, Any}"><code>DelaunayTriangulation.maximum_distance_to_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximum_distance_to_box(a, b, c, d, p) -&gt; Number</code></pre><p>Computes the maximum squared distance from the point <code>p</code> to the box with corners <code>(a, c)</code>, <code>(b, c)</code>, <code>(b, d)</code>, <code>(a, d)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The minimum <code>x</code>-coordinate of the box. </li><li><code>b</code>: The maximum <code>x</code>-coordinate of the box.</li><li><code>c</code>: The minimum <code>y</code>-coordinate of the box.</li><li><code>d</code>: The maximum <code>y</code>-coordinate of the box.</li><li><code>p</code>: The point.</li></ul><p><strong>Outputs</strong></p><ul><li><code>dist</code>: The maximum squared distance from <code>p</code> to the box.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/clipped_coordinates.jl#L170-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.liang_barsky-NTuple{6, Any}" href="#DelaunayTriangulation.liang_barsky-NTuple{6, Any}"><code>DelaunayTriangulation.liang_barsky</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">liang_barsky(a, b, c, d, p, q) -&gt; (Point, Point)</code></pre><p>Applies the Liang-Barsky algorithm to find the intersection of the line segment <code>pq</code> with the rectangle  <code>[a, b] × [c, d]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: The first point of the line segment.</li><li><code>q</code>: The second point of the line segment.</li><li><code>a</code>: The minimum x-coordinate of the rectangle.</li><li><code>b</code>: The maximum x-coordinate of the rectangle.</li><li><code>c</code>: The minimum y-coordinate of the rectangle.</li><li><code>d</code>: The maximum y-coordinate of the rectangle.</li></ul><p><strong>Output</strong></p><ul><li><code>u</code>: The first coordinate of the intersection, or <code>(NaN, NaN)</code> if there is no intersection. </li><li><code>v</code>: The second coordinate of the intersection, or <code>(NaN, NaN)</code> if there is no intersection.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/polygon_clipping/liang_barsky.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.clip_polygon-NTuple{4, Any}" href="#DelaunayTriangulation.clip_polygon-NTuple{4, Any}"><code>DelaunayTriangulation.clip_polygon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clip_polygon(vertices, points, clip_vertices, clip_points; predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Vector</code></pre><p>Clip a polygon defined by <code>(vertices, points)</code> to a convex clip polygon defined by <code>(clip_vertices, clip_points)</code> with the Sutherland-Hodgman algorithm. The polygons should be defined in counter-clockwise order.</p><p><strong>Arguments</strong></p><ul><li><code>vertices</code>: The vertices of the polygon to be clipped.</li><li><code>points</code>: The underlying point set that the vertices are defined over. </li><li><code>clip_vertices</code>: The vertices of the clipping polygon.</li><li><code>clip_points</code>: The underlying point set that the clipping vertices are defined over.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><ul><li><code>clipped_polygon</code>: The coordinates of the clipped polygon, given in counter-clockwise order and <code>clipped_polygon[begin] == clipped_polygon[end]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/polygon_clipping/sutherland_hodgman.jl#L1-L18">source</a></section></article><h2 id="Centroidal-Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Centroidal-Voronoi-Tessellations">Centroidal Voronoi Tessellations</a><a id="Centroidal-Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Centroidal-Voronoi-Tessellations" title="Permalink"></a></h2><p>Here are some functions related to the computation of centroidal Voronoi tessellations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation._centroidal_smooth_itr" href="#DelaunayTriangulation._centroidal_smooth_itr"><code>DelaunayTriangulation._centroidal_smooth_itr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_centroidal_smooth_itr(vorn::VoronoiTessellation, points, rng, predicates::AbstractPredicateKernel=AdaptiveKernel(); kwargs...) -&gt; (VoronoiTessellation, Number)</code></pre><p>Performs a single iteration of the centroidal smoothing algorithm. </p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>points</code>: The underlying point set. This is a <code>deepcopy</code> of the points of the underlying triangulation.</li><li><code>rng</code>: The random number generator.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>clip_polygon=nothing</code>: If <code>clip=true</code>, then this is the polygon to clip the Voronoi tessellation to. If <code>nothing</code>, the convex hull of the triangulation is used. The polygon should be defined as a <code>Tuple</code> of the form <code>(points, boundary_nodes)</code> where the <code>boundary_nodes</code> are vertices mapping to coordinates in <code>points</code>, adhering to the usual conventions for defining boundaries.</li><li><code>kwargs...</code>: Extra keyword arguments passed to <a href="../../api/triangulation/#DelaunayTriangulation.retriangulate"><code>retriangulate</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>vorn</code>: The updated <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>max_dist</code>: The maximum distance moved by any generator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/centroidal.jl#L42-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.centroidal_smooth-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.centroidal_smooth-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.centroidal_smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centroidal_smooth(vorn::VoronoiTessellation; maxiters=1000, tol=default_displacement_tolerance(vorn), rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -&gt; VoronoiTessellation</code></pre><p>Smooths <code>vorn</code> into a centroidal tessellation so that the new tessellation is of a set of generators whose associated Voronoi polygon is that polygon&#39;s centroid.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>maxiters=1000</code>: The maximum number of iterations.</li><li><code>clip_polygon=nothing</code>: If <code>clip=true</code>, then this is the polygon to clip the Voronoi tessellation to. If <code>nothing</code>, the convex hull of the triangulation is used. The polygon should be defined as a <code>Tuple</code> of the form <code>(points, boundary_nodes)</code> where the <code>boundary_nodes</code> are vertices mapping to coordinates in <code>points</code>, adhering to the usual conventions for defining boundaries. Must be a convex polygon. </li><li><code>tol=default_displacement_tolerance(vorn)</code>: The displacement tolerance. See <a href="#DelaunayTriangulation.default_displacement_tolerance-Tuple{VoronoiTessellation}"><code>default_displacement_tolerance</code></a> for the default. </li><li><code>rng=Random.default_rng()</code>: The random number generator.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>kwargs...</code>: Extra keyword arguments passed to <a href="../../api/triangulation/#DelaunayTriangulation.retriangulate"><code>retriangulate</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>vorn</code>: The updated <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>. This is not done in-place.</li></ul><p><strong>Extended help</strong></p><p>The algorithm is simple. We iteratively smooth the generators, moving them to the centroid of their associated Voronoi polygon for the current tessellation,  continuing until the maximum distance moved of any generator is less than <code>tol</code>. Boundary generators are not moved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/centroidal.jl#L77-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.default_displacement_tolerance-Tuple{VoronoiTessellation}" href="#DelaunayTriangulation.default_displacement_tolerance-Tuple{VoronoiTessellation}"><code>DelaunayTriangulation.default_displacement_tolerance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_displacement_tolerance(vorn::VoronoiTessellation) -&gt; Number</code></pre><p>Returns the default displacement tolerance for the centroidal smoothing algorithm. The default is given by  <code>max_extent / 1e4</code>, where <code>max_extent = max(width, height)</code>, where <code>width</code> and <code>height</code> are the width and height  of the bounding box of the underlying point set.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>tol</code>: The default displacement tolerance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/centroidal.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.move_generator_to_centroid!-Tuple{Any, VoronoiTessellation, Any}" href="#DelaunayTriangulation.move_generator_to_centroid!-Tuple{Any, VoronoiTessellation, Any}"><code>DelaunayTriangulation.move_generator_to_centroid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">move_generator_to_centroid!(points, vorn::VoronoiTessellation, generator) -&gt; Number</code></pre><p>Moves the generator <code>generator</code> to the centroid of its Voronoi cell. Returns the distance moved.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The underlying point set. This is a <code>deepcopy</code> of the points of the underlying triangulation. </li><li><code>vorn</code>: The <a href="../data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>generator</code>: The generator to move.</li></ul><p><strong>Outputs</strong></p><ul><li><code>dist</code>: The distance moved.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/voronoi/centroidal.jl#L1-L13">source</a></section></article><h2 id="Triangulating-Curve-Bounded-Domains"><a class="docs-heading-anchor" href="#Triangulating-Curve-Bounded-Domains">Triangulating Curve-Bounded Domains</a><a id="Triangulating-Curve-Bounded-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulating-Curve-Bounded-Domains" title="Permalink"></a></h2><p>We have several functions related to the triangulation of curve-bounded domains.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.coarse_discretisation!-Union{Tuple{I}, Tuple{Any, Any, Any}} where I" href="#DelaunayTriangulation.coarse_discretisation!-Union{Tuple{I}, Tuple{Any, Any, Any}} where I"><code>DelaunayTriangulation.coarse_discretisation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coarse_discretisation!(points, boundary_nodes, boundary_curve; n=0)</code></pre><p>Constructs an initial coarse discretisation of a curve-bounded domain with bonudary defines by  <code>(points, boundary_nodes, boundary_curves)</code>, where <code>boundary_nodes</code> and <code>boundary_curves</code> should  come from <a href="#DelaunayTriangulation.convert_boundary_curves!-Union{Tuple{I}, Tuple{Any, Any, Type{I}}} where I&lt;:Integer"><code>convert_boundary_curves!</code></a>. The argument <code>n</code> is the amount of times to split an edge. If non-zero, this should be a power of two (otherwise it will be rounded up to the next power of two). If it is  zero, then the splitting will continue until the maximum total variation over any subcurve is less than π/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L111-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_split_position" href="#DelaunayTriangulation.compute_split_position"><code>DelaunayTriangulation.compute_split_position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_split_position(enricher::BoundaryEnricher, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; (Float64, Float64, NTuple{2,Float64})</code></pre><p>Gets the point to split the edge <code>(i, j)</code> at.</p><p><strong>Arguments</strong></p><ul><li><code>enricher::BoundaryEnricher</code>: The enricher.</li><li><code>i</code>: The first point of the edge.</li><li><code>j</code>: The second point of the edge.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>t</code>: The parameter value of the split point.</li><li><code>Δθ</code>: The total variation of the subcurve <code>(i, t)</code>. If a split was created due to a small angle, this will be set to zero.</li><li><code>ct</code>: The point to split the edge at.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L295-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}" href="#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}"><code>DelaunayTriangulation.enrich_boundary!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enrich_boundary!(enricher::BoundaryEnricher; predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Enriches the initial boundary defined inside <code>enricher</code>, implementing the algorithm of Gosselin and Ollivier-Gooch (2007). At the termination of the algorithm, all edges will contain no other points inside their  diametral circles.</p><p>The <code>predicates</code> argument determines how predicates are computed, and should be  one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_acute_neighbouring_angles-Union{Tuple{I}, Tuple{C}, Tuple{B}, Tuple{P}, Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher{P, B, C, I}, Any, Any}} where {P, B, C, I}" href="#DelaunayTriangulation.has_acute_neighbouring_angles-Union{Tuple{I}, Tuple{C}, Tuple{B}, Tuple{P}, Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher{P, B, C, I}, Any, Any}} where {P, B, C, I}"><code>DelaunayTriangulation.has_acute_neighbouring_angles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_acute_neighbouring_angles(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j) -&gt; Int, Vertex</code></pre><p>Given a boundary edge <code>(i, j)</code>, tests if the neighbouring angles are acute. The first returned value  is the number of angles adjoining <code>(i, j)</code> that are acute (0, 1, or 2). The second returned value is the vertex that adjoins the edge <code>(i, j)</code> that is acute. If there are no such angles, or if there are two, then this  returned vertex is <code>0</code>.</p><p>(The purpose of this function is similar to <a href="#DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle"><code>segment_vertices_adjoin_other_segments_at_acute_angle</code></a>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L419-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.split_subcurve!" href="#DelaunayTriangulation.split_subcurve!"><code>DelaunayTriangulation.split_subcurve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_subcurve!(enricher::BoundaryEnricher, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -&gt; Bool</code></pre><p>Splits the curve associated with the edge <code>(i, j)</code> into two subcurves by inserting a point <code>r</code> between <code>(i, j)</code> such that the  total variation of the subcurve is equal on <code>(i, r)</code> and <code>(r, j)</code>. The returned value is a <code>flag</code> that is <code>true</code>  if there was a precision issue, and <code>false</code> otherwise.</p><p>The <code>predicate</code> argument determines how predicates are computed, and should be  one of <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L235-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.test_visibility-Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}" href="#DelaunayTriangulation.test_visibility-Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}"><code>DelaunayTriangulation.test_visibility</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_visibility(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j, k) -&gt; Certificate</code></pre><p>Tests if the vertex <code>k</code> is visible from the edge <code>(i, j)</code>. Returns a <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is</p><ul><li><code>Invisible</code>: If <code>k</code> is not visible from <code>(i, j)</code>.</li><li><code>Visible</code>: If <code>k</code> is visible from <code>(i, j)</code>.  </li></ul><p>For this function, <code>k</code> should be inside the diametral circle of <code>(i, j)</code>.</p><p>We say that <code>k</code> is invisibile from <code>(i, j)</code> if the edges <code>(i, k)</code> or <code>(j, k)</code> intersect any other  boundary edges, or there is a hole between <code>(i, j)</code> and <code>k</code>.</p><div class="admonition is-danger"><header class="admonition-header">Definition incompatibility</header><div class="admonition-body"><p>This is not the same definition used in defining constrained Delaunay triangulations,  where visibility means visible from ANY point on the edge instead of only from the endpoints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L450-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_curve_bounded-Union{Tuple{Es}, Tuple{E}, Tuple{I}, Tuple{P}} where {P, I, E, Es}" href="#DelaunayTriangulation.triangulate_curve_bounded-Union{Tuple{Es}, Tuple{E}, Tuple{I}, Tuple{P}} where {P, I, E, Es}"><code>DelaunayTriangulation.triangulate_curve_bounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_curve_bounded(points::P;
segments=nothing,
boundary_nodes=nothing,
predicates::AbstractPredicateKernel=AdaptiveKernel(),
IntegerType::Type{I}=Int,
polygonise_n=4096,
coarse_n=0,
check_arguments=true,
delete_ghosts=false,
delete_empty_features=true,
recompute_representative_points=true,
rng::Random.AbstractRNG=Random.default_rng(),
insertion_order=nothing, 
kwargs...) where {P,I} -&gt; Triangulation</code></pre><p>Triangulates a curve-bounded domain defined by <code>(points, segments, boundary_nodes)</code>. Please see <a href="../../api/triangulation/#DelaunayTriangulation.triangulate"><code>triangulate</code></a> for a description of the arguments. The only differences are:</p><ul><li><code>insertion_order=nothing</code>: This argument is ignored for curve-bounded domains.</li><li><code>polygonise_n=4096</code>: For generating a high-resolution discretisation of a boundary initially for   the construction of a <a href="../data_structures/#PolygonHierarchy"><code>PolygonHierarchy</code></a>, many points are needed. This number of points is defined   by <code>polygonise_n</code>, and must be a power of 2 (otherwise, the next highest power of 2 is used). See <a href="../data_structures/#DelaunayTriangulation.polygonise-Tuple{Any, Any, Any}"><code>polygonise</code></a>.</li><li><code>coarse_n=0</code>: This is the number of points to use for initialising a curve-bounded domain via <a href="#DelaunayTriangulation.coarse_discretisation!-Union{Tuple{I}, Tuple{Any, Any, Any}} where I"><code>coarse_discretisation!</code></a>.  The default <code>coarse_n=0</code> means the discretisation is performed until the maximum variation over any subcurve is   less than <code>π/2</code>.</li><li><code>skip_points</code>: This is still used, but it is ignored during the enrichment phase (see <a href="#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}"><code>enrich_boundary!</code></a>).</li></ul><p>See also <a href="../data_structures/#BoundaryEnricher"><code>BoundaryEnricher</code></a> and <a href="#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}"><code>enrich_boundary!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Refinement</header><div class="admonition-body"><p>To refine the mesh further beyond its initial coarse discretisation, as produced from this function,  please see <a href="../../api/triangulation/#DelaunayTriangulation.refine!"><code>refine!</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.convert_boundary_curves!-Union{Tuple{I}, Tuple{Any, Any, Type{I}}} where I&lt;:Integer" href="#DelaunayTriangulation.convert_boundary_curves!-Union{Tuple{I}, Tuple{Any, Any, Type{I}}} where I&lt;:Integer"><code>DelaunayTriangulation.convert_boundary_curves!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_boundary_curves!(points, boundary_nodes, IntegerType) -&gt; (NTuple{N, AbstractParametricCurve} where N, Vector)</code></pre><p>Converts the provided <code>points</code> and <code>boundary_nodes</code> into a set of boundary curves and modified boundary nodes suitable for  triangulation. In particular:</p><ol><li>The function gets <code>boundary_curves</code> from <a href="#DelaunayTriangulation.to_boundary_curves-Tuple{Any, Any}"><code>to_boundary_curves</code></a>.</li><li><code>boundary_nodes</code> is replaced with a set of initial boundary nodes (from <a href="../data_structures/#DelaunayTriangulation.get_skeleton-Union{Tuple{I}, Tuple{Any, Type{I}}} where I"><code>get_skeleton</code></a>). These nodes come from evaluating each boundary curve at <code>t = 0</code> and <code>t = 1</code>. In the case of a piecewise linear boundary, the vertices are copied directly. Note that not all control points of a <a href="../../math/curves/#CatmullRomSpline"><code>CatmullRomSpline</code></a> (which <a href="../data_structures/#DelaunayTriangulation.is_interpolating-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>is_interpolating</code></a>) will be added - only those at <code>t = 0</code> and <code>t = 1</code>.</li><li>The <code>points</code> are modified to include the new boundary nodes. If a point is already in <code>points</code>, it is not added again.  </li></ol><p><strong>Arguments</strong></p><ul><li><code>points</code>: The point set. This is modified in place with the new boundary points.</li><li><code>boundary_nodes</code>: The boundary nodes to be converted. This is not modified in place.</li><li><code>IntegerType</code>: The type of integer to use for the boundary nodes.</li></ul><p><strong>Output</strong></p><ul><li><code>boundary_curves</code>: The boundary curves associated with <code>boundary_nodes</code>.</li><li><code>boundary_nodes</code>: The modified boundary nodes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_curves.jl#L73-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_curve_bounded" href="#DelaunayTriangulation.is_curve_bounded"><code>DelaunayTriangulation.is_curve_bounded</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_curve_bounded(tri::Triangulation) -&gt; Bool 
is_curve_bounded(boundary_nodes) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> is curve bounded, and <code>false</code> otherwise; similarly for the  <code>boundary_nodes</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_curves.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.to_boundary_curves-Tuple{Any, Any}" href="#DelaunayTriangulation.to_boundary_curves-Tuple{Any, Any}"><code>DelaunayTriangulation.to_boundary_curves</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_boundary_curves(points, boundary_nodes) -&gt; NTuple{N, AbstractParametricCurve} where N</code></pre><p>Returns the set of boundary curves associated with <code>boundary_nodes</code> and <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/data_structures/triangulation/methods/boundary_curves.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_visible" href="#DelaunayTriangulation.is_visible"><code>DelaunayTriangulation.is_visible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_visible(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Visible</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_invisible" href="#DelaunayTriangulation.is_invisible"><code>DelaunayTriangulation.is_invisible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_invisible(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Invisible</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.test_visibility" href="#DelaunayTriangulation.test_visibility"><code>DelaunayTriangulation.test_visibility</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_visibility([kernel::AbstractPredicateKernel = AdaptiveKernel(),] tri::Triangulation, q, i) -&gt; Certificate</code></pre><p>Tests if the vertex <code>i</code> and the point <code>q</code> can see each other. Here, visibility means that the line segment joining  the two does not intersect any segments.</p><p><strong>Arguments</strong></p><ul><li><code>kernel::AbstractPredicateKernel = AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a> (the default), and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The point from which we are testing visibility.</li><li><code>i</code>: The vertex we are testing visibility of.</li></ul><p><strong>Outputs</strong></p><ul><li><code>cert</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a>. This will be <code>Visible</code> if <code>i</code> is visible from <code>q</code>, and <code>Invisible</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/predicates.jl#L785-L799">source</a></section><section><div><pre><code class="language-julia hljs">test_visibility([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, i; shift=0.0, attractor=get_point(tri,i)) -&gt; Certificate</code></pre><p>Tests if the edge <code>(u, v)</code> and the point <code>i</code> can see each other. Here, visibility means that any point in the interior  of <code>(u, v)</code> can see <code>i</code>. To test this, we only check <code>10</code> points equally spaced between <code>u</code> and <code>v</code>, excluding <code>u</code> and <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>kernel::AbstractPredicateKernel=AdaptiveKernel()</code>: How predicates are computed. See the documentation for information on the choices between <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>.</li><li><code>tri</code>: The <a href="../data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>u</code>: The first vertex of the edge.</li><li><code>v</code>: The second vertex of the edge.</li><li><code>i</code>: The vertex we are testing visibility of.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shift=0.0</code>: The amount by which to shift each point on the edge towards <code>attractor</code>, i.e. if <code>p</code> is a point on the edge, then <code>p .+ shift .* (attractor - p)</code> is the point used to test visibility rather than <code>p</code> itself.</li><li><code>attractor=get_point(tri,i)</code>: Related to <code>shift</code>; see above. </li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../../api/predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../../api/predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../../api/predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>cert</code>: A <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a>. This will be <code>Visible</code> if <code>i</code> is visible from <code>(u, v)</code>, and <code>Invisible</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/predicates/predicates.jl#L810-L830">source</a></section><section><div><pre><code class="language-julia hljs">test_visibility(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j, k) -&gt; Certificate</code></pre><p>Tests if the vertex <code>k</code> is visible from the edge <code>(i, j)</code>. Returns a <a href="../../api/predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is</p><ul><li><code>Invisible</code>: If <code>k</code> is not visible from <code>(i, j)</code>.</li><li><code>Visible</code>: If <code>k</code> is visible from <code>(i, j)</code>.  </li></ul><p>For this function, <code>k</code> should be inside the diametral circle of <code>(i, j)</code>.</p><p>We say that <code>k</code> is invisibile from <code>(i, j)</code> if the edges <code>(i, k)</code> or <code>(j, k)</code> intersect any other  boundary edges, or there is a hole between <code>(i, j)</code> and <code>k</code>.</p><div class="admonition is-danger"><header class="admonition-header">Definition incompatibility</header><div class="admonition-body"><p>This is not the same definition used in defining constrained Delaunay triangulations,  where visibility means visible from ANY point on the edge instead of only from the endpoints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/7f719934bf209672245f855397479b9aa423743e/src/algorithms/triangulation/triangulate_curve_bounded.jl#L450-L467">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structures/">« Data Structures</a><a class="docs-footer-nextpage" href="../utils/">Utility Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 28 September 2024 07:50">Saturday 28 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
