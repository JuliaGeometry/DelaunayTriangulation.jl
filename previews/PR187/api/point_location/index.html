<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Point Location · DelaunayTriangulation.jl</title><meta name="title" content="Point Location · DelaunayTriangulation.jl"/><meta property="og:title" content="Point Location · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Point Location · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/point_location/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/point_location/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/point_location/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../triangulation/">Triangulations</a></li><li><a class="tocitem" href="../operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li><li class="is-active"><a class="tocitem" href>Point Location</a></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li><a class="tocitem" href="../statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Point Location</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Point Location</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/api/point_location.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Point-Location"><a class="docs-heading-anchor" href="#Point-Location">Point Location</a><a id="Point-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Location" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search" href="#DelaunayTriangulation.brute_force_search"><code>DelaunayTriangulation.brute_force_search</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">brute_force_search(tri::Triangulation, q; itr = each_triangle(tri), predicates::AbstractPredicateKernel=AdaptiveKernel())</code></pre><p>Searches for the triangle containing the point <code>q</code> by brute force. An exception will be  raised if no triangle contains the point.</p><p>See also <a href="#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The point to be located.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>itr = each_triangle(tri)</code>: The iterator over the triangles of the triangulation.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle containing the point <code>q</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/d14f2557fae337f666e0e14d1a523b07b7f6f68b/src/algorithms/point_location/brute_force.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_triangle" href="#DelaunayTriangulation.find_triangle"><code>DelaunayTriangulation.find_triangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_triangle(tri, q; kwargs...) -&gt; Triangle[, Bool]</code></pre><p>Find the triangle in the triangulation <code>tri</code> containing the query point <code>q</code> using the jump-and-march algorithm.</p><div class="admonition is-danger"><header class="admonition-header">Ghost triangles</header><div class="admonition-body"><p>For this function to work best, the triangulation should have ghost triangles, which you can add using <code>add_ghost_triangles!</code> in case <code>tri</code> does not already have them.  Without ghost triangles, the function may not be able to find the correct triangle containing <code>q</code>.</p></div></div><p>For the variables defined below, you may want to refer to the extended help which also gives  some warnings and notes.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>predicates::AbstractPredicateKernel=ExactKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>point_indices=each_solid_vertex(tri)</code>: The indices of the vertices to consider as possible starting points for the algorithm.</li><li><code>m=default_num_samples(num_vertices(point_indices))</code>: The number of samples to use when selecting the initial point.</li><li><code>try_points=()</code>: A list of points to try as the initial point in addition to the <code>m</code> sampled.</li><li><code>rng=Random.default_rng()</code>: The random number generator to use.</li><li><code>k=select_initial_point(tri, q; point_indices, m, try_points, rng)</code>: The initial point to start the algorithm from. See <a href="../../extended/algorithms/#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the algorithm.</li><li><code>history=nothing</code>: The history of the algorithm. If <code>store_history</code>, then this should be a <a href="../../extended/data_structures/#PointLocationHistory"><code>PointLocationHistory</code></a> object.</li><li><code>maxiters=2 + num_exterior_curves(tri) - num_solid_vertices(tri) + num_solid_edges(tri)</code>: The maximum number of iterations to perform before restarting the algorithm with <a href="../../extended/algorithms/#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}"><code>restart_find_triangle</code></a>.</li><li><code>concavity_protection=false</code>: Whether to use concavity protection. See <a href="../../extended/algorithms/#DelaunayTriangulation.concavity_protection_check"><code>concavity_protection_check</code></a>. This is only needed if your triangulation is not convex. </li><li><code>use_barriers::Val{U}=Val(false)</code>: Whether to stop searching beyond any segments in the triangulation. </li></ul><p><strong>Output</strong></p><ul><li><code>V</code>: The triangle containing <code>q</code>, with type given by <code>triangle_type(tri)</code>.</li></ul><p>If you have <code>use_barriers == Val(true)</code>, then we also return </p><ul><li><code>invisible_flag</code>: <code>false</code> if the triangle was found without hitting a barrier, and <code>true</code> otherwise.</li></ul><p><strong>Extended help</strong></p><p>The algorithm underlying this function is complicated and broken into many parts. Here, we describe a brief overview of the algorithm, but note that the      documentation contains a much more detailed description.</p><ol><li>Firstly, the algorithm is initialised depending on whether <code>k</code> is a boundary or an interior vertex, using    <a href="../../extended/algorithms/#DelaunayTriangulation.initialise_find_triangle_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any, Any}} where F"><code>initialise_find_triangle_boundary_vertex</code></a> or <a href="../../extended/algorithms/#DelaunayTriangulation.initialise_find_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F"><code>initialise_find_triangle_interior_vertex</code></a> respectively.</li><li>From the initial triangle <code>(i, j, k)</code> chosen, we then check if <code>q</code> is one of <code>pᵢ</code>, <code>pⱼ</code>, and <code>p = pₖ</code> and then return according to <a href="../../extended/algorithms/#DelaunayTriangulation.find_triangle_return_on_vertex-Tuple{Triangulation, Vararg{Any, 8}}"><code>find_triangle_return_on_vertex</code></a> if needed.</li><li>If we do not return above, we need to step from the initial triangle towards <code>q</code>. Since we put <code>pᵢ</code> and <code>pⱼ</code>   to the left and right of the line <code>pq</code>, respectively, this means that we step until the triangle <code>pᵢpⱼq</code> is no longer    positively oriented. So, while the triangle is positively oriented, we step according to <a href="../../extended/algorithms/#DelaunayTriangulation.find_triangle_across_triangle-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 12}}} where F"><code>find_triangle_across_triangle</code></a>.</li><li>If we have not yet returned and the triangle is no longer positively oriented, we check if the triangle is degenerate using <a href="../../extended/algorithms/#DelaunayTriangulation.find_triangle_degenerate_arrangement-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 5}}} where F"><code>find_triangle_degenerate_arrangement</code></a>   and reinitialise the algorithm if needed. Otherwise, we have found the triangle containing <code>q</code> and return the triangle.</li></ol><p>Here are some additional warnings and notes for the variables defined in this function.</p><div class="admonition is-info"><header class="admonition-header">Restarting the algorithm</header><div class="admonition-body"><p>If the algorithm restarts, then the initial point <code>k</code> is selected again using <a href="../../extended/algorithms/#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>, and the algorithm is restarted from there.  This is done if the algorithm gets stuck in a loop, or if the algorithm is not able to find the correct triangle containing <code>q</code> after <code>maxiters</code> iterations. For a convex  geometry, <code>maxiters</code> can be safely ignored, as the sequence of triangles visited is acyclic [see H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251-260.)].</p></div></div><div class="admonition is-warning"><header class="admonition-header">Found triangles with barriers</header><div class="admonition-body"><p>If you are using barriers, it will be your responsibility to verify that any found triangle from this function actually  contains the triangle. This can be verified using the returned <code>flag</code> (see below), although the point might still be on the triangle&#39;s  boundary.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Walking past vertices of barriers</header><div class="admonition-body"><p>If you are using barriers, it is possible that the algorithm can walk past vertices of barriers. One way this can happen is if  the initial search line intersects a vertex, in which case the segment might not be considered. Another way this can happen is if you  start the algorithm directly on a segment vertex, in which case the algorithm can go past it (e.g. this means that it is possible that a  ghost triangle might still be returned if you start the algorithm on a boundary node).</p></div></div><p>Some notes about the output:</p><div class="admonition is-danger"><header class="admonition-header">Hitting barriers</header><div class="admonition-body"><p>If a barrier is hit before any initial triangle is properly identified, the returned triangle is  <code>(0, 0, 0)</code>; this is only possible if <code>use_barriers == Val(true)</code>. Moreover, if <code>use_barriers == Val(true)</code>,  the final triangle may not even be valid if <code>invisible_flag == true</code> (defined below).</p></div></div><div class="admonition is-warning"><header class="admonition-header">Non-convex geometries</header><div class="admonition-body"><p>While this function does still work for non-convex geometries, it may be significantly slower than for convex geometries, as most of the details  of the algorithm assume that the geometry is convex, and so the algorithm may have to restart many times at new initial vertices <code>k</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/d14f2557fae337f666e0e14d1a523b07b7f6f68b/src/algorithms/point_location/jump_and_march.jl#L669-L752">source</a></section><section><div><pre><code class="language-julia hljs">find_triangle(tri::SphericalTriangulation, q::SphericalPoint; check_sphere=true, kwargs...)</code></pre><p>Finds the spherical triangle in <code>tri</code> that contains the point <code>q</code>. The keyword arguments are the same as those for  the usual [<code>find_triangle</code>], except that <code>check_sphere</code> can be used to check if the found triangle actually contains <code>q</code>  (since the check is done in the stereographic projection). If it&#39;s not, it will be found by searching the triangles near the found  triangle or using an exhaustive search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/d14f2557fae337f666e0e14d1a523b07b7f6f68b/src/spherical/triangulation.jl#L133-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_nearest_neighbour" href="#DelaunayTriangulation.get_nearest_neighbour"><code>DelaunayTriangulation.get_nearest_neighbour</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nearest_neighbour(tri_or_vor, q; kwargs...)</code></pre><p>Get the index of the nearest neighbour of <code>q</code> in <code>tri_or_vor</code>. </p><p>For power diagrams, distance is measured using <a href="../../extended/algorithms/#DelaunayTriangulation.get_power_distance-Tuple{Triangulation, Any, Any}"><code>get_power_distance</code></a> (with <code>q</code> being assigned zero weight).</p><p><strong>Arguments</strong></p><ul><li><code>tri_or_vor</code>: A <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> or <a href="../../extended/data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li><li><code>q</code>: The point to be located.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs...</code>: Keyword arguments passed to <a href="#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</li></ul><p><strong>Output</strong></p><ul><li><code>i</code>: The index of the nearest neighbour. This is a point of the triangulation if <code>tri_or_vor</code> is a <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> or of a generator if <code>tri_or_vor</code> is a <a href="../../extended/data_structures/#VoronoiTessellation"><code>VoronoiTessellation</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/d14f2557fae337f666e0e14d1a523b07b7f6f68b/src/algorithms/point_location/nearest_neighbour.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_polygon" href="#DelaunayTriangulation.find_polygon"><code>DelaunayTriangulation.find_polygon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_polygon(tri::Triangulation, q) -&gt; Integer</code></pre><p>Given a point <code>q</code>, finds the index of the polygon in the triangulation <code>tri</code> that contains <code>q</code>. If  <code>q</code> is on the boundary of the triangulation or outside the triangulation, the function returns <code>0</code>.</p><p>See also <a href="../triangulation/#DelaunayTriangulation.dist"><code>dist</code></a> and <a href="../other/#DelaunayTriangulation.distance_to_polygon"><code>distance_to_polygon</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/d14f2557fae337f666e0e14d1a523b07b7f6f68b/src/algorithms/point_location/find_polygon.jl#L1-L8">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iterators/">« Iterators</a><a class="docs-footer-nextpage" href="../predicates/">Predicates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 30 October 2024 18:49">Wednesday 30 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
