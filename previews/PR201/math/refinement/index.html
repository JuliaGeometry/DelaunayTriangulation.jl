<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh Refinement · DelaunayTriangulation.jl</title><meta name="title" content="Mesh Refinement · DelaunayTriangulation.jl"/><meta property="og:title" content="Mesh Refinement · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Mesh Refinement · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/refinement/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/refinement/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/refinement/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li class="is-active"><a class="tocitem" href>Mesh Refinement</a><ul class="internal"><li><a class="tocitem" href="#Triangle-Quality"><span>Triangle Quality</span></a></li><li><a class="tocitem" href="#Edge-Encroachment"><span>Edge Encroachment</span></a></li><li><a class="tocitem" href="#Deleting-Free-Vertices"><span>Deleting Free Vertices</span></a></li><li><a class="tocitem" href="#Splitting-a-Triangle"><span>Splitting a Triangle</span></a></li><li><a class="tocitem" href="#Small-Angles"><span>Small Angles</span></a></li><li><a class="tocitem" href="#The-Complete-Algorithm"><span>The Complete Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Mesh Refinement</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mesh Refinement</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/refinement.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mesh-Refinement"><a class="docs-heading-anchor" href="#Mesh-Refinement">Mesh Refinement</a><a id="Mesh-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-Refinement" title="Permalink"></a></h1><p>Now we describe how we refine meshes. We do not discuss curve-bounded domains here, leaving this discussion to the <a href="../curve_bounded/">curve-bounded section</a>. The mesh refinement algorithm we implement is Ruppert&#39;s Delaunay refinement algorithm with some modifications from Shewchuk, following the presentation in Chapter 6 of the book <a href="https://people.eecs.berkeley.edu/~jrs/meshbook.html"><em>Delaunay Mesh Generation</em> by Cheng, Dey, and Shewchuk (2013)</a>. </p><p>To introduce the mesh refinement algorithm, we need to discuss a few preliminaries. We let <span>$\mathcal M$</span> denote a mesh <span>$\mathcal D\mathcal T(\mathcal P, \mathcal S, \mathcal B)$</span>, where <span>$\mathcal P$</span> is the point set, <span>$\mathcal S$</span> is the segment set, and <span>$\mathcal B$</span> is the boundary.</p><h2 id="Triangle-Quality"><a class="docs-heading-anchor" href="#Triangle-Quality">Triangle Quality</a><a id="Triangle-Quality-1"></a><a class="docs-heading-anchor-permalink" href="#Triangle-Quality" title="Permalink"></a></h2><p>We need a way to measure the &quot;quality&quot; of a triangle in order to know what triangles need refinement. The quality of a triangle is typically measured using the <em>radius-edge ratio</em>, which is the ratio of the radius of the triangle&#39;s circumference to its minimmu edge length. Symbolically, <span>$\rho = R/\ell_{min}$</span>, where <span>$R$</span> is the triangle&#39;s circumradius, <span>$\ell_{\min}$</span> its minimum edge length, and <span>$\rho$</span> is the radius-edge ratio. The lower the radius-edge ratio, the better we say the triangle&#39;s quality is. We can also view reducing <span>$\rho$</span> as increasing the minimum angle, <span>$\theta_{\min}$</span>, since <span>$\rho$</span> is related to <span>$\theta_{\min}$</span> by </p><p class="math-container">\[\rho = \frac{R}{\ell_{\min}} = \frac{1}{2\sin\theta_{\min}}.\]</p><p>We say that a triangle is of bad quality if <span>$\rho &gt; \bar\rho$</span> for some <span>$\bar\rho &gt; 0$</span> or, equivalently, <span>$\theta_{\min} &lt; \bar\theta$</span>. Typically, <span>$\bar\theta \approx 33.9^{\circ}$</span> is about the limit of convergence for the algorithm. In addition to controlling <span>$\rho$</span>, we can also control the area <span>$A$</span> of the triangle, saying a triangle is too large if <span>$A &gt; A_{\max}$</span> and too small if <span>$A &lt; A_{\min}$</span>. </p><p>Thus, given a triangle <span>$T$</span> and constants <span>$\bar\rho$</span>, <span>$A_{\min}$</span>, and <span>$A_{\max}$</span>, we say that <span>$T$</span> is of bad quality if any of the following are true: (1) <span>$\rho &gt; \bar \rho$</span> or (2) <span>$A &gt; A_{\max}$</span>. For <span>$A_{\min}$</span>, we of course can&#39;t split <span>$T$</span> in order to increase its area. Instead, the <span>$A_{\min}$</span> threshold will be used to stop the splitting of any bad quality triangle if its area would be reduced to below <span>$A_{\min}$</span>, and any triangle whose area is already below <span>$A_{\min}$</span> will never be refined further.</p><h2 id="Edge-Encroachment"><a class="docs-heading-anchor" href="#Edge-Encroachment">Edge Encroachment</a><a id="Edge-Encroachment-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Encroachment" title="Permalink"></a></h2><p>Mesh refinement algorithms typically refine bad quality triangles by inserting their circumcenter into the triangulation (there are other variants, but we will not discuss them here). There is one problem with this approach: the circumcenter of a triangle might lie outside of <span>$\mathcal M$</span>, and so we would never be able to insert it. To get around this, we introduce the concept of <em>edge encroachment</em>. We say that a vertex <span>$v$</span> <em>encroaches upon</em> a segment <span>$e$</span> if it is inside the closed diametral circle of <span>$e$</span> but is not a vertex of <span>$e$</span>, and <span>$v$</span> is visible from <span>$e$</span>.</p><p>Checking for encroachment is relatively straightforward: The only vertices that might encroach upon a segment <span>$e$</span> are those adjacent to it. In particular, let the segment be <span>$e = e_{uv}$</span> and find the triangles <span>$T_{uvw}$</span> and <span>$T_{uvx}$</span> adjacent to <span>$e$</span>. If either <span>$p_w$</span> or <span>$p_x$</span> are in the diametral circle of <span>$e_{uv}$</span>, then <span>$e$</span> is encroached. Checking whether a point is inside a diametral circle is also simple: By Thales&#39; theorem, the angle <span>$\angle p_upp_v$</span> is a right angle when <span>$p$</span> is on the diametral circle, so <span>$p$</span> is inside the diametral circle if and only if <span>$\angle p_upp_v \leq 90^{\circ}$</span>. To efficiently check if <span>$\theta = \angle p_upp_v \leq 90^{\circ}$</span>, we can use a dot product. Since </p><p class="math-container">\[\cos \theta = \frac{\langle p - p_u, p - p_v \rangle}{\|p - p_u\|\|p - p_v\|}\]</p><p>and <span>$\cos 90^{\circ} = 0$</span>, we can check if <span>$\theta \leq 90^{\circ}$</span> by checking if <span>$\langle p - p_u, p - p_v \rangle \geq 0$</span>. Thus:</p><ol><li>If <span>$\langle p - p_u, p - p_v\rangle &gt; 0$</span>, then <span>$\theta &lt; 90^{\circ}$</span>.</li><li>If <span>$\langle p - p_u, p - p_v\rangle = 0$</span>, then <span>$\theta = 90^{\circ}$</span>.</li><li>If <span>$\langle p - p_u, p - p_v\rangle &lt; 0$</span>, then <span>$\theta &gt; 90^{\circ}$</span>.</li></ol><p>The first two cases would imply that <span>$p$</span> encroaches upon <span>$e_{uv}$</span>.</p><p>Once we have identifed an edge as being encroached, we need to split it. We do this by simply inserting the midpoint <span>$p_m = (p_u + p_v) / 2$</span> into the triangulation, and replacing the segment <span>$e_{uv}$</span> by the two new subsegments, legalising any new edges as needed to restore the Delaunay property.</p><p>One issue with this definition of encroachment is that there may be a large number of vertices that have to be inserted to deal with all encroached edges as the diametral circle is quite large. To avoid this, we generalise the definition of a diametral circle to that of a <em>diametral lens</em> defined by some lens angle <span>$\theta_\ell$</span>. Firstly, let <span>$p$</span> be a point on the perpendicular bisector <span>$L_{uv}$</span> of <span>$e_{uv}$</span>, and left of <span>$e_{uv}$</span>, such that <span>$\angle p_upp_v = \theta_\ell$</span>, and similarly for a point <span>$q$</span> right of <span>$L$</span>. Now draw two circles through <span>$p_u, p_v, p$</span> and <span>$p_u, p_v, q$</span>, respectively, and compute their intersection. The diametral lens is this intersection. We show an example of a diametral lens below.</p><img src="18007673.png" alt="Example block output"/><p>In this figure, the blue circle shows the diametral circle, and the red shape shows the diametral lens, the grey line is the perpendicular bisector of <span>$e_{uv}$</span>, and the magenta circles show the two circles whose intersection defines the diametral lens. Checking if a point <span>$p$</span> is inside the diametral lens can be done using an extended version of Thales&#39; theorem (see, for example, Theorem 9 in <a href="https://repositorio.ufmg.br/bitstream/1843/RHCT-7GMJR6/1/adriano_chaves_lisboa.pdf">Lisboa&#39;s thesis</a>). We define the quantity </p><p class="math-container">\[\Delta(p_u, p_v, p) = \langle p_u - p, p_v - p \rangle^2 - \|p_u - p\|^2 \|p_v - p\|^2 \cos^2(\theta_\ell).\]</p><p>Then:</p><ul><li>If <span>$\Delta(p_u, p_v, p) &gt; 0$</span>, then <span>$p$</span> is inside the diametral lens.</li><li>If <span>$\Delta(p_u, p_v, p) = 0$</span>, then <span>$p$</span> is on the boundary of the diametral lens.</li><li>If <span>$\Delta(p_u, p_v, p) &lt; 0$</span>, then <span>$p$</span> is outside the diametral lens.</li></ul><p>One issue with diametral lens is that the final mesh is not guaranteed to be Delaunay, but many more subsegment splits will be avoided than if we had used diametral circles so that the final mesh has fewer triangles. It is possible that circumcenters are outside of the boundary when using diametral lens. In this case, we insert the triangle&#39;s centroid rather than its circumcenter.</p><h2 id="Deleting-Free-Vertices"><a class="docs-heading-anchor" href="#Deleting-Free-Vertices">Deleting Free Vertices</a><a id="Deleting-Free-Vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Deleting-Free-Vertices" title="Permalink"></a></h2><p>In addition to splitting a subsegment whenever it is encroached, we can also use an idea from Chew&#39;s algorithm for mesh refinement to improve our refinement. When we split a subsegment, points inside the original segment&#39;s diametral circle might cause unduly short edges to be created, leading to bad quality triangles that will just have to be split once again. To overcome this, we delete all <em>free vertices</em> inside the diametral circle, except those that are not visible to the segment (i.e., a segment in <span>$\mathcal S$</span> occludes the visibility between the segment and the vertex), before splitting the segment. A free vertex is any vertex not belonging to a segment that was inserted into the triangulation through refinement, i.e. a vertex that was not originally in <span>$\mathcal P$</span> and is not on the boundary or on an interior segment.</p><p>To delete these free vertices, we apply the following routine to each of <span>$e_{uv}$</span> and <span>$e_{vu}$</span>. We write these details for <span>$e_{uv}$</span> only.</p><ol><li>Get the vertex <span>$w$</span> adjacent to <span>$e_{uv}$</span> using the adjacent map.</li><li>If <span>$w$</span> is a free vertex and is either inside or on the diametral circle of <span>$e_{uv}$</span>, delete <span>$w$</span> from the triangulation and return to step 1. Otherwise, stop the routine here.</li></ol><p>Using this idea, we can reduce the number of triangles present in the final refined mesh while still retaining a high quality output. Moreover, since we use diametral lens instead of diametral circles, we avoid introducing as many vertices that would just be deleted by this procedure anyway.</p><h2 id="Splitting-a-Triangle"><a class="docs-heading-anchor" href="#Splitting-a-Triangle">Splitting a Triangle</a><a id="Splitting-a-Triangle-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-a-Triangle" title="Permalink"></a></h2><p>Now let&#39;s discuss how we actually insert a circumcenter into the triangulation to improve the quality of a triangle <span>$T_{uvw}$</span>. The procedure is simple:</p><ol><li>Let <span>$c$</span> be the circumcenter of a bad quality <span>$T_{uvw}$</span>.</li><li>If <span>$c$</span> encroaches upon some subsegment <span>$e \in \mathcal S$</span>, split <span>$e$</span>. Otherwise, insert <span>$c$</span> into <span>$\mathcal M$</span>.</li></ol><p>Inserting <span>$c$</span> into <span>$\mathcal M$</span> is simple using the Bowyer-Watson algorithm. Note that, for the point location step, we already know that the triangle <span>$T_{uvw}$</span> is a triangle containg <span>$c$</span> in its circumcircle, so we can skip the point location step.</p><p>Checking if <span>$c$</span> encroaches upon a subsegment <span>$e$</span> can be expensive. The cheapest way to do this is to actually just insert <span>$c$</span> into <span>$\mathcal M$</span>, and simply check if any of the edges of triangles containing <span>$c$</span> are encroahced. If they are, we undo the insertion of <span>$c$</span> and return to the original <span>$\mathcal M$</span> prior to the insertion of <span>$c$</span>, and split the marked encroached edges. To undo this insertion efficiently, we store a list of all changes to the triangulation made during the insertion of <span>$c$</span>.</p><h2 id="Small-Angles"><a class="docs-heading-anchor" href="#Small-Angles">Small Angles</a><a id="Small-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Angles" title="Permalink"></a></h2><p>A very crucial issue to notice with our refinement algorithm thus far is that it may fail to handle small angles. The first problem is called <em>ping-pong encroachment</em>, encountered when segments share a vertex and meet at an angle less than <span>$45^{\circ}$</span>. Consider the example below; we illustrate this using diametral circles, but the same problem can be encountered when using diametral lenses.</p><img src="fea8639d.png" alt="Example block output"/><p>In the first figure, the bottom segment <span>$e_1$</span> encroaches upon the vertex of the other adjoining segment <span>$e_2$</span>, so we split <span>$e_1$</span> at its midpoint. Once we insert this new midpoint, the segment <span>$e_2$</span> is encroached upon, and so we need to split <span>$e_2$</span>. The third figure then shows how the new segment of <span>$e_1$</span> is encroached upon by the vertex adding onto <span>$e_2$</span>, and so yet again we must split this subsegment. We can continue this process again to obtain the fourth figure. This will repeat indefinitely, leading to many points added as shown in the last figure. This is the ping-pong encroachment problem.</p><p>To overcome this problem, we use <em>concentric circular shells</em>. The basic idea is to imagine that each input vertex is surrounded by concentric circles whose radii are all the powers of two. We will still always split a segment initially at its midpoint, but for any future subsegments we need to make use of the concentric circles. When an encroached subsegment adjoins another segment at an acute angle, we split it at one of the circular shells centred at the shared vertex, so that one of the new subsegments has a power of two length. The shell we choose to split at is the one that guarantees that the two new subsegments produced by the split are between <span>$1/3$</span> and <span>$2/3$</span> the length of the split subsegment. With this approach, we can avoid the ping-pong encroachment. Notice that the choice of having the shells be powers of two implies that, for any future splits, the most balanced split for the power-of-two length subsegment will always be at the midpoint. If both vertices of a segment adjoin other segments, then the segment could be split twice at each end. To deal with this, just chosoe one vertex arbitrarily and split it so that the subsegment adjoining that vertex has a power-of-two length between <span>$1/4$</span> and <span>$1/2$</span> the length of the split subsegment. The other subsegment could still undergo another off-center split, but eventually all subsegment splits are bisections. This solves our ping-pong encroachment problem since adjoining subsegments of equal length cannot encroach upon each other. An example of this adaptation is shown below.</p><img src="1ec2b795.png" alt="Example block output"/><p>In the second and third figures we have two midpoint splits since the segments are the input segments. For the subsegment in the fourth figure, we see that the new point is being put onto the concentric circles surrounding the input vertex, and similarly for the last figure. In the last figure, we finally see that the newly inserted vertx is no longer encroaching upon the other subsegment, and so the ping-pong encroachment stops.</p><p>One other improvement made by Ruppert is to avoid splitting triangles that are nestled in the corner of a small input angle. For a triangle <span>$T_{uvw}$</span>, suppose that <span>$e_{uv}$</span> is its shortest edge so that the smallest angle of <span>$T_{uvw}$</span> is opposite <span>$e_{uv}$</span>. Then, if <span>$e_{wu}$</span> and <span>$e_{wv}$</span> are both segments and the triangle is skinny, it is considered to be a nestled triangle and so the triangle will never be split.</p><p>The last improvement we consider involves <em>seditious triangles</em>. If two adjoining subsegments meet at a very small angle, then splitting them may lead to a new edge that is shorter than the previously shortest edge in the mesh, leading to a bad quality mesh. Moreover, this short edge will cause more triangles to be refined as the adjoining triangles will necessarily be skinny, leading to more short edges, thus leading to an infinite loop. To avoid this, we need to prevent these short edges from causing more refinement. We say that an edge is <em>seditious</em> if its two vertices lie on two distinct segments that meet each other at an angle less than <span>$60^{\circ}$</span> (in this package, the default definition for a seditious edge actually uses an angle of <span>$20^{\circ}$</span>), they lie on the same concentric shell (we don&#39;t check this requirement in this package), and the two vertices are true midpoints (not off-center splits). With this definition, we say that a triangle is <em>seditious</em> if its shortest edge is seditious, and refuse to split any skinny triangle that is seditious, thus preventing seditious edges from infesting the rest of the mesh.</p><h2 id="The-Complete-Algorithm"><a class="docs-heading-anchor" href="#The-Complete-Algorithm">The Complete Algorithm</a><a id="The-Complete-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Complete-Algorithm" title="Permalink"></a></h2><p>Now that we have an understanding of all the pieces involved in the refinement algorithm, we can list the complete algorithm.</p><ol><li>Start by identifying all encroached segments and placing them into a priority queue, prioritising the longer segments first.</li><li>For each encroached subsegment <span>$e$</span>: Delete all free vertices in the diametral circle (or lens) of <span>$e$</span> and then split <span>$e$</span> at a position depending on whether <span>$e$</span> is an input segment or meets another subsegment at a small angle.</li><li>Next, identify all triangles that need to be refined, i.e. any triangle <span>$T_{uvw}$</span> with <span>$\rho &gt; \bar\rho$</span> or <span>$A &gt; A_{\max}$</span>, ignoring any of those which are nestled or seditious or <span>$A &lt; A_{\min}$</span>. Store these triangles in a priority queue, prioriting the triangles with the largest radius-edge ratio first.</li><li>Next, while there are any bad quality triangles: Attempt to split the bad quality triangle <span>$T$</span> by inserting its circumcenter <span>$c$</span> into <span>$\mathcal M$</span> (or centroid, if <span>$c$</span> is outside of the domain in case diametral lenses are used). If <span>$c$</span> encroaches on any new edges, undo the insertion and then split all those encroached segments as in step 2. If the insertion was successful, check all the newly added triangles for bad quality and add them to the priority queue if needed.</li><li>Once there are no more bad quality triangles to split, the algorithm is complete.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convex/">« Triangulating Convex Polygons</a><a class="docs-footer-nextpage" href="../curves/">Curves »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 1 October 2024 20:26">Tuesday 1 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
