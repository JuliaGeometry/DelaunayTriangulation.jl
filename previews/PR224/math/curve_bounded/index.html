<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Triangulating Curve-Bounded Domains · DelaunayTriangulation.jl</title><meta name="title" content="Triangulating Curve-Bounded Domains · DelaunayTriangulation.jl"/><meta property="og:title" content="Triangulating Curve-Bounded Domains · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Triangulating Curve-Bounded Domains · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curve_bounded/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curve_bounded/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curve_bounded/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li class="is-active"><a class="tocitem" href>Triangulating Curve-Bounded Domains</a><ul class="internal"><li><a class="tocitem" href="#Boundary-Enrichment"><span>Boundary Enrichment</span></a></li><li><a class="tocitem" href="#Mesh-Refinement"><span>Mesh Refinement</span></a></li></ul></li><li><a class="tocitem" href="../weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Triangulating Curve-Bounded Domains</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Triangulating Curve-Bounded Domains</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/curve_bounded.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Triangulating-Curve-Bounded-Domains"><a class="docs-heading-anchor" href="#Triangulating-Curve-Bounded-Domains">Triangulating Curve-Bounded Domains</a><a id="Triangulating-Curve-Bounded-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulating-Curve-Bounded-Domains" title="Permalink"></a></h1><p>In this section, we discuss the mathematical details behind the triangulation of curve-bounded domains. The algorithm we implement for this is from the PhD thesis <a href="https://open.library.ubc.ca/media/stream/pdf/24/1.0067778/2"><em>Delaunay Refinement Mesh Generation of Curve-bounded Domains</em></a> by Serge Gosselin (2009). A basic description of the algorithm is as follows:</p><h2 id="Boundary-Enrichment"><a class="docs-heading-anchor" href="#Boundary-Enrichment">Boundary Enrichment</a><a id="Boundary-Enrichment-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Enrichment" title="Permalink"></a></h2><p>The first step of the algorithm is to obtain a piecewise linear approximation to the domain so that we obtain an initial triangulation. This approximation must have no intersecting edges so that we can compute a triangulation of the approximate domain. For this approximtaion, we need to also be careful about the resolution of the approximation: Too many points will greatly increase the number of triangles in the final mesh, but too few points could result in a poor approximation and cause difficulty when triangulating with overlapping curves.</p><p>The approach we take for obtaining this approximation is based on the total variation of the curve, as defined in the <a href="../curves/">last section</a>. Recall that this total variation helps describe how much a curve varies around an interval, and so we can use the total variation to determine how many points are needed to approximate the curve by straight edges. Using the total variation as a guide so that any subcurve has total variation less than <span>$\pi/2$</span>, we will be able to <em>enrich</em> the boundary, adding points until no edges contain any other boundary points inside their diametral circles. With this requirement, all boundary edges will satisfy the constrained Delaunay property, allowing us to obtain an initial triangulation.</p><p>One difficulty with this approach is that finding all vertices inside a given edge&#39;s diametral circle is no longer as easy a task as it is for a triangulation, since we do not have any triangulation data structure to work with during this enrichment phase. To overcome this, we instead use an R-Tree <span>$\tau$</span>. This is a spatial indexing tree that will allow us to efficiently compute intersections. Once we have found such a vertex <span>$v$</span> inside an edge <span>$e$</span>&#39;s diametral circle, we need to check if it is actually visible from <span>$e$</span>. Visibility will be blocked if there is a hole between <span>$v$</span> and <span>$e$</span>, or there are other segments between <span>$v$</span> and <span>$e$</span> such that a segment from any point <span>$e$</span> to the vertex would intersect with another segment.</p><h3 id="Testing-Visibility"><a class="docs-heading-anchor" href="#Testing-Visibility">Testing Visibility</a><a id="Testing-Visibility-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Visibility" title="Permalink"></a></h3><p>Let us consider the problem of testing visibility between a vertex <span>$v$</span> and an edge <span>$e$</span>. One approach would be to take a small subset of points on the edge and simply test whether the line segment from <span>$v$</span> to each of these points intersects with any other segment, using the tree <span>$\tau$</span> to compute these intersections. This would not be efficient, though, and might still miss eom intersections. Instead, it is actually sufficient to test visibility just from the endpoints of <span>$e$</span>. To understand why, suppose that <span>$v$</span> is not visible from <span>$e$</span>&#39;s endpoints but is visible from a point in <span>$e$</span>&#39;s interior. This would imply that there are other vertices located inside <span>$e$</span>&#39;s diametral circle. Since we split all edges that contain other vertices inside their diametral circles, these subcurves would eventually be split anyway, which is the same outcome as if we had currently declared <span>$v$</span> as visible to begin with. Thus, for testing visibility we simply check the endpoints.</p><p>The actual algorithm we use for testing this visibility is as follows, assuming that we have a point <span>$p_k$</span> inside an edge <span>$e_{ij}$</span>&#39;s diametral circle:</p><ol><li>First, we check if there is a hole between <span>$p_k$</span> and <span>$e_{ij}$</span> that would occlude visibility. To check this, let <span>$C$</span> be the curve associated with <span>$e_{ij}$</span>, and compute the certificates <span>$s_c$</span> and <span>$s_e$</span> that give the positions of <span>$p_k$</span> relative to <span>$C$</span> and <span>$e_{ij}$</span>, respectively. If <span>$p_k$</span> is directly on <span>$e_{ij}$</span>, then this means that an endpoint of a boundary edge is directly on <span>$e_{ij}$</span>, and so we declare that <span>$p_k$</span> is visible from <span>$e_{ij}$</span>; if <span>$s_c \neq s_e$</span>, then <span>$e_{ij}$</span> intersects another boundary edge with <span>$p_k$</span> as a vertex and so we declare that <span>$p_k$</span> is visible from <span>$e_{ij}$</span>; if <span>$p_k$</span> is right of <span>$C$</span>, then this means that <span>$c$</span> bounds a hole and so we declare that <span>$p_k$</span> is not visible from <span>$e_{ij}$</span>. Otherwise, we proceed onto the next step.</li><li>We now need to determine if <span>$p_k$</span> is visible from either of the endpoints of <span>$e_{ij}$</span>. We initialise the variables <code>int1 = false</code> and <code>int2 = false</code>. To efficiently compute the intersections, we compute the intersection of the bounding box <span>$B$</span> of <span>$T_{ijk}$</span> with the bounding boxes in the R-Tree <span>$\tau$</span> (described in the algorithm for boundary enrichment later). Then, for each edge <span>$e_{uv}$</span> disjoint from <span>$e_{ij}$</span> in the set of intersections, we set <code>int1 = true</code> if <span>$e_{uv}$</span> insteads <span>$e_{ik}$</span> and <code>int2 = true</code> if <span>$e_{uv}$</span> intersects <span>$e_{jk}$</span>. If ever <code>int1</code> and <code>int2</code> are both true, then we declare that <span>$p_k$</span> is not visible from <span>$e_{ij}$</span>. Otherwise, if after processing all intersections either <code>int1</code> or <code>int2</code> is false, then we declare that <span>$p_k$</span> is visible from <span>$e_{ij}$</span>.</li></ol><h3 id="Splitting-a-Subcurve"><a class="docs-heading-anchor" href="#Splitting-a-Subcurve">Splitting a Subcurve</a><a id="Splitting-a-Subcurve-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-a-Subcurve" title="Permalink"></a></h3><p>Once we have determined that an edge <span>$e_{ij}$</span> needs to be split, we need to determine where to place the split point. This point cannot just be, for example, <span>$(p_i + p_j) / 2$</span>, since that might not lie on <span>$e_{ij}$</span>&#39;s parent curve <span>$C$</span>. Instead, we use the equivariation split of the subcurve between <span>$p_i$</span> and <span>$p_j$</span>, so that <span>$TV(t_1, t^*) = TV(t^*, t_2) = TV(t_1, t_2) / 2$</span>, where <span>$t_1$</span> and <span>$t_2$</span> are the parameters corresponding to <span>$p_i$</span> and <span>$p_j$</span>, respectively, and <span>$t^*$</span> is the parameter corresponding to the split point. This split point will be the new vertex that we add to the triangulation, provided there are no issues related to small angles like those we discuss below.</p><h3 id="Small-Angle-Complexes"><a class="docs-heading-anchor" href="#Small-Angle-Complexes">Small Angle Complexes</a><a id="Small-Angle-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Angle-Complexes" title="Permalink"></a></h3><p>For discussing boundary enrichment, we also need to handle small angles between curves. We that an input angle between two curves is <em>small</em> if it is less than <span>$\pi/3$</span>. Any curves where the angle between them is small must be protected and handled appropriately during enrichment. For this, we define a <em>small angle complex</em> <span>$\Sigma$</span> to be a set of subcurves having a common apex vertex as an endpoint and forming contiguous small angles at this apex vertex. </p><img src="0dd0ea65.png" alt="Example block output"/><p>In the figure above, we show an example of a set of subcurves <span>$\{s_1, s_2, s_3, s_4, s_5, s_6\}$</span> together with a common apex vertex. We see that the curve <span>$s_1$</span> forms no small angle with any other curve, and so it is not a part of any small angle complex. The curves <span>$\{s_2, s_3, s_4\}$</span> together form a small angle complex since they form a contiguous set of small angles. The curve <span>$s_5$</span> is not included in this complex since the angle between <span>$s_4$</span> and <span>$s_5$</span> is not small. Lastly, the curves <span>$\{s_5, s_6\}$</span> define a small angle complex. See that it is possible for a single apex vertex to define several separate small angle complexes.</p><h3 id="Locally-Small-Angles"><a class="docs-heading-anchor" href="#Locally-Small-Angles">Locally Small Angles</a><a id="Locally-Small-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Locally-Small-Angles" title="Permalink"></a></h3><p>In addition to handling small angle complexes, we also want to handle small angles that are locally acute, meaning that the angle between two segments is small. These are <em>local</em> checks since the curves associated with these edges might not define actually small angle at this point. We include these checks though to ensure that the enrichment phase cannot get stuck by any missed small angles.</p><h3 id="Splitting-Subcurves-Near-Small-Angles"><a class="docs-heading-anchor" href="#Splitting-Subcurves-Near-Small-Angles">Splitting Subcurves Near Small Angles</a><a id="Splitting-Subcurves-Near-Small-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-Subcurves-Near-Small-Angles" title="Permalink"></a></h3><p>Now let&#39;s discuss how we split subcurves near small angles. Let&#39;s first discuss the case where the subcurve is not part of a small angle complex. If there are no neighbouring acute angles to the edge <span>$e_{ij}$</span> associated with the subcurve <span>$s_{ij}$</span>, letting <span>$s_{ij}$</span> be the part of the parent curve <span>$C$</span> between <span>$p_i$</span> and <span>$p_j$</span>, then we just use an equivariation split. Otherwise, the split position depends on whether there are one or two neighbouring acute angles. The rule that we apply is the same as used for mesh refinement of piecewise linear bounaries as described <a href="../refinement/">here</a>. The only difference is that the split position we compute is based on the intersection of the concentric circular shell with the subcurve itself instead of with <span>$e_{ij}$</span>.</p><p>The main difficulty to work through is the splitting of a subcurve belonging to a small angle complex. Suppose <span>$s_{ij}$</span> belongs to a small angle complex <span>$\Sigma$</span> comprised of subcurves <span>$s_1, \ldots, s_m$</span>. We define the maximum split radius <span>$r_{\max} = 2\ell_{\min}/3$</span>, where <span>$\ell_{\min}$</span> is the length of the shortest boundary edge approximating a subcurve of <span>$\Sigma$</span>. The biggest power of two less than <span>$r_{\max}$</span> is then chosen to be the radius of the concentric circular shell to place the new vertex onto, meaning the radius of the shell is <span>$r_s = 2^k$</span> where <span>$k = \lfloor \log_2(r_{\max}) \rfloor$</span>. Then, for each subcurve <span>$s_i$</span>, we compute the intersection of this shell, centered at the apex of <span>$\Sigma$</span>, with <span>$s_i$</span> closest to the apex and place the new vertex there. We show an example of this below, where we are considering splitting a subcurve in the complex <span>$\Sigma$</span> defined by <span>$\{s_2, s_3, s_4\}$</span>.</p><img src="548834c0.png" alt="Example block output"/><p>In the above figure, the subcurves of interest are the subcures defined by the curves from <span>$a$</span> to each of the first blue points on each curve. These blue points and lines shows the piecewise linear approximation to each subcurve. The shortest edge length is then used to compute <span>$r_{\max}$</span>, giving the circle shown in red. The shell with radius <span>$2^{\lfloor \log_2 r_{\max}}\rfloor$</span> is shown in green. We then split each of the subcurves at their intersection with this green curve, giving the points shown in green and the updated piecewise linear approximation in the second figure. All subsequent splits of these subcurves (those between <span>$a$</span> and the new split points) will be at the next smaller power of two shell, i.e. <span>$2^{\lfloor \log_2 r_{\max} \rfloor - 1}$</span>.</p><h3 id="Enriching-the-Boundary"><a class="docs-heading-anchor" href="#Enriching-the-Boundary">Enriching the Boundary</a><a id="Enriching-the-Boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Enriching-the-Boundary" title="Permalink"></a></h3><p>Now we can finally discuss the full algorithm for enriching the boundary to prepare for triangulation. We describe these steps one at a time. We assume that all the small angle complexes have already been computed. Moreover, while our discussion thus far has not included the possibility of interior segments, simple modifications to the steps below and the details above could be made to handle them. We do not discuss interior segments here.</p><h4 id="Coarse-discretisation"><a class="docs-heading-anchor" href="#Coarse-discretisation">Coarse discretisation</a><a id="Coarse-discretisation-1"></a><a class="docs-heading-anchor-permalink" href="#Coarse-discretisation" title="Permalink"></a></h4><p>The first step is to obtain a coarse discretisation of the boundary. For each curve, we compute a coarse discretisation by, starting with the two endpoints, computing equivariation curves between each pair of points until the total variation across any subcurve is less than <span>$\pi/2$</span>. In this package this is the default, but we also provide an option to simply add a specified number of equivariation splits rather than taking care of the total variation.</p><h4 id="Spatial-indexing"><a class="docs-heading-anchor" href="#Spatial-indexing">Spatial indexing</a><a id="Spatial-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-indexing" title="Permalink"></a></h4><p>We then compute the R-Tree used for computing intersections. The R-Tree is initialised by inserting into it the axis-aligned bounding box of each segment&#39;s diametral circle in the coarse discretisation.</p><h4 id="Queueing-vertices"><a class="docs-heading-anchor" href="#Queueing-vertices">Queueing vertices</a><a id="Queueing-vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Queueing-vertices" title="Permalink"></a></h4><p>To determine the order in which to process vertices in the provided vertex set <span>$\mathcal P$</span>, we use a queue. This is a simple FIFO queue, i.e. just a vector, that we initialise with <span>$\mathcal Q = \mathcal P$</span>. We then process the vertices in the order they were added to the queue.</p><h4 id="Enrichment"><a class="docs-heading-anchor" href="#Enrichment">Enrichment</a><a id="Enrichment-1"></a><a class="docs-heading-anchor-permalink" href="#Enrichment" title="Permalink"></a></h4><p>We are now ready to actually being enriching. The idea is to process each vertex in the queue, adding new vertices as needed, and then stop once the queue is empty. So, let us suppose that <span>$\mathcal Q$</span> is not empty and dequeue a point <span>$p_i$</span> from <span>$\mathcal Q$</span>. We then compute the intersection of <span>$p_i$</span> with the R-Tree <span>$\tau$</span>, returning the set of all edges whose diametral circle&#39;s bounding box contains <span>$p_i$</span>. We then need to process each edge <span>$e_{uv}$</span> in this set.</p><p>For this edge <span>$e_{uv}$</span>, we only need to consider processing it if <span>$p_i$</span> is in its diametral circle and is visible from <span>$p_i$</span>. If this is not the case, we can continue onto the next edge <span>$e_{uv}$</span> onto the next set or dequeue another point. Otherwise, we split the subcurve associated with <span>$e_{uv}$</span> as described previously, ensuring we take care of small angles and small angle complexes. The point <span>$p_i$</span> gets enqueued back into <span>$\mathcal Q$</span>, and when we split the subcurve we (1) delete <span>$e_{uv}$</span> from <span>$\tau$</span> and add back in the two new segments and (2) enqueue the newly added point into <span>$\mathcal Q$</span>.</p><p>The above iterative procedure continues until <span>$\mathcal Q$</span> is empty. Once it is, we will have obtained a piecewise linear approximation to the boundary that satisfies the constrained Delaunay property. We can then proceed to compute the Delaunay triangulation of the boundary as usual.</p><h2 id="Mesh-Refinement"><a class="docs-heading-anchor" href="#Mesh-Refinement">Mesh Refinement</a><a id="Mesh-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-Refinement" title="Permalink"></a></h2><p>Once we have obtained the initial triangulation of the boundary, we can then refine the mesh to obtain a higher-quality mesh. The algorithm for this is reasonably straightforward. We use the existing algorithm for mesh refinement as discussed <a href="../refinement/">previously</a>, but when splitting the encroached segments we use the same method for splitting a subcurve as was used during enrichment.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../curves/">« Curves</a><a class="docs-footer-nextpage" href="../weighted/">Weighted Delaunay Triangulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 23 May 2025 19:06">Friday 23 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
