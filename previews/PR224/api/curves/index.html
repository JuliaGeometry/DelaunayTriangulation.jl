<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Curves · DelaunayTriangulation.jl</title><meta name="title" content="Curves · DelaunayTriangulation.jl"/><meta property="og:title" content="Curves · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Curves · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/curves/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/curves/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/curves/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../triangulation/">Triangulations</a></li><li><a class="tocitem" href="../operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li class="is-active"><a class="tocitem" href>Curves</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li><li><a class="tocitem" href="../point_location/">Point Location</a></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li><a class="tocitem" href="../statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Curves</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Curves</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/api/curves.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Curves"><a class="docs-heading-anchor" href="#Curves">Curves</a><a id="Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Curves" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.AbstractParametricCurve" href="#DelaunayTriangulation.AbstractParametricCurve"><code>DelaunayTriangulation.AbstractParametricCurve</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractParametricCurve &lt;: Function end</code></pre><p>Abstract type for representing a parametric curve parametrised over <code>0 ≤ t ≤ 1</code>. The curves represented by this  abstract type should not be self-intersecting, with the exception of allowing for closed curves.</p><p>The structs that subtype this abstract type must implement are:</p><ul><li><a href="#DelaunayTriangulation.differentiate"><code>differentiate</code></a>.</li><li><a href="#DelaunayTriangulation.twice_differentiate"><code>twice_differentiate</code></a>.</li><li><a href="#DelaunayTriangulation.thrice_differentiate"><code>thrice_differentiate</code></a> (only if you have not manually defined <a href="#DelaunayTriangulation.total_variation"><code>total_variation</code></a>).</li><li>The struct must be callable so that <code>c(t)</code>, where <code>c</code> an instance of the struct, returns the associated value of the curve at <code>t</code>.</li><li>If the struct does not implement <a href="#DelaunayTriangulation.point_position_relative_to_curve"><code>point_position_relative_to_curve</code></a>, then the struct must implement <a href="#DelaunayTriangulation.get_closest_point"><code>get_closest_point</code></a>. Alternatively,  rather than implementing <a href="#DelaunayTriangulation.get_closest_point"><code>get_closest_point</code></a>, the struct should have a <code>lookup_table</code> field as a <code>Vector{NTuple{2,Float64}}</code>, which returns values on the curve at a set of points,   where <code>lookup_table[i]</code> is the value of the curve at <code>t = (i - 1) / (length(lookup_table) - 1)</code>.</li></ul><p>Functions that are defined for all <a href="../../math/curves/#AbstractParametricCurve"><code>AbstractParametricCurve</code></a> subtypes are:</p><ul><li><a href="#DelaunayTriangulation.arc_length"><code>arc_length</code></a></li><li><a href="#DelaunayTriangulation.curvature"><code>curvature</code></a></li><li><a href="#DelaunayTriangulation.total_variation"><code>total_variation</code></a></li></ul><div class="admonition is-info" id="Efficiently-computing-the-total-variation-cb6a9034c1f1604a"><header class="admonition-header">Efficiently computing the total variation<a class="admonition-anchor" href="#Efficiently-computing-the-total-variation-cb6a9034c1f1604a" title="Permalink"></a></header><div class="admonition-body"><p>The curves in this package evaluate the total variation not by evaluating the integral itself, but by taking care of the changes in orientation in the curve to efficiently compute it. This is done by using the orientation markers of the curves, obtained using <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>, that stored in the field  <code>orientation_markers</code> of these curves. The function <a href="#DelaunayTriangulation.marked_total_variation"><code>marked_total_variation</code></a> is then used to evaluate it. You may like to consider using these functions for  any curve you wish to implement yourself, using e.g. the <a href="../../math/curves/#BezierCurve"><code>BezierCurve</code></a> struct&#39;s implementation as a reference.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L256-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.LineSegment" href="#DelaunayTriangulation.LineSegment"><code>DelaunayTriangulation.LineSegment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineSegment &lt;: AbstractParametricCurve</code></pre><p>Curve for representing a line segment, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be using  <code>line_segment(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p><strong>Fields</strong></p><ul><li><code>first::NTuple{2,Float64}</code>: The first point of the line segment.</li><li><code>last::NTuple{2,Float64}</code>: The last point of the line segment.</li><li><code>length::Float64</code>: The length of the line segment.</li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>LineSegment</code> using </p><pre><code class="nohighlight hljs">LineSegment(first, last)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/linesegment.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.CircularArc" href="#DelaunayTriangulation.CircularArc"><code>DelaunayTriangulation.CircularArc</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularArc &lt;: AbstractParametricCurve</code></pre><p>Curve for representing a circular arc, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be evaluated  using <code>circular_arc(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p><strong>Fields</strong></p><ul><li><code>center::NTuple{2,Float64}</code>: The center of the arc.</li><li><code>radius::Float64</code>: The radius of the arc.</li><li><code>start_angle::Float64</code>: The angle of the initial point of the arc, in radians.</li><li><code>sector_angle::Float64</code>: The angle of the sector of the arc, in radians. This is given by <code>end_angle - start_angle</code>, where <code>end_angle</code> is the angle at <code>last</code>, and so might be negative for negatively oriented arcs.</li><li><code>first::NTuple{2,Float64}</code>: The first point of the arc.</li><li><code>last::NTuple{2,Float64}</code>: The last point of the arc.</li><li><code>pqr::NTuple{3, NTuple{2, Float64}}</code>: Three points on the circle through the arc. This is needed for <a href="#DelaunayTriangulation.point_position_relative_to_curve"><code>point_position_relative_to_curve</code></a>.</li></ul><div class="admonition is-warning" id="Orientation-9134824330dd19f2"><header class="admonition-header">Orientation<a class="admonition-anchor" href="#Orientation-9134824330dd19f2" title="Permalink"></a></header><div class="admonition-body"><p>The angles <code>start_angle</code> and <code>end_angle</code> should be setup such that <code>start_angle &gt; end_angle</code> implies a positively oriented arc,  and <code>start_angle &lt; end_angle</code> implies a negatively oriented arc. Moreover, they must be in <code>[0°, 2π°)</code>.</p></div></div><p><strong>Constructor</strong></p><p>You can construct a <code>CircularArc</code> using </p><pre><code class="nohighlight hljs">CircularArc(first, last, center; positive=true)</code></pre><p>It is up to you to ensure that <code>first</code> and <code>last</code> are equidistant from <code>center</code> - the radius used will be the  distance between <code>center</code> and <code>first</code>. The <code>positive</code> keyword argument is used to determine if the  arc is positively oriented or negatively oriented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/circulararc.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.EllipticalArc" href="#DelaunayTriangulation.EllipticalArc"><code>DelaunayTriangulation.EllipticalArc</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EllipticalArc &lt;: AbstractParametricCurve</code></pre><p>Curve for representing an elliptical arc, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be evaluated using <code>elliptical_arc(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p><strong>Fields</strong></p><ul><li><code>center::NTuple{2,Float64}</code>: The center of the ellipse.</li><li><code>horz_radius::Float64</code>: The horizontal radius of the ellipse. </li><li><code>vert_radius::Float64</code>: The vertical radius of the ellipse.</li><li><code>rotation_scales::NTuple{2,Float64}</code>: If <code>θ</code> is the angle of rotation of the ellipse, then this is <code>(sin(θ), cos(θ))</code>.</li><li><code>start_angle::Float64</code>: The angle of the initial point of the arc measured from <code>center</code>, in radians. This angle is measured from the center prior to rotating the ellipse.</li><li><code>sector_angle::Float64</code>: The angle of the sector of the arc, in radians. This is given by <code>end_angle - start_angle</code>, where <code>end_angle</code> is the angle at <code>last</code>, and so might be negative for negatively oriented arcs.</li><li><code>first::NTuple{2,Float64}</code>: The first point of the arc.</li><li><code>last::NTuple{2,Float64}</code>: The last point of the arc.</li></ul><p><strong>Constructor</strong></p><p>You can construct an <code>EllipticalArc</code> using </p><pre><code class="nohighlight hljs">EllipticalArc(first, last, center, major_radius, minor_radius, rotation; positive=true)</code></pre><p>where <code>rotation</code> is the angle of rotation of the ellipse, in degrees. The <code>positive</code> keyword argument is used to determine if the  arc is positively oriented or negatively oriented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/ellipticalarc.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.BezierCurve" href="#DelaunayTriangulation.BezierCurve"><code>DelaunayTriangulation.BezierCurve</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BezierCurve &lt;: AbstractParametricCurve</code></pre><p>Curve for representing a Bezier curve, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be evaluated using <code>bezier_curve(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p>A good reference on Bezier curves is <a href="https://pomax.github.io/bezierinfo/">this</a>.</p><p>See also <a href="../../math/curves/#BSpline"><code>BSpline</code></a> and <a href="../../math/curves/#CatmullRomSpline"><code>CatmullRomSpline</code></a>.</p><div class="admonition is-danger" id="Loops-be16c798625bd57b"><header class="admonition-header">Loops<a class="admonition-anchor" href="#Loops-be16c798625bd57b" title="Permalink"></a></header><div class="admonition-body"><p>This curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.</p></div></div><div class="admonition is-danger" id="Interpolation-1e5fd2cd29e7e865"><header class="admonition-header">Interpolation<a class="admonition-anchor" href="#Interpolation-1e5fd2cd29e7e865" title="Permalink"></a></header><div class="admonition-body"><p>Remember that Bezier curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. If you want an interpolation curve, use <a href="../../math/curves/#CatmullRomSpline"><code>CatmullRomSpline</code></a>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>control_points::Vector{NTuple{2,Float64}}</code>: The control points of the Bezier curve. The curve goes through the first and last control points, but not the intermediate ones.</li><li><code>cache::Vector{NTuple{2,Float64}}</code>: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Casteljau&#39;s algorithm. </li><li><code>lookup_table::Vector{NTuple{2,Float64}}</code>: A lookup table for the Bezier curve, used for finding the point on the curve closest to a given point. The <code>i</code>th entry of the lookup table  corresponds to the <code>t</code>-value <code>i / (length(lookup_table) - 1)</code>.</li><li><code>orientation_markers::Vector{Float64}</code>: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always <code>0</code> and <code>1</code>, respectively. See <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</li></ul><div class="admonition is-warning" id="Concurrency-2417986d5ede0828"><header class="admonition-header">Concurrency<a class="admonition-anchor" href="#Concurrency-2417986d5ede0828" title="Permalink"></a></header><div class="admonition-body"><p>The cache is not thread-safe, and so you should not evaluate this curve in parallel.</p></div></div><p><strong>Constructor</strong></p><p>You can construct a <code>BezierCurve</code> using </p><pre><code class="nohighlight hljs">BezierCurve(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)</code></pre><p>The keyword argument <code>lookup_steps=100</code> controls how many time points in <code>[0, 1]</code> are used for the lookup table. The <code>kwargs...</code> are keyword arguments passed to <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/beziercurve.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.BSpline" href="#DelaunayTriangulation.BSpline"><code>DelaunayTriangulation.BSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSpline &lt;: AbstractParametricCurve</code></pre><p>Curve for representing a BSpline, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be evaluated  using <code>b_spline(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p>See also <a href="../../math/curves/#BezierCurve"><code>BezierCurve</code></a> and <a href="../../math/curves/#CatmullRomSpline"><code>CatmullRomSpline</code></a>.</p><p>Our implementation of a BSpline is based on https://github.com/thibauts/b-spline.</p><div class="admonition is-danger" id="Loops-be16c798625bd57b"><header class="admonition-header">Loops<a class="admonition-anchor" href="#Loops-be16c798625bd57b" title="Permalink"></a></header><div class="admonition-body"><p>This curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.</p></div></div><div class="admonition is-danger" id="Interpolation-dda4f2087cc416ba"><header class="admonition-header">Interpolation<a class="admonition-anchor" href="#Interpolation-dda4f2087cc416ba" title="Permalink"></a></header><div class="admonition-body"><p>Remember that B-spline curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. For an interpolating spline, see <a href="../../math/curves/#CatmullRomSpline"><code>CatmullRomSpline</code></a>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>control_points::Vector{NTuple{2,Float64}}</code>: The control points of the BSpline. The curve goes through the first and last control points, but not the intermediate ones. </li><li><code>knots::Vector{Int}</code>: The knots of the BSpline. You should not modify or set this field directly (in particular, do not expect any support for non-uniform B-splines).</li><li><code>cache::Vector{NTuple{2,Float64}}</code>: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Boor&#39;s algorithm.</li><li><code>lookup_table::Vector{NTuple{2,Float64}}</code>: A lookup table for the B-spline curve, used for finding the point on the curve closest to a given point. The <code>i</code>th entry of the lookup table  corresponds to the <code>t</code>-value <code>i / (length(lookup_table) - 1)</code>.</li><li><code>orientation_markers::Vector{Float64}</code>: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always <code>0</code> and <code>1</code>, respectively. See <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</li></ul><p><strong>Constructor</strong></p><p>You can construct a <code>BSpline</code> using </p><pre><code class="nohighlight hljs">BSpline(control_points::Vector{NTuple{2,Float64}}; degree=3, lookup_steps=5000, kwargs...)</code></pre><p>The keyword argument <code>lookup_steps</code> is used to build the lookup table for the curve. Note that the default  <code>degree=3</code> corresponds to a cubic B-spline curve. The <code>kwargs...</code> are keyword arguments passed to <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/bspline.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.CatmullRomSpline" href="#DelaunayTriangulation.CatmullRomSpline"><code>DelaunayTriangulation.CatmullRomSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CatmullRomSpline &lt;: AbstractParametricCurve</code></pre><p>Curve for representing a Catmull-Rom spline, parametrised over <code>0 ≤ t ≤ 1</code>. This curve can be evaluated  using <code>catmull_rom_spline(t)</code> and returns a tuple <code>(x, y)</code> of the coordinates of the point on the curve at <code>t</code>.</p><p>For information on these splines, see e.g. <a href="https://people.engr.tamu.edu/schaefer/research/cr_cad.pdf">this article</a> and <a href="https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html">this article</a>. Additionally, <a href="https://splines.readthedocs.io/en/latest/euclidean/catmull-rom-properties.html">this article</a> lists some nice properties of these splines.</p><div class="admonition is-danger" id="Loops-be16c798625bd57b"><header class="admonition-header">Loops<a class="admonition-anchor" href="#Loops-be16c798625bd57b" title="Permalink"></a></header><div class="admonition-body"><p>This curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.</p></div></div><div class="admonition is-info" id="Extension-c2064a4c5e6e1356"><header class="admonition-header">Extension<a class="admonition-anchor" href="#Extension-c2064a4c5e6e1356" title="Permalink"></a></header><div class="admonition-body"><p>Typically, Catmull-Rom splines are defined on segments of four control points, and drawn between the two interior control points. This creates an issue in that the first and last control points will not be joined to the spline. To overcome this, we extend the spline to the left and right during the evaluation of a spline, using the fields <code>left</code> and <code>right</code> defined below. The rules used for extending these points come from <a href="https://github.com/JeffreySarnoff/CatmullRom.jl">CatmullRom.jl</a>, which extrapolates based on a Thiele-like cubic polynomial.</p></div></div><p><strong>Fields</strong></p><ul><li><code>control_points::Vector{NTuple{2,Float64}}</code>: The control points of the Catmull-Rom spline. The curve goes through each point.</li><li><code>knots::Vector{Float64}</code>: The parameter values of the Catmull-Rom spline. The <code>i</code>th entry of this vector corresponds to the <code>t</code>-value associated with the <code>i</code>th control point.   With an alpha parameter <code>α</code>, these values are given by <code>knots[i+1] = knots[i] + dist(control_points[i], control_points[i+1])^α</code>, where <code>knots[1] = 0</code>,   and the vector is the normalised by dividing by <code>knots[end]</code>.</li><li><code>lookup_table::Vector{NTuple{2,Float64}}</code>: A lookup table for the Catmull-Rom spline, used for finding the point on the curve closest to a given point. The <code>i</code>th entry of the lookup table  corresponds to the <code>t</code>-value <code>i / (length(lookup_table) - 1)</code>.</li><li><code>alpha::Float64</code>: The alpha parameter of the Catmull-Rom spline. This controls the type of the parametrisation, where <code>alpha = 0</code> corresponds to uniform parametrisation,   <code>alpha = 1/2</code> corresponds to centripetal parametrisation, and <code>alpha = 1</code> corresponds to chordal parametrisation. Must be in <code>[0, 1]</code>. For reasons similar to what we describe for <code>tension</code> below, we only support    <code>alpha = 1/2</code> for now. (If you do really want to change it, use the <code>_alpha</code> keyword argument in the constructor.)</li><li><code>tension::Float64</code>: The tension parameter of the Catmull-Rom spline. This controls the tightness of the spline, with <code>tension = 0</code> being the least tight, and <code>tension = 1</code> leading to straight lines between the control points. Must be in <code>[0, 1]</code>.   You can not currently set this to anything except <code>0.0</code> due to numerical issues with boundary refinement. (For example, equivariation splits are not possible if <code>tension=1</code> since   the curve is piecewise linear in that case, and for <code>tension</code> very close to <code>1</code>, the equivariation split is not always between the provided times. If you <em>really</em> want to change it, then you   can use the <code>_tension</code> keyword argument in the constructor - but be warned that this may lead to numerical issues and potentially infinite loops.)</li><li><code>left::NTuple{2,Float64}</code>: The left extension of the spline. This is used to evaluate the spline on the first segment.</li><li><code>right::NTuple{2,Float64}</code>: The right extension of the spline. This is used to evaluate the spline on the last segment.</li><li><code>lengths::Vector{Float64}</code>: The lengths of the individual segments of the spline.</li><li><code>segments::Vector{CatmullRomSplineSegment}</code>: The individual segments of the spline.</li><li><code>orientation_markers::Vector{Float64}</code>: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always <code>0</code> and <code>1</code>, respectively. See <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</li></ul><p><strong>Constructor</strong></p><p>To construct a <code>CatmullRomSpline</code>, use </p><pre><code class="nohighlight hljs">CatmullRomSpline(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)</code></pre><p>The keyword argument <code>lookup_steps</code> is used to build the lookup table for the curve, with <code>lookup_steps</code> giving the number of time points in <code>[0, 1]</code> used for the lookup table.  The <code>kwargs...</code> are keyword arguments passed to <a href="#DelaunayTriangulation.orientation_markers"><code>orientation_markers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/catmullromspline.jl#L147-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.arc_length" href="#DelaunayTriangulation.arc_length"><code>DelaunayTriangulation.arc_length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arc_length(c::AbstractParametricCurve) -&gt; Float64
arc_length(c::AbstractParametricCurve, t₁, t₂) -&gt; Float64</code></pre><p>Returns the arc length of the [<code>AbstractParametricCurve</code>] <code>c</code>. The second method returns the arc length in the interval <code>[t₁, t₂]</code>, where <code>0 ≤ t₁ ≤ t₂ ≤ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L322-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.differentiate" href="#DelaunayTriangulation.differentiate"><code>DelaunayTriangulation.differentiate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate(c::AbstractParametricCurve, t) -&gt; NTuple{2, Float64}</code></pre><p>Evaluates the derivative of <code>c</code> at <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.twice_differentiate" href="#DelaunayTriangulation.twice_differentiate"><code>DelaunayTriangulation.twice_differentiate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twice_differentiate(c::AbstractParametricCurve, t) -&gt; NTuple{2, Float64}</code></pre><p>Evaluates the second derivative of <code>c</code> at <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.thrice_differentiate" href="#DelaunayTriangulation.thrice_differentiate"><code>DelaunayTriangulation.thrice_differentiate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thrice_differentiate(c::AbstractParametricCurve, t) -&gt; NTuple{2, Float64}</code></pre><p>Evaluates the third derivative of <code>c</code> at <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.curvature" href="#DelaunayTriangulation.curvature"><code>DelaunayTriangulation.curvature</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curvature(c::AbstractParametricCurve, t) -&gt; Float64</code></pre><p>Returns the curvature of the [<code>AbstractParametricCurve</code>] <code>c</code> at <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.total_variation" href="#DelaunayTriangulation.total_variation"><code>DelaunayTriangulation.total_variation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">total_variation(c::AbstractParametricCurve) -&gt; Float64
total_variation(c::AbstractParametricCurve, t₁, t₂) -&gt; Float64</code></pre><p>Returns the total variation of a curve <code>c</code>, or the subcurve over <code>[t₁, t₂]</code> with <code>0 ≤ t₁ ≤ t₂ ≤ 1</code>, defined as the integral of the absolute curvature over this interval. (This is also known as the total absolute curvature.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L376-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_curve" href="#DelaunayTriangulation.point_position_relative_to_curve"><code>DelaunayTriangulation.point_position_relative_to_curve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] e::AbstractParametricCurve, p) -&gt; Certificate</code></pre><p>Returns the position of the point <code>p</code> relative to the curve <code>c</code>. This function returns a [<code>Certificate</code>]:</p><ul><li><code>Left</code>: <code>p</code> is to the left of <code>c</code>.</li><li><code>Right</code>: <code>p</code> is to the right of <code>c</code>.</li><li><code>On</code>: <code>p</code> is on <code>c</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L445-L457">source</a></section><section><div><pre><code class="language-julia hljs">point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] L::LineSegment, p) -&gt; Certificate</code></pre><p>Returns the position of <code>p</code> relative to <code>L</code>, returning a <a href="../predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a>:</p><ul><li><code>Left</code>: <code>p</code> is to the left of <code>L</code>.</li><li><code>Right</code>: <code>p</code> is to the right of <code>L</code>.</li><li><code>On</code>: <code>p</code> is on <code>L</code>.</li></ul><p>See also <a href="../predicates/#DelaunayTriangulation.point_position_relative_to_line"><code>point_position_relative_to_line</code></a>.</p><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/linesegment.jl#L56-L70">source</a></section><section><div><pre><code class="language-julia hljs">point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] enricher::BoundaryEnricher, curve_index, p) -&gt; Certificate</code></pre><p>Returns a <a href="../predicates/#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is </p><ul><li><code>Left</code>: If <code>p</code> is to the left of the <code>curve_index</code>th curve.</li><li><code>Right</code>: If <code>p</code> is to the right of the <code>curve_index</code>th curve.</li><li><code>On</code>: If <code>p</code> is on the <code>curve_index</code>th curve.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L826-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_closest_point" href="#DelaunayTriangulation.get_closest_point"><code>DelaunayTriangulation.get_closest_point</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_closest_point(b::AbstractParametricCurve p) -&gt; (Float64, NTuple{2,Float64})</code></pre><p>Returns the <code>t</code>-value and the associated point <code>q</code> on the curve <code>b</code> that is nearest to <code>p</code> using a binary search. The search is done until the  binary search interval is smaller than <code>1e-12</code>. This function will only work if the curve <code>b</code> has a lookup table.</p><div class="admonition is-danger" id="Loops-38b24b582ce1e899"><header class="admonition-header">Loops<a class="admonition-anchor" href="#Loops-38b24b582ce1e899" title="Permalink"></a></header><div class="admonition-body"><p>This function is only tested on loop-free curves. It is not guaranteed to work on curves with loops. Moreover, for this function to be accurate,  you want the lookup table in <code>b</code> to be sufficiently dense.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L479-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_equidistant_split" href="#DelaunayTriangulation.get_equidistant_split"><code>DelaunayTriangulation.get_equidistant_split</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_equidistant_split(c::AbstractParametricCurve, t₁, t₂) -&gt; Float64</code></pre><p>Returns a value of <code>t</code> such that the arc length along <code>c</code> from <code>t₁</code> to <code>t</code> is equal to the arc length along <code>c</code> from <code>t</code> to <code>t₂</code>.  Uses the bisection method to compute the <code>t</code>-value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L879-L884">source</a></section><section><div><pre><code class="language-julia hljs">get_equidistant_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -&gt; Float64</code></pre><p>Returns the equidistant split of the <code>curve_index</code>th curve between <code>t₁</code> and <code>t₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L799-L803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_equivariation_split" href="#DelaunayTriangulation.get_equivariation_split"><code>DelaunayTriangulation.get_equivariation_split</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_equivariation_split(c::AbstractParametricCurve, t₁, t₂) -&gt; Float64, Float64</code></pre><p>Returns a value of <code>t</code> such that the total variation of <code>c</code> from <code>t₁</code> to <code>t</code> is equal to the total variation of <code>c</code> from <code>t</code> to <code>t₂</code>. Uses the bisection method to compute the <code>t</code>-value. Also returns the new total variation of the two pieces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L901-L906">source</a></section><section><div><pre><code class="language-julia hljs">get_equivariation_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -&gt; Float64, Float64</code></pre><p>Returns the equivariation split of the <code>curve_index</code>th curve between <code>t₁</code> and <code>t₂</code>. Also returns the total variation of the two pieces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L786-L790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_inverse" href="#DelaunayTriangulation.get_inverse"><code>DelaunayTriangulation.get_inverse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_inverse(c::AbstractParametricCurve, p) -&gt; Float64</code></pre><p>Given a point <code>p</code> on <code>c</code>, returns the <code>t</code>-value such that <code>c(t) ≈ p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L924-L928">source</a></section><section><div><pre><code class="language-julia hljs">get_inverse(enricher::BoundaryEnricher, curve_index, q) -&gt; Float64</code></pre><p>Returns the inverse of the <code>curve_index</code>th curve at <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L773-L777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.angle_between" href="#DelaunayTriangulation.angle_between"><code>DelaunayTriangulation.angle_between</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle_between(c₁::AbstractParametricCurve, c₂::AbstractParametricCurve) -&gt; Float64</code></pre><p>Given two curves <code>c₁</code> and <code>c₂</code> such that <code>c₁(1) == c₂(0)</code>, returns the angle between the two curves, treating the interior of the  curves as being left of both.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L934-L939">source</a></section><section><div><pre><code class="language-julia hljs">angle_between(L₁::LineSegment, L₂::LineSegment) -&gt; Float64</code></pre><p>Returns the angle between <code>L₁</code> and <code>L₂</code>, assuming that <code>L₁.last == L₂.first</code> (this is not checked). For consistency with  If the segments are part of some domain, then the line segments should be oriented so that the interior is to the left of both segments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/linesegment.jl#L102-L107">source</a></section><section><div><pre><code class="language-julia hljs">angle_between(enricher::BoundaryEnricher, curve_index1, curve_index2) -&gt; Float64</code></pre><p>Evaluates <a href="#DelaunayTriangulation.angle_between"><code>angle_between</code></a> on the curves with indices <code>curve_index1</code> and <code>curve_index2</code> in <code>enricher</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L849-L853">source</a></section><section><div><pre><code class="language-julia hljs">angle_between(p, q) -&gt; Number</code></pre><p>Returns the angle between the vectors <code>p</code> and <code>q</code> in radians, treating <code>q</code> as the base. See <a href="https://straypixels.net/angle-between-vectors/">this article</a>. The returned angle is in <code>[0, 2π)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/utils/geometry_utils.jl#L449-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_circle_intersection" href="#DelaunayTriangulation.get_circle_intersection"><code>DelaunayTriangulation.get_circle_intersection</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_circle_intersection(c::AbstractParametricCurve, t₁, t₂, r) -&gt; (Float64, NTuple{2,Float64})</code></pre><p>Given a circle centered at <code>c(t₁)</code> with radius <code>r</code>, finds the first intersection of the circle with  the curve after <code>t₁</code> and less than <code>t₂</code>. It is assumed that such an intersection exists. The returned value  is <code>(t, q)</code>, where <code>t</code> is the parameter value of the intersection and <code>q</code> is the point of intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L951-L957">source</a></section><section><div><pre><code class="language-julia hljs">get_circle_intersection(enricher::BoundaryEnricher, curve_index, t₁, t₂, r) -&gt; (Float64, NTuple{2,Float64})</code></pre><p>Finds the intersection of the <code>curve_index</code>th curve with the circle centered at the curve evaluated at <code>t₁</code> with radius <code>r</code>. The argument  <code>t₂</code> defines the end of the subcurve to consider. The returned tuple is <code>(t, p)</code> where <code>t</code> is the parameter value of the intersection and <code>p</code> is the point of intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/boundary_enricher.jl#L862-L867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.orientation_markers" href="#DelaunayTriangulation.orientation_markers"><code>DelaunayTriangulation.orientation_markers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orientation_markers(c::AbstractParametricCurve; steps=200, iters=50, tol=1e-5) -&gt; Vector{Float64}</code></pre><p>Finds all orientation markers of the <a href="../../math/curves/#AbstractParametricCurve"><code>AbstractParametricCurve</code></a> <code>c</code>. These are points <code>t</code> where any of the following  conditions hold (not necessarily simultaneously), letting <code>c(t) = (x(t), y(t))</code>:</p><ul><li><code>x&#39;(t) = 0</code></li><li><code>y&#39;(t) = 0</code></li><li><code>κ(t; x) = 0</code>, where <code>κ(t; x)</code> is the curvature of the component function <code>x(t)</code></li><li><code>κ(t; y) = 0</code>, where <code>κ(t; y)</code> is the curvature of the component function <code>y(t)</code></li><li><code>κ(t) = 0</code>, where <code>κ</code> is the curvature of <code>c(t)</code></li></ul><p>Note that the third and fourth conditions give all the inflection points of the component functions, and similarly for the fifth condition.</p><p>See also <a href="../../extended/data_structures/#DelaunayTriangulation.horizontal_turning_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>horizontal_turning_points</code></a>, <a href="../../extended/data_structures/#DelaunayTriangulation.vertical_turning_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>vertical_turning_points</code></a>, <a href="../../extended/data_structures/#DelaunayTriangulation.horizontal_inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>horizontal_inflection_points</code></a>, <a href="../../extended/data_structures/#DelaunayTriangulation.vertical_inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>vertical_inflection_points</code></a>, and <a href="../../extended/data_structures/#DelaunayTriangulation.inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}"><code>inflection_points</code></a>.</p><div class="admonition is-danger" id="High-degree-curves-2b4bfa07090caa81"><header class="admonition-header">High-degree curves<a class="admonition-anchor" href="#High-degree-curves-2b4bfa07090caa81" title="Permalink"></a></header><div class="admonition-body"><p>For curves of very high degree, such as Bezier curves with <code>steps</code> control points or greater, this function might fail to return all  inflection points.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>c::AbstractParametricCurve</code>: The <a href="../../math/curves/#AbstractParametricCurve"><code>AbstractParametricCurve</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>steps=200</code>: The number of equally spaced points to use for initialising Newton&#39;s method.</li><li><code>iters=50</code>: How many iterations to use for Newton&#39;s method.</li><li><code>tol=1e-5</code>: The tolerance used for determining if two <code>t</code>-values are the same.</li></ul><p><strong>Output</strong></p><ul><li><code>markers::Vector{Float64}</code>: The <code>t</code>-values of the orientation markers of <code>b</code>. The returned vector is sorted, and also includes the   endpoints <code>0</code> and <code>1</code>; any <code>t</code>-values outside of <code>[0, 1]</code> are discarded, and multiplicity   of any <code>t</code> is not considered (so the <code>t</code>-values in the returned vector are unique). These values can be used to split the curve into monotone pieces, meaning   the orientation is monotone. These markers also guarantee that, over any monotone piece, the orientation changes by an angle of at most <code>π/2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L830-L864">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.marked_total_variation" href="#DelaunayTriangulation.marked_total_variation"><code>DelaunayTriangulation.marked_total_variation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marked_total_variation(b::AbstractParametricCurve, t₁, t₂)</code></pre><p>Returns the total variation of the curve <code>b</code> over the interval <code>[t₁, t₂]</code> using the orientation markers of <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/c7127eb4e3cb66000039a3bffac3096b8dd173a0/src/data_structures/mesh_refinement/curves/abstract.jl#L400-L404">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convex_hull/">« Convex Hull</a><a class="docs-footer-nextpage" href="../iterators/">Iterators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 23 May 2025 20:06">Friday 23 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
