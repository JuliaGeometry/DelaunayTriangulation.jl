<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Points · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/points/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li><a class="tocitem" href="../edges/">Edges</a></li><li class="is-active"><a class="tocitem" href>Points</a><ul class="internal"><li><a class="tocitem" href="#Individual-Points"><span>Individual Points</span></a></li><li><a class="tocitem" href="#Collection-of-Points"><span>Collection of Points</span></a></li></ul></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Points</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Points</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/points.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Individual-Points"><a class="docs-heading-anchor" href="#Individual-Points">Individual Points</a><a id="Individual-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Points" title="Permalink"></a></h2><p>Points are assumed to take the form <code>(x, y)</code>, but we allow for customisation in how we represent these points. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods"><a class="docs-heading-anchor" href="#Necessary-Methods">Necessary Methods</a><a id="Necessary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getx" href="#DelaunayTriangulation.getx"><code>DelaunayTriangulation.getx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getx(p::P) where {P}</code></pre><p>Given a point <code>p</code>, returns the <code>x</code>-coordinate. The  only methods currently defined are</p><pre><code class="nohighlight hljs">getx(p::NTuple{N,T}) where {N,T}
getx(p::AbstractVector)</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.gety" href="#DelaunayTriangulation.gety"><code>DelaunayTriangulation.gety</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gety(p::P) where {P}</code></pre><p>Given a point <code>p</code>, returns the <code>y</code>-coordinate. The  only methods currently defined are</p><pre><code class="nohighlight hljs">gety(p::NTuple{N,T}) where {N,T}
gety(p::AbstractVector)</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L19-L29">source</a></section></article><h3 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getxy" href="#DelaunayTriangulation.getxy"><code>DelaunayTriangulation.getxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getxy(p)</code></pre><p>Given a point <code>p</code>, returns <code>(getx(p), gety(p))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L37-L41">source</a></section></article><h2 id="Collection-of-Points"><a class="docs-heading-anchor" href="#Collection-of-Points">Collection of Points</a><a id="Collection-of-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-Points" title="Permalink"></a></h2><p>A collection of points simply store many points. It does not need to be mutable (unless you want to add points into the triangulation not already in <code>tri.points</code>, or if you want mesh refinement). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods-2"><a class="docs-heading-anchor" href="#Necessary-Methods-2">Necessary Methods</a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getpoint" href="#DelaunayTriangulation.getpoint"><code>DelaunayTriangulation.getpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpoint(pts::P, i)</code></pre><p>Given a collection of points <code>pts</code>, returns a <code>Tuple</code>  of the <code>x</code> and <code>y</code> coordinates of the <code>i</code>th point in  the collection. The methods currently defined are </p><pre><code class="nohighlight hljs">getpoint(pts::AbstractVector, i)
getpoint(pts::AbstractMatrix, i)</code></pre><p>You can extend this function as you need. </p><p>It is assumed that whenever <code>i</code> is not an integer, <code>i</code> is meant to be  a point, so <code>(getx(i), gety(i))</code> would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L44-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point_index" href="#DelaunayTriangulation.each_point_index"><code>DelaunayTriangulation.each_point_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_point_index(pts::P) where {P}</code></pre><p>Given a collection of points <code>pts</code>, returns an iterator  over the indices of the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_point_index(pts::AbstractVector)
each_point_index(pts::AbstractMatrix)</code></pre><p>with the first returning <code>eachindex(pts)</code> and the second  returning <code>axes(pts, 2)</code>. You can extend this function  as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L125-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point" href="#DelaunayTriangulation.each_point"><code>DelaunayTriangulation.each_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_point(pts::P) where {p}</code></pre><p>For a given collection of points <code>p</code>, returns an iterator that  goes over each point in the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_point(pts::AbstractVector)
each_point(pts::AbstractMatrix)</code></pre><p>with the first method simply returning <code>pts</code>, and the second returning  <code>eachcol(pts)</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L146-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_points" href="#DelaunayTriangulation.num_points"><code>DelaunayTriangulation.num_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_points(pts)</code></pre><p>Returns the number of points in <code>pts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.number_type" href="#DelaunayTriangulation.number_type"><code>DelaunayTriangulation.number_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_type(x)</code></pre><p>Given a container <code>x</code>, returns the number type used for storing coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/utils.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.push_point!" href="#DelaunayTriangulation.push_point!"><code>DelaunayTriangulation.push_point!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push_point!(pts, x, y)</code></pre><p>Pushes the point <code>(x, y)</code> into <code>pts</code>. The only methods currently  defined are  </p><pre><code class="nohighlight hljs">push_point!(pts::AbstractVector{T}, x, y) where {F,T&lt;:NTuple{2,F}} = push!(pts, (F(x), F(y)))
push_point!(pts::AbstractVector{T}, x, y) where {F&lt;:Number,T&lt;:AbstractVector{F}} = push!(pts, F[x, y])</code></pre><p>You can extend this function as needed. We also provide the method </p><pre><code class="nohighlight hljs">push_point!(pts, p) = push_point!(pts, getx(p), gety(p))</code></pre><p>which you can extend if you have a point type <code>p</code> that has <code>getx</code> and <code>gety</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L209-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.pop_point!" href="#DelaunayTriangulation.pop_point!"><code>DelaunayTriangulation.pop_point!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop_point!(pts)</code></pre><p>Pops the last point from <code>pts</code>. The only method currently defined is</p><pre><code class="nohighlight hljs">pop_point!(pts::AbstractVector) = pop!(pts)</code></pre><p>You can extend this function as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L233-L241">source</a></section></article><h3 id="Generic-Methods-2"><a class="docs-heading-anchor" href="#Generic-Methods-2">Generic Methods</a><a class="docs-heading-anchor-permalink" href="#Generic-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_point" href="#DelaunayTriangulation.get_point"><code>DelaunayTriangulation.get_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_point(pts::P, i...)</code></pre><p>Given a collection of points <code>pts</code>, returns the points  corresponding to the indices in <code>i...</code>. This simply  calls <a href="#DelaunayTriangulation.getpoint"><code>getpoint</code></a> - you do not need to  extend this method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.points_are_unique" href="#DelaunayTriangulation.points_are_unique"><code>DelaunayTriangulation.points_are_unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points_are_unique(pts)</code></pre><p>Returns <code>true</code> if <code>pts</code> has no duplicate points, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.lexicographic_order" href="#DelaunayTriangulation.lexicographic_order"><code>DelaunayTriangulation.lexicographic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lexicographic_order(pts)</code></pre><p>Returns a set of indices <code>idx</code> that gives the lexicographic ordering  of the set of points <code>pts</code>, i.e. sorting by <code>x</code> and then sorting points  with duplicate <code>x</code>-coordinates by <code>y</code>. The implementation is simply </p><pre><code class="nohighlight hljs">lexicographic_order(pts) = (sortperm ∘ collect ∘ each_point)(pts)</code></pre><p>which you might want to specialise for an easier representation of your  points <code>pts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/609621584ef399014f697fd672c0a0a8ba08d26c/src/interfaces/points.jl#L194-L205">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../edges/">« Edges</a><a class="docs-footer-nextpage" href="../boundary_nodes/">Boundary Nodes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 16 April 2023 11:24">Sunday 16 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
