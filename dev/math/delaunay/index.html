<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Delaunay Triangulations · DelaunayTriangulation.jl</title><meta name="title" content="Delaunay Triangulations · DelaunayTriangulation.jl"/><meta property="og:title" content="Delaunay Triangulations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Delaunay Triangulations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/delaunay/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/delaunay/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/delaunay/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Delaunay Triangulations</a><ul class="internal"><li><a class="tocitem" href="#Triangulations"><span>Triangulations</span></a></li><li><a class="tocitem" href="#Delaunay-Property"><span>Delaunay Property</span></a></li><li><a class="tocitem" href="#Bowyer-Watson-Algorithm"><span>Bowyer-Watson Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Delaunay Triangulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Delaunay Triangulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/delaunay.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Delaunay-Triangulations"><a class="docs-heading-anchor" href="#Delaunay-Triangulations">Delaunay Triangulations</a><a id="Delaunay-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Delaunay-Triangulations" title="Permalink"></a></h1><h2 id="Triangulations"><a class="docs-heading-anchor" href="#Triangulations">Triangulations</a><a id="Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulations" title="Permalink"></a></h2><p>We start this section by introducing what Delaunay triangulations actually are. To precisely define a Delaunay triangulation first requires a few other definitions, so we will spare some of these exact details. Roughly speaking, a <em>triangulation</em> is a partition of a set of points <span>$\mathcal P \subseteq \mathbb R^2$</span> in the plane into non-overlapping triangles, such that the union of the triangles is the <em>convex hull</em> of the points and any two triangles intersect either at a common edge or not at all.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> Here, a <em>convex hull</em> is the smallest convex set containing all the points. We will use <span>$\mathcal T(\mathcal P)$</span> to denote any triangulation of <span>$\mathcal P$</span>, and <span>$\mathcal C\mathcal H(\mathcal P)$</span> to denote the convex hull of <span>$\mathcal P$</span>. It is possible to show that any given <span>$\mathcal P$</span> will have a triangulation.</p><h2 id="Delaunay-Property"><a class="docs-heading-anchor" href="#Delaunay-Property">Delaunay Property</a><a id="Delaunay-Property-1"></a><a class="docs-heading-anchor-permalink" href="#Delaunay-Property" title="Permalink"></a></h2><p>There are several ways to motivate the Delaunay property, but here we will just skip straight to the definition. We have two definitions to make first, relative to some point set <span>$\mathcal P$</span>:</p><ol><li>A triangle <span>$T$</span> is said to be <em>Delaunay</em> if its open circumcircle contains no points of <span>$\mathcal P$</span> in its interior. Note that this does not prohibit points from being on the boundary of the circumcircle.</li><li>An edge <span>$e$</span> is said to be <em>Delaunay</em> if its diametral circle contains no points of <span>$\mathcal P$</span> in its interior. Here, the diametral circle of an edge <span>$e$</span> is the circle whose diameter is the edge <span>$e$</span>.</li></ol><p>With these definitions, we say that a triangulation <span>$\mathcal T(\mathcal P)$</span> is a <em>Delaunay triangulation</em>, and write <span>$\mathcal D\mathcal T(\mathcal P)$</span>, if each triangle <span>$T \in \mathcal T(\mathcal P)$</span> is Delaunay. Note that <span>$\mathcal D\mathcal T(\mathcal P)$</span> is not necessarily unique if there are cocircular vertices. If we adjust the above definitions to instead require that the closed circumcircles contain no points in <span>$\mathcal P$</span> other than those from <span>$T$</span>, meaning <span>$T$</span> is <em>strongly Delaunay</em>, then the triangulation would instead be unique. It is possible to show the following fact, known as the <em>Delaunay lemma</em>: Given a triangulation <span>$\mathcal T(\mathcal P)$</span> of a point set, the following three statements are equivalent:</p><ul><li>We have <span>$\mathcal T(\mathcal P) = \mathcal D\mathcal T(\mathcal P)$</span>.</li><li>Every edge in <span>$\mathcal T$</span> is Delaunay.</li><li>Every edge in <span>$\mathcal T$</span> is locally Delaunay. Here, <em>locally Delaunay</em> means that <span>$e$</span> is either (1) an edge of fewer than two triangles in <span>$\mathcal T$</span>, or (2) an edge of exactly two triangles <span>$T_1$</span> and <span>$T_2$</span> and the open circumcircle of <span>$T_2$</span> contains no vertex of <span>$T_1$</span>.</li></ul><p>Below we show an example of Delaunay triangulation.</p><img src="ff79ca87.png" alt="Example block output"/><p>We can see that the circumcircles of the triangles contain no points in their interior. This is a Delaunay triangulation.</p><h2 id="Bowyer-Watson-Algorithm"><a class="docs-heading-anchor" href="#Bowyer-Watson-Algorithm">Bowyer-Watson Algorithm</a><a id="Bowyer-Watson-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Bowyer-Watson-Algorithm" title="Permalink"></a></h2><p>Let us now discuss how we actually construct a Delaunay triangulation. The algorithm we use is the famous Bowyer-Watson algorithm, an incremental algorithm that builds the Delaunay triangulation one at a time. Suppose we have started with some initial triangulation <span>$\mathcal D\mathcal T(\mathcal P_0)$</span>, where <span>$\mathcal P_0 \subseteq \mathcal P$</span>, and we want to add in some point <span>$p$</span>, giving <span>$\mathcal D\mathcal T(\mathcal P_0 \cup \{p\})$</span>. To do this, we:</p><ol><li>Find one triangle whose open circumdisk contains <span>$p$</span>.</li><li>Find all the other triangles by a depth-first search in the triangulation.</li><li>Delete all the triangles containing <span>$p$</span> in their circumcircle, leaving behind a polyhedral cavity.</li><li>For each edge of this cavity, adjoin the vertices to <span>$p$</span> to create a new triangle.</li></ol><p>This procedure will give us <span>$\mathcal D\mathcal T(\mathcal P_0 \cup \{p\})$</span>. Let&#39;s consider an example of this procedure. </p><img src="fa44eabb.png" alt="Example block output"/><p>In the above figure, we are considering insertion the red point into the triangulation. We then then all triangles whose circumcircles contain this red point, shown in blue. Deleting these triangles leaves behind a cavity shown in the third figure. Finally, connecting the vertices of the cavity to the red point gives the final triangulation.</p><p>Of course, this procedure is hiding away many important details and leaves more questions than answers:</p><ul><li>How do we find a triangle containing the point in its circumdisk?</li><li>How do we perform a depth-first search to find all the triangles?</li><li>How do we determine if a point is inside a circumcircle?</li><li>What happens if the point is outside of the triangulation?</li><li>How do we initialise the triangulation?</li></ul><p>Let&#39;s address all these questions.</p><h3 id="Point-Location"><a class="docs-heading-anchor" href="#Point-Location">Point Location</a><a id="Point-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Location" title="Permalink"></a></h3><p>The problem of finding a triangle containing a point in its circumdisk is related to <em>point location</em>. Here, our point location problem is: Given a point <span>$p$</span>, find a triangle <span>$T \in \mathcal D\mathcal T(\mathcal P)$</span> containing <span>$p$</span>; note that finding a triangle containing <span>$p$</span> will be the same as finding a triangle containing <span>$p$</span> in its circumdisk. We use a <em>jump and march</em> algorithm for this, following the work of <a href="https://doi.org/10.1016/S0925-7721(98)00035-2">Mücke et al. (1999)</a>. The basic idea is simple: To find a triangle <span>$T$</span> containing a point <span>$p$</span>, start from some point <span>$q$</span> and walk along the triangulation in the direction of the line <span>$qp$</span> until such a triangle is found. here is an example:</p><img src="f0a4d416.png" alt="Example block output"/><p>The algorithm draws a line connecting some initial point <span>$q$</span> and the search point <span>$p$</span>, as shown in red, and then marches along triangles until <span>$p$</span> is found, traversing the blue triangles shown above. </p><h3 id="Depth-First-Search"><a class="docs-heading-anchor" href="#Depth-First-Search">Depth-First Search</a><a id="Depth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-First-Search" title="Permalink"></a></h3><p>We also need to discuss how a depth-first search is used to find all the triangles containing the point <span>$p$</span> in their circumcircles, using the triangle <span>$T$</span> found from point location for initialising the search. The idea is reasonably simple. Let&#39;s consider a single edge of <span>$T = T_{ijk}$</span>, say <span>$e_{ij}$</span>, assuming for now that <span>$e_{ij}$</span> is not a boundary edge so that there exists a triangle <span>$T_{ji\ell}$</span> that adjoins <span>$e_{ij}$</span>. If the circumcircle of <span>$T_{ji\ell}$</span> contains <span>$p$</span>, then in addition to deleting <span>$T_{ijk}$</span> from the triangulation we also know that <span>$T_{ji\ell}$</span> can be deleted. If instead <span>$T_{ji\ell}$</span> does not contain <span>$p$</span> in its circumcircle, we know that <span>$e_{ij}$</span> is an edge of the final cavity and we can thus add <span>$T_{ijr}$</span> to the triangulation, where <span>$r$</span> is the vertex associated with the point <span>$p$</span>. We apply this method of searching across edges to each other edge of <span>$T_{ijk}$</span>, and then to each edge of the triangles found in these searches, until all triangles containing <span>$p$</span> in their circumcircles are found.</p><p>The problem of finding the vertex <span>$\ell$</span> is also an important issue. To address this, we define a map <span>$\mathcal A \colon \mathcal E \to \mathcal V$</span>, called the adjacent map, that takes an edge <span>$e_{ij}$</span> to a vertex <span>$\ell$</span> such that <span>$T_{ij\ell}$</span> is a triangle in the triangulation. This map is used to find the vertex <span>$\ell$</span> in the above search. We define <span>$\mathcal A(e_{ij}) = \emptyset$</span> if there is no such <span>$\ell$</span>.</p><p>Let us now make this search algorithm more concrete. In code, omitting many details, we could implement this as </p><pre><code class="language-julia hljs">function add_point!(pᵣ,  Tᵢⱼₖ)
    delete_triangle!(Tᵢⱼₖ)
    dig_cavity!(pᵣ, eᵢⱼ)
    dig_cavity!(pᵣ, eⱼₖ)
    dig_cavity!(pᵣ, eₖᵢ)
    return
end
function dig_cavity!(pᵣ, eᵢⱼ)
    ℓ = get_adjacent(eⱼᵢ)
    x === ∅ &amp;&amp; return # the triangle was already deleted 
    if in_circle(pᵣ, Tᵢⱼₗ) # Tᵢⱼₖ and Tⱼᵢₗ are not Delaunay 
        delete_triangle!(Tⱼᵢₗ)
        dig_cavity!(pᵣ, eᵢₗ)
        dig_cavity!(pᵣ, eₗⱼ)
    else # eᵢⱼ is an edge of the polygonal cavity 
        add_triangle!(Tᵣᵢⱼ)
    end 
    return
end</code></pre><h3 id="Incircle-Predicate"><a class="docs-heading-anchor" href="#Incircle-Predicate">Incircle Predicate</a><a id="Incircle-Predicate-1"></a><a class="docs-heading-anchor-permalink" href="#Incircle-Predicate" title="Permalink"></a></h3><p>To determine if a point is inside a triangle&#39;s circumcircle, we need to use a predicate. The <code>in_circle</code> predicate is used for this. In particular:</p><p class="math-container">\[\text{in_circle}(a, b, c, d) = \begin{vmatrix} a_x &amp; a_y &amp; a_x^2 + a_y^2 &amp; 1 \\ b_x &amp; b_y &amp; b_x^2 + b_y^2 &amp; 1 \\ c_x &amp; c_y &amp; c_x^2 + c_y^2 &amp; 1 \\ d_x &amp; d_y &amp; d_x^2 + d_y^2 &amp; 1 \end{vmatrix} \]</p><p>can be used to determine the position of a point <span>$d$</span> relative to a triangle <span>$T_{abc}$</span>&#39;s circumcircle: If the determinant is positive, then <span>$d$</span> is inside the circumcircle; if it is negative, then <span>$d$</span> is outside the circumcircle; and if it is zero, then <span>$d$</span> is on the circumcircle. This predicate is used in the above search algorithm to determine if a point is inside a circumcircle. We use <a href="https://github.com/lairez/ExactPredicates.jl">ExactPredicates.jl</a> for this predicate.</p><h3 id="Exterior-Points"><a class="docs-heading-anchor" href="#Exterior-Points">Exterior Points</a><a id="Exterior-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Exterior-Points" title="Permalink"></a></h3><p>When a point is outside of the triangulation, notice that there will be no triangle containing <span>$p$</span>, and so our point location step will fail. To overcome this, we need what is known as a <em>ghost vertex</em>, which is a point out at infinity that all edges on the boundary share an edge with. In order for us to work with this, we need to understand how to treat the circumcircle of such a triangle with a point out at infinity, called a <em>ghost vertex</em>. Let <span>$g$</span> denote the ghost vertex, and let <span>$T_{ijg}$</span> be a ghost triangle. To get this triangle&#39;s circumcircle, imagine some point on the side of <span>$e_{ij}$</span> and dragging it slowly out to infinity. In the limit, the circle eventually becomes a straight line, and so the circumcircle of <span>$T_{ijg}$</span> should be considered as the <em>oriented outer halfplane</em> of <span>$e_{ij}$</span>: The union of the halfplane on the side of <span>$e_{ij}$</span> away from the triangulation&#39;s interior and the open edge <span>$e_{ij}$</span>. Using this definition, we can say that a ghost triangle <span>$T_{ijg}$</span> should be deleted if <span>$p$</span> falls in the oriented outer halfplane of <span>$e_{ij}$</span>. To determine this position, we can use the <code>orient</code> predicate, defined as:</p><p class="math-container">\[\text{orient}(a, b, c) = \begin{vmatrix} a_x &amp; a_y &amp; 1 \\ b_x &amp; b_y &amp; 1 \\ c_x &amp; c_y &amp; 1 \end{vmatrix}\]</p><p>which says that <span>$c$</span> is on the right of the line <span>$ab$</span> if the determinant is positive, on the left if it is negative, and on the line if it is zero. </p><p>Let us consider an example.</p><img src="1826e0ff.png" alt="Example block output"/><p>In this example, we are interested in the ghost triangle associated with the blue edge. The oriented outer halfplane for this edge can be defined simply as <span>$H = \{(x, y) ∈ \mathbb R^2 : y &gt; 1\} ∪ \{(x, y) ∈ \mathbb R^2 : 0 &lt; x &lt; 1, y = 1\}$</span>. Using this definition, we see that the red point is not in <span>$H$</span>, the magenta point is in <span>$H$</span> (in fact, it is exactly on <span>$\partial H$</span>, where <span>$\partial H$</span> denotes the boundary of <span>$H$</span>), the black point is in <span>$H$</span>, and the green point is not in <span>$H$</span>.</p><p>Now that we have a way of identifying when ghost triangles should be deleted, we need a way to uniquely associate an exterior point with a ghost triangle. To do this, we associate with the triangulation a central point, typically the centroid when the triangulation is constructed, that each ghost edge <span>$e_{ig}$</span> is oriented with. In particular, take some vertex <span>$v_i$</span> on the boundary of the triangulation so that <span>$e_{ig}$</span> is a ghost edge. We treat the ghost edge <span>$e_{ig}$</span> as a ray emnating from <span>$p_i$</span> out to infinity, oriented in the direction of the central point. Using this definition, we are able to split the region of space outside of the triangulation into a non-overlapping set of convex sets. Consider the example below:</p><img src="eedda4a0.png" alt="Example block output"/><p>The ghost edges are the blue lines, and the central point is the red dot. With this definition, we therefore see that we can uniquely each region in space with a triangle - be it a ghost triangle or a real (solid) triangle.</p><h3 id="Initialising-the-Triangulation"><a class="docs-heading-anchor" href="#Initialising-the-Triangulation">Initialising the Triangulation</a><a id="Initialising-the-Triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-Triangulation" title="Permalink"></a></h3><p>The initialisation of the triangulation is simple. We pick three points <span>$p_i$</span>, <span>$p_j$</span>, and <span>$p_k$</span> at random, ordering them so that they define a positively oriented triangle. We add <span>$T_{ijk}$</span> into the triangulation, initialise the adjacent map <span>$\mathcal A$</span>, add the ghost triangles <span>$T_{jig}$</span>, <span>$T_{kij}$</span>, and <span>$T_{kji}$</span>, and initialise the central point as <span>$c = (p_i + p_j + p_k) / 3$</span>.</p><h3 id="Putting-Everything-Together"><a class="docs-heading-anchor" href="#Putting-Everything-Together">Putting Everything Together</a><a id="Putting-Everything-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-Everything-Together" title="Permalink"></a></h3><p>Now having all these pieces of the algorithm together, the Bowyer-Watson algorithm can be implemented. The order of the points that we insert into the triangulation is random. Rather than rewrite the algorithm, we just note that the simple description we initially gave is still accurate, but of course the internal details have a lot of complications.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This is not the only possible definition of a triangulation. We could also define <span>$\mathcal T(\mathcal P)$</span> to be a maximal planar subdivision whose vertex set is <span>$\mathcal P$</span>, where a maximal planar subdivision is a planar graph such that no edge can be added without intersecting other existing edges. With this definition though, there is some extra work to be done to show that the boundary of <span>$\mathcal T(\mathcal P)$</span> is indeed <span>$\mathcal C\mathcal H(\mathcal P)$</span>. To see this, take some edge <span>$e_{ij}$</span> on the boundary <span>$\mathcal T(\mathcal P)$</span>. To argue that <span>$e_{ij}$</span> is on the boundary of <span>$\mathcal C\mathcal H(\mathcal P)$</span>, we argue by contradiction. Suppose that <span>$e_{ij}$</span> is not on the boundary of <span>$\mathcal C\mathcal H(\mathcal P)$</span>. Then either <span>$e_{ij}$</span> is inside of <span>$\mathcal C\mathcal H(\mathcal P)$</span>, or it is on the outside. It of course cannot be outside of <span>$\mathcal C\mathcal H(\mathcal P)$</span> since there would have to be some edge <span>$e_{kl}$</span> that is inside of <span>$\mathcal C\mathcal H(\mathcal P)$</span> that intersects <span>$e_{ij}$</span>, which is a contradiction to the maximal planarity. So, <span>$e_{ij}$</span> has to be inside. This implies that there is some space to the side of <span>$\mathcal T(\mathcal P)$</span> near <span>$e_{ij}$</span> that is not contained inside <span>$\mathcal C\mathcal H(\mathcal P)$</span>, but this implies that there is a line segment that would have to go outside of the convex hull, which is a contradiction. Thus, <span>$e_{ij}$</span> must be on the boundary, and so each edge of <span>$\mathcal T(\mathcal P)$</span>&#39;s boundary is on the boundary of <span>$\mathcal C\mathcal H(\mathcal P)$</span>, meaning <span>$\partial\mathcal T(\mathcal P) = \mathcal C\mathcal H(\mathcal P)$</span>, where <span>$\partial\mathcal T(\mathcal P)$</span> is the boundary of <span>$\mathcal T(\mathcal P)$</span>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../constrained/">Constrained Delaunay Triangulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 02:18">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
