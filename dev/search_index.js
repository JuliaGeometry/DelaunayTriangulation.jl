var documenterSearchIndex = {"docs":
[{"location":"extended/utils/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"extended/utils/","page":"Utility Functions","title":"Utility Functions","text":"This section lists some of the internal utility functions, or other miscellaneous functions, used in this package.","category":"page"},{"location":"extended/utils/#DelaunayTriangulation.number_type-extended-utils","page":"Utility Functions","title":"DelaunayTriangulation.number_type","text":"number_type(x) -> DataType\n\nGiven a container x, returns the number type used for storing coordinates.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.number_type([1, 2, 3])\nInt64\n\njulia> DelaunayTriangulation.number_type((1, 2, 3))\nInt64\n\njulia> DelaunayTriangulation.number_type([1.0 2.0 3.0; 4.0 5.0 6.0])\nFloat64\n\njulia> DelaunayTriangulation.number_type([[[1, 2, 3, 4, 5, 1]], [[6, 8, 9], [9, 10, 11], [11, 12, 6]]])\nInt64\n\njulia> DelaunayTriangulation.number_type((1.0f0, 2.0f0))\nFloat32\n\njulia> DelaunayTriangulation.number_type(Vector{Float64})\nFloat64\n\njulia> DelaunayTriangulation.number_type(Vector{Vector{Float64}})\nFloat64\n\njulia> DelaunayTriangulation.number_type(NTuple{2, Float64})\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation._to_val-Tuple{V} where V","page":"Utility Functions","title":"DelaunayTriangulation._to_val","text":"_to_val(v) -> Val\n\nWraps v in a Val, or if v isa Val simply returns v.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.adjust_θ-Tuple{Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.adjust_θ","text":"adjust_θ(θ₁, θ₂, positive) -> (Number, Number)\n\nGiven two angles θ₁ and θ₂ in radians, adjusts the angles to new angles θ₁′, θ₂′ so that  θ₁′ ≤ θ₂′ if positive is true, and θ₁′ ≥ θ₂′ if positive is false.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.check_absolute_precision-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.check_absolute_precision","text":"check_absolute_precision(x, y) -> Bool\n\nReturns true if abs(x - y) is less than or equal to sqrt(eps(Float64)).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.check_precision-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.check_precision","text":"check_precision(x) -> Bool\n\nReturns true if abs(x) is less than or equal to sqrt(eps(number_type(eps))).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.check_ratio_precision-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.check_ratio_precision","text":"check_ratio_precision(x, y) -> Bool\n\nReturns true if abs(x/y) is bounded between 0.99 and 1.01.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.check_relative_precision-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.check_relative_precision","text":"check_relative_precision(x, y) -> Bool\n\nReturns true if abs(x - y)/max(abs(x), abs(y)) is less than or equal to sqrt(eps(Float64)).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.choose_uvw-NTuple{6, Any}","page":"Utility Functions","title":"DelaunayTriangulation.choose_uvw","text":"choose_uvw(e1, e2, e3, u, v, w) -> (Vertex, Vertex, Vertex)\n\nChoose values for (u, v, w) based on the Booleans (e1, e2, e3),  assuming only one is true. The three cases are: \n\nIf e1, returns (u, v, w).\nIf e2, returns (v, w, u).\nIf e3, returns (w, u, v).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.circular_equality-Union{Tuple{F}, Tuple{Any, Any}, Tuple{Any, Any, F}} where F","page":"Utility Functions","title":"DelaunayTriangulation.circular_equality","text":"circular_equality(A, B, by=isequal) -> Bool\n\nCompares the two circular vectors A and B for equality up to circular rotation,  using by to compare individual elements.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.dist-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.dist","text":"dist(p, q) -> Number\n\nAssuming p and q are two-dimensional, computes the Euclidean distance between p and q.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.dist-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.dist","text":"dist(tri::Triangulation, p) -> Number\n\nGiven a point p, returns the distance from p to the triangulation, using the  conventions from distance_to_polygon:\n\nδ > 0: If the returned distance is positive, then p is inside the triangulation.\nδ < 0: If the returned distance is negative, then p is outside the triangulation.\nδ = 0: If the returned distance is zero, then p is on the boundary of the triangulation.\n\nWhere we say distance, we are referring to the distance from p to the boundary of the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.dist_sqr-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.dist_sqr","text":"dist_sqr(p, q) -> Number\n\nAssuming p and q are two-dimensional, computes the square of the Euclidean distance between p and q.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.edge_length","page":"Utility Functions","title":"DelaunayTriangulation.edge_length","text":"edge_length(tri::Triangulation, u, v) -> Number\nedge_length(tri::Triangulation, e) -> Number\n\nComputes the length of the edge e = (u, v).\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.edge_length_sqr-Tuple{Triangulation, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.edge_length_sqr","text":"edge_length_sqr(tri::Triangulation, u, v) -> Number\nedge_length_sqr(tri::Triangulation, e) -> Number\n\nComputes the square of the length of the edge e = (u, v).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.eval_fnc_at_het_tuple_element-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Any}} where {F, T}","page":"Utility Functions","title":"DelaunayTriangulation.eval_fnc_at_het_tuple_element","text":"eval_fnc_at_het_tuple_element(f, tup, idx)\n\nEvaluates f(tup[idx]) in a type-stable way. If idx > length(tup), then f is evaluated on the last element of tup. If length(tup) > 32, then the function is not type-stable; note that, in this case, idx > length(tup) leads to a BoundsError.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.eval_fnc_at_het_tuple_element_with_arg-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Any, Any}} where {F, T}","page":"Utility Functions","title":"DelaunayTriangulation.eval_fnc_at_het_tuple_element_with_arg","text":"eval_fnc_at_het_tuple_element_with_arg(f, tup, arg, idx)\n\nEvaluates f(tup[idx], arg...) in a type-stable way. If idx > length(tup), then f is evaluated on the last element of tup. If length(tup) > 32, then the function is not type-stable; note that, in this case, idx > length(tup) leads to a BoundsError.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.eval_fnc_at_het_tuple_element_with_arg_and_prearg-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Any, Any, Any}} where {F, T}","page":"Utility Functions","title":"DelaunayTriangulation.eval_fnc_at_het_tuple_element_with_arg_and_prearg","text":"eval_fnc_at_het_tuple_element_with_arg_and_prearg(f, tup, prearg, arg, idx)\n\nEvaluates f(prearg, tup[idx], arg...) in a type-stable way. If idx > length(tup), then f is evaluated on the last element of tup. If length(tup) > 32, then the function is not type-stable; note that, in this case, idx > length(tup) leads to a BoundsError.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.eval_fnc_at_het_tuple_two_elements-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Any, Any}} where {F, T<:Tuple}","page":"Utility Functions","title":"DelaunayTriangulation.eval_fnc_at_het_tuple_two_elements","text":"eval_fnc_at_het_tuple_two_elements(f, tup, idx1, idx2)\n\nEvaluates f(tup[idx1], tup[idx2]) in a type-stable way. If length(tup) > 32, then the function is not type-stable.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.eval_fnc_in_het_tuple-Union{Tuple{A}, Tuple{T}, Tuple{T, A, Any}} where {T, A}","page":"Utility Functions","title":"DelaunayTriangulation.eval_fnc_in_het_tuple","text":"eval_fnc_in_het_tuple(tup, arg, idx)\n\nEvaluates tup[idx](arg...) in a type-stable way. If idx > length(tup), then tup[end](arg...) is evaluated.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_area-Tuple{Triangulation}","page":"Utility Functions","title":"DelaunayTriangulation.get_area","text":"get_area(tri::Triangulation) -> Number\n\nReturns the area of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_boundary_chain-Tuple{Triangulation, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.get_boundary_chain","text":"get_boundary_chain(tri::Triangulation, i, j) -> Edges\n\nGiven two boundary vertices i and j on a boundary with ghost vertex ghost_vertex,  walks counter-clockwise from i to j along the boundary and returns the collection of all vertices encountered in  counter-clockwise order.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_ghost_vertex","page":"Utility Functions","title":"DelaunayTriangulation.get_ghost_vertex","text":"get_ghost_vertex(i, j, k) -> Vertex\nget_ghost_vertex(i, j) -> Vertex\n\nGiven three vertices i, j, and k, returns the ghost vertex among them. If none of them are ghost vertices, returns k. The two-argument version is equivalent to get_ghost_vertex(i, j, j).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_ghost_vertex(1, 7, -2)\n-2\n\njulia> DelaunayTriangulation.get_ghost_vertex(-1, 2, 3)\n-1\n\njulia> DelaunayTriangulation.get_ghost_vertex(1, 5, 10)\n10\n\njulia> DelaunayTriangulation.get_ghost_vertex(1, -1)\n-1\n\njulia> DelaunayTriangulation.get_ghost_vertex(-5, 2)\n-5\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.get_ordinal_suffix-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.get_ordinal_suffix","text":"get_ordinal_suffix(i) -> String\n\nReturns the ordinal suffix for the integer i. \n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_ordinal_suffix(1)\n\"st\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(2)\n\"nd\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(3)\n\"rd\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(4)\n\"th\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(5)\n\"th\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(6)\n\"th\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(11)\n\"th\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(15)\n\"th\"\n\njulia> DelaunayTriangulation.get_ordinal_suffix(100)\n\"th\"\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_circular-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_circular","text":"is_circular(A) -> Bool\n\nTests if A is circular, meaning that A[begin] == A[end].\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_true","page":"Utility Functions","title":"DelaunayTriangulation.is_true","text":"is_true(b) -> Bool\n\nReturns b represents a true value, and false otherwise.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.is_true(true)\ntrue\n\njulia> DelaunayTriangulation.is_true(false)\nfalse\n\njulia> DelaunayTriangulation.is_true(Val(true))\ntrue\n\njulia> DelaunayTriangulation.is_true(Val(false))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.iterated_neighbourhood-Tuple{Triangulation, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.iterated_neighbourhood","text":"iterated_neighbourhood(tri::Triangulation, i, d) -> Set{Vertex}\n\nReturns the set of vertices of tri in the iterated neighbourhood of the vertex i of depth d. \n\nExtended help\n\nThe d-times iterated neighbourhood is defined by \n\nN_i^d = bigcup_j in N_i^d-1 N_j setminus i\n\nwhere N_i^1 = N_i is the set of neighbours of i.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.midpoint-Tuple{Number, Number}","page":"Utility Functions","title":"DelaunayTriangulation.midpoint","text":"midpoint(p, q) -> Number or NTuple{2, Number}\n\nAssuming p and q are either both numbers are both 2-vectors, computes their average.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.midpoint-Tuple{Triangulation, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.midpoint","text":"midpoint(tri::Triangulation, u, v) -> NTuple{2, Number}\nmidpoint(tri::Triangulation, e) -> NTuple{2, Number}\n\nComputes the midpoint of e = (u, v).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.nextindex_circular-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.nextindex_circular","text":"nextindex_circular(C, i) -> Integer\n\nReturns the next index after i in the circular vector C. \n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.norm-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.norm","text":"norm(p) -> Number\n\nAssuming p is two-dimensional, computes the Euclidean norm of p.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.norm_sqr-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.norm_sqr","text":"norm_sqr(p) -> Number\n\nAssuming p is two-dimensional, computes the square of the Euclidean norm of p.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.previndex_circular-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.previndex_circular","text":"previndex_circular(C, i) -> Integer\n\nReturns the previous index before i in the circular vector C.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle","text":"replace_boundary_triangle_with_ghost_triangle(tri::Triangulation, V) -> Triangle\n\nGiven a boundary triangle V of tri, returns the adjacent ghost triangle. Note that  for triangles in a corner of a domain, like a lattice triangulation, there are two choices  of ghost triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.replace_ghost_triangle_with_boundary_triangle-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.replace_ghost_triangle_with_boundary_triangle","text":"replace_ghost_triangle_with_boundary_triangle(tri::Triangulation, V) -> Triangle\n\nGiven a ghost triangle V of tri, returns the adjacent boundary triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.self_eval-Tuple{Any, Vararg{Any}}","page":"Utility Functions","title":"DelaunayTriangulation.self_eval","text":"self_eval(f, args...)\n\nEvaluates f(args...).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.uniquetol-Tuple{Vector{Float64}}","page":"Utility Functions","title":"DelaunayTriangulation.uniquetol","text":"uniquetol(A::Vector{Float64}; tol=1e-12) -> Vector{Float64}\n\nReturns the unique elements of A up to tolerance tol. We say that two values x and y are within tolerance if abs(u - v) ≤ M*tol, where M = maximum(abs.(A)). It  is assumed that A is sorted - this is NOT checked.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.angle_between-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.angle_between","text":"angle_between(p, q) -> Number\n\nReturns the angle between the vectors p and q in radians, treating q as the base. See this article. The returned angle is in [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.classify_and_compute_segment_intersection-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Vararg{Any, 4}}","page":"Utility Functions","title":"DelaunayTriangulation.classify_and_compute_segment_intersection","text":"classify_and_compute_segment_intersection([kernel::AbstractPredicateKernel,] a, b, c, d) -> (Certificate, Certificate, Certificate, NTuple{2, Number})\n\nGiven two line segments (a, b) and (c, d), classifies the intersection of the two segments. The returned value is (cert, cert_c, cert_d, p), where:\n\ncert: A Certificate indicating the intersection type.\ncert_c: A Certificate indicating the position of c relative to the line through (a, b).\ncert_d: A Certificate indicating the position of d relative to the line through (a, b).\np: The intersection point if cert is Cert.Single or Cert.Touching, and (NaN, NaN) otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.distance_to_polygon-Tuple{Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.distance_to_polygon","text":"distance_to_polygon(q, points, boundary_nodes) -> Number\n\nGiven a query point q and a polygon defined by (points, boundary_nodes), returns the signed distance from q to the polygon. The boundary_nodes must match the specification in the documentation and in check_args.\n\nSee also dist.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_distance_to_plane-NTuple{4, Tuple}","page":"Utility Functions","title":"DelaunayTriangulation.get_distance_to_plane","text":"get_distance_to_plane(a, b, c, p) -> Number\n\nReturns the distance from the point p to the plane defined by the points  (a, b, c). The distance is positive if p is above the plane.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_plane_through_three_points-Tuple{Tuple, Tuple, Tuple}","page":"Utility Functions","title":"DelaunayTriangulation.get_plane_through_three_points","text":"get_plane_through_three_points(a, b, c) -> NTuple{4, Number}\n\nGiven three points (a, b, c) in ℝ³ represented as Tuples, computes the equation of the plane  through the points. The result is given in the form (α, β, γ, δ), so that the plane  is given by \n\nαx + βy + γz + δ = 0.\n\nExtended help\n\nThe equation of the plane is computed by expanding the equation \n\ndet beginbmatrix x  y  z  1  a_x  a_y  a_z  1  b_x  b_y  b_z  1  c_x  c_y  c_z  1 endbmatrix = 0\n\nFrom this, we find:\n\nbeginalign*\nalpha = a_y b_z - a_z b_y - a_y c_z + a_z c_y + b_y c_z - b_z c_y \nbeta = a_z b_x - a_x b_z + a_x c_z - a_z c_x - b_x c_z + b_z c_x \ngamma = a_x b_y - a_y b_x - a_x c_y + a_y c_x + b_x c_y - b_y c_x \ndelta = a_x b_z c_y - a_x b_y c_z + a_y b_x c_z - a_y b_z c_x - a_z b_x c_y + a_z b_y c_x\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_steepest_descent_direction-Tuple{Tuple, Tuple, Tuple}","page":"Utility Functions","title":"DelaunayTriangulation.get_steepest_descent_direction","text":"get_steepest_descent_direction(a, b, c) -> NTuple{2, Number}\n\nGiven three points in ℝ³ defining a plane, returns the direction (x, y) of the steepest descent along the plane. In particular, if \n\nαx + βy + γz + δ = 0\n\nis the plane, then the steepest descent direction is (α, β)/γ. The returned  value is given by (x, y) = sign(γ)(α, β).\n\nSee also get_plane_through_three_points.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.get_vertical_distance_to_plane-NTuple{4, Tuple}","page":"Utility Functions","title":"DelaunayTriangulation.get_vertical_distance_to_plane","text":"get_vertical_distance_to_plane(a, b, c, p) -> Number\n\nReturns the vertical distance from the point p to the plane defined by the points  (a, b, c). The distance is positive if p is above the plane.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.intersection_of_edge_and_bisector_ray-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.intersection_of_edge_and_bisector_ray","text":"intersection_of_edge_and_bisector_ray([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, c; project=false) -> (Certificate, NTuple{2, Number})\n\nGiven an edge (a, b) and a ray emanating from c perpendicular with the edge and collinear with its midpoint (or, if project=true, the projection of c onto the edge), tests if c intersects the edge. The returned value is (cert, p), where:\n\ncert: A Certificate indicating the position of c relative to the line through (a, b).\np: The intersection point if c intersects the edge, (NaN, NaN) otherwise.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.intersection_of_ray_with_bounding_box-NTuple{6, Any}","page":"Utility Functions","title":"DelaunayTriangulation.intersection_of_ray_with_bounding_box","text":"intersection_of_ray_with_bounding_box(p, q, a, b, c, d) -> NTuple{2, Number}\n\nCompute the intersection of the ray emanating from p and passing through q with the box [a, b] × [c, d]. It is assumed that  p is inside of the box.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.polygon_bounds","page":"Utility Functions","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(points, boundary_nodes, check_all_curves=Val(false)) -> (Number, Number, Number, Number)\n\nComputes the bounding box of the polygon defined by (points, boundary_nodes). The boundary_nodes must match the specification in the documentation and in check_args. If check_all_curves is true, then the bounding box of the union of all curves of the polygon is computed instead of just the first curve.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.polygon_features-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(points, boundary_nodes) -> (Number, NTuple{2, Number})\n\nComputes the signed area and centroid of the polygon defined by (points, boundary_nodes). The boundary_nodes must match the specification in the documentation  and in check_args.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.project_onto_line-Tuple{Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.project_onto_line","text":"project_onto_line(p, q, r) -> NTuple{2, Number}\n\nProjects the point r onto the line through p and q. It is possible that  the projected point is not on the line segment [p, q].\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.segment_intersection_coordinates-NTuple{4, Any}","page":"Utility Functions","title":"DelaunayTriangulation.segment_intersection_coordinates","text":"segment_intersection_coordinates(a, b, c, d) -> NTuple{2, Number}\n\nGiven two segments (a, b) and (c, d) that are assumed to intersect, computes the coordinates of the intersection.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.sort_convex_polygon!-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.sort_convex_polygon!","text":"sort_convex_polygon!(vertices, points)\n\nSorts the vertices of a convex polygon in counter-clockwise order. The polygon is defined by (points, vertices), and the vertices are sorted in-place. It is  assumed that the vertices are not circular, i.e. vertices[begin] ≠ vertices[end].\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.squared_distance_to_segment-NTuple{6, Any}","page":"Utility Functions","title":"DelaunayTriangulation.squared_distance_to_segment","text":"squared_distance_to_segment(x₁, y₁, x₂, y₂, x, y) -> Number\n\nGiven a line segment (x₁, y₁) → (x₂, y₂) and a query point (x, y), returns the squared distance from (x, y) to the line segment.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.angle_is_acute_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.angle_is_acute_predicate","text":"angle_is_acute([kernel::AbstractPredicateKernel,] p, q, r)\n\nTests if the angle opposite (p, q) in the triangle (p, q, r),  meaning ∠prq, is acute, returning:\n\n1: ∠prq is acute.\n0: ∠prq is a right angle.\n-1: ∠prq is obtuse.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.det-NTuple{4, Any}","page":"Utility Functions","title":"DelaunayTriangulation.det","text":"det(a, b, c, d)\n\nComputes ExactPredicates.det(a, b, c, d), i.e. returns a*d - b*c.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.det-NTuple{9, Any}","page":"Utility Functions","title":"DelaunayTriangulation.det","text":"det(a, b, c, d, e, f, g, h, i)\n\nComputes ExactPredicates.det(a, b, c, d, e, f, g, h, i), i.e. returns the determinant of \n\ndet beginbmatrix a  b  c  d  e  f  g  h  i endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.ext-NTuple{4, Any}","page":"Utility Functions","title":"DelaunayTriangulation.ext","text":"ext(ux, uy, vx, vy)\n\nComputes ExactPredicates.ext((ux, uy), (vx, vy)), i.e.  returns ux * vy - uy * vx.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.incircle_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Vararg{Any, 4}}","page":"Utility Functions","title":"DelaunayTriangulation.incircle_predicate","text":"incircle_predicate([kernel::AbstractPredicateKernel,] a, b, c, p; cache = nothing) -> Integer\n\nAssuming that (a, b, c) is a positively oriented triangle, returns\n\n1: If p is inside the circle defined by (a, b, c).\n0: If p is on the circle defined by (a, b, c).\n-1: If p is outside the circle defined by (a, b, c).\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe optional cache keyword argument can be used for preallocating memory for intermediate results, passing the argument from AdaptivePredicates.incircleadapt_cache(T), where T is the number type of the input points. If nothing is passed, no cache is used. This is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.inp-NTuple{4, Any}","page":"Utility Functions","title":"DelaunayTriangulation.inp","text":"inp(ux, uy, vx, vy)\n\nComputes ExactPredicates.inp((ux, uy), (vx, vy)), i.e. returns ux * vx + uy * vy.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.meet_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Vararg{Any, 4}}","page":"Utility Functions","title":"DelaunayTriangulation.meet_predicate","text":"meet_predicate([kernel::AbstractPredicateKernel], p, q, a, b) -> Integer\n\nReturns\n\n1: The open line segments (p, q) and (a, b) meet in a single point.\n0: The closed line segments [p, q] and [a, b] meet in one or several points. \n-1: Otherwise.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.opposite_signs-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.opposite_signs","text":"opposite_signs(x, y) -> Bool\n\nFrom ExactPredicates.jl, returns true if x and y have opposite signs, and false otherwise. Assumes that x and y are in [-1, 0, 1].\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.orient_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate([kernel::AbstractPredicateKernel,] p, q, r) -> Integer\n\nReturns \n\n1: (p, q, r) is positively oriented.\n0: (p, q, r) is collinear / degenerate.\n-1: (p, q, r) is negatively oriented.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.orient_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Vararg{Any, 4}}","page":"Utility Functions","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate([kernel::AbstractPredicateKernel,] p, q, r; cache = nothing) -> Integer\n\nReturns \n\n1: (p, q, r, s) is positively oriented.\n0: (p, q, r, s) is collinear / degenerate.\n-1: (p, q, r, s) is negatively oriented.\n\nHere, a positively oriented tetrahedron (p, q, r, s) takes the form\n\n                               z.\n                             .\n                           ,/\n                         s\n                       ,/|'\\\n                     ,/  |  '\\\n                   ,/    '.   '\\\n                 ,/       |     '\\                 \n               ,/         |       '\\              \n              p-----------'.--------q --> x\n               '\\.         |      ,/              \n                  '\\.      |    ,/                 \n                     '\\.   '. ,/    \n                        '\\. |/      \n                           'r       \n                             '\\.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe optional cache keyword argument can be used for preallocating memory for intermediate results, passing the argument from AdaptivePredicates.orient3adapt_cache(T), where T is the number type of the input points. If nothing is passed, no cache is used. This is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.parallelorder_predicate-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Vararg{Any, 4}}","page":"Utility Functions","title":"DelaunayTriangulation.parallelorder_predicate","text":"parallelorder_predicate([kernel::AbstractPredicateKernel,] a, b, p, q) -> Integer\n\nReturns\n\n1: q is closer to the line (a, b) than p.\n0: p and q are equidistant from the line (a, b).\n-1: p is closer to the line (a, b) than q.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.sameside_predicate-Tuple{Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.sameside_predicate","text":"sameside_predicate(a, b, p) -> Integer\n\nAssuming all of a, b, p are collinear, returns\n\n1: a and b are on the same side of p on the line.\n0: a == p or b == p.\n-1: a and b are on different sides of p on the line.\n\nnote: Note\nThe difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.sgn-Tuple{Any}","page":"Utility Functions","title":"DelaunayTriangulation.sgn","text":"sgn(x) -> Int\n\nReturns Int(sign(x)).\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(tri::Triangulation, ij) -> Bool\nis_boundary_edge(tri::Triangulation, i, j) -> Bool\n\nTests if the edge (i, j) is a boundary edge of tri, meaning (j, i) adjoins a ghost vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_boundary_node-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(tri::Triangulation, i) -> (Bool, Vertex)\n\nTests if the vertex i is a boundary node of tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The vertex to test. \n\nOutputs\n\nflag: true if i is a boundary node, and false otherwise.\ng: Either the ghost vertex corresponding with the section that i lives on if flag is true, or 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(tri::Triangulation, T) -> Bool\nis_boundary_triangle(tri::Triangulation, i, j, k) -> Bool\n\nReturns true if the triangle T = (i, j, k) of tri has an edge on the boundary, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_exterior_boundary_node-Tuple{Triangulation, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_exterior_boundary_node","text":"is_exterior_boundary_node(tri::Triangulation, i) -> Bool\n\nTests if the vertex i is an exterior boundary node of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_exterior_ghost_edge-Tuple{Triangulation, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_exterior_ghost_edge","text":"is_exterior_ghost_edge(tri::Triangulation, i, j) -> Bool\n\nTests if the edge (i, j) is an exterior ghost edge of tri.\n\nSee also is_exterior_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_exterior_ghost_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_exterior_ghost_triangle","text":"is_exterior_ghost_triangle(tri::Triangulation, i, j, k) -> Bool\n\nTests if the triangle (i, j, k) is an exterior ghost triangle of tri.\n\nSee also is_exterior_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_ghost_edge-Tuple{Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_ghost_edge","text":"is_ghost_edge(ij) -> Bool \nis_ghost_edge(i, j) -> Bool\n\nTests if the edge (i, j) is a ghost edge, meaning i or j is a ghost vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_ghost_triangle-Tuple{Any, Any, Any}","page":"Utility Functions","title":"DelaunayTriangulation.is_ghost_triangle","text":"is_ghost_triangle(T) -> Bool\nis_ghost_triangle(i, j, k) -> Bool\n\nTests if T = (i, j, k) is a ghost triangle, meaning i, j or k is a ghost vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.is_ghost_vertex-Tuple{I} where I<:Integer","page":"Utility Functions","title":"DelaunayTriangulation.is_ghost_vertex","text":"is_ghost_vertex(i) -> Bool\n\nTests if i is a ghost vertex, meaning i ≤ -1.\n\n\n\n\n\n","category":"method"},{"location":"extended/utils/#DelaunayTriangulation.convert_certificate","page":"Utility Functions","title":"DelaunayTriangulation.convert_certificate","text":"convert_certificate(cert::I, Cert1, Cert2, Cert3) -> Certificate\n\nGiven cert ∈ (-1, 0, 1), return Cert1, Cert2 or Cert3 depending on if cert == -1, cert == 0 or cert == 1, respectively.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.DefaultAdjacentValue","page":"Utility Functions","title":"DelaunayTriangulation.DefaultAdjacentValue","text":"DefaultAdjacentValue = 0\n\nDefault value used for representing an empty result  from an adjacency query.\n\n\n\n\n\n","category":"constant"},{"location":"extended/utils/#DelaunayTriangulation.𝒢","page":"Utility Functions","title":"DelaunayTriangulation.𝒢","text":"𝒢 = GhostVertex\n\nAlias for GhostVertex.\n\n\n\n\n\n","category":"constant"},{"location":"extended/utils/#DelaunayTriangulation.GhostVertex","page":"Utility Functions","title":"DelaunayTriangulation.GhostVertex","text":"GhostVertex = -1\n\nNumber used for representing initial ghost vertices.  All other ghost vertices are derived from subtracting from  this number. See https://juliageometry.github.io/DelaunayTriangulation.jl/stable/manual/ghost_triangles/.\n\n\n\n\n\n","category":"constant"},{"location":"extended/utils/#DelaunayTriangulation.ε","page":"Utility Functions","title":"DelaunayTriangulation.ε","text":"ε(x) = sqrt(eps(number_type(x)))\n\nNumber used as a tolerance in certain functions, e.g.  for mesh refinement when using check_precision to  avoid degenerate circumcenters.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.∅","page":"Utility Functions","title":"DelaunayTriangulation.∅","text":"∅ = DefaultAdjacentValue\n\nAlias for DefaultAdjacentValue.\n\n\n\n\n\n","category":"constant"},{"location":"extended/utils/#DelaunayTriangulation.fix_orient3_cache","page":"Utility Functions","title":"DelaunayTriangulation.fix_orient3_cache","text":"fix_orient3_cache(tri::Triangulation, cache)\n\nReturns cache if validate_orient3_cache(tri, cache) is true, otherwise returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.fix_incircle_cache","page":"Utility Functions","title":"DelaunayTriangulation.fix_incircle_cache","text":"fix_incircle_cache(tri::Triangulation, cache)\n\nReturns cache if validate_incircle_cache(tri, cache) is true, otherwise returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.validate_orient3_cache","page":"Utility Functions","title":"DelaunayTriangulation.validate_orient3_cache","text":"validate_orient3_cache(tri::Triangulation, cache) -> Bool\n\nChecks if the cache cache is of the correct type for cmoputing orient3 predicates for the triangulation tri. If isnothing(cache) or  the cache is of the correct type, then true is returned. Otherwise, false is returned.\n\n\n\n\n\n","category":"function"},{"location":"extended/utils/#DelaunayTriangulation.validate_incircle_cache","page":"Utility Functions","title":"DelaunayTriangulation.validate_incircle_cache","text":"validate_incircle_cache(tri::Triangulation, cache) -> Bool\n\nChecks if the cache cache is of the correct type for computing incircle predicates for the triangulation tri. If isnothing(cache) or the cache is of the correct type, then true is returned. Otherwise, false is returned.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/clipped/#Clipped-Voronoi-Tessellations","page":"Clipping to the Convex Hull","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"tutorials/clipped/#Clipping-to-the-Convex-Hull","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"","category":"section"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"One issue that may arise when dealing with Voronoi tessellations is the presence of unbounded polygons occurring on the boundary. One way to deal with this is to clip polygons to the convex hull of the tessellation. We describe how to also clip the tessellation to a generic convex polygon, instead of just the convex hull, in this tutorial.","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"In the example below, we clip the tessellation to the convex hull of the point set by using clip=true in the keyword arguments.","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"clipped_vorn = voronoi(tri, clip = true)","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"Note that the clipping has put more polygon vertices in. We compare the clipped tessellations below.","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"fig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, colormap = :matter, strokewidth = 4)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, colormap = :matter, strokewidth = 4)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"As you can see, the unbounded polygons, and any polygons that included points outside of the convex hull, have now been clipped to the convex hull.","category":"page"},{"location":"tutorials/clipped/#Just-the-code","page":"Clipping to the Convex Hull","title":"Just the code","text":"","category":"section"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)\n\nclipped_vorn = voronoi(tri, clip = true)\n\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, colormap = :matter, strokewidth = 4)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, colormap = :matter, strokewidth = 4)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"","category":"page"},{"location":"tutorials/clipped/","page":"Clipping to the Convex Hull","title":"Clipping to the Convex Hull","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/voronoi/#Voronoi-Tessellations","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"","category":"section"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"In this tutorial, we demonstrate how we can construct Voronoi tessellations and work with them. Voronoi tessellations are built from a dual Delaunay triangulation using voronoi. To start, let us load in the packages.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"We build the tessellation by constructing the triangulation, and then passing that triangulation into voronoi.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"points = [\n    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),\n    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),\n    (-4.0, -3.0), (3.0, 8.0),\n]\nrng = StableRNG(123)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"To visualise the tessellation, you can use voronoiplot. Here, we also compare the tessellation with its dual triangulation.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"fig, ax, sc = voronoiplot(vorn, markersize = 13, colormap = :matter, strokecolor = :white, strokewidth = 5)\ntriplot!(ax, tri)\nfig","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The polygons each correspond to a generator, which is the black point inside it coming from points, i.e. the vertices of the triangulation. The polygons are all convex. Note also that the unbounded polygons, those coming from generators on the convex hull of the point set, are clipped in the above plot but in reality they go on to infinity. In the clipping to rectangular regions tutorial, we discuss how these polygons are clipped to a rectangle in more detail.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Let us now demonstrate in more detail how we can work with vorn.","category":"page"},{"location":"tutorials/voronoi/#Iterating-over-generators","page":"Voronoi Tessellations","title":"Iterating over generators","text":"","category":"section"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The generators are stored in a Dict, mapping vertices to coordinates; this is a Dict rather than a Vector because the original triangulation may not contain all the points, noting that get_generators(vorn) is just a repackaged version of get_points(tri). (A separate field is needed so that clipped and centroidal tessellations can add new generators without affecting the points in tri.) These generators can be accessed using get_generators(vorn):","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"DelaunayTriangulation.get_generators(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"It is preferred that you use each_generator(vorn), though, which is an iterator over the generators:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"each_generator(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Note that this is just the keys of the above Dict. To access specific generators, you use get_generator. For example,","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_generator(vorn, 3)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"To give an example, here is how we can compute the average generator position.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"function average_generator(vorn)\n    cx, cy = 0.0, 0.0\n    for i in each_generator(vorn)\n        p = get_generator(vorn, i)\n        px, py = getxy(p)\n        cx += px\n        cy += py\n    end\n    n = num_polygons(vorn) # same as DelaunayTriangulation.num_generators(vorn)\n    cx /= n\n    cy /= n\n    return cx, cy\nend\ncx, cy = average_generator(vorn)","category":"page"},{"location":"tutorials/voronoi/#Iterating-over-polygon-and-polygon-vertices","page":"Voronoi Tessellations","title":"Iterating over polygon and polygon vertices","text":"","category":"section"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"You can also look at the individual polygons, and all their vertices. These polygons and their vertices are stored as below:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"DelaunayTriangulation.get_polygons(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"DelaunayTriangulation.get_polygon_points(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"You should not work with these fields directly, though. If you want to look at a specific polygon, you should use get_polygon. For example,","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_polygon(vorn, 1)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"This is a Vector of the vertices of the polygon, in counter-clockwise order, and such that the first and last vertices are the same. The vertices refer to points in the polygon_points field, which you could then obtain using get_polygon_point. For example, the first vertex corresponds to the coordinates:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_polygon_point(vorn, 1)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"In get_polygon(vorn, 1), notice that there are two negative indices. These negative indices correspond to vertices out at infinity; their actual values do not matter, just that they are negative. Thus, this polygon is actually an unbounded polygon. This can be checked in two ways:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"1 ∈ DelaunayTriangulation.get_unbounded_polygons(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_area(vorn, 1) == Inf","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"There are several ways that you can iterate over the polygons. If you want each polygon, then you can use each_polygon:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"each_polygon(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"This is an iterator over all the polygon vertices, but you do not get the associated polygon index. If you want an iterator that is over the polygon indices, you use each_polygon_index:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"each_polygon_index(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"If you did want to have both the indices and the vertices together, you can use zip on these two iterators. This would be the same as iterating over the internal polygons field, but this could be subject to change in the future. To get an iterator over the polygon vertices rather than caring about a specific polygon, you use each_polygon_vertex:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"each_polygon_vertex(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"This is just an iterator of the indices to pass into get_polygon_point. You can also query the number of polygons and polygon vertices as follows:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"num_polygons(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"num_polygon_vertices(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"To give an example of how we might use these iterators, here we compute the area of all polygons.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"function get_polygon_area(vorn, i)\n    i ∈ DelaunayTriangulation.get_unbounded_polygons(vorn) && return Inf\n    area = 0.0\n    vertices = get_polygon(vorn, i)\n    vⱼ = vertices[begin]\n    pⱼ = get_polygon_point(vorn, vⱼ)\n    xⱼ, yⱼ = getxy(pⱼ)\n    for j in (firstindex(vertices) + 1):lastindex(vertices) # same as 2:length(vertices)\n        vⱼ₊₁ = vertices[j]\n        pⱼ₊₁ = get_polygon_point(vorn, vⱼ₊₁)\n        xⱼ₊₁, yⱼ₊₁ = getxy(pⱼ₊₁)\n        area += xⱼ * yⱼ₊₁ - xⱼ₊₁ * yⱼ\n        vⱼ, pⱼ, xⱼ, yⱼ = vⱼ₊₁, pⱼ₊₁, xⱼ₊₁, yⱼ₊₁\n    end\n    return area / 2\nend\nfunction get_polygon_areas(vorn)\n    areas = zeros(num_polygons(vorn))\n    for i in each_polygon_index(vorn)\n        areas[i] = get_polygon_area(vorn, i)\n    end\n    return areas\nend\nvorn_areas = get_polygon_areas(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Note that this could have also been obtained using get_area:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"function direct_polygon_areas(vorn)\n    areas = zeros(num_polygons(vorn))\n    for i in each_polygon_index(vorn)\n        areas[i] = get_area(vorn, i)\n    end\n    return areas\nend\nvorn_areas ≈ direct_polygon_areas(vorn)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Moreover, note that the following is false:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"vorn_areas ≈ [get_area(vorn, i) for i in each_polygon_index(vorn)]","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"because each_polygon_index does not return the polygons in a sorted order.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Before we move on, we emphasise that it is not guaranteed that the values of the vertices for a given polygon are the same if you were to recompute the tessellation. The actual coordinates will all be the same, but they just might correspond to different vertex values. The indices of the polygons will be the same, though, as they are derived from the point indices.","category":"page"},{"location":"tutorials/voronoi/#Getting-polygons-adjacent-to-an-edge","page":"Voronoi Tessellations","title":"Getting polygons adjacent to an edge","text":"","category":"section"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Given an edge in the tessellation, you can use get_adjacent to get the polygon that it is a part of (taking care of order). For example,","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_adjacent(vorn, 1, 8)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"means that the edge (1, 8) belongs to the third polygon, as we can easily verify:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_polygon(vorn, 3)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"see that (1, 8) at the end. The order is important here, since","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_adjacent(vorn, 8, 1)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"means that the edge (8, 1) belongs to the seventh polygon:","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"get_polygon(vorn, 7)","category":"page"},{"location":"tutorials/voronoi/#Just-the-code","page":"Voronoi Tessellations","title":"Just the code","text":"","category":"section"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\npoints = [\n    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),\n    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),\n    (-4.0, -3.0), (3.0, 8.0),\n]\nrng = StableRNG(123)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)\n\nfig, ax, sc = voronoiplot(vorn, markersize = 13, colormap = :matter, strokecolor = :white, strokewidth = 5)\ntriplot!(ax, tri)\nfig\n\nDelaunayTriangulation.get_generators(vorn)\n\neach_generator(vorn)\n\nget_generator(vorn, 3)\n\nfunction average_generator(vorn)\n    cx, cy = 0.0, 0.0\n    for i in each_generator(vorn)\n        p = get_generator(vorn, i)\n        px, py = getxy(p)\n        cx += px\n        cy += py\n    end\n    n = num_polygons(vorn) # same as DelaunayTriangulation.num_generators(vorn)\n    cx /= n\n    cy /= n\n    return cx, cy\nend\ncx, cy = average_generator(vorn)\n\nDelaunayTriangulation.get_polygons(vorn)\n\nDelaunayTriangulation.get_polygon_points(vorn)\n\nget_polygon(vorn, 1)\n\nget_polygon_point(vorn, 1)\n\n1 ∈ DelaunayTriangulation.get_unbounded_polygons(vorn)\n\nget_area(vorn, 1) == Inf\n\neach_polygon(vorn)\n\neach_polygon_index(vorn)\n\neach_polygon_vertex(vorn)\n\nnum_polygons(vorn)\n\nnum_polygon_vertices(vorn)\n\nfunction get_polygon_area(vorn, i)\n    i ∈ DelaunayTriangulation.get_unbounded_polygons(vorn) && return Inf\n    area = 0.0\n    vertices = get_polygon(vorn, i)\n    vⱼ = vertices[begin]\n    pⱼ = get_polygon_point(vorn, vⱼ)\n    xⱼ, yⱼ = getxy(pⱼ)\n    for j in (firstindex(vertices) + 1):lastindex(vertices) # same as 2:length(vertices)\n        vⱼ₊₁ = vertices[j]\n        pⱼ₊₁ = get_polygon_point(vorn, vⱼ₊₁)\n        xⱼ₊₁, yⱼ₊₁ = getxy(pⱼ₊₁)\n        area += xⱼ * yⱼ₊₁ - xⱼ₊₁ * yⱼ\n        vⱼ, pⱼ, xⱼ, yⱼ = vⱼ₊₁, pⱼ₊₁, xⱼ₊₁, yⱼ₊₁\n    end\n    return area / 2\nend\nfunction get_polygon_areas(vorn)\n    areas = zeros(num_polygons(vorn))\n    for i in each_polygon_index(vorn)\n        areas[i] = get_polygon_area(vorn, i)\n    end\n    return areas\nend\nvorn_areas = get_polygon_areas(vorn)\n\nfunction direct_polygon_areas(vorn)\n    areas = zeros(num_polygons(vorn))\n    for i in each_polygon_index(vorn)\n        areas[i] = get_area(vorn, i)\n    end\n    return areas\nend\nvorn_areas ≈ direct_polygon_areas(vorn)\n\nvorn_areas ≈ [get_area(vorn, i) for i in each_polygon_index(vorn)]\n\nget_adjacent(vorn, 1, 8)\n\nget_polygon(vorn, 3)\n\nget_adjacent(vorn, 8, 1)\n\nget_polygon(vorn, 7)","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"","category":"page"},{"location":"tutorials/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/refinement/#Mesh-Refinement","page":"Mesh Refinement","title":"Mesh Refinement","text":"","category":"section"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In this tutorial, we show how we can use mesh refinement to improve the quality of a mesh by inserting more points. In this package, we allow for constant area and angle constraints, and also for custom constraints based on a user-provided function. You can also limit the maximum number of points. Moreover, any type of triangulation can be provided, regardless of whether the triangulation is unconstrained or triangulations, and regardless of the number of holes and domains. Curve-bounded domains, not included in this tutorial, can also be refined as discussed in this tutorial.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let us start by loading in the packages we will need.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/refinement/#Unconstrained-triangulation","page":"Mesh Refinement","title":"Unconstrained triangulation","text":"","category":"section"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let us start with a simple example, refining an unconstrained triangulation. We will constrain the triangulation such that the minimum angle is 30 degrees, and the maximum area of a triangulation is 1% of the triangulation's total area. Note that below we need to make sure points is mutable, else it is not possible to push points into the triangulation. Here we use a vector, but you could also use e.g. an ElasticMatrix from ElasticArrays.jl.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"rng = StableRNG(123)\nx = rand(rng, 50)\ny = rand(rng, 50)\npoints = tuple.(x, y)\ntri = triangulate(points; rng)\norig_tri = deepcopy(tri)\nA = get_area(tri)\nrefine!(tri; min_angle = 30.0, max_area = 0.01A, rng)","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The refine! function operates on tri in-place. If we wanted to review the statistics of the refined mesh, we can use statistics:","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"statistics(tri)","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"As we can see, the maximum area of a triangle is about 0.0064, which is indeed less than 1% of the triangulation's area, which is about 0.0067. Moreover, the smallest angle is indeed greater than 30.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let us compare the triangulation pre- and post-refinement.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig, ax, sc = triplot(orig_tri, axis = (title = \"Pre-refinement\",))\nax = Axis(fig[1, 2], title = \"Post-refinement\")\ntriplot!(ax, tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The triangulation is now much finer. There are still some parts with many more triangles than other regions, but these are mostly near a boundary or where was a cluster of random points. If we wanted, we could refine again to try and improve this.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"refine!(tri; min_angle = 30.0, max_area = 0.001A, rng) # 0.1% instead of 1%\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The quality has now been improved. We could also try improving the minimum angle further, but even 30 is a bit closer to the limit of convergence (which is about 33.9 degrees). For example, if we try a minimum angle of 35 degrees, the algorithm just doesn't even converge, instead it reaches the maximum number of points.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"test_tri = deepcopy(tri)\nrefine!(test_tri; min_angle = 35.0, max_area = 0.001A, max_points = 5_000, rng) # 20_000 so that it doesn't just keep going\nstatistics(test_tri)","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"As we can see, the smallest angle is about 29 degrees instead of 35 degrees, and there are now 5000 points in the triangulation. The resulting triangulation is given below:","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig, ax, sc = triplot(test_tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"This is certainly not a suitable triangulation.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"One useful figure to look at for these plots are histograms that look at the areas and angles. Looking to tri, we can plot these as follows:","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"stats = statistics(tri)\nfig = Figure(fontsize = 33)\nareas = get_all_stat(stats, :area) ./ A\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nax = Axis(fig[1, 1], xlabel = \"A/A(Ω)\", ylabel = \"Count\", title = \"Area histogram\", width = 400, height = 400, titlealign = :left)\nhist!(ax, areas, bins = 0:0.0001:0.0005)\nax = Axis(fig[1, 2], xlabel = \"θₘᵢₙ\", ylabel = \"Count\", title = \"Angle histogram\", width = 400, height = 400, titlealign = :left)\nhist!(ax, rad2deg.(angles), bins = 20:2:60)\nvlines!(ax, [30.0], color = :red)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We see that indeed many of the triangle areas are very small, and the angles are all greater than 30 degrees.","category":"page"},{"location":"tutorials/refinement/#Constrained-triangulation-and-custom-constraints","page":"Mesh Refinement","title":"Constrained triangulation and custom constraints","text":"","category":"section"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We now give an example of a constrained triangulation being refined. This is the most common case where the mesh refinement is needed. For this example, we consider an example with holes, but note that any triangulation can be refined, regardless of the type. Here is the triangulation we consider.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"n = 100\nθ = LinRange(0, 2π, n + 1)\nθ = [θ[1:n]; 0]\nrev_θ = reverse(θ) # to go from ccw to cw\nr₁ = 10.0\nr₂ = 5.0\nr₃ = 2.5\nouter_x, outer_y = r₁ * cos.(θ), r₁ * sin.(θ)\ninner_x, inner_y = r₂ * cos.(rev_θ), r₂ * sin.(rev_θ)\ninnermost_x, innermost_y = r₃ * cos.(θ), r₃ * sin.(θ)\nx = [[outer_x], [inner_x], [innermost_x]]\ny = [[outer_y], [inner_y], [innermost_y]]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let us now refine this triangulation.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = get_area(tri)\nrefine!(tri; min_angle = 27.3, max_area = 0.01A, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We inspect the plot, and we might think that it's perhaps not fine enough. Let's use finer constraints and see what happens. Since refine! operates on tri in-place, refining it again with the constraints below is going to take roughly the same amount of time as if we had refined it with these constraints in the first place.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"refine!(tri; min_angle = 33.9, max_area = 0.001A, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"This is indeed much better, but notice that the inner hole is much more fine than the outer. This is because we are applying the same area constraint inside and outside, when really we should try and take note of the total contribution to the area that each part of the domain gives. To refine with this in mind, we need to use custom constraints. The function that we use for constraining the area takes the form f(tri, T), where T is the triangle's vertices and tri is the triangulation. It should return true if the triangle should be refined, and false otherwise. Let us define a function such that, instead of applying constraints so that the triangles are limited to 1% of the total triangulation area, we do 0.5% or 0.1% of the area of the inner or outer domain, respectively.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"outer_area = π * (r₁^2 - r₂^2)\ninner_area = π * r₃^2\nfunction in_inner(p, q, r)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    cx, cy = (px + qx + rx) / 3, (py + qy + ry) / 3\n    rad2 = cx^2 + cy^2\n    return rad2 ≤ r₃^2\nend\nfunction area_constraint(_tri, T)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    A = DelaunayTriangulation.triangle_area(p, q, r)\n    return in_inner(p, q, r) ? (A ≥ 0.005inner_area) : (A ≥ 0.001outer_area)\nend","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let's now refine. We recompute the triangulation so that we can see the new results.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"boundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; min_angle = 30.0, custom_constraint = area_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"This is now much better, and the two parts of the domain are appropriately refined. Let us extend our custom constraint function to also require that any triangle has minimum angle less than 33 degrees inside the innermost domain, and less than 20 degrees outside the innermost domain.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"function angle_constraint(_tri, T)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    θ = rad2deg(minimum(DelaunayTriangulation.triangle_angles(p, q, r)))\n    return in_inner(p, q, r) ? (θ ≤ 33.9) : (θ ≤ 20.0)\nend\nfunction custom_constraint(_tri, T)\n    return area_constraint(_tri, T) || angle_constraint(_tri, T)\nend\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; custom_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Indeed, the inner domain is much finer. These examples could be extended to more complicated cases, for example using adaptive mesh refinement for a numerical PDE solution so that triangles are refined based on some a posteriori error estimate, implemented using a custom area constraint like above, or even some refinement based on the triangle's location in space in case of some geospatial application.","category":"page"},{"location":"tutorials/refinement/#Domains-with-small-angles","page":"Mesh Refinement","title":"Domains with small angles","text":"","category":"section"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In the examples considered, none of the boundaries had small angles. When domains have small angles, it is not always possible to satisfy the minimum angle constraints, but the algorithm will still try its best to refine in these locations. Let's consider a complicated example with many small angles. We consider the boundary of Switzerland, as obtained in this NaturalNeighbours.jl example.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"using Downloads\nusing DelimitedFiles\nboundary_url = \"https://gist.githubusercontent.com/DanielVandH/13687b0918e45a416a5c93cd52c91449/raw/a8da6cdc94859fd66bcff85a2307f0f9cd57a18c/boundary.txt\"\nboundary_dir = Downloads.download(boundary_url)\nboundary = readdlm(boundary_dir, skipstart = 6)\nboundary_points = [(boundary[i, 1], boundary[i, 2]) for i in axes(boundary, 1)]\nreverse!(boundary_points)","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Here is the boundary.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"boundary_nodes, points = convert_boundary_points_to_indices(boundary_points)\nrng = StableRNG(789)\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Now let's refine.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = get_area(tri)\nrefine!(tri; min_angle = 30.0, max_area = 0.001A, rng)","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We see that the triangulation is now adequately refined. There are still triangles near the boundaries whose minimum angle is less than 30 degrees, though, because of the angles that boundary edges meet at in some places. Most of the triangles will satisfy the constraint, though, as we show below.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"stats = statistics(tri)\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nfig, ax, sc = scatter(rad2deg.(angles))\nhlines!(ax, [30.0], color = :red, linewidth = 4)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"As we can see, the vast majority of the triangles satisfy the constraint, but there are still some that do not. Here is another set of results with a lower minimum angle constraint.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"boundary_nodes, points = convert_boundary_points_to_indices(boundary_points)\nrng = StableRNG(789)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; min_angle = 18.73, max_area = 0.001A, rng)\nfig = Figure(fontsize = 43)\nax = Axis(fig[1, 1], width = 600, height = 400)\ntriplot!(tri)\nax = Axis(fig[1, 2], width = 600, height = 400)\nstats = statistics(tri)\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nscatter!(ax, rad2deg.(angles))\nhlines!(ax, [18.73], color = :red, linewidth = 4)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In this case, all the triangles satisfy the constraint, of course at the expense of some other triangles having lesser quality.","category":"page"},{"location":"tutorials/refinement/#Just-the-code","page":"Mesh Refinement","title":"Just the code","text":"","category":"section"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\nx = rand(rng, 50)\ny = rand(rng, 50)\npoints = tuple.(x, y)\ntri = triangulate(points; rng)\norig_tri = deepcopy(tri)\nA = get_area(tri)\nrefine!(tri; min_angle = 30.0, max_area = 0.01A, rng)\n\nstatistics(tri)\n\nfig, ax, sc = triplot(orig_tri, axis = (title = \"Pre-refinement\",))\nax = Axis(fig[1, 2], title = \"Post-refinement\")\ntriplot!(ax, tri)\nfig\n\nrefine!(tri; min_angle = 30.0, max_area = 0.001A, rng) # 0.1% instead of 1%\nfig, ax, sc = triplot(tri)\nfig\n\ntest_tri = deepcopy(tri)\nrefine!(test_tri; min_angle = 35.0, max_area = 0.001A, max_points = 5_000, rng) # 20_000 so that it doesn't just keep going\nstatistics(test_tri)\n\nfig, ax, sc = triplot(test_tri)\nfig\n\nstats = statistics(tri)\nfig = Figure(fontsize = 33)\nareas = get_all_stat(stats, :area) ./ A\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nax = Axis(fig[1, 1], xlabel = \"A/A(Ω)\", ylabel = \"Count\", title = \"Area histogram\", width = 400, height = 400, titlealign = :left)\nhist!(ax, areas, bins = 0:0.0001:0.0005)\nax = Axis(fig[1, 2], xlabel = \"θₘᵢₙ\", ylabel = \"Count\", title = \"Angle histogram\", width = 400, height = 400, titlealign = :left)\nhist!(ax, rad2deg.(angles), bins = 20:2:60)\nvlines!(ax, [30.0], color = :red)\nresize_to_layout!(fig)\nfig\n\nn = 100\nθ = LinRange(0, 2π, n + 1)\nθ = [θ[1:n]; 0]\nrev_θ = reverse(θ) # to go from ccw to cw\nr₁ = 10.0\nr₂ = 5.0\nr₃ = 2.5\nouter_x, outer_y = r₁ * cos.(θ), r₁ * sin.(θ)\ninner_x, inner_y = r₂ * cos.(rev_θ), r₂ * sin.(rev_θ)\ninnermost_x, innermost_y = r₃ * cos.(θ), r₃ * sin.(θ)\nx = [[outer_x], [inner_x], [innermost_x]]\ny = [[outer_y], [inner_y], [innermost_y]]\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nA = get_area(tri)\nrefine!(tri; min_angle = 27.3, max_area = 0.01A, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nrefine!(tri; min_angle = 33.9, max_area = 0.001A, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nouter_area = π * (r₁^2 - r₂^2)\ninner_area = π * r₃^2\nfunction in_inner(p, q, r)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    cx, cy = (px + qx + rx) / 3, (py + qy + ry) / 3\n    rad2 = cx^2 + cy^2\n    return rad2 ≤ r₃^2\nend\nfunction area_constraint(_tri, T)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    A = DelaunayTriangulation.triangle_area(p, q, r)\n    return in_inner(p, q, r) ? (A ≥ 0.005inner_area) : (A ≥ 0.001outer_area)\nend\n\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; min_angle = 30.0, custom_constraint = area_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nfunction angle_constraint(_tri, T)\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    θ = rad2deg(minimum(DelaunayTriangulation.triangle_angles(p, q, r)))\n    return in_inner(p, q, r) ? (θ ≤ 33.9) : (θ ≤ 20.0)\nend\nfunction custom_constraint(_tri, T)\n    return area_constraint(_tri, T) || angle_constraint(_tri, T)\nend\nboundary_nodes, points = convert_boundary_points_to_indices(x, y)\nrng = StableRNG(456)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; custom_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nusing Downloads\nusing DelimitedFiles\nboundary_url = \"https://gist.githubusercontent.com/DanielVandH/13687b0918e45a416a5c93cd52c91449/raw/a8da6cdc94859fd66bcff85a2307f0f9cd57a18c/boundary.txt\"\nboundary_dir = Downloads.download(boundary_url)\nboundary = readdlm(boundary_dir, skipstart = 6)\nboundary_points = [(boundary[i, 1], boundary[i, 2]) for i in axes(boundary, 1)]\nreverse!(boundary_points)\n\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points)\nrng = StableRNG(789)\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nA = get_area(tri)\nrefine!(tri; min_angle = 30.0, max_area = 0.001A, rng)\n\nfig, ax, sc = triplot(tri)\nfig\n\nstats = statistics(tri)\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nfig, ax, sc = scatter(rad2deg.(angles))\nhlines!(ax, [30.0], color = :red, linewidth = 4)\nfig\n\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points)\nrng = StableRNG(789)\ntri = triangulate(points; boundary_nodes, rng)\nrefine!(tri; min_angle = 18.73, max_area = 0.001A, rng)\nfig = Figure(fontsize = 43)\nax = Axis(fig[1, 1], width = 600, height = 400)\ntriplot!(tri)\nax = Axis(fig[1, 2], width = 600, height = 400)\nstats = statistics(tri)\nangles = first.(get_all_stat(stats, :angles)) # the first is the smallest\nscatter!(ax, rad2deg.(angles))\nhlines!(ax, [18.73], color = :red, linewidth = 4)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"","category":"page"},{"location":"tutorials/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/predicates/#Predicates","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"api/predicates/#Certificates","page":"Predicates","title":"Certificates","text":"","category":"section"},{"location":"api/predicates/#DelaunayTriangulation.Certificate","page":"Predicates","title":"DelaunayTriangulation.Certificate","text":"Certificate\n\nThis is an Enum that defines certificates returned from predicates. The instances, and associated certifiers, are:\n\nInside: is_inside\nDegenerate: is_degenerate\nOutside: is_outside\nOn: is_on\nLeft: is_left\nRight: is_right\nPositivelyOriented: is_positively_oriented\nNegativelyOriented: is_negatively_oriented\nCollinear: is_collinear\nNone: is_none or has_no_intersections\nSingle: is_single or has_one_intersection\nMultiple: is_multiple or has_multiple_intersections\nTouching: is_touching\nLegal: is_legal\nIllegal: is_illegal\nCloser: is_closer\nFurther: is_further\nEquidistant: is_equidistant\nObtuse: is_obtuse\nAcute: is_acute\nSuccessfulInsertion: is_successful_insertion\nFailedInsertion: is_failed_insertion\nPrecisionFailure: is_precision_failure\nEncroachmentFailure: is_encroachment_failure\nAbove: is_above\nBelow: is_below\nVisible: is_visible\nInvisible: is_invisible\n\n\n\n\n\n","category":"module"},{"location":"api/predicates/#DelaunayTriangulation.is_inside","page":"Predicates","title":"DelaunayTriangulation.is_inside","text":"is_inside(cert::Certificate) -> Bool\n\nReturns true if cert is Inside, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_degenerate","page":"Predicates","title":"DelaunayTriangulation.is_degenerate","text":"is_degenerate(cert::Certificate) -> Bool\n\nReturns true if cert is Degenerate, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_outside","page":"Predicates","title":"DelaunayTriangulation.is_outside","text":"is_outside(cert::Certificate) -> Bool\n\nReturns true if cert is Outside, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_on","page":"Predicates","title":"DelaunayTriangulation.is_on","text":"is_on(cert::Certificate) -> Bool\n\nReturns true if cert is On, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_left","page":"Predicates","title":"DelaunayTriangulation.is_left","text":"is_left(cert::Certificate) -> Bool\n\nReturns true if cert is Left, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_right","page":"Predicates","title":"DelaunayTriangulation.is_right","text":"is_right(cert::Certificate) -> Bool\n\nReturns true if cert is Right, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_positively_oriented","page":"Predicates","title":"DelaunayTriangulation.is_positively_oriented","text":"is_positively_oriented(tri::Triangulation, curve_index) -> Bool\n\nTests if the curve_indexth curve in tri is positively oriented, returning true if so and false otherwise.\n\n\n\n\n\nis_positively_oriented(cert::Certificate) -> Bool\n\nReturns true if cert is PositivelyOriented, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_negatively_oriented","page":"Predicates","title":"DelaunayTriangulation.is_negatively_oriented","text":"is_negatively_oriented(cert::Certificate) -> Bool\n\nReturns true if cert is NegativelyOriented, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_collinear","page":"Predicates","title":"DelaunayTriangulation.is_collinear","text":"is_collinear(cert::Certificate) -> Bool\n\nReturns true if cert is Collinear, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_none","page":"Predicates","title":"DelaunayTriangulation.is_none","text":"is_none(cert::Certificate) -> Bool\n\nReturns true if cert is None, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_no_intersections","page":"Predicates","title":"DelaunayTriangulation.has_no_intersections","text":"has_no_intersections(cert::Certificate) -> Bool\n\nReturns true if cert is None, and false otherwise. Synonymous with is_none.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_single","page":"Predicates","title":"DelaunayTriangulation.is_single","text":"is_single(cert::Certificate) -> Bool\n\nReturns true if cert is Single, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_one_intersection","page":"Predicates","title":"DelaunayTriangulation.has_one_intersection","text":"has_one_intersection(cert::Certificate) -> Bool\n\nReturns true if cert is Single, and false otherwise. Synonymous with is_single.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_multiple","page":"Predicates","title":"DelaunayTriangulation.is_multiple","text":"is_multiple(cert::Certificate) -> Bool\n\nReturns true if cert is Multiple, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_multiple_intersections","page":"Predicates","title":"DelaunayTriangulation.has_multiple_intersections","text":"has_multiple_intersections(cert::Certificate) -> Bool\n\nReturns true if cert is Multiple, and false otherwise. Synonymous with is_multiple.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_touching","page":"Predicates","title":"DelaunayTriangulation.is_touching","text":"is_touching(r1::BoundingBox, r2::BoundingBox) -> Bool\n\nTests whether r1 and r2 are touching, i.e. if they share a common boundary. This only considers interior touching.\n\n\n\n\n\nis_touching(cert::Certificate) -> Bool\n\nReturns true if cert is Touching, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_illegal","page":"Predicates","title":"DelaunayTriangulation.is_illegal","text":"is_illegal(cert::Certificate) -> Bool\n\nReturns true if cert is Illegal, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_closer","page":"Predicates","title":"DelaunayTriangulation.is_closer","text":"is_closer(cert::Certificate) -> Bool\n\nReturns true if cert is Closer, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_further","page":"Predicates","title":"DelaunayTriangulation.is_further","text":"is_further(cert::Certificate) -> Bool\n\nReturns true if cert is Further, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_equidistant","page":"Predicates","title":"DelaunayTriangulation.is_equidistant","text":"is_equidistant(cert::Certificate) -> Bool\n\nReturns true if cert is Equidistant, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_obtuse","page":"Predicates","title":"DelaunayTriangulation.is_obtuse","text":"is_obtuse(cert::Certificate) -> Bool\n\nReturns true if cert is Obtuse, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_acute","page":"Predicates","title":"DelaunayTriangulation.is_acute","text":"is_acute(cert::Certificate) -> Bool\n\nReturns true if cert is Acute, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_above","page":"Predicates","title":"DelaunayTriangulation.is_above","text":"is_above(cert::Certificate) -> Bool\n\nReturns true if cert is Above, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_below","page":"Predicates","title":"DelaunayTriangulation.is_below","text":"is_below(cert::Certificate) -> Bool\n\nReturns true if cert is Below, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#Predicates-2","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"api/predicates/#DelaunayTriangulation.AbstractPredicateKernel","page":"Predicates","title":"DelaunayTriangulation.AbstractPredicateKernel","text":"abstract type AbstractPredicateKernel\n\nAbstract type for defining a method for computing predicates. The subtypes are:\n\nFastKernel: Uses the determinant definitions of the predicates, with no adaptivity or exact arithmetic.\nExactKernel: Uses ExactPredicates.jl.\nAdaptiveKernel: Uses AdaptivePredicates.jl.\n\nPlease see the documentation for more information on the differences between these predicate types.\n\n\n\n\n\n","category":"type"},{"location":"api/predicates/#DelaunayTriangulation.FastKernel","page":"Predicates","title":"DelaunayTriangulation.FastKernel","text":"FastKernel()\n\nPass this to predicates to declare that determinant definitions of predicates should be used, avoiding adaptivity and exact arithmetic.\n\nSee also ExactKernel and AdaptiveKernel.\n\n\n\n\n\n","category":"type"},{"location":"api/predicates/#DelaunayTriangulation.ExactKernel","page":"Predicates","title":"DelaunayTriangulation.ExactKernel","text":"ExactKernel()\n\nPass this to predicates to use ExactPredicates.jl for computing predicates.\n\nSee also FastKernel and AdaptiveKernel.\n\n\n\n\n\n","category":"type"},{"location":"api/predicates/#DelaunayTriangulation.AdaptiveKernel","page":"Predicates","title":"DelaunayTriangulation.AdaptiveKernel","text":"AdaptiveKernel()\n\nPass this to predicates to use AdaptivePredicates.jl for computing predicates.\n\nSee also FastKernel and ExactKernel.\n\n\n\n\n\n","category":"type"},{"location":"api/predicates/#DelaunayTriangulation.orient_predicate","page":"Predicates","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate([kernel::AbstractPredicateKernel,] p, q, r) -> Integer\n\nReturns \n\n1: (p, q, r) is positively oriented.\n0: (p, q, r) is collinear / degenerate.\n-1: (p, q, r) is negatively oriented.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\norient_predicate([kernel::AbstractPredicateKernel,] p, q, r; cache = nothing) -> Integer\n\nReturns \n\n1: (p, q, r, s) is positively oriented.\n0: (p, q, r, s) is collinear / degenerate.\n-1: (p, q, r, s) is negatively oriented.\n\nHere, a positively oriented tetrahedron (p, q, r, s) takes the form\n\n                               z.\n                             .\n                           ,/\n                         s\n                       ,/|'\\\n                     ,/  |  '\\\n                   ,/    '.   '\\\n                 ,/       |     '\\                 \n               ,/         |       '\\              \n              p-----------'.--------q --> x\n               '\\.         |      ,/              \n                  '\\.      |    ,/                 \n                     '\\.   '. ,/    \n                        '\\. |/      \n                           'r       \n                             '\\.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe optional cache keyword argument can be used for preallocating memory for intermediate results, passing the argument from AdaptivePredicates.orient3adapt_cache(T), where T is the number type of the input points. If nothing is passed, no cache is used. This is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.incircle_predicate","page":"Predicates","title":"DelaunayTriangulation.incircle_predicate","text":"incircle_predicate([kernel::AbstractPredicateKernel,] a, b, c, p; cache = nothing) -> Integer\n\nAssuming that (a, b, c) is a positively oriented triangle, returns\n\n1: If p is inside the circle defined by (a, b, c).\n0: If p is on the circle defined by (a, b, c).\n-1: If p is outside the circle defined by (a, b, c).\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe optional cache keyword argument can be used for preallocating memory for intermediate results, passing the argument from AdaptivePredicates.incircleadapt_cache(T), where T is the number type of the input points. If nothing is passed, no cache is used. This is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.parallelorder_predicate","page":"Predicates","title":"DelaunayTriangulation.parallelorder_predicate","text":"parallelorder_predicate([kernel::AbstractPredicateKernel,] a, b, p, q) -> Integer\n\nReturns\n\n1: q is closer to the line (a, b) than p.\n0: p and q are equidistant from the line (a, b).\n-1: p is closer to the line (a, b) than q.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.angle_is_acute_predicate","page":"Predicates","title":"DelaunayTriangulation.angle_is_acute_predicate","text":"angle_is_acute([kernel::AbstractPredicateKernel,] p, q, r)\n\nTests if the angle opposite (p, q) in the triangle (p, q, r),  meaning ∠prq, is acute, returning:\n\n1: ∠prq is acute.\n0: ∠prq is a right angle.\n-1: ∠prq is obtuse.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.sameside_predicate","page":"Predicates","title":"DelaunayTriangulation.sameside_predicate","text":"sameside_predicate(a, b, p) -> Integer\n\nAssuming all of a, b, p are collinear, returns\n\n1: a and b are on the same side of p on the line.\n0: a == p or b == p.\n-1: a and b are on different sides of p on the line.\n\nnote: Note\nThe difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.meet_predicate","page":"Predicates","title":"DelaunayTriangulation.meet_predicate","text":"meet_predicate([kernel::AbstractPredicateKernel], p, q, a, b) -> Integer\n\nReturns\n\n1: The open line segments (p, q) and (a, b) meet in a single point.\n0: The closed line segments [p, q] and [a, b] meet in one or several points. \n-1: Otherwise.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.triangle_orientation","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k) -> Certificate \ntriangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T) -> Certificate\ntriangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -> Certificate\n\nComputes the orientation of the triangle T = (i, j, k) with correspondig coordinates (p, q, r). The returned value is a Certificate, which is one of:\n\nPositivelyOriented: The triangle is positively oriented.\nDegenerate: The triangle is degenerate, meaning the coordinates are collinear.\nNegativelyOriented: The triangle is negatively oriented.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_circle","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circle","text":"point_position_relative_to_circle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, c, p; cache = nothing) -> Certificate\n\nGiven a circle through the coordinates (a, b, c), assumed to be positively oriented, computes the position of p relative to the circle. Returns a Certificate, which is one of:\n\nInside: p is inside the circle.\nOn: p is on the circle.\nOutside: p is outside the triangle.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is passed to [incircle_predicate] and should be one of \n\nnothing: No cache is used.\nAdaptivePredicates.incircleadapt_cache(T), where T is the number type used (Float64 or Float32).\n\nThe cache is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_line","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p) -> Certificate\npoint_position_relative_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, u) -> Certificate\n\nTests the position of p (or the vertex u of tri) relative to the edge (a, b) (or the edge with vertices (i, j) of tri), returning  a Certificate which is one of:\n\nLeft: p is to the left of the line.\nCollinear: p is on the line.\nRight: p is to the right of the line.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_closest_to_line","page":"Predicates","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p, q) -> Certificate\npoint_closest_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, u, v) -> Certificate\n\nGiven a line ℓ through (a, b) (or through the vertices (i, j)), tests if p (or the vertex u) is closer to ℓ than q (or the vertex v), assuming that p and q are to the left of ℓ, returning a Certificate which is one of:\n\nCloser: p is closer to ℓ.\nFurther: q is closer to ℓ.\nEquidistant: p and q are the same distance from ℓ.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_on_line_segment","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(a, b, p) -> Certificate\npoint_position_on_line_segment(tri::Triangulation, i, j, u) -> Certificate\n\nGiven a point p (or vertex u) and the line segment (a, b) (or edge (i, j)), assuming p to be collinear with a and b, computes the position of p relative to the line segment. The returned value is a  Certificate which is one of:\n\nOn: p is on the line segment, meaning between a and b.\nDegenerate: Either p == a or p == b, i.e. p is one of the endpoints.\nLeft: p is off and to the left of the line segment.\nRight: p is off and to the right of the line segment.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.line_segment_intersection_type","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, a, b) -> Certificate \nline_segment_intersection_type([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, i, j) -> Certificate\n\nGiven the coordinates (p, q) (or vertices (u, v)) and (a, b) (or vertices (i, j)) defining two line segments, tests the number of intersections between the two segments. The returned value is a Certificate, which is one of:\n\nNone: The line segments do not meet at any points.\nMultiple: The closed line segments [p, q] and [a, b] meet in one or several points.\nSingle: The open line segments (p, q) and (a, b) meet in a single point.\nTouching: One of the endpoints is on [a, b], but there are no other intersections.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_triangle","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, c, p) -> Certificate\npoint_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, u) -> Certificate\npoint_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, u) -> Certificate\n\nGiven a positively oriented triangle with coordinates (a, b, c) (or triangle T = (i, j, k) of tri), computes the position of p (or vertex u) relative to the triangle. The returned value is a Certificate, which is one of:\n\nOutside: p is outside of the triangle.\nOn: p is on one of the edges.\nInside: p is inside the triangle.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nnote: Ghost triangles\nIf T is a ghost triangle, then it is not checked if the point is on any of the ghost edges,\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","text":"point_position_relative_to_oriented_outer_halfplane([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p) -> Certificate\n\nGiven an edge with coordinates (a, b) and a point p,  tests the position of p relative to the oriented outer halfplane defined by (a, b). The returned value is a Certificate, which is one of:\n\nOutside: p is outside of the oriented outer halfplane, meaning to the right of the line (a, b) or collinear with a and b but not on the line segment (a, b).\nOn: p is on the line segment [a, b].\nInside: p is inside of the oriented outer halfplane, meaning to the left of the line (a, b).\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nExtended help\n\nThe oriented outer halfplane is the union of the open halfplane defined by the region to the left of the oriented line (a, b), and the open line segment (a, b).\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_legal","page":"Predicates","title":"DelaunayTriangulation.is_legal","text":"is_legal([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j; cache = nothing) -> Certificate \nis_legal([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r, s[, cache = nothing]) -> Certificate\n\nTests if the edge (p, q) (or the edge (i, j) of tri) is legal, where the edge (p, q) is incident to two triangles (p, q, r) and (q, p, s). In partiuclar, tests that s is not inside  the triangle through (p, q, r). The returned value is a Certificate, which is one of:\n\nLegal: The edge (p, q) is legal.\nIllegal: The edge (p, q) is illegal.\n\nIf the edge (i, j) is a segment of tri or is a ghost edge, then the edge is always legal.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is passed to [point_position_relative_to_circumcircle] and should be one of \n\nnothing: No cache is used.\nAdaptivePredicates.incircleadapt_cache(T), where T is the number type used (Float64 or Float32).\n\nThe cache is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.triangle_line_segment_intersection","page":"Predicates","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r, a, b) -> Certificate \ntriangle_line_segment_intersection([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, u, v) -> Certificate\n\nClassifies the intersection of the line segment (a, b) (or the edge (u, v) of tri) with the triangle (p, q, r) (or the triangle (i, j, k) of tri). The returned value is a Certificate, which is one of:\n\nInside: (a, b) is entirely inside (p, q, r).\nSingle: (a, b) has one endpoint inside (p, q, r), and the other is outside.\nOutside: (a, b) is entirely outside (p, q, r).\nTouching: (a, b) is on (p, q, r)'s boundary, but not in its interior.\nMultiple: (a, b) passes entirely through (p, q, r). This includes the case where a point is on the boundary of (p, q, r).\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.find_edge","page":"Predicates","title":"DelaunayTriangulation.find_edge","text":"find_edge([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, ℓ) -> Edge\n\nGiven a triangle T = (i, j, k) of tri and a vertex ℓ of tri, returns the edge of T that contains ℓ.  If no such edge exists, the edge (k, i) is returned. You can control the method for computing predicates  using the kernel argument.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_circumcircle","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, ℓ; cache = nothing) -> Certificate\npoint_position_relative_to_circumcircle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, ℓ; cache = nothing) -> Certificate\n\nTests the position of the vertex ℓ of tri relative to the circumcircle of the triangle T = (i, j, k). The returned value is a Certificate, which is one of:\n\nOutside: ℓ is outside of the circumcircle of T.\nOn: ℓ is on the circumcircle of T.\nInside: ℓ is inside the circumcircle of T.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is useful when an AdaptiveKernel() is used. Depending on whether the triangulation is weighted or not, the cache should be of the following:\n\nnothing: No cache is used.\nAdaptivePredicates.incircleadapt_cache(T), where T is the number type used (Float64 or Float32). This is used for unweighted triangulations.\nAdaptivePredicates.orient3adapt_cache(T), where T is the number type used (Float64 or Float32). This is used for weighted triangulations.\n\nIn case the wrong cache type is used, it is replaced with nothing.\n\nnote: Ghost triangles\nThe circumcircle of a ghost triangle is defined as the oriented outer halfplane of the solid edge of the triangle. See point_position_relative_to_oriented_outer_halfplane.\n\nnote: Weighted triangulations\nIf tri is a weighted triangulation, then an orientation test is instead applied, testing the orientation of the lifted companions of each point to determine if  ℓ is above or below the witness plane relative to (i, j, k). For ghost triangles, the same rule applies, although if the vertex is on the solid edge of the ghost triangle then, in addition to checking point_position_relative_to_oriented_outer_halfplane, we must check if the new vertex is not submerged by the adjoining solid triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_witness_plane","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_witness_plane","text":"point_position_relative_to_witness_plane([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, ℓ; cache = nothing) -> Certificate\n\nGiven a positively oriented triangle T = (i, j, k) of tri and a vertex ℓ of tri, returns the position of ℓ relative to the witness plane of T. The returned value is a Certificate, which is one of:\n\nAbove: ℓ is above the witness plane of T.\nOn: ℓ is on the witness plane of T.\nBelow: ℓ is below the witness plane of T.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is useful when an AdaptiveKernel() is used, and should be one of:\n\nnothing: No cache is used.\nAdaptivePredicates.orient3adapt_cache(T), where T is the number type used (Float64 or Float32).\n\nExtended help\n\nThe witness plane of a triangle is defined as the plane through the triangle (i⁺, j⁺, k⁺) where, for example, pᵢ⁺ = (x, y, x^2 + y^2 - wᵢ) is the lifted companion of i  and (x, y) are the coordinates of the ith vertex. Moreover, by the orientation of ℓ relative to this witness plane we are referring to ℓ⁺'s position, not the plane point ℓ.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.opposite_angle","page":"Predicates","title":"DelaunayTriangulation.opposite_angle","text":"opposite_angle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -> Certificate\n\nTests the angle opposite to the edge (p, q) in the triangle (p, q, r), meaning ∠prq. The returned value is a  Certificate, which is one of:\n\nObtuse: The angle opposite to (p, q) is obtuse.\nRight: The angle opposite to (p, q) is a right angle.\nAcute: The angle opposite to (p, q) is acute.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nnote: Angle between two vectors\nThis function computes (p - r) ⋅ (q - r). If you want the angle between vectors a = pq and b = pr, then you should use opposite_angle(r, q, p) = (r - p) ⋅ (q - p).\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_diametral_circle","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_diametral_circle","text":"point_position_relative_to_diametral_circle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -> Certificate\n\nGiven an edge (p, q) and a point r, returns the position of r relative to the diametral circle of (p, q). The returned value  is a Certificate, which is one of:\n\nInside: r is inside the diametral circle.\nOn: r is on the diametral circle.\nOutside: r is outside the diametral circle.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nExtended help\n\nThe check is done by noting that a point is in the diametral circle if, and only if, the angle at r is obtuse.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.point_position_relative_to_diametral_lens","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_diametral_lens","text":"point_position_relative_to_diametral_lens(p, q, r, lens_angle=30.0) -> Certificate\n\nGiven an edge (p, q) and a point r, returns the position of r relative to the diametral lens of (p, q) with lens angle lens_angle (in degrees). The returned value  is a Certificate, which is one of:\n\nInside: r is inside the diametral lens.\nOn: r is on the diametral lens.\nOutside: r is outside the diametral lens.\n\nwarning: Warning\nThis function assumes that the lens angle is at most 45°.\n\nExtended help\n\nThe diametral lens is slightly similar to a diametral circle. Let us first define the standard definition of a diametral lens, where lens_angle = 30°, and then we define its  generalisation. The standard definition was introduced by Shewchuk in 2002 in this paper, and the generalisation was originally  described in Section 3.4 of Shewchuk's 1997 PhD thesis here (as was the standard definition, of course).\n\nStandard definition: Let the segment be s ≔ (p, q) and let ℓ be the perpendicular bisector of s. Define two circles C⁺ and C⁻ whose centers lie left and right  of s, respectively, both the same distance away from the midpoint m = (p + q)/2. By placing each disk a distance |s|/(2√3) away from m and extending the disks so that  they both touch p and q, meaning they each have radius |s|/√3, we obtain disks that touch p and q as well as the center of the other disk. The intersection of the two  disks defines the diametral lens. The lens angle associated with this lens is 30°, as we could draw lines between p and q and the poles of the disks to form isosceles triangles  on each side, giving angles of 30° at p and q.\n\nGeneralised definition: The generalisation of the above definition aims to generalise the lens angle to some angle θ. In particular, let us draw a line from p towards some point  u which is left of s and on the perpendicular bisector, where the line is at an angle θ. This defines a triplet of points (p, q, u) from which we can define a circle, and similarly for a point v right of s. The intersection of these two circles is the diametral lens with angle θ. We can also figure out how far u is along the perpendicular bisector, i.e. how far away it is from (p + q)/2, using basic trigonometry. Let m = (p +  q)/2, and consider the triangle △pmu. The side lengths of this triangle are |pm| = |s|/2, |mu| ≔ b, and |up| ≔ c. Let us first compute c.  We have cos(θ) = |pm|/|up| = |s|/(2c), and so c = |s|/(2cos(θ)). So, sin(θ) = |mu|/|up| = b/c, which gives b = csin(θ) = |s|sin(θ)/(2cos(θ)) = |s|tan(θ)/2. So, u is a distance |s|tan(θ)/2 from the midpoint. Notice that in the case θ = 30°, tan(θ) = √3/3, giving b = |s|√3/6 = |s|/(2√3), which is the same as the standard definition.\n\nTo test if a point r is inside the diametral lens with lens angle θ°, we simply have to check the angle  at that point, i.e. the angle at r in the triangle pqr. If this angle is greater than 180° - 2θ°, then r is inside of the lens. This result  comes from Shewchuk (2002). Note that this is the same as a diametral circle in the case θ° = 45°. \n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_ghost_vertex","page":"Predicates","title":"DelaunayTriangulation.is_ghost_vertex","text":"is_ghost_vertex(i) -> Bool\n\nTests if i is a ghost vertex, meaning i ≤ -1.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_boundary_edge","page":"Predicates","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(tri::Triangulation, ij) -> Bool\nis_boundary_edge(tri::Triangulation, i, j) -> Bool\n\nTests if the edge (i, j) is a boundary edge of tri, meaning (j, i) adjoins a ghost vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_boundary_triangle","page":"Predicates","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(tri::Triangulation, T) -> Bool\nis_boundary_triangle(tri::Triangulation, i, j, k) -> Bool\n\nReturns true if the triangle T = (i, j, k) of tri has an edge on the boundary, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_ghost_edge","page":"Predicates","title":"DelaunayTriangulation.is_ghost_edge","text":"is_ghost_edge(ij) -> Bool \nis_ghost_edge(i, j) -> Bool\n\nTests if the edge (i, j) is a ghost edge, meaning i or j is a ghost vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_ghost_triangle","page":"Predicates","title":"DelaunayTriangulation.is_ghost_triangle","text":"is_ghost_triangle(T) -> Bool\nis_ghost_triangle(i, j, k) -> Bool\n\nTests if T = (i, j, k) is a ghost triangle, meaning i, j or k is a ghost vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_boundary_node","page":"Predicates","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(tri::Triangulation, i) -> (Bool, Vertex)\n\nTests if the vertex i is a boundary node of tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The vertex to test. \n\nOutputs\n\nflag: true if i is a boundary node, and false otherwise.\ng: Either the ghost vertex corresponding with the section that i lives on if flag is true, or 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.contains_segment","page":"Predicates","title":"DelaunayTriangulation.contains_segment","text":"contains_segment(tri::Triangulation, ij) -> Bool \ncontains_segment(tri::Triangulation, i, j) -> Bool\n\nReturns true if (i, j) is a segment in tri, and false otherwise. Both (i, j) and (j, i) are checked.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.contains_triangle","page":"Predicates","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(T, V) -> (Triangle, Bool)\n\nCheck if the collection of triangles V contains the triangle T up to rotation. The Triangle returned is the triangle in V that is equal to T up to rotation,  or T if no such triangle exists. The Bool is true if V contains T, and false otherwise.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (7, 8, 9)\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.contains_triangle((1, 2, 3), V)\n((1, 2, 3), true)\n\njulia> DelaunayTriangulation.contains_triangle((2, 3, 1), V)\n((1, 2, 3), true)\n\njulia> DelaunayTriangulation.contains_triangle((10, 18, 9), V)\n((10, 18, 9), false)\n\njulia> DelaunayTriangulation.contains_triangle(9, 7, 8, V)\n((7, 8, 9), true)\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.edge_exists","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(tri::Triangulation, ij) -> Bool \nedge_exists(tri::Triangulation, i, j) -> Bool\n\nTests if the edge (i, j) is in tri, returning true if so and false otherwise. \n\nSee also unoriented_edge_exists.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.unoriented_edge_exists","page":"Predicates","title":"DelaunayTriangulation.unoriented_edge_exists","text":"unoriented_edge_exists(tri::Triangulation, ij) -> Bool \nunoriented_edge_exists(tri::Triangulation, i, j) -> Bool\n\nTests if the unoriented edge (i, j) is in tri, returning true if so and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_ghost_triangles","page":"Predicates","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(tri::Triangulation) -> Bool\n\nReturns true if tri has ghost triangles, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_constrained","page":"Predicates","title":"DelaunayTriangulation.is_constrained","text":"is_constrained(tri::Triangulation) -> Bool\n\nReturns true if tri has constrained edges (segments), and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_multiple_curves","page":"Predicates","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(boundary_nodes) -> Bool\n\nCheck if boundary_nodes has multiple curves.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.has_multiple_curves([1, 2, 3, 1])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_curves([[1, 2, 3], [3, 4, 1]])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_multiple_sections","page":"Predicates","title":"DelaunayTriangulation.has_multiple_sections","text":"has_multiple_sections(boundary_nodes) -> Bool\n\nCheck if boundary_nodes has multiple sections.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.has_multiple_sections([1, 2, 3, 1])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_sections([[1, 2, 3], [3, 4, 1]])\ntrue\n\njulia> DelaunayTriangulation.has_multiple_sections([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.has_boundary_nodes","page":"Predicates","title":"DelaunayTriangulation.has_boundary_nodes","text":"has_boundary_nodes(tri::Triangulation) -> Bool\n\nReturns true if tri has boundary nodes, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_weighted","page":"Predicates","title":"DelaunayTriangulation.is_weighted","text":"is_weighted(weights) -> Bool\n\nReturns true if weights represents a set of weights that are not all zero, and false otherwise. Note that even for vectors like zeros(n), this will return true; by default, false is returned only for  weights = ZeroWeight().\n\n\n\n\n\nis_weighted(tri::Triangulation) -> Bool\n\nReturns true if tri is weighted, and false otherwise.\n\n\n\n\n\nis_weighted(vorn::VoronoiTessellation) -> Bool\n\nReturns true if the Voronoi tessellation vorn is weighted, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_negativelyoriented","page":"Predicates","title":"DelaunayTriangulation.is_negativelyoriented","text":"is_negativelyoriented(cert::Certificate) -> Bool\n\nReturns true if cert is NegativelyOriented, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/predicates/#DelaunayTriangulation.is_positivelyoriented","page":"Predicates","title":"DelaunayTriangulation.is_positivelyoriented","text":"is_positivelyoriented(cert::Certificate) -> Bool\n\nReturns true if cert is PositivelyOriented, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/operations_ghost_triangles/#Triangulation-Operations","page":"Adding or Clearing Ghost Triangles","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_ghost_triangles/#Adding-or-Clearing-Ghost-Triangles","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"","category":"section"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"An important component to be aware of when considering dynamic updates to triangulations are the ghost triangles. As we discussed in the vertex insertion/deletion example, ghost triangles are needed when we are making updates outside of the boundary of the current triangulation.","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"Let us take an example triangulation.","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"points = [(-1.0, -1.0), (1.0, -1.0), (0.0, 1.0)]\ntri = triangulate(points)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"fig, ax, sc = triplot(tri, show_ghost_edges = true)\nfig","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"The ghost triangles are represented by the convex regions bounded by the blue lines. By default, triangulate will keep these ghost triangles. If you want to remove them, you'd have to use delete_ghost_triangles! or use delete_ghosts = true inside triangulate.","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"If you do need to query whether your triangulation already has ghost triangles, use","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"DelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"To clear the ghost triangles, use","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"delete_ghost_triangles!(tri)\nDelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"An important note for us to make is that ghost triangles are not just there as a concept, but they are actually physically stored. Adding them back with add_ghost_triangles!, we have:","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"add_ghost_triangles!(tri)\nget_triangles(tri)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"See that there is not just the triangle (1, 2, 3), but also (3, 2, -1), (1, 3, -1), and (2, 1, -1) (where the ghost triangles are also oriented counter-clockwise). For example,","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent(tri, 3, 2)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent(tri, 3, -1)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent(tri, -1, 2)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_neighbours(tri, -1)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent2vertex(tri, -1)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"If we delete them, they are no longer there.","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"delete_ghost_triangles!(tri)\nget_triangles(tri)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"As a last note, we remark that the ghost vertices that define the vertex of these ghost triangles is still there regardless of whether the triangulation has ghost triangles. Thus, for example, the following still work","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_neighbours(tri, -1)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent2vertex(tri, -1)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"get_adjacent(tri, 3, 2)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"You can remove them from the graph, using","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"DelaunayTriangulation.delete_ghost_vertices_from_graph!(tri)","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"so that e.g. get_neighbours(tri, -1) is then an error. This will still not remove them from the adjacent and adjacent2vertex maps, but it does mean for example that","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"collect(each_solid_vertex(tri)) == collect(each_vertex(tri))","category":"page"},{"location":"tutorials/operations_ghost_triangles/#Just-the-code","page":"Adding or Clearing Ghost Triangles","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [(-1.0, -1.0), (1.0, -1.0), (0.0, 1.0)]\ntri = triangulate(points)\n\nfig, ax, sc = triplot(tri, show_ghost_edges = true)\nfig\n\nDelaunayTriangulation.has_ghost_triangles(tri)\n\ndelete_ghost_triangles!(tri)\nDelaunayTriangulation.has_ghost_triangles(tri)\n\nadd_ghost_triangles!(tri)\nget_triangles(tri)\n\nget_adjacent(tri, 3, 2)\n\nget_adjacent(tri, 3, -1)\n\nget_adjacent(tri, -1, 2)\n\nget_neighbours(tri, -1)\n\nget_adjacent2vertex(tri, -1)\n\ndelete_ghost_triangles!(tri)\nget_triangles(tri)\n\nget_neighbours(tri, -1)\n\nget_adjacent2vertex(tri, -1)\n\nget_adjacent(tri, 3, 2)\n\nDelaunayTriangulation.delete_ghost_vertices_from_graph!(tri)\n\ncollect(each_solid_vertex(tri)) == collect(each_vertex(tri))","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"","category":"page"},{"location":"tutorials/operations_ghost_triangles/","page":"Adding or Clearing Ghost Triangles","title":"Adding or Clearing Ghost Triangles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/constrained_multiply_connected/#Constrained-Triangulations","page":"Domain with Interior Holes","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tutorials/constrained_multiply_connected/#Domain-with-Interior-Holes","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"","category":"section"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"We now consider triangulating a domain which has not only a boundary, but also an interior boundary. To start, let us load the packages.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"Let us now define what we will be triangulating. The boundary will be made up of a boundary and three interior holes. To represent the boundaries for this case, we use a vector of vector of vectors. The triple-nested vector structure is necessary to allow for individual boundaries to be segmented (as in the previous tutorial). Moreover, while the outer boundary must be counter-clockwise, the interior boundaries must be clockwise so that the orientations of the interiors relative to the boundaries are consistent. Note again that neighbouring segments must connect.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"curve_1 = [\n    # first segment\n    [\n        (0.0, 0.0), (4.0, 0.0), (8.0, 0.0), (12.0, 0.0), (12.0, 4.0),\n        (12.0, 8.0), (14.0, 10.0), (16.0, 12.0), (16.0, 16.0),\n        (14.0, 18.0), (12.0, 20.0), (12.0, 24.0), (12.0, 28.0),\n    ],\n    # second segment\n    [\n        (12.0, 28.0), (8.0, 28.0), (4.0, 28.0), (0.0, 28.0), (-2.0, 26.0), (0.0, 22.0),\n        (0.0, 18.0), (0.0, 10.0), (0.0, 8.0), (0.0, 4.0), (-4.0, 4.0),\n        (-4.0, 0.0), (0.0, 0.0),\n    ],\n] # outer: counter-clockwise\ncurve_2 = [\n    # first segment\n    [\n        (4.0, 26.0), (8.0, 26.0), (10.0, 26.0), (10.0, 24.0),\n        (10.0, 22.0), (10.0, 20.0),\n    ],\n    # second segment\n    [\n        (10.0, 20.0), (8.0, 20.0), (6.0, 20.0),\n        (4.0, 20.0), (4.0, 22.0), (4.0, 24.0), (4.0, 26.0),\n    ],\n] # inner: clockwise\ncurve_3 = [[(4.0, 16.0), (12.0, 16.0), (12.0, 14.0), (4.0, 14.0), (4.0, 16.0)]] # inner: clockwise\ncurve_4 = [[(4.0, 8.0), (10.0, 8.0), (8.0, 6.0), (6.0, 6.0), (4.0, 8.0)]] # inner: clockwise\ncurves = [curve_1, curve_2, curve_3, curve_4]\npoints = [\n    (2.0, 26.0), (2.0, 24.0), (6.0, 24.0), (6.0, 22.0), (8.0, 24.0), (8.0, 22.0),\n    (2.0, 22.0), (0.0, 26.0), (10.0, 18.0), (8.0, 18.0), (4.0, 18.0), (2.0, 16.0),\n    (2.0, 12.0), (6.0, 12.0), (2.0, 8.0), (2.0, 4.0), (4.0, 2.0),\n    (-2.0, 2.0), (4.0, 6.0), (10.0, 2.0), (10.0, 6.0), (8.0, 10.0), (4.0, 10.0),\n    (10.0, 12.0), (12.0, 12.0), (14.0, 26.0), (16.0, 24.0), (18.0, 28.0),\n    (16.0, 20.0), (18.0, 12.0), (16.0, 8.0), (14.0, 4.0), (14.0, -2.0),\n    (6.0, -2.0), (2.0, -4.0), (-4.0, -2.0), (-2.0, 8.0), (-2.0, 16.0),\n    (-4.0, 22.0), (-4.0, 26.0), (-2.0, 28.0), (6.0, 15.0), (7.0, 15.0),\n    (8.0, 15.0), (9.0, 15.0), (10.0, 15.0), (6.2, 7.8),\n    (5.6, 7.8), (5.6, 7.6), (5.6, 7.4), (6.2, 7.4), (6.0, 7.6),\n    (7.0, 7.8), (7.0, 7.4),\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points = points);\nnothing #hide","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"Notice that curve_1 and curve_2 are split up into multiple segments. For curve_3 and curve_4, note that we have to wrap the entire vector in a vector, essentially treating them as a single segment.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"Now let us triangulate.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"rng = StableRNG(123) # the triangulation is not unique due to cocircular points\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri, show_constrained_edges = true, show_convex_hull = true)\nfig","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"Like before, we examine individual segments by referring to them by their ghost vertices, which are still in the order -1, -2, and so on in the order of the segments provided in boundary_nodes. This is a lot more cumbersome to keep track of than the previous tutorials since there are many more ghost vertices. This is where the boundary fields become much more useful. For instance, the boundary_edge_map in this case is given by:","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"get_boundary_edge_map(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"The Tuples in the values are now of the form ((I, J), K), with I the curve index (with 1 being the outer boundary), J the segment index, and K the position of the edge within the segment. To look at the ghost vertices directly, another useful field is ghost_vertex_ranges:","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"get_ghost_vertex_ranges(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"This field maps a ghost vertex to the complete set of ghost vertices that might be found on the curve corresponding to that ghost vertex. For example, -3 => -4:-3 means that the ghost vertex -3 is part of a curve that, in addition to itself, contains the ghost vertex -4. If you want all the ghost vertex, you can use","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"DelaunayTriangulation.all_ghost_vertices(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"which is just keys(get_ghost_vertex_ranges(tri)). If you just want to find what curve and what segment a ghost vertex belongs to, you can look at the ghost_vertex_map:","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"get_ghost_vertex_map(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"So that, for example, -3 => (2, 1) means that the ghost vertex -3 corresponds to the first part (from the second Tuple element) of the second curve (from the first Tuple element).","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"To get all the boundary nodes, you can use","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"DelaunayTriangulation.get_all_boundary_nodes(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"To give an example of how we can work with this boundary, let us compute the area of the triangulation (a more efficient approach is with get_area(tri), but this is just for demonstration). For this, the order of the boundary edges is appropriate, so we must iterate in a way that respects the ordering.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"function get_triangulation_area(tri)\n    A = 0.0\n    nc = DelaunayTriangulation.num_curves(tri)\n    for curve_index in 1:nc\n        bn = get_boundary_nodes(tri, curve_index)\n        ns = DelaunayTriangulation.num_sections(bn)\n        for segment_index in 1:ns\n            bnn = get_boundary_nodes(bn, segment_index)\n            ne = num_boundary_edges(bnn)\n            for i in 1:ne\n                vᵢ = get_boundary_nodes(bnn, i)\n                vᵢ₊₁ = get_boundary_nodes(bnn, i + 1)\n                pᵢ, pᵢ₊₁ = get_point(tri, vᵢ, vᵢ₊₁)\n                xᵢ, yᵢ = getxy(pᵢ)\n                xᵢ₊₁, yᵢ₊₁ = getxy(pᵢ₊₁)\n                A += (yᵢ + yᵢ₊₁) * (xᵢ - xᵢ₊₁)\n            end\n        end\n    end\n    return A / 2\nend\nA = get_triangulation_area(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"This is of course quite a complicated example since we need to take care of the order. If we don't care about order, then the complexity of the code for iterating over a boundary is much simpler. For example, here we compute the perimeter of the boundary, and we also consider the length of each curve and of each segment.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"function get_perimeters(tri)\n    total_perimeter = 0.0\n    nc = DelaunayTriangulation.num_curves(tri)\n    curve_perimeters = zeros(nc) # curve_index => perimeter\n    segment_perimeters = Dict{NTuple{2, Int}, Float64}() # (curve_index, segment_index) => perimeter\n    for (e, ((curve_index, section_index), node_index)) in get_boundary_edge_map(tri)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ = sqrt((getx(p) - getx(q))^2 + (gety(p) - gety(q))^2)\n        total_perimeter += ℓ\n        curve_perimeters[curve_index] += ℓ\n        if haskey(segment_perimeters, (curve_index, section_index))\n            segment_perimeters[(curve_index, section_index)] += ℓ\n        else\n            segment_perimeters[(curve_index, section_index)] = ℓ\n        end\n    end\n    return total_perimeter, curve_perimeters, segment_perimeters\nend\nℓ, cℓ, sℓ = get_perimeters(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/#Just-the-code","page":"Domain with Interior Holes","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\ncurve_1 = [\n    # first segment\n    [\n        (0.0, 0.0), (4.0, 0.0), (8.0, 0.0), (12.0, 0.0), (12.0, 4.0),\n        (12.0, 8.0), (14.0, 10.0), (16.0, 12.0), (16.0, 16.0),\n        (14.0, 18.0), (12.0, 20.0), (12.0, 24.0), (12.0, 28.0),\n    ],\n    # second segment\n    [\n        (12.0, 28.0), (8.0, 28.0), (4.0, 28.0), (0.0, 28.0), (-2.0, 26.0), (0.0, 22.0),\n        (0.0, 18.0), (0.0, 10.0), (0.0, 8.0), (0.0, 4.0), (-4.0, 4.0),\n        (-4.0, 0.0), (0.0, 0.0),\n    ],\n] # outer: counter-clockwise\ncurve_2 = [\n    # first segment\n    [\n        (4.0, 26.0), (8.0, 26.0), (10.0, 26.0), (10.0, 24.0),\n        (10.0, 22.0), (10.0, 20.0),\n    ],\n    # second segment\n    [\n        (10.0, 20.0), (8.0, 20.0), (6.0, 20.0),\n        (4.0, 20.0), (4.0, 22.0), (4.0, 24.0), (4.0, 26.0),\n    ],\n] # inner: clockwise\ncurve_3 = [[(4.0, 16.0), (12.0, 16.0), (12.0, 14.0), (4.0, 14.0), (4.0, 16.0)]] # inner: clockwise\ncurve_4 = [[(4.0, 8.0), (10.0, 8.0), (8.0, 6.0), (6.0, 6.0), (4.0, 8.0)]] # inner: clockwise\ncurves = [curve_1, curve_2, curve_3, curve_4]\npoints = [\n    (2.0, 26.0), (2.0, 24.0), (6.0, 24.0), (6.0, 22.0), (8.0, 24.0), (8.0, 22.0),\n    (2.0, 22.0), (0.0, 26.0), (10.0, 18.0), (8.0, 18.0), (4.0, 18.0), (2.0, 16.0),\n    (2.0, 12.0), (6.0, 12.0), (2.0, 8.0), (2.0, 4.0), (4.0, 2.0),\n    (-2.0, 2.0), (4.0, 6.0), (10.0, 2.0), (10.0, 6.0), (8.0, 10.0), (4.0, 10.0),\n    (10.0, 12.0), (12.0, 12.0), (14.0, 26.0), (16.0, 24.0), (18.0, 28.0),\n    (16.0, 20.0), (18.0, 12.0), (16.0, 8.0), (14.0, 4.0), (14.0, -2.0),\n    (6.0, -2.0), (2.0, -4.0), (-4.0, -2.0), (-2.0, 8.0), (-2.0, 16.0),\n    (-4.0, 22.0), (-4.0, 26.0), (-2.0, 28.0), (6.0, 15.0), (7.0, 15.0),\n    (8.0, 15.0), (9.0, 15.0), (10.0, 15.0), (6.2, 7.8),\n    (5.6, 7.8), (5.6, 7.6), (5.6, 7.4), (6.2, 7.4), (6.0, 7.6),\n    (7.0, 7.8), (7.0, 7.4),\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points = points);\n\nrng = StableRNG(123) # the triangulation is not unique due to cocircular points\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri, show_constrained_edges = true, show_convex_hull = true)\nfig\n\nget_boundary_edge_map(tri)\n\nget_ghost_vertex_ranges(tri)\n\nDelaunayTriangulation.all_ghost_vertices(tri)\n\nget_ghost_vertex_map(tri)\n\nDelaunayTriangulation.get_all_boundary_nodes(tri)\n\nfunction get_triangulation_area(tri)\n    A = 0.0\n    nc = DelaunayTriangulation.num_curves(tri)\n    for curve_index in 1:nc\n        bn = get_boundary_nodes(tri, curve_index)\n        ns = DelaunayTriangulation.num_sections(bn)\n        for segment_index in 1:ns\n            bnn = get_boundary_nodes(bn, segment_index)\n            ne = num_boundary_edges(bnn)\n            for i in 1:ne\n                vᵢ = get_boundary_nodes(bnn, i)\n                vᵢ₊₁ = get_boundary_nodes(bnn, i + 1)\n                pᵢ, pᵢ₊₁ = get_point(tri, vᵢ, vᵢ₊₁)\n                xᵢ, yᵢ = getxy(pᵢ)\n                xᵢ₊₁, yᵢ₊₁ = getxy(pᵢ₊₁)\n                A += (yᵢ + yᵢ₊₁) * (xᵢ - xᵢ₊₁)\n            end\n        end\n    end\n    return A / 2\nend\nA = get_triangulation_area(tri)\n\nfunction get_perimeters(tri)\n    total_perimeter = 0.0\n    nc = DelaunayTriangulation.num_curves(tri)\n    curve_perimeters = zeros(nc) # curve_index => perimeter\n    segment_perimeters = Dict{NTuple{2, Int}, Float64}() # (curve_index, segment_index) => perimeter\n    for (e, ((curve_index, section_index), node_index)) in get_boundary_edge_map(tri)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ = sqrt((getx(p) - getx(q))^2 + (gety(p) - gety(q))^2)\n        total_perimeter += ℓ\n        curve_perimeters[curve_index] += ℓ\n        if haskey(segment_perimeters, (curve_index, section_index))\n            segment_perimeters[(curve_index, section_index)] += ℓ\n        else\n            segment_perimeters[(curve_index, section_index)] = ℓ\n        end\n    end\n    return total_perimeter, curve_perimeters, segment_perimeters\nend\nℓ, cℓ, sℓ = get_perimeters(tri)","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"","category":"page"},{"location":"tutorials/constrained_multiply_connected/","page":"Domain with Interior Holes","title":"Domain with Interior Holes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/point_in_polygon/#Point-in-Polygon-Testing","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"","category":"section"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"This tutorial shows how we can perform point-in-polygon testing, and how we can find a polygon containing a point. First, let us build this ploygon.","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nC = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [\n    [\n        K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n        O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n        H5, I5, J5, K5,\n    ],\n]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nxmin, xmax, ymin, ymax = DelaunayTriangulation.polygon_bounds(points, nodes, Val(true)) # Val(true) => check all parts of the polygon\nrng = StableRNG(123)\nquery_points = [((xmax - xmin) * rand(rng) + xmin, (ymax - ymin) * rand(rng) + ymin) for _ in 1:1000]\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, query_points)\nfor nodes in nodes\n    lines!(ax, points[reduce(vcat, nodes)], color = :magenta, linewidth = 3)\nend\nfig","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"To now determine which of these query points are inside any of the magenta regions, we have several methods:","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"Using DelaunayTriangulation.distance_to_polygon, check if the distance to the polygon is positive (inside) or negative (outside).\nTriangulate the domain and use DelaunayTriangulation.dist to get the distance from a point to the triangulation.\nTriangulate the domain and use find_polygon to find a polygon, or identify the lack of a polygon, containing the point.\nSimilar to the previous method, but constructing the DelaunayTriangulation.PolygonHierarchy to avoid the need for triangulating (this is what the third method does).","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"The most efficient approach is the first (since all of them essentially just use the first method), but for the sake of demonstration, we will show all four methods here since, for example, you might already have a triangulation and want to use that. We also emphasise that the tests we perform here do not use exact arithmetic, unlike other predicates in this package, so there may be some robustness issues for points very close to the boundary. Here is the first approach:","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"is_inside = [DelaunayTriangulation.distance_to_polygon(q, points, nodes) > 0 for q in query_points]\nscatter!(ax, query_points[is_inside], color = :blue)\nscatter!(ax, query_points[.!is_inside], color = :red)\nfig","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"Here is the second method.","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"tri = triangulate(points; boundary_nodes = nodes)\nis_inside_2 = [DelaunayTriangulation.dist(tri, q) > 0 for q in query_points];\nnothing #hide","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"The third method is to use find_polygon to find the polygon containing the point. If no such polygon exists, find_polygon returns 0, so this is what we use to determine if a point is inside or outside the polygon.","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"is_inside_3 = [find_polygon(tri, q) ≠ 0 for q in query_points];\nnothing #hide","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"This test is not exactly the same as the previous one (with a difference of about five points) due to points near the boundary. The fourth method is:","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"hierarchy = DelaunayTriangulation.construct_polygon_hierarchy(points, nodes)\nis_inside_4 = [find_polygon(hierarchy, points, nodes, q) ≠ 0 for q in query_points];\nnothing #hide","category":"page"},{"location":"tutorials/point_in_polygon/#Just-the-code","page":"Point-in-Polygon Testing","title":"Just the code","text":"","category":"section"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nC = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [\n    [\n        K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n        O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n        H5, I5, J5, K5,\n    ],\n]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nxmin, xmax, ymin, ymax = DelaunayTriangulation.polygon_bounds(points, nodes, Val(true)) # Val(true) => check all parts of the polygon\nrng = StableRNG(123)\nquery_points = [((xmax - xmin) * rand(rng) + xmin, (ymax - ymin) * rand(rng) + ymin) for _ in 1:1000]\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, query_points)\nfor nodes in nodes\n    lines!(ax, points[reduce(vcat, nodes)], color = :magenta, linewidth = 3)\nend\nfig\n\nis_inside = [DelaunayTriangulation.distance_to_polygon(q, points, nodes) > 0 for q in query_points]\nscatter!(ax, query_points[is_inside], color = :blue)\nscatter!(ax, query_points[.!is_inside], color = :red)\nfig\n\ntri = triangulate(points; boundary_nodes = nodes)\nis_inside_2 = [DelaunayTriangulation.dist(tri, q) > 0 for q in query_points];\n\nis_inside_3 = [find_polygon(tri, q) ≠ 0 for q in query_points];\n\nhierarchy = DelaunayTriangulation.construct_polygon_hierarchy(points, nodes)\nis_inside_4 = [find_polygon(hierarchy, points, nodes, q) ≠ 0 for q in query_points];","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"","category":"page"},{"location":"tutorials/point_in_polygon/","page":"Point-in-Polygon Testing","title":"Point-in-Polygon Testing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/ghost_triangles/#Ghost-(Negative)-Vertices","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"","category":"section"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"In this section, we will describe how ghost triangles and ghost vertices are used in this package to represent boundary information. This is a crucial part of the package, and especially for understanding output from triangulations, as it is how we represent regions exterior to a boundary and traverse this exterior.","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"Ghost vertices are negative vertices that are associated with a part of a boundary. Mathematically speaking, they are typically treated as points out at infinity, and each edge on the boundary adjoins a ghost vertex. This way, all edges have two adjoining vertices and we can associate any point in space, including points outside of the triangulation, with a triangle. As an example, if tri is a triangulation and get_adjacent(tri, u, v) == -1, then this means that (u, v) is an edge on the boundary of the triangulation. This number -1 is defined as DelaunayTriangulation.𝒢 internally.","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"In the case of a single contiguous boundary, the only possible ghost vertex is -1. When it comes to considering a boundary with mutliple sections or multiple boundaries, then we need to have multiple ghost vertices to refer to eachs ection separately. We accomplish this by simply subtracting 1 from the current ghost vertex for each new section. For example, if the boundary node vector is ","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"boundary_nodes = [\n    [section_1, section_2, section_3],\n    [section_4, section_5],\n    [section_6],\n    [section_7, section_8, section_9, section_10]\n]","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"then the ith section will be associated with the ghost vertex -i. We note that this setup does not allow for all nodes to be uniquely associated with a ghost vertex, since nodes connecting between two sections will necessarily have two ghost vertices associated with them. Instead, each edge has only one ghost vertex associated with it. This issue causes problems when using get_adjacent to step along a boundary and is why you will notice, if you look at the internals for get_adjacent(::Triangulation, ::Any), the implementation is somewhat verbose. These issues are also why the Triangulation data structure has the ghost_vertex_map and ghost_vertex_ranges fields, with the former allowing get_boundary_nodes(tri, DelaunayTriangulation.map_ghost_vertex(tri, g)) to be used to get the boundary nodes associated with a ghost vertex g. The issue with a curve having multiple ghost vertices is handled with ghost_vertex_ranges, allowing us to identify all possible ghost vertices associated with a curve that has a specific ghost vertex via DelaunayTriangulation.get_ghost_vertex_range(tri, g). For example, in the boundary_nodes example above, -2 would map to -3:-1.","category":"page"},{"location":"manual/ghost_triangles/#Ghost-Triangles","page":"Ghost (Negative) Vertices","title":"Ghost Triangles","text":"","category":"section"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"Ghost triangles are special triangles that have a solid edge (u, v) and a vertex g associated with some ghost vertex. These ghost triangles are needed to make point location work when points are outside of the triangulation, provided that we associate the ghost vertex g with a physical point. For the first boundary, the physical point just has to be somewhat in the centre of the domain, which we define using a centroid when building the triangulation and the pole of inaccessibility once the triangulation is built. With this physical point, ghost edges (u, g) are then interpreted to be of infinite extent, pointing from u out to infinity, but collinear with this central point.","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"The physical point associated with a ghost vertex g, and the interpretation of a ghost edge (u, g), also depends on whether the curve's orientation. For all curves, the pole of inaccessibility defines the physical point for the single curve, except for the first ghost vertex in which case the pole of inaccessibility is defined relative to the entire domain. The ghost edge is considered to be of infinite extent, as mentioned above, for curves that are counter-clockwise. For curves that are oriented clockwise, the ghost edge has a finite interpretation, simply connecting the point u with the associated curve's pole of inaccessibility. We give an example of this below.","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"using DelaunayTriangulation\nusing CairoMakie\npoints = [(-1.0, -1.0), (1.0, -1.0), (1.0, 1.0), (-1.0, 1.0)]\nboundary_nodes = [[[1, 2, 3, 4, 1]], [[CircularArc((0.0, 0.5), (0.0, 0.5), (0.0, 0.0), positive=false)]]]\ntri = triangulate(points; boundary_nodes, coarse_n=32)\nfig, ax, sc = triplot(tri, show_ghost_edges=true)\nc1 = DelaunayTriangulation.get_representative_point_coordinates(tri, 1)\nc2 = DelaunayTriangulation.get_representative_point_coordinates(tri, 2)\nscatter!(ax, [c1, c2], color = [:red, :magenta])\nfig","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"As you can see, the outer boundary has ghost edges (shown in blue) going out to infinity, oriented with the pole of inaccessibility of the entire domain (shown in red). The ghost edges along the circular boundary are finite and simply connect with the pole of inaccessibility of the circle (shown in magenta). ","category":"page"},{"location":"manual/ghost_triangles/","page":"Ghost (Negative) Vertices","title":"Ghost (Negative) Vertices","text":"For more complex domains, in particular non-convex domains, the ghost edges start to overlap and they become less useful, which unfortunately slows down point location (see find_triangle's docstring).","category":"page"},{"location":"tutorials/centroidal/#Centroidal-Voronoi-Tessellations","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"","category":"section"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"In this tutorial, we demonstrate how we can compute centroidal Voronoi tessellations. These are tessellations for which each generator is approximately the centroid of its associated polygon, except for boundary generators which are fixed in place. This method is only applicable to clipped tessellations.","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"We give a simple example. First, we compute the clipped tessellation of a point set.","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\nrng = StableRNG(123)\npoints = 25randn(rng, 2, 500)\ntri = triangulate(points; rng)\nvorn = voronoi(tri, clip = true)","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"To now compute the centroidal tessellation, use centroidal_smooth. ( If you want to go straight from a triangulation to a centroidal tessellation, you can also just use smooth_vorn = voronoi(tri, clip = true, smooth = true).)","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"smooth_vorn = centroidal_smooth(vorn; rng)","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"Let us now compare the two tessellations.","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"fig = Figure()\nax1 = Axis(fig[1, 1], title = \"Original\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Smoothed\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, colormap = :matter, strokewidth = 2)\nvoronoiplot!(ax2, smooth_vorn, colormap = :matter, strokewidth = 2)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"As you can see, the tiles are all reasonably uniform, and their generators do look to be near the centroid of their corresponding tile. Note that this function centroidal_smooth is iterative, and you can control the iteration limits and the tolerance of the iterations (based on the maximum displacement of any generator at each iteration) using the maxiters and tol keyword arguments.","category":"page"},{"location":"tutorials/centroidal/#Just-the-code","page":"Centroidal Voronoi Tessellations","title":"Just the code","text":"","category":"section"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\nrng = StableRNG(123)\npoints = 25randn(rng, 2, 500)\ntri = triangulate(points; rng)\nvorn = voronoi(tri, clip = true)\n\nsmooth_vorn = centroidal_smooth(vorn; rng)\n\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Original\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Smoothed\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, colormap = :matter, strokewidth = 2)\nvoronoiplot!(ax2, smooth_vorn, colormap = :matter, strokewidth = 2)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"","category":"page"},{"location":"tutorials/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/nearest/#Nearest-Neighbour-Queries","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"","category":"section"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"One useful feature of Voronoi tessellations is that they can be used to obtain nearest neighbours, since by definition a Voronoi tile contains all points in the plane closest to the associated generator. This implies that finding a nearest neighbour is the same as a point location problem, meaning given a point p find the Voronoi tile P containing it. Here we give an example of how we can use triangulations or tessellations to find the nearest neighbour in the point set to a given point. We note that these same ideas could be applied for power diagrams, except that the metric used for defining distances is based on the power distance instead of the Euclidean distance (see the power diagram tutorial for more details); this is not demonstrated in this tutorial. First, we load in the packages we need.","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"Now we define the tessellation we will use for this example. The white points shown are the points that we will query.","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"points = [\n    (-3.0, 7.0), (2.0, 6.0), (0.0, 3.0),\n    (0.0, 0.0), (-5.0, 5.0), (-3.0, 1.0),\n    (2.0, -3.0), (5.0, 5.0), (-4.0, 3.0),\n]\ntri = triangulate(points)\nvorn = voronoi(tri)\np, q = (-2.0, 7.5), (0.0, 4.0)\nfig, ax, sc = voronoiplot(vorn, markersize = 14)\nscatter!(ax, [p, q], color = :white, strokecolor = :black, strokewidth = 2, markersize = 14)\nfig","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"To get the nearest neighbour of a point, we use get_nearest_neighbour.","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"np = get_nearest_neighbour(vorn, p)","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"nq = get_nearest_neighbour(vorn, q)","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"We see that the nearest point in points to p is the first point, and to q it is the third point. We note that we could have also performed this query without constructing vorn directly, instead using tri:","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"np_tri = get_nearest_neighbour(tri, p)","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"nq_tri = get_nearest_neighbour(tri, q)","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"Both methods lead to the same results because they use the same algorithm.","category":"page"},{"location":"tutorials/nearest/#Just-the-code","page":"Nearest Neighbour Queries","title":"Just the code","text":"","category":"section"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (-3.0, 7.0), (2.0, 6.0), (0.0, 3.0),\n    (0.0, 0.0), (-5.0, 5.0), (-3.0, 1.0),\n    (2.0, -3.0), (5.0, 5.0), (-4.0, 3.0),\n]\ntri = triangulate(points)\nvorn = voronoi(tri)\np, q = (-2.0, 7.5), (0.0, 4.0)\nfig, ax, sc = voronoiplot(vorn, markersize = 14)\nscatter!(ax, [p, q], color = :white, strokecolor = :black, strokewidth = 2, markersize = 14)\nfig\n\nnp = get_nearest_neighbour(vorn, p)\n\nnq = get_nearest_neighbour(vorn, q)\n\nnp_tri = get_nearest_neighbour(tri, p)\n\nnq_tri = get_nearest_neighbour(tri, q)","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"","category":"page"},{"location":"tutorials/nearest/","page":"Nearest Neighbour Queries","title":"Nearest Neighbour Queries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/operations_split_edge/#Triangulation-Operations","page":"Edge Splitting","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_split_edge/#Edge-Splitting","page":"Edge Splitting","title":"Edge Splitting","text":"","category":"section"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"Sometimes you have a point r that you know is on, or is very close to being on, an edge (i, j). In this tutorial, we show how the split_edge! function can be used for putting a point on this edge. First, let us consider the following triangulation.","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (0.0, 0.0), (0.0, 4.0), (2.0, 3.0), (-2.0, 3.0),\n    (-2.0, 7.0), (3.0, 6.0), (2.0, -2.0), (-4.0, 1.0),\n    (1.0, 5.0),\n]\np = (0.0, 3.0)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"We want to add the blue point onto the edge shown, which is (1, 2). To do this, we can use the function split_edge!.","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"push!(points, p)\nr = length(points)\ni, j = 1, 2\nsplit_edge!(tri, i, j, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"Notice that this has only split the edge in one direction. This is because the edges in this case are treated as being oriented. To split the edge in the other direction, we simply swap the indices.","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"split_edge!(tri, j, i, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"If you also want to restore the Delaunay property of the triangulation following this splitting, you need to use legalise_edge!. In this example, though, there are no illegal edges. If there were, we would use","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"k = get_adjacent(tri, i, r) # get_adjacent(tri, i, j) before split_edge!(tri, i, j)\nlegalise_edge!(tri, j, k, r)\nlegalise_edge!(tri, k, i, r)\nk = get_adjacent(tri, j, r) # get_adjacent(tri, j, i) before split_edge!(tri, j, i)\nlegalise_edge!(tri, i, k, r)\nlegalise_edge!(tri, k, j, r)","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"These steps, in particular the steps of splitting both sides of the edge and then legalising, are also implemented in DelaunayTriangulation.complete_split_edge_and_legalise!.","category":"page"},{"location":"tutorials/operations_split_edge/#Just-the-code","page":"Edge Splitting","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (0.0, 0.0), (0.0, 4.0), (2.0, 3.0), (-2.0, 3.0),\n    (-2.0, 7.0), (3.0, 6.0), (2.0, -2.0), (-4.0, 1.0),\n    (1.0, 5.0),\n]\np = (0.0, 3.0)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig\n\npush!(points, p)\nr = length(points)\ni, j = 1, 2\nsplit_edge!(tri, i, j, r)\nfig, ax, sc = triplot(tri)\nfig\n\nsplit_edge!(tri, j, i, r)\nfig, ax, sc = triplot(tri)\nfig\n\nk = get_adjacent(tri, i, r) # get_adjacent(tri, i, j) before split_edge!(tri, i, j)\nlegalise_edge!(tri, j, k, r)\nlegalise_edge!(tri, k, i, r)\nk = get_adjacent(tri, j, r) # get_adjacent(tri, j, i) before split_edge!(tri, j, i)\nlegalise_edge!(tri, i, k, r)\nlegalise_edge!(tri, k, j, r)","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"","category":"page"},{"location":"tutorials/operations_split_edge/","page":"Edge Splitting","title":"Edge Splitting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/curve_bounded/#Triangulating-Curve-Bounded-Domains","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In this tutorial, we show how we can triangulate a domain that is defined by curves rather than by straight lines. This tutorial makes use of functions introduced in the refinement tutorial.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let us start by loading in the packages we will need.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"using DelaunayTriangulation\nusing DelaunayTriangulation: EllipticalArc # CairoMakie also exports this\nusing CairoMakie\nusing StableRNGs\nusing LinearAlgebra","category":"page"},{"location":"tutorials/curve_bounded/#Curves","page":"Triangulating Curve-Bounded Domains","title":"Curves","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In this package, only a small subset of curves are provided (although arbitrary curves could be provided by the user, as discussed in here. The curves, defined as parametric curves over a parameter t  0 1, are:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"LineSegment: Just a simple line segment between two points.\nCircularArc: A circular arc defined between two points and a center.\nEllipticalArc: An elliptical arc defined by two points, a center, a major radius, a minor radius, and an angle of rotation.\nBezierCurve: A Bézier curve defined by a set of control points.\nBSpline: A B-spline curve defined by a set of control points. Defaults to a cubic B-spline.\nCatmullRomSpline: A Catmull-Rom spline defined by a set of control points.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"This set of curves is sufficient to represent a large number of curves.","category":"page"},{"location":"tutorials/curve_bounded/#A-Circular-Domain","page":"Triangulating Curve-Bounded Domains","title":"A Circular Domain","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"We start with a simple domain: a circle. In particular, we consider a circle of radius r = 2 centered at (x y) = (12 2). In past tutorials, we would have defined a domain like this by a set of points around a boundary, e.g.:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"n = 50\nr = 2.0\nxc, yc = 1 / 2, 2.0\nθ = range(0, 2π, length = n + 1) |> collect;\nθ[end] = θ[begin];\nx = xc .+ r * cos.(θ)\ny = yc .+ r * sin.(θ);\nnothing #hide","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"One problem with this approach is that we had to decide what value of n to use for discretising this boundary. Instead, we can use CircularArc. For this, we use:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"p = (xc + r, yc)\nc = (xc, yc)\narc = CircularArc(p, p, c)","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Here, the syntax is CircularArc(first_point, last_point, centre). Since the circle is closed, we use p for both first_point and last_point. Notice that the arc is a function. In particular,","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"typeof(arc) |> supertype |> supertype","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"If we wanted to look at this circle, we would need to evaluate it at a set of t in 0 1.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"t = LinRange(0, 1, 2500)\npoints = arc.(t)","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"fig, ax, sc = lines(points)","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's now triangulate this domain. We need to put the arc into its own vector, and we still need to pass a set of points into triangulate:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"points = NTuple{2, Float64}[]\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = [arc], rng)","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Notice that the domain doesn't look like a circle yet. This is because using triangulate on the curve just by itself isn't enough. In fact, the triangulation returned in this case is simply one where:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"No point is contained in the interior of any boundary edge's diametral circle.\nThe total variation between any two neighbouring points is less than pi2, meaning that the absolute change in the angle along the parametric curve between these points is less than pi2.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"This is probably not what we actually want, though. Instead, we need to refine the domain using mesh refinement. The syntax for this is the same as in the refinement tutorial:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"refine!(tri; max_area = 1.0e-1, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Much better! We have now triangulated our first curve-bounded domain.","category":"page"},{"location":"tutorials/curve_bounded/#A-Boundary-Defined-by-Multiple-Parametric-Curves","page":"Triangulating Curve-Bounded Domains","title":"A Boundary Defined by Multiple Parametric Curves","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"We now take a domain which is defined by three separate curves: a circular arc, a B-spline, and a piecewise linear curve. For piecewise linear curves, we use the same method as we would in previous tutorials, where instead of using coordinates to define the boundary we use numbers that refer to points in the point set. To start, the point set we will be using is","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"points = [(0.1, 0.1), (0.15, 0.15), (0.23, 0.23), (0.009, 0.11), (0.0, -2.0), (0.2, -1.7), (0.000591, 0.00019), (0.111, -0.005), (-0.0001, -0.00991), (1.0, 0.0)]","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Now, for the boundary, we will take:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"A circular arc defined between (1 0) and (0 1) centred at (0 0).\nA B-spline with control points (01), (-1 2), (-20), (-2-1), and (0-2).\nA piecewise linear curve defined between the fixth, sixth, and tenth points in points.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"We can define these curves as follows:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"arc = CircularArc((1.0, 0.0), (0.0, 1.0), (0.0, 0.0))\nbspl = BSpline([(0.0, 1.0), (-1.0, 2.0), (-2.0, 0.0), (-2.0, -1.0), (0.0, -2.0)])\npce = [5, 6, 10]","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Notice that we still must make sure that the curves connect, and that together the curves define a positively-oriented boundary. The domain we get from this looks like:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"t = LinRange(0, 1, 1000)\npts = vcat(arc.(t), bspl.(t), points[pce])\nfig, ax, sc = lines(pts)\nfig","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's now get a triangulation of this domain. We will use a custom constraint to force triangles closer to the origin to be smaller than those outside of it.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"curve = [[arc], [bspl], pce]\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = curve, rng)\nrefine!(\n    tri; max_area = 1.0e-2, rng, custom_constraint = (_tri, T) -> begin\n        i, j, k = triangle_vertices(T)\n        p, q, r = get_point(_tri, i, j, k)\n        c = (p .+ q .+ r) ./ 3\n        return norm(c) < 1 / 2 && DelaunayTriangulation.triangle_area(p, q, r) > 1.0e-3\n    end,\n)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/#A-Complicated-Multiply-Connected-Disjoint-Domain","page":"Triangulating Curve-Bounded Domains","title":"A Complicated Multiply-Connected Disjoint Domain","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"For our last example, we take a complicated case with a domain that is disjoint, and where the individual domains are multiply-connected. Let us give the domain followed by an explanation of how it is defined:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"curve = [\n    [\n        [1, 2, 3], [EllipticalArc((2.0, 0.0), (-2.0, 0.0), (0.0, 0.0), 2, 1 / 2, 0.0)],\n    ],\n    [\n        [BSpline([(0.0, 0.4), (1.0, 0.2), (0.0, 0.1), (-1.0, 0.2), (0.0, 0.4)])],\n    ],\n    [\n        [4, 5, 6, 7, 4],\n    ],\n    [\n        [BezierCurve([(0.0, -2.0), (0.0, -2.5), (-1.0, -2.5), (-1.0, -3.0)])], [CatmullRomSpline([(-1.0, -3.0), (0.0, -4.0), (1.0, -3.0), (0.0, -2.0)])],\n    ],\n    [\n        [12, 11, 10, 12],\n    ],\n    [\n        [CircularArc((1.1, -3.0), (1.1, -3.0), (0.0, -3.0), positive = false)],\n    ],\n]\npoints = [(-2.0, 0.0), (0.0, 0.0), (2.0, 0.0), (-2.0, -5.0), (2.0, -5.0), (2.0, -1 / 10), (-2.0, -1 / 10), (-1.0, -3.0), (0.0, -4.0), (0.0, -2.3), (-0.5, -3.5), (0.9, -3.0)]\nt = LinRange(0, 1, 1000)\nfig\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, [get_point(points, curve[1][1]...)...], color = :red, label = \"(1, 2, 3)\")\nlines!(ax, curve[1][2][1].(t), color = :red, linestyle = :dashdot, label = \"EllipticalArc\")\nlines!(ax, curve[2][1][1].(t), color = :green, label = \"BSpline\")\nlines!(ax, [get_point(points, curve[3][1]...)...], color = :blue, label = \"(4, 5, 6, 7, 4)\")\nlines!(ax, curve[4][1][1].(t), color = :purple, label = \"BezierCurve\")\nlines!(ax, curve[4][2][1].(t), color = :purple, linestyle = :dashdot, label = \"CatmullRomSpline\")\nlines!(ax, [get_point(points, curve[5][1]...)...], color = :orange, label = \"(12, 11, 10, 12)\")\nlines!(ax, curve[6][1][1].(t), color = :black, label = \"CircularArc\")\nfig[1, 2] = Legend(fig, ax, \"Curve\")\nfig","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's walk through the definition of curve.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The first domain that is defined is the red curve in the above figure, defined in terms of a piecewise linear portion and an elliptical arc. The elliptical arc is defined by the points (2 0), (-2 0), and (0 0), with a major radius of 2, a minor radius of 12, and an angle of rotation of 0.\nThe second domain that is defined is the green curve, defined as a cubic B-spline with control points (0 04), (1 02), (0 01), (-1 02), (0 04).\nThe third domain that we define is the square blue curve.\nThe fourth domain that we define is the purple curve, defined by a Bézier curve and a Catmull-Rom spline. The Bézier curve is defined by the control points (-1 -3), (-1 -25), (0 -25), and (0 -2). The Catmull-Rom spline is defined by the control points (0 -2), (1 -3), (0 -4), and (-1 -3).\nThe fifth domain that we define is the orange curve, defined as a piecewise linear curve to represent a triangle.\nThe last domain that we define is a circular arc. To get the orientation correct, i.e. to make sure the circle is defined clockwise so that the domain remains positively oriented, we must use positive=false.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In addition to ensuring that the curves are all oriented correctly, care has also been taken in the definition of these curves to make sure that the curves connect at the correct points.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's now triangulate.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"rng = StableRNG(123)\ntri = triangulate(copy(points); boundary_nodes = curve, rng) # copying so that we don't mutate for the next section\nrefine!(tri; max_area = 1.0e-2)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/#Using-Custom-Constraints-to-Control-Refinement","page":"Triangulating Curve-Bounded Domains","title":"Using Custom Constraints to Control Refinement","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's give another example of using custom constraints to better control the refinement within different domains. Referencing the previous figure where we showed each domain by colour, let us try and use a coarse mesh in the region bounded between the red and green curves, a slightly denser mesh bounded between the blue and black curves, and finally a dense mesh in the region bounded between the purple and orange curves. To do this, we must have a method for deciding which region a given point resides in. This is what find_polygon for is, as we also use in the point-in-polygon tutorial. To write this function, we note that the indices of these polygons are 1, 3, and 4 for the red, blue, and purple regions, respectively.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"poly_constraint = (_tri, T) -> begin\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    c = (p .+ q .+ r) ./ 3\n    idx = find_polygon(_tri, c)\n    if idx ∉ (1, 3, 4)\n        return true\n    end\n    max_area = if idx == 1 # coarse\n        1.0e-1\n    elseif idx == 3 # medium\n        1.0e-2\n    else # dense\n        1.0e-3\n    end\n    area = DelaunayTriangulation.triangle_area(p, q, r)\n    return area > max_area\nend\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = curve, rng)\nrefine!(tri; custom_constraint = poly_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/#Defining-a-New-Parametric-Curve","page":"Triangulating Curve-Bounded Domains","title":"Defining a New Parametric Curve","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let us now give an example where we define a domain by a parametric curve that is not provided natively by this package. For this example, we consider the astroid, where","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"beginaligned\nx(t) = cos^3(2pi t) \ny(t) = sin^3(2pi t)\nendaligned","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Following the docstring of DelaunayTriangulation.AbstractParametricCurve, we know that to define this curve to be compatible with this package we need:","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"To represent the curve as a callable struct that subtypes AbstractParametricCurve that maps Float64 -> NTuple{2,Float64}.\nTo define DelaunayTriangulation.differentiate, DelaunayTriangulation.twice_differentiate, and DelaunayTriangulation.thrice_differentiate.\nHave a lookup_table field that maps lookup_table[i] to the position of the curve at t = (i - 1) / (length(lookup_table) - 1), where lookup_table is a Vector.\nHave defined the parametric curve according to 0  t  1 (already done).","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's now meet these requirements.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"struct Astroid <: DelaunayTriangulation.AbstractParametricCurve\n    lookup_table::Vector{NTuple{2, Float64}}\nend\nfunction (c::Astroid)(t)\n    if t == 0.0 || t == 1.0\n        return (1.0, 0.0)\n    end\n    x = cos(2π * t)^3\n    y = sin(2π * t)^3\n    return (x, y)\nend\nfunction DelaunayTriangulation.differentiate(c::Astroid, t)\n    x = -6π * sin(2π * t) * cos(2π * t)^2\n    y = 6π * sin(2π * t)^2 * cos(2π * t)\n    return (x, y)\nend\nfunction DelaunayTriangulation.twice_differentiate(c::Astroid, t)\n    x = -12π^2 * cos(2π * t) * (cos(2π * t)^2 - 2sin(2π * t)^2)\n    y = -12π^2 * sin(2π * t) * (sin(2π * t)^2 - 2cos(2π * t)^2)\n    return (x, y)\nend\nfunction DelaunayTriangulation.thrice_differentiate(c::Astroid, t)\n    x = 24π^3 * sin(2π * t) * (7cos(2π * t)^2 - 2sin(2π * t)^2)\n    y = 24π^3 * cos(2π * t) * (2cos(2π * t)^2 - 7sin(2π * t)^2)\n    return (x, y)\nend","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let's now define an astroid curve and triangulate it.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"function Astroid(n::Int)\n    lookup_table = Vector{NTuple{2, Float64}}(undef, n)\n    c = Astroid(lookup_table)\n    for i in 1:n\n        lookup_table[i] = c((i - 1) / (n - 1))\n    end\n    return Astroid(lookup_table)\nend\nrng = StableRNG(123)\ncurve = Astroid(1000)\ntri = triangulate(NTuple{2, Float64}[]; boundary_nodes = [curve], rng)\nrefine!(tri; max_area = 1.0e-2)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/#Just-the-code","page":"Triangulating Curve-Bounded Domains","title":"Just the code","text":"","category":"section"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"using DelaunayTriangulation\nusing DelaunayTriangulation: EllipticalArc # CairoMakie also exports this\nusing CairoMakie\nusing StableRNGs\nusing LinearAlgebra\n\nn = 50\nr = 2.0\nxc, yc = 1 / 2, 2.0\nθ = range(0, 2π, length = n + 1) |> collect;\nθ[end] = θ[begin];\nx = xc .+ r * cos.(θ)\ny = yc .+ r * sin.(θ);\n\np = (xc + r, yc)\nc = (xc, yc)\narc = CircularArc(p, p, c)\n\ntypeof(arc) |> supertype |> supertype\n\nt = LinRange(0, 1, 2500)\npoints = arc.(t)\n\nfig, ax, sc = lines(points)\n\npoints = NTuple{2, Float64}[]\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = [arc], rng)\n\nfig, ax, sc = triplot(tri)\nfig\n\nrefine!(tri; max_area = 1.0e-1, rng)\nfig, ax, sc = triplot(tri)\nfig\n\npoints = [(0.1, 0.1), (0.15, 0.15), (0.23, 0.23), (0.009, 0.11), (0.0, -2.0), (0.2, -1.7), (0.000591, 0.00019), (0.111, -0.005), (-0.0001, -0.00991), (1.0, 0.0)]\n\narc = CircularArc((1.0, 0.0), (0.0, 1.0), (0.0, 0.0))\nbspl = BSpline([(0.0, 1.0), (-1.0, 2.0), (-2.0, 0.0), (-2.0, -1.0), (0.0, -2.0)])\npce = [5, 6, 10]\n\nt = LinRange(0, 1, 1000)\npts = vcat(arc.(t), bspl.(t), points[pce])\nfig, ax, sc = lines(pts)\nfig\n\ncurve = [[arc], [bspl], pce]\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = curve, rng)\nrefine!(\n    tri; max_area = 1.0e-2, rng, custom_constraint = (_tri, T) -> begin\n        i, j, k = triangle_vertices(T)\n        p, q, r = get_point(_tri, i, j, k)\n        c = (p .+ q .+ r) ./ 3\n        return norm(c) < 1 / 2 && DelaunayTriangulation.triangle_area(p, q, r) > 1.0e-3\n    end,\n)\nfig, ax, sc = triplot(tri)\nfig\n\ncurve = [\n    [\n        [1, 2, 3], [EllipticalArc((2.0, 0.0), (-2.0, 0.0), (0.0, 0.0), 2, 1 / 2, 0.0)],\n    ],\n    [\n        [BSpline([(0.0, 0.4), (1.0, 0.2), (0.0, 0.1), (-1.0, 0.2), (0.0, 0.4)])],\n    ],\n    [\n        [4, 5, 6, 7, 4],\n    ],\n    [\n        [BezierCurve([(0.0, -2.0), (0.0, -2.5), (-1.0, -2.5), (-1.0, -3.0)])], [CatmullRomSpline([(-1.0, -3.0), (0.0, -4.0), (1.0, -3.0), (0.0, -2.0)])],\n    ],\n    [\n        [12, 11, 10, 12],\n    ],\n    [\n        [CircularArc((1.1, -3.0), (1.1, -3.0), (0.0, -3.0), positive = false)],\n    ],\n]\npoints = [(-2.0, 0.0), (0.0, 0.0), (2.0, 0.0), (-2.0, -5.0), (2.0, -5.0), (2.0, -1 / 10), (-2.0, -1 / 10), (-1.0, -3.0), (0.0, -4.0), (0.0, -2.3), (-0.5, -3.5), (0.9, -3.0)]\nt = LinRange(0, 1, 1000)\nfig\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, [get_point(points, curve[1][1]...)...], color = :red, label = \"(1, 2, 3)\")\nlines!(ax, curve[1][2][1].(t), color = :red, linestyle = :dashdot, label = \"EllipticalArc\")\nlines!(ax, curve[2][1][1].(t), color = :green, label = \"BSpline\")\nlines!(ax, [get_point(points, curve[3][1]...)...], color = :blue, label = \"(4, 5, 6, 7, 4)\")\nlines!(ax, curve[4][1][1].(t), color = :purple, label = \"BezierCurve\")\nlines!(ax, curve[4][2][1].(t), color = :purple, linestyle = :dashdot, label = \"CatmullRomSpline\")\nlines!(ax, [get_point(points, curve[5][1]...)...], color = :orange, label = \"(12, 11, 10, 12)\")\nlines!(ax, curve[6][1][1].(t), color = :black, label = \"CircularArc\")\nfig[1, 2] = Legend(fig, ax, \"Curve\")\nfig\n\nrng = StableRNG(123)\ntri = triangulate(copy(points); boundary_nodes = curve, rng) # copying so that we don't mutate for the next section\nrefine!(tri; max_area = 1.0e-2)\nfig, ax, sc = triplot(tri)\nfig\n\npoly_constraint = (_tri, T) -> begin\n    i, j, k = triangle_vertices(T)\n    p, q, r = get_point(_tri, i, j, k)\n    c = (p .+ q .+ r) ./ 3\n    idx = find_polygon(_tri, c)\n    if idx ∉ (1, 3, 4)\n        return true\n    end\n    max_area = if idx == 1 # coarse\n        1.0e-1\n    elseif idx == 3 # medium\n        1.0e-2\n    else # dense\n        1.0e-3\n    end\n    area = DelaunayTriangulation.triangle_area(p, q, r)\n    return area > max_area\nend\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes = curve, rng)\nrefine!(tri; custom_constraint = poly_constraint, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nstruct Astroid <: DelaunayTriangulation.AbstractParametricCurve\n    lookup_table::Vector{NTuple{2, Float64}}\nend\nfunction (c::Astroid)(t)\n    if t == 0.0 || t == 1.0\n        return (1.0, 0.0)\n    end\n    x = cos(2π * t)^3\n    y = sin(2π * t)^3\n    return (x, y)\nend\nfunction DelaunayTriangulation.differentiate(c::Astroid, t)\n    x = -6π * sin(2π * t) * cos(2π * t)^2\n    y = 6π * sin(2π * t)^2 * cos(2π * t)\n    return (x, y)\nend\nfunction DelaunayTriangulation.twice_differentiate(c::Astroid, t)\n    x = -12π^2 * cos(2π * t) * (cos(2π * t)^2 - 2sin(2π * t)^2)\n    y = -12π^2 * sin(2π * t) * (sin(2π * t)^2 - 2cos(2π * t)^2)\n    return (x, y)\nend\nfunction DelaunayTriangulation.thrice_differentiate(c::Astroid, t)\n    x = 24π^3 * sin(2π * t) * (7cos(2π * t)^2 - 2sin(2π * t)^2)\n    y = 24π^3 * cos(2π * t) * (2cos(2π * t)^2 - 7sin(2π * t)^2)\n    return (x, y)\nend\n\nfunction Astroid(n::Int)\n    lookup_table = Vector{NTuple{2, Float64}}(undef, n)\n    c = Astroid(lookup_table)\n    for i in 1:n\n        lookup_table[i] = c((i - 1) / (n - 1))\n    end\n    return Astroid(lookup_table)\nend\nrng = StableRNG(123)\ncurve = Astroid(1000)\ntri = triangulate(NTuple{2, Float64}[]; boundary_nodes = [curve], rng)\nrefine!(tri; max_area = 1.0e-2)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"","category":"page"},{"location":"tutorials/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/#Constrained-Triangulations","page":"Segmented Outer Boundary","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary_segmented/#Sectioned-Outer-Boundary","page":"Segmented Outer Boundary","title":"Sectioned Outer Boundary","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"In this tutorial, we again consider a triangulation with a constrained boundary. In contrast to the previous tutorial, this outer boundary will be represented as a chain of multiple paths or sections. This changes nothing geometrically, but it allows for the identification of separate parts of a boundary. This is useful, for example, if you want to assign different boundary conditions on different parts of the boundary for a differential equation problem. To start, let us load in the packages we will need.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Now, we define some of the points we will be triangulating.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"points = [\n    (2.0, 8.0), (6.0, 4.0), (2.0, 6.0),\n    (2.0, 4.0), (8.0, 2.0),\n]","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"We now want to define our boundary. The method for providing a boundary to be identified into multiple sections is to provided a vector of vectors of indices, where each vector of indices is a section. The last index of each section must match the first index of the next section, including the last with the first section so that the boundary is closed. Here, we provide three .","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"section_1 = [(0.0, 0.0), (14.0, 0.0)]\nsection_2 = [(14.0, 0.0), (10.0, 4.0), (4.0, 6.0), (2.0, 12.0), (0.0, 14.0)]\nsection_3 = [(0.0, 14.0), (0.0, 0.0)]\nboundary_points = [section_1, section_2, section_3]","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"We now convert these boundary points to indices using convert_boundary_points_to_indices, and then we triangulate. We also add a constrained edge.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"E = Set(((6, 9),)) # (0, 0) → (4, 6)\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points; existing_points = points)\ntri = triangulate(points; boundary_nodes, segments = E)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"fig, ax, sc = triplot(tri, show_constrained_edges = true, constrained_edge_linewidth = 6)\nlines!(ax, section_1, color = :red, linewidth = 6)\nlines!(ax, section_2, color = :green, linewidth = 6)\nlines!(ax, section_3, color = :blue, linewidth = 6)\nfig","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"The first section is in red, the second section is in green, and the third section is in blue. We use ghost vertices to identify the sections, where the first section is identified by -1, the second by -2, and the third by -3.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Before we go into how the sections can be worked with, let us make a note regarding get_interior_segments(tri), now that we have both constrained segments and boundary segments which might technically both be thought of as being constrained edges. If we look at get_interior_segments(tri), we get:","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_interior_segments(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"This is just the constrained segment we provided, and not the boundary segment. If we instead want all constrained segments, considering both the boundary segments and the segments provided, we can instead use get_all_segments(tri).","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_all_segments(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Let us now explore the several ways available for working with this boundary. First, if we just want to work with the boundary edges without caring about the order, we can again use the boundary edge map.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_boundary_edge_map(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Remember that the keys are the edges, and the values are Tuples that give us (1) the section index, and (2) the position of the edge within that section (more specifically, the position of the first vertex of the edge). This would be useful if, for example, you don't care about the order of the edges, but you do care about what section the edge belongs to so that you can assign a boundary condition for example. In the previous tutorial, we mentioned that the Tuples are of the form (I, J) so that the corresponding edge is identified from get_boundary_nodes(get_boundary_nodes(tri, I), J), but since both I and J are integers in this case (since we have sections), we can just use get_boundary_nodes(tri, (I, J)). (The former form is still the most general to support the case of a single boundary.) Here is an example of using this map to compute the sum","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"S = sum_(i j) in mathcal E fleft(fracx_i+x_j2 fracy_i+y_j2right)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"where mathcal E are the set of boundary edges, and","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"f(x y) = begincases\n   1  (x y) in Gamma_1 \n   sin(x - y)  (x y) in Gamma_2 \n   cos(x + y)  (x y) in Gamma_3\nendcases","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"and Gamma_i denotes the ith section.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"function section_function(x, y, section_index)\n    f = if abs(section_index) == 1\n        1.0\n    elseif abs(section_index) == 2\n        sin(x - y)\n    else\n        cos(x + y)\n    end\n    return f\nend\nfunction compute_sum(tri)\n    bem = get_boundary_edge_map(tri)\n    s = 0.0\n    for (e, (section_index, _)) in bem\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        mx, my = (px + qx) / 2, (py + qy) / 2\n        s += section_function(mx, my, section_index)\n    end\n    return s\nend\ns = compute_sum(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"An alternative way to look at each section is to use get_adjacent2vertex with the associated ghost vertex.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_adjacent2vertex(tri, -1)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_adjacent2vertex(tri, -2)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_adjacent2vertex(tri, -3)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Note that the provided edges are not in order, but this is helpful for considering specific sections. For example, if we just wanted to compute the above sum over the second section, we could do","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"function compute_sum_2(tri)\n    edges = get_adjacent2vertex(tri, -2)\n    s = 0.0\n    for e in edges\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        mx, my = (px + qx) / 2, (py + qy) / 2\n        s += section_function(mx, my, -2)\n    end\n    return s\nend\ns = compute_sum_2(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"If your application instead wanted all the nodes on the section rather than the edges, you can look at the neighbours to the ghost vertex. For example, all the nodes on the section section can be identified using","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_neighbours(tri, -2)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"Another field is the ghost_vertex_map, which maps a given ghost vertex to the associated section. This is more so useful for internal methods, but you may sometimes need it.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"get_ghost_vertex_map(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"In this case, the ith section just has the ghost vertex -i, but this is typically used to deal with the case of multiple boundaries so that we know where a ghost vertex belongs.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/#Just-the-code","page":"Segmented Outer Boundary","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (2.0, 8.0), (6.0, 4.0), (2.0, 6.0),\n    (2.0, 4.0), (8.0, 2.0),\n]\n\nsection_1 = [(0.0, 0.0), (14.0, 0.0)]\nsection_2 = [(14.0, 0.0), (10.0, 4.0), (4.0, 6.0), (2.0, 12.0), (0.0, 14.0)]\nsection_3 = [(0.0, 14.0), (0.0, 0.0)]\nboundary_points = [section_1, section_2, section_3]\n\nE = Set(((6, 9),)) # (0, 0) → (4, 6)\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points; existing_points = points)\ntri = triangulate(points; boundary_nodes, segments = E)\n\nfig, ax, sc = triplot(tri, show_constrained_edges = true, constrained_edge_linewidth = 6)\nlines!(ax, section_1, color = :red, linewidth = 6)\nlines!(ax, section_2, color = :green, linewidth = 6)\nlines!(ax, section_3, color = :blue, linewidth = 6)\nfig\n\nget_interior_segments(tri)\n\nget_all_segments(tri)\n\nget_boundary_edge_map(tri)\n\nfunction section_function(x, y, section_index)\n    f = if abs(section_index) == 1\n        1.0\n    elseif abs(section_index) == 2\n        sin(x - y)\n    else\n        cos(x + y)\n    end\n    return f\nend\nfunction compute_sum(tri)\n    bem = get_boundary_edge_map(tri)\n    s = 0.0\n    for (e, (section_index, _)) in bem\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        mx, my = (px + qx) / 2, (py + qy) / 2\n        s += section_function(mx, my, section_index)\n    end\n    return s\nend\ns = compute_sum(tri)\n\nget_adjacent2vertex(tri, -1)\n\nget_adjacent2vertex(tri, -2)\n\nget_adjacent2vertex(tri, -3)\n\nfunction compute_sum_2(tri)\n    edges = get_adjacent2vertex(tri, -2)\n    s = 0.0\n    for e in edges\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        mx, my = (px + qx) / 2, (py + qy) / 2\n        s += section_function(mx, my, -2)\n    end\n    return s\nend\ns = compute_sum_2(tri)\n\nget_neighbours(tri, -2)\n\nget_ghost_vertex_map(tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"","category":"page"},{"location":"tutorials/constrained_outer_boundary_segmented/","page":"Segmented Outer Boundary","title":"Segmented Outer Boundary","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/voronoi_output/#Voronoi-Tessellation-output","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation output","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"In this section, we discuss the output given from voronoi. We consider a simple clipped example for examining this output.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"using DelaunayTriangulation\nusing StableRNGs \nrng = StableRNG(123)\np1 = (0.0, 1.0)\np2 = (3.0, -1.0)\np3 = (2.0, 0.0)\np4 = (-1.0, 2.0)\np5 = (4.0, 2.0)\np6 = (-2.0, -1.0)\np7 = (2.0, 1.0)\np8 = (5.0, 1.0)\npoints = [p1, p2, p3, p4, p5, p6, p7, p8]\ntri = triangulate(points; rng)\nvorn = voronoi(tri, clip = true, rng = rng)\nvorn","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"Now let's inspect vorn. The fields in vorn are:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"propertynames(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"Let's examine this fields one at a time.","category":"page"},{"location":"manual/voronoi_output/#[get_triangulation(vorn)](@ref-get_triangulation)","page":"Voronoi Tessellation Output","title":"get_triangulation(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field stores the triangulation object used to generate the Voronoi tessellation.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_triangulation(vorn)","category":"page"},{"location":"manual/voronoi_output/#[get_generators(vorn)](@ref-get_generators)","page":"Voronoi Tessellation Output","title":"get_generators(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field stores the generators of the Voronoi tessellation, i.e. the points associated with the polygons in the tessellation. These are simply the points in the triangulation, but are stored differently in case some points are not present in the triangulation.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_generators(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"See that the generators are stored as a Dict, with the vertices mapping to their associated coordinates. The preferred way to access the generators is through get_generator, which can be used to obtain the coordinates for a given vertex. For example:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_generator(vorn, 1)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_generator(vorn, 2, 6)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"If you want to iterate over each generator, you should use each_generator, which simply returns an unordered iterator over the generators.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"each_generator(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"You can get the number of generators using num_generators:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.num_generators(vorn)","category":"page"},{"location":"manual/voronoi_output/#[get_polygon_points(vorn)](@ref-get_polygon_points)","page":"Voronoi Tessellation Output","title":"get_polygon_points(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field is used for storing the coordinates of the Voronoi polygons:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_polygon_points(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"These coordinates are used to define the vertices of these polygons. It is important to note that these points are not guaranteed to be unique if a circumcenter appears on the boundary, or if the tessellation is clipped. To access the coordinate of a polygon associated with a given polygon vertex, use get_polygon_point:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon_point(vorn, 1)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"If you wanted the total number of polygon vertices, possibly counting duplicate vertices, you can use num_polygon_vertices:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"num_polygon_vertices(vorn)","category":"page"},{"location":"manual/voronoi_output/#[get_polygons(vorn)](@ref-get_polygons)","page":"Voronoi Tessellation Output","title":"get_polygons(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field is used for mapping polygon indices to their vertices, with these vertices referring to coordinates from get_polygon_points(vorn):","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_polygons(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"For example, using get_polygon with the first polygon:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon(vorn, 1)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"means that the first polygon has vertices [19, 21, 4, 18, 16, 3, 19]. All polygons are stored as a circular vector of counter-clockwise oriented vertices. Note also that polygon indices are the same as the generator vertex, so that e.g. this polygon 1 is that associated with generator 1.  You can get the number of polygons using num_polygons:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"num_polygons(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"Of course, this is the same as the number of generators. If you wanted to get the coordinates instead of the vertices associated with a polygon, you use get_polygon_coordinates:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon_coordinates(vorn, 1)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This is almost the same result as doing","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon_point.(Ref(vorn), get_polygon(vorn, 1))","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"but is more efficient.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"When the tessellation is unbounded, this field is slightly different. Let's consider an example.","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"rng2 = StableRNG(321)\npoints2 = rand(rng2, 2, 10)\ntri2 = triangulate(points2; rng = rng2)\nvorn2 = voronoi(tri2, rng = rng2)\nDelaunayTriangulation.get_polygons(vorn2)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"Notice that some of these polygons have negative vertices. These vertices are not the same as ghost vertices from triangulations. They do still represent points out at infinity, but their numbering is of no importance - only the fact that they are negative is. All polygons that have a negative vertex are unbounded, and the negative vertex is the vertex that is out at infinity. When we try to get the coordinates of a polygon with a negative vertex, we get an error:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon_coordinates(vorn2, 5)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"We need to provide a bounding box to obtain these coordinates. As mentioned, we can obtain a reasonable default for a bounding box using polygon_bounds, which returns the bounding box in the form (xmin, xmax, ymin, ymax):","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"bbox = polygon_bounds(vorn2)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"If we now use this bounding box to get the coordinates of the polygon, we get a polygon that will have been clipped with this box:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_polygon_coordinates(vorn2, 4, bbox)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"For iterating over polygons, there are two main methods. If you only care about the vertices and not the index associated with a polygon, you can use each_polygon:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"each_polygon(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"Alternatively, each_polygon_index can be used  to iterate over the index of each polygon (equivalently, over each generator vertex), followed by get_polygon to access the associated vertices of that polygon:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"for v in each_polygon_index(vorn)\n    println(v, \": \", get_polygon(vorn, v))\nend","category":"page"},{"location":"manual/voronoi_output/#[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)","page":"Voronoi Tessellation Output","title":"get_circumcenter_to_triangle(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"When a Voronoi tessellation is constructed, the circumcenters of the triangles from the underlying Delaunay triangulation are used to define the polygon vertices. This field is used to associate a given polygon vertex with the triangle that it came from:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_circumcenter_to_triangle(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"We see, for example, that the fifth polygon vertex is derived from the circumcenter of the triangle (3, 6, 2). We can verify this:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"p = DelaunayTriangulation.triangle_circumcenter(tri, (3, 6, 2)) \nq = get_polygon_point(vorn, 5)\np == q ","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"The negative vertices show what ghost triangle is being associated with an unbounded edge of the tessellation. Since we clipped our tessellation, these no longer appear in the previously mentioned fields, but they are still stored in this field; they are used in clipping for determining the direction of the unbounded edges. If you wanted the triangle associated with a specific vertex, you could use ","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_circumcenter_to_triangle(vorn, 5)","category":"page"},{"location":"manual/voronoi_output/#[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)","page":"Voronoi Tessellation Output","title":"get_triangle_to_circumcenter(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This map is the inverse of get_circumcenter_to_triangle(vorn), and is used to map a triangle to its circumcenter:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_triangle_to_circumcenter(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"The triangles are stored so that the minimum vertex is always last, maintaining the counter-clockwise orientation of each. You can get the circumcenter index associated with a given triangle using:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_triangle_to_circumcenter(vorn, (3, 7, 1))","category":"page"},{"location":"manual/voronoi_output/#[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)","page":"Voronoi Tessellation Output","title":"get_unbounded_polygons(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field is used to store the polygons that are unbounded. For our clipped tessellation, this field is empty:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_unbounded_polygons(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"For our unclipped tessellation, we have","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_unbounded_polygons(vorn2)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"and we can verify that this is consistent with our observation that each unbounded polygon has a negative vertex:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"S1 = DelaunayTriangulation.get_unbounded_polygons(vorn2)\nS2 = Set{Int}()\nfor v in each_polygon_index(vorn2)\n    C = get_polygon(vorn2, v)\n    if any(<(0), C)\n        push!(S2, v)\n    end\nend\nS1 == S2","category":"page"},{"location":"manual/voronoi_output/#[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)","page":"Voronoi Tessellation Output","title":"get_cocircular_circumcenters(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"In cases where pairs of triangles are cocircular, meaning lie on the same circle, their circumcenter will be equal and thus the polygon vertex associated with these two triangles will be the same. This field will store the vertices of these circumcenters that came from cocircular triangles. For our case, there is a single entry:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_cocircular_circumcenters(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This means that the first polygon vertex is associated with at least two cocircular triangles, and is why, for example, the values from get_triangle_to_circumcenter(vorn) are not unique:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"t2c = DelaunayTriangulation.get_triangle_to_circumcenter(vorn)\nallunique(values(t2c))","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"and also explains why get_circumcenter_to_triangle(vorn) and get_triangle_to_circumcenter(vorn) are not perfect inverses of each other. The triangle mapped to from 5 inside the circumcenter_to_triangle map is simply the first one that the algorithm happened to encounter. To find the two cocircular triangles, we could use the triangle_to_circumcenter map:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"triangles = NTuple{3,Int}[]\nfor (t, c) in t2c\n    c == 1 && push!(triangles, t)\nend","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"In fact, there are three triangles that all have the same circumcenter!","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.triangle_circumcenter.(Ref(tri), triangles)","category":"page"},{"location":"manual/voronoi_output/#[get_adjacent(vorn)](@ref-get_adjacent)","page":"Voronoi Tessellation Output","title":"get_adjacent(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This map is similar to the Adjacent map for triangulations:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_adjacent(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"In this case, oriented edges are being mapped to the polygon it belongs to. For example,","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"get_adjacent(vorn, 3, 19)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"means that the edge (3, 19) belongs to the first polygon; these vertices 3 and 19 refer to the vertices from the polygon, while the 1 from the output refers to a generator.","category":"page"},{"location":"manual/voronoi_output/#[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)","page":"Voronoi Tessellation Output","title":"get_boundary_polygons(vorn)","text":"","category":"section"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"This field is used to store the polygons that are on the boundary of the tessellation, and is only relevant for clipped tessellations. For our clipped tessellation, we have:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_boundary_polygons(vorn)","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"For our unclipped tessellation, the field is empty:","category":"page"},{"location":"manual/voronoi_output/","page":"Voronoi Tessellation Output","title":"Voronoi Tessellation Output","text":"DelaunayTriangulation.get_boundary_polygons(vorn2)","category":"page"},{"location":"tutorials/operations_legalise_edge/#Triangulation-Operations","page":"Legalising an Edge","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_legalise_edge/#Legalising-an-Edge","page":"Legalising an Edge","title":"Legalising an Edge","text":"","category":"section"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"One important procedure, used for example in the paper Randomized Incremental Construction of Delaunay and Voronoi Diagrams by Guibas et al., 1992 (which is also the algorithm discussed by de Berg et al. in the book Computational Geometry: Algorithms and Applications (3 ed., 2008)), is the legalising of an edge. This isn't used anywhere in the package directly, but perhaps you might need it (for example, to implement the above algorithm). The idea is that we may sometimes have edges that are not Delaunay, meaning illegal, and we want to somehow fix them to be Delaunay, which may also require fixes to nearby edges after fixing the initial edge. In this way, we are legalising the edge. (The edge e_ij is illegal if the circle through p_i, p_j, and p_k contains p_r in its interior, where p_k and p_r are the other points on the triangles adjoining e_ij.)","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"We provide a function legalise_edge! for this procedure, and the function assumes that there is a point r that has been inserted inside some triangle (i, j, k); the legality of an edge is checked using DelaunayTriangulation.is_legal. The function then helps to restore the Delaunay property of the triangulation following such an insertion; this is the main step of the algorithm of Guibas et al. (1992) above.","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"We use this tutorial to demonstrate how this can be used. First, let us define some initial triangulation.","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (-1.0, 2.0), (4.0, 6.0), (4.0, 3.0), (-3.0, 7.0),\n    (-6.0, -1.0), (9.0, 5.0), (5.0, -5.0), (-6.0, 7.0),\n    (0.0, 0.0), (-3.0, 4.0), (-5.0, 5.0), (-3.0, -4.0),\n    (5.0, -1.0), (2.0, -2.0),\n]\np = (3.0, 2.0)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"The blue point is the point to be added. It is inside the triangle (9, 14, 3). To insert it, follow Guibas et al. (1992) and connect the edges of (9, 14, 3) to the new point. This is done using split_triangle!. (Note: the function DelaunayTriangulation.complete_split_triangle_and_legalise! does the splitting and the legalising all in the same step, but we do not demonstrate this here.)","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"push!(points, p)\nr = length(points)\ni, j, k = 9, 14, 3\nsplit_triangle!(tri, i, j, k, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"This splitting introduces some new illegal edges, shown in red below.","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"function get_all_illegal_edges(tri) #hide\n    T = NTuple{2, Float64}[] #hide\n    for E in each_edge(tri) #hide\n        cert = DelaunayTriangulation.is_legal(tri, E...) #hide\n        if DelaunayTriangulation.is_illegal(cert) #hide\n            push!(T, get_point(tri, E...)...) #hide\n        end #hide\n    end #hide\n    return T #hide\nend #hide\nfig, ax, sc = triplot(tri) #hide\nT = get_all_illegal_edges(tri) #hide\nlinesegments!(ax, T, color = :red, linewidth = 3) #hide\nfig #hide","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"To fix this, we use legalise_edge!. This functions take in a single edge, so to legalise all the new edges we apply the function to each edge of the triangle that the point resides in. (The function DelaunayTriangulation.legalise_split_triangle! also performs these three calls below.)","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"legalise_edge!(tri, i, j, r)\nlegalise_edge!(tri, j, k, r)\nlegalise_edge!(tri, k, i, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"The triangulation is now Delaunay, and there are no more illegal edges.","category":"page"},{"location":"tutorials/operations_legalise_edge/#Just-the-code","page":"Legalising an Edge","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (-1.0, 2.0), (4.0, 6.0), (4.0, 3.0), (-3.0, 7.0),\n    (-6.0, -1.0), (9.0, 5.0), (5.0, -5.0), (-6.0, 7.0),\n    (0.0, 0.0), (-3.0, 4.0), (-5.0, 5.0), (-3.0, -4.0),\n    (5.0, -1.0), (2.0, -2.0),\n]\np = (3.0, 2.0)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig\n\npush!(points, p)\nr = length(points)\ni, j, k = 9, 14, 3\nsplit_triangle!(tri, i, j, k, r)\nfig, ax, sc = triplot(tri)\nfig\n\n\nlegalise_edge!(tri, i, j, r)\nlegalise_edge!(tri, j, k, r)\nlegalise_edge!(tri, k, i, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"","category":"page"},{"location":"tutorials/operations_legalise_edge/","page":"Legalising an Edge","title":"Legalising an Edge","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/point_location/#Point-Location","page":"Point Location","title":"Point Location","text":"","category":"section"},{"location":"api/point_location/#DelaunayTriangulation.brute_force_search","page":"Point Location","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q; itr = each_triangle(tri), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nSearches for the triangle containing the point q by brute force. An exception will be  raised if no triangle contains the point.\n\nSee also find_triangle.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The point to be located.\n\nKeyword Arguments\n\nitr = each_triangle(tri): The iterator over the triangles of the triangulation.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nV: The triangle containing the point q.\n\n\n\n\n\n","category":"function"},{"location":"api/point_location/#DelaunayTriangulation.find_triangle","page":"Point Location","title":"DelaunayTriangulation.find_triangle","text":"find_triangle(tri, q; kwargs...) -> Triangle[, Bool]\n\nFind the triangle in the triangulation tri containing the query point q using the jump-and-march algorithm.\n\ndanger: Ghost triangles\nFor this function to work best, the triangulation should have ghost triangles, which you can add using add_ghost_triangles! in case tri does not already have them.  Without ghost triangles, the function may not be able to find the correct triangle containing q.\n\nFor the variables defined below, you may want to refer to the extended help which also gives  some warnings and notes.\n\nArguments\n\ntri: The Triangulation.\nq: The query point.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=ExactKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\npoint_indices=each_solid_vertex(tri): The indices of the vertices to consider as possible starting points for the algorithm.\nm=default_num_samples(num_vertices(point_indices)): The number of samples to use when selecting the initial point.\ntry_points=(): A list of points to try as the initial point in addition to the m sampled.\nrng=Random.default_rng(): The random number generator to use.\nk=select_initial_point(tri, q; point_indices, m, try_points, rng): The initial point to start the algorithm from. See select_initial_point.\nstore_history=Val(false): Whether to store the history of the algorithm.\nhistory=nothing: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nmaxiters=2 + num_exterior_curves(tri) - num_solid_vertices(tri) + num_solid_edges(tri): The maximum number of iterations to perform before restarting the algorithm with restart_find_triangle.\nconcavity_protection=false: Whether to use concavity protection. See concavity_protection_check. This is only needed if your triangulation is not convex. \nuse_barriers::Val{U}=Val(false): Whether to stop searching beyond any segments in the triangulation. \n\nOutput\n\nV: The triangle containing q, with type given by triangle_type(tri).\n\nIf you have use_barriers == Val(true), then we also return \n\ninvisible_flag: false if the triangle was found without hitting a barrier, and true otherwise.\n\nExtended help\n\nThe algorithm underlying this function is complicated and broken into many parts. Here, we describe a brief overview of the algorithm, but note that the      documentation contains a much more detailed description.\n\nFirstly, the algorithm is initialised depending on whether k is a boundary or an interior vertex, using    initialise_find_triangle_boundary_vertex or initialise_find_triangle_interior_vertex respectively.\nFrom the initial triangle (i, j, k) chosen, we then check if q is one of pᵢ, pⱼ, and p = pₖ and then return according to find_triangle_return_on_vertex if needed.\nIf we do not return above, we need to step from the initial triangle towards q. Since we put pᵢ and pⱼ   to the left and right of the line pq, respectively, this means that we step until the triangle pᵢpⱼq is no longer    positively oriented. So, while the triangle is positively oriented, we step according to find_triangle_across_triangle.\nIf we have not yet returned and the triangle is no longer positively oriented, we check if the triangle is degenerate using find_triangle_degenerate_arrangement   and reinitialise the algorithm if needed. Otherwise, we have found the triangle containing q and return the triangle.\n\nHere are some additional warnings and notes for the variables defined in this function.\n\nnote: Restarting the algorithm\nIf the algorithm restarts, then the initial point k is selected again using select_initial_point, and the algorithm is restarted from there.  This is done if the algorithm gets stuck in a loop, or if the algorithm is not able to find the correct triangle containing q after maxiters iterations. For a convex  geometry, maxiters can be safely ignored, as the sequence of triangles visited is acyclic [see H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251-260.)].\n\nwarning: Found triangles with barriers\nIf you are using barriers, it will be your responsibility to verify that any found triangle from this function actually  contains the triangle. This can be verified using the returned flag (see below), although the point might still be on the triangle's  boundary.\n\nwarning: Walking past vertices of barriers\nIf you are using barriers, it is possible that the algorithm can walk past vertices of barriers. One way this can happen is if  the initial search line intersects a vertex, in which case the segment might not be considered. Another way this can happen is if you  start the algorithm directly on a segment vertex, in which case the algorithm can go past it (e.g. this means that it is possible that a  ghost triangle might still be returned if you start the algorithm on a boundary node).\n\nSome notes about the output:\n\ndanger: Hitting barriers\nIf a barrier is hit before any initial triangle is properly identified, the returned triangle is  (0, 0, 0); this is only possible if use_barriers == Val(true). Moreover, if use_barriers == Val(true),  the final triangle may not even be valid if invisible_flag == true (defined below).\n\nwarning: Non-convex geometries\nWhile this function does still work for non-convex geometries, it may be significantly slower than for convex geometries, as most of the details  of the algorithm assume that the geometry is convex, and so the algorithm may have to restart many times at new initial vertices k.\n\n\n\n\n\n","category":"function"},{"location":"api/point_location/#DelaunayTriangulation.get_nearest_neighbour","page":"Point Location","title":"DelaunayTriangulation.get_nearest_neighbour","text":"get_nearest_neighbour(tri_or_vor, q; kwargs...)\n\nGet the index of the nearest neighbour of q in tri_or_vor. \n\nFor power diagrams, distance is measured using get_power_distance (with q being assigned zero weight).\n\nArguments\n\ntri_or_vor: A Triangulation or VoronoiTessellation.\nq: The point to be located.\n\nKeyword Arguments\n\nkwargs...: Keyword arguments passed to find_triangle.\n\nOutput\n\ni: The index of the nearest neighbour. This is a point of the triangulation if tri_or_vor is a Triangulation or of a generator if tri_or_vor is a VoronoiTessellation.\n\n\n\n\n\n","category":"function"},{"location":"api/point_location/#DelaunayTriangulation.find_polygon","page":"Point Location","title":"DelaunayTriangulation.find_polygon","text":"find_polygon(tri::Triangulation, q) -> Integer\n\nGiven a point q, finds the index of the polygon in the triangulation tri that contains q. If  q is on the boundary of the triangulation or outside the triangulation, the function returns 0.\n\nSee also dist and distance_to_polygon.\n\n\n\n\n\n","category":"function"},{"location":"applications/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"applications/overview/","page":"Overview","title":"Overview","text":"This section shows how this package can be used for some applications, giving an example of how to use this package beyond the simple examples in the tutorials. The applications we consider are:","category":"page"},{"location":"applications/overview/","page":"Overview","title":"Overview","text":"Interpolation: How to use Delaunay triangulations for interpolation. We consider spatial interpolation, showing an example of what has been implemented in NaturalNeighbours.jl using this package.\nCellular Biology: How to use Delaunay triangulations to simulate some cell dynamics.\nSolving PDEs: How to use Delaunay triangulations to define a mesh for a PDE in two dimensions. This follows what has been implemented in FiniteVolumeMethod.jl.","category":"page"},{"location":"applications/overview/","page":"Overview","title":"Overview","text":"More applications could be added in the future - feel free to contribute some if you believe they are interesting.","category":"page"},{"location":"tutorials/operations_convex_hull_locking/#Triangulation-Operations","page":"Locking and Unlocking the Convex Hull","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_convex_hull_locking/#Locking-and-Unlocking-the-Convex-Hull","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"","category":"section"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"For unconstrained triangulations, the only boundary is the convex hull of the point set, but the boundary_nodes field is empty because it is reserved for a constrained boundary. There may be cases where you want to treat the convex hull as if it were a constrained boundary. For example, this is done internally inside refine! when providing an unconstrained triangulation for mesh refinement. Let us give an example of how this can be done, in case you want to do this for your own application.","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = rand(2, 50)\ntri = triangulate(points)\nget_boundary_nodes(tri)","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"As you can see, the boundary nodes field is empty. We can lock the convex hull using lock_convex_hull!:","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"lock_convex_hull!(tri)\nget_boundary_nodes(tri)","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"Now the boundary nodes field is not empty. Note that if you try and lock the convex hull again, you will get an error because DelaunayTriangulation.has_boundary_nodes(tri) is now true. To now unlock the convex hull, we use unlock_convex_hull!:","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"unlock_convex_hull!(tri)\nget_boundary_nodes(tri)","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"This function will error if it detects that the existing boundary isn't actually equal to the convex hull.","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"Note that this locking/unlocking doesn't actually change anything about the triangulation, it just adds information into tri to treat it as if you had provided the convex hull as a constrained boundary to start with.","category":"page"},{"location":"tutorials/operations_convex_hull_locking/#Just-the-code","page":"Locking and Unlocking the Convex Hull","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = rand(2, 50)\ntri = triangulate(points)\nget_boundary_nodes(tri)\n\nlock_convex_hull!(tri)\nget_boundary_nodes(tri)\n\nunlock_convex_hull!(tri)\nget_boundary_nodes(tri)","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"","category":"page"},{"location":"tutorials/operations_convex_hull_locking/","page":"Locking and Unlocking the Convex Hull","title":"Locking and Unlocking the Convex Hull","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/clipped_rectangle/#Clipped-Voronoi-Tessellations","page":"Clipping to a Rectangle","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"tutorials/clipped_rectangle/#Clipping-to-a-Rectangle","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"","category":"section"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"In the previous tutorial, we demonstrated how we can clip to the convex hull of the point set. However, it is often useful to clip to a rectangle, for example if you want to clip to a region of interest in a simulation. Here we obtain the coordinates just by looping over all the polygons, but you can also use this by providing a clip_polygon into voronoi, as described in this tutorial.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"Let us now demonstrate. First, we construct a tessellation of some example point set.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"using DelaunayTriangulation\nusing CairoMakie\nA = (-3.0, 7.0)\nB = (1.0, 6.0)\nC = (-1.0, 3.0)\nD = (-2.0, 4.0)\nE = (3.0, -2.0)\nF = (5.0, 5.0)\nG = (-4.0, -3.0)\nH = (3.0, 8.0)\npoints = [A, B, C, D, E, F, G, H]\ntri = triangulate(points)\nvorn = voronoi(tri)","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"Let us show the tessellation, and the rectangle we want to clip the tessellation to.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"fig, ax, sc = voronoiplot(vorn)\na, b, c, d = -2.0, 3.0, 0.0, 7.0\nlines!(ax, [(a, c), (b, c), (b, d), (a, d), (a, c)], color = :black, linewidth = 4)\nfig","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"To apply this clipping, we need to provide a bounding box of the form (xmin, xmax, ymin, ymax). Here, we will use","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"bounding_box = (a, b, c, d)","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"You can obtain some reasonable defaults for this bounding box using DelaunayTriangulation.polygon_bounds(vorn). The coordinates for each polygon clipped to this box can be obtained as follows.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"clipped_coords = Vector{Vector{NTuple{2, Float64}}}(undef, num_polygons(vorn))\nfor i in each_polygon_index(vorn)\n    clipped_coords[i] = get_polygon_coordinates(vorn, i, bounding_box)\nend\nclipped_coords","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"Now let's plot these.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"fig, ax, sc = poly(clipped_coords, color = :white, strokewidth = 4)\nfig","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"As we can see, the polygons have been clipped to the rectangle. Note that if you just want this for plotting, you can also call voronoiplot with the bounding_box keyword argument.","category":"page"},{"location":"tutorials/clipped_rectangle/#Just-the-code","page":"Clipping to a Rectangle","title":"Just the code","text":"","category":"section"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"using DelaunayTriangulation\nusing CairoMakie\nA = (-3.0, 7.0)\nB = (1.0, 6.0)\nC = (-1.0, 3.0)\nD = (-2.0, 4.0)\nE = (3.0, -2.0)\nF = (5.0, 5.0)\nG = (-4.0, -3.0)\nH = (3.0, 8.0)\npoints = [A, B, C, D, E, F, G, H]\ntri = triangulate(points)\nvorn = voronoi(tri)\n\nfig, ax, sc = voronoiplot(vorn)\na, b, c, d = -2.0, 3.0, 0.0, 7.0\nlines!(ax, [(a, c), (b, c), (b, d), (a, d), (a, c)], color = :black, linewidth = 4)\nfig\n\nbounding_box = (a, b, c, d)\n\nclipped_coords = Vector{Vector{NTuple{2, Float64}}}(undef, num_polygons(vorn))\nfor i in each_polygon_index(vorn)\n    clipped_coords[i] = get_polygon_coordinates(vorn, i, bounding_box)\nend\nclipped_coords\n\nfig, ax, sc = poly(clipped_coords, color = :white, strokewidth = 4)\nfig","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"","category":"page"},{"location":"tutorials/clipped_rectangle/","page":"Clipping to a Rectangle","title":"Clipping to a Rectangle","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/power/#Power-Diagrams","page":"Power Diagrams","title":"Power Diagrams","text":"","category":"section"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Now we discuss power diagrams, the dual of a weighted Delaunay triangulation. The main difference between a power diagram and a Voronoi tessellation is that the power diagram is defined using a power distance instead of a Euclidean distance. Recall that weighted Delaunay triangulations are derived from a point set mathcal P and an associated set of weights mathcal W so that each point p_i has an associated weight w_i. If we let pw denote a point p with weight w, then the power distance between two points p and q is defined by","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"pi(pw_p qw_p) = d(p q)^2 - w_p - w_q","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"where d(p q) is the Euclidean distance between p and q. This notation is also used for unweighted points, which are assigned a weight of 0.","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"We can use this power distance to define a power diagram. For a given site u, its power cell is ","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"W_u = p in mathbb R^2  forall q in mathcal P^+ pi(p uw_u) leq pi(p qw_q)","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"where mathcal P^+ is the set of points mathcal P with the assigned weights from mathcal W. In particular, W_u is the set of all points closer to u than to any other point in mathcal P, where the distance is measured using the power distance.","category":"page"},{"location":"math/power/#Orthoballs-and-Orthocenters:-Generalising-Circumcircles","page":"Power Diagrams","title":"Orthoballs and Orthocenters: Generalising Circumcircles","text":"","category":"section"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Recall that Voronoi tessellations are computed by simply connecting the circumcenters of the Delaunay triangles. For power diagrams, we need a generalisation of the circumcenter. Remember that the circumcenter can be derived by intersecting the perpendicular bisectors of a triangle's edges. A similar definition can be used for obtaining what is called the orthocenter.","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"To start, we need a geometric interpretion of a weighted point. We can relate it to the notion of a power of a point. Define the ball B_p = x in mathbb R^2 d(p x) leq sqrtw_p, and note that the squared length of the line segment extending from a point x to touch B_p tangentially is given by d(x p)^2 - w_p (see the first equation on the linked Wikipedia page).  This distance is exactly pi(x pw_p). Thus:","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"If x notin B_p, then pi(x pw_p)  0.\nIf x is exactly on the boundary of B_p, then pi(x pw_p) = 0.\nIf x in B_p, then pi(x pw_p)  0.","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Note that, since weights may be negative, sqrtw_p may be complex, in which case every point lies outside B_p. Thus, our geometric interpretation of a weighted point is exactly as the ball B_p.","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"We can use this interpretation to understand how the generators of the power diagram are related to the vertices of the power cells. Remember that the definition of a power cell implies that a vertex v of the diagram if equidistant in power distance from the weighted generators that generate it, e.g. if v neighbours generators u and w, then pi(v uw_u) = pi(v ww_w). Let this constant power distance be omega_v. Then, the power distance from v to its weighted generators is ","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"pi(vomega_v uw_u) = d(v u)^2 - omega_v - w_u","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"but we also know pi(v uw_u) = omega_v = d(v u)^2 - w_u. Thus,","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"pi(vomega_v uw_u) = 0","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"We say that vomega_v is orthogonal to uw_u. With this definition, vomega_v is orthogonal to all of its generators. Letting B_v be the ball centered at v with radius sqrtomega_v (which could be complex), we call B_v the orthoball centered at v. More generally, we say that two weighted points are","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Orthogonal if the power distance between them is zero;\nFarther than orthogonal if the power distance between them is positive;\nCloser than orthogonal if the power distance between them is negative.","category":"page"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"The orthoball can be used to generalise circumcircles. The orthoball of a triangle is defined to be the ball that is orthogonal to all three vertices of the triangle. In particular, if c if the ball's center, called the orthocenter, and sqrtomega_c is its radius, called the orthoradius, then d(v c)^2 - w_v - omega_c = 0 for each vertex v of the triangle. The center and radius can be computed by solving this system of equations d(v c)^2 - w_v - omega_c = 0. It is possible to show these orthoballs are exactly what we need to define duality between the power diagram and the weighted Delaunay triangulation. ","category":"page"},{"location":"math/power/#Computing-the-Power-Diagram","page":"Power Diagrams","title":"Computing the Power Diagram","text":"","category":"section"},{"location":"math/power/","page":"Power Diagrams","title":"Power Diagrams","text":"The above discussion leads us to a method for computing the power diagram. Just as a Voronoi tessellation can be computed by joining up the circumcenters, simply join up the orthocenters of each triangle. Special care may be needed to accommodate the fact that not all generator's power cells are non-empty.","category":"page"},{"location":"tutorials/lattice/#Triangulating-Rectangular-Regions","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"","category":"section"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"In this tutorial, we show how you can easily triangulate rectangular regions of the form a b times c d. Rather than using triangulate, you can use triangulate_rectangle for this purpose. To start, we give a simple example","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"using DelaunayTriangulation\nusing CairoMakie\n\na, b, c, d = 0.0, 2.0, 0.0, 10.0\nnx, ny = 10, 25\ntri = triangulate_rectangle(a, b, c, d, nx, ny)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"This can be much faster than if we just construct the points in the lattice manually and triangulate those. Here's a comparison of the times.","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"using BenchmarkTools\npoints = get_points(tri)\n@benchmark triangulate($points; randomise = $false) # randomise=false because points are already in lattice order, i.e. spatially sorted","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"@benchmark triangulate_rectangle($a, $b, $c, $d, $nx, $ny)","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"This difference would be more pronounced for larger nx, ny.","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"Note that the output of triangulate_rectangle treats the boundary as a constrained boundary:","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"get_boundary_nodes(tri)","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"This boundary is split into four separate sections, one for each side of the rectangle. If you would prefer to keep the boundary as one contiguous section, use single_boundary=true. Moreover, note that this tri has ghost triangles:","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"tri","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"You can opt into not having these by using delete_ghosts=true:","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"tri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary = true, delete_ghosts = true)\ntri","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"get_boundary_nodes(tri)","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"DelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/lattice/#Just-the-code","page":"Triangulating Rectangular Regions","title":"Just the code","text":"","category":"section"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"using DelaunayTriangulation\nusing CairoMakie\n\na, b, c, d = 0.0, 2.0, 0.0, 10.0\nnx, ny = 10, 25\ntri = triangulate_rectangle(a, b, c, d, nx, ny)\nfig, ax, sc = triplot(tri)\nfig\n\nusing BenchmarkTools\npoints = get_points(tri)\n@benchmark triangulate($points; randomise = $false) # randomise=false because points are already in lattice order, i.e. spatially sorted\n\n@benchmark triangulate_rectangle($a, $b, $c, $d, $nx, $ny)\n\nget_boundary_nodes(tri)\n\ntri\n\ntri = triangulate_rectangle(a, b, c, d, nx, ny; single_boundary = true, delete_ghosts = true)\ntri\n\nget_boundary_nodes(tri)\n\nDelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"","category":"page"},{"location":"tutorials/lattice/","page":"Triangulating Rectangular Regions","title":"Triangulating Rectangular Regions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"api/iterators/#DelaunayTriangulation.each_vertex","page":"Iterators","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all vertices in tri. Note that, if has_ghost_triangles(tri), then some of these vertices will be ghost vertices.\n\nSee also each_solid_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_solid_vertex","page":"Iterators","title":"DelaunayTriangulation.each_solid_vertex","text":"each_solid_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all solid vertices in tri. \n\nSee also each_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_ghost_vertex","page":"Iterators","title":"DelaunayTriangulation.each_ghost_vertex","text":"each_ghost_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all ghost vertices in tri.\n\nSee also each_vertex and each_solid_vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_edge","page":"Iterators","title":"DelaunayTriangulation.each_edge","text":"each_edge(E) -> Iterator\n\nGet an iterator over the edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1,2),(1,3),(2,-1)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (1, 3)\n  (2, -1)\n\njulia> each_edge(E)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (1, 3)\n  (2, -1)\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_solid_edge","page":"Iterators","title":"DelaunayTriangulation.each_solid_edge","text":"each_solid_edge(tri::Triangulation) -> Edges\n\nReturns an iterator over all solid edges in tri.\n\nSee also each_edge and each_ghost_edge.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_ghost_edge","page":"Iterators","title":"DelaunayTriangulation.each_ghost_edge","text":"each_ghost_edge(tri::Triangulation) -> Edges\n\nReturns an iterator over all ghost edges in tri.\n\nSee also each_edge and each_solid_edge.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_vertices","page":"Iterators","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(G::Graph) -> Integer\n\nReturns the number of vertices in G.\n\n\n\n\n\nnum_vertices(tri::Triangulation) -> Integer\n\nReturns the number of vertices in tri. Note that, if has_ghost_triangles(tri), then some of these vertices will be ghost vertices.\n\nSee also num_solid_vertices and num_ghost_vertices.\n\n\n\n\n\nnum_vertices(stats::TriangulationStatistics)\n\nReturns the num_vertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_solid_vertices","page":"Iterators","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(tri::Triangulation) -> Integer\n\nReturns the number of solid vertices in tri.\n\nSee also num_ghost_vertices and num_vertices.\n\n\n\n\n\nnum_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_ghost_vertices","page":"Iterators","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(tri::Triangulation) -> Integer\n\nReturns the number of ghost vertices in tri. \n\nSee also num_solid_vertices and num_vertices.\n\n\n\n\n\nnum_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_edges","page":"Iterators","title":"DelaunayTriangulation.num_edges","text":"num_edges(G::Graph) -> Integer\n\nReturns the number of edges in G. The   edges (i, j) and (j, i) are counted as one edge.\n\n\n\n\n\nnum_edges(tri::Triangulation) -> Integer\n\nReturns the number of edges in tri. Note that, if has_ghost_triangles(tri), then some of these edges will be ghost edges.\n\nSee also num_solid_edges and num_ghost_edges.\n\n\n\n\n\nnum_edges(history::PointLocationHistory) -> Integer\n\nReturns the number of edges in history.collinear_segments.\n\n\n\n\n\nnum_edges(stats::TriangulationStatistics)\n\nReturns the num_edges field from the TriangulationStatistics` stats.\n\n\n\n\n\nnum_edges(E) -> Integer\n\nGet the number of edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = [(1, 2), (3, 4), (1, 5)];\n\njulia> num_edges(e)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_solid_edges","page":"Iterators","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(tri::Triangulation) -> Integer\n\nReturns the number of solid edges in tri.\n\nSee also num_ghost_edges and num_edges.\n\n\n\n\n\nnum_solid_edges(stats::TriangulationStatistics)\n\nReturns the numsolidedges field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_ghost_edges","page":"Iterators","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(tri::Triangulation) -> Integer\n\nReturns the number of ghost edges in tri.\n\nSee also num_solid_edges and num_edges.\n\n\n\n\n\nnum_ghost_edges(stats::TriangulationStatistics)\n\nReturns the numghostedges field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_triangle","page":"Iterators","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(T) -> Iterator\n\nReturn an iterator over the triangles in T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (-1, 5, 10), (17, 13, 18)));\n\njulia> each_triangle(T)\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (-1, 5, 10)\n  (1, 2, 3)\n  (17, 13, 18)\n\njulia> T = [[1, 2, 3], [10, 15, 18], [1, 5, 6]];\n\njulia> each_triangle(T)\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [10, 15, 18]\n [1, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_solid_triangle","page":"Iterators","title":"DelaunayTriangulation.each_solid_triangle","text":"each_solid_triangle(tri::Triangulation) -> Triangles\n\nReturns an iterator over all solid triangles in tri.\n\nSee also each_triangle and each_ghost_triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_ghost_triangle","page":"Iterators","title":"DelaunayTriangulation.each_ghost_triangle","text":"each_ghost_triangle(tri::Triangulation) -> Triangles\n\nReturns an iterator over all ghost triangles in tri.\n\nSee also each_triangle and each_solid_triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_triangles","page":"Iterators","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(tri::Triangulation) -> Integer\n\nReturns the number of triangles in tri. Note that, if has_ghost_triangles(tri), then some of these triangles will be ghost triangles.\n\n\n\n\n\nnum_triangles(stats::TriangulationStatistics)\n\nReturns the num_triangles field from the TriangulationStatistics` stats.\n\n\n\n\n\nnum_triangles(T) -> Integer\n\nGet the number of triangles in T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T1, T2, T3 = (1, 5, 10), (17, 23, 10), (-1, 10, 5);\n\njulia> T = Set((T1, T2, T3));\n\njulia> num_triangles(T)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_solid_triangles","page":"Iterators","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(tri::Triangulation) -> Integer\n\nReturns the number of solid triangles in tri.\n\n\n\n\n\nnum_solid_triangles(stats::TriangulationStatistics)\n\nReturns the numsolidtriangles field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.num_ghost_triangles","page":"Iterators","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(tri::Triangulation) -> Integer\n\nReturns the number of ghost triangles in tri.\n\n\n\n\n\nnum_ghost_triangles(stats::TriangulationStatistics)\n\nReturns the numghosttriangles field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_point","page":"Iterators","title":"DelaunayTriangulation.each_point","text":"each_point(points) -> Iterator\n\nReturns an iterator over each point in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (5.0, 13.0)];\n\njulia> DelaunayTriangulation.each_point(points)\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (5.0, 13.0)\n\njulia> points = [1.0 5.0 17.7; 5.5 17.7 0.0];\n\njulia> DelaunayTriangulation.each_point(points)\n3-element ColumnSlices{Matrix{Float64}, Tuple{Base.OneTo{Int64}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1.0, 5.5]\n [5.0, 17.7]\n [17.7, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_point_index","page":"Iterators","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(points) -> Iterator\n\nReturns an iterator over each point index in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (-5.0, 2.0), (2.3, 2.3)];\n\njulia> DelaunayTriangulation.each_point_index(points)\nBase.OneTo(3)\n\njulia> points = [1.0 -5.0 2.3; 2.0 2.0 2.3];\n\njulia> DelaunayTriangulation.each_point_index(points)\nBase.OneTo(3)\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_boundary_edge","page":"Iterators","title":"DelaunayTriangulation.each_boundary_edge","text":"each_boundary_edge(enricher::BoundaryEnricher) -> KeySet\n\nReturns the set of keys in the parent map of enricher, i.e. each boundary edge in enricher.\n\n\n\n\n\neach_boundary_edge(tri::Triangulation) -> KeySet\n\nReturns an iterator over the boundary edges of tri, in no specific order.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_segment","page":"Iterators","title":"DelaunayTriangulation.each_segment","text":"each_segment(tri::Triangulation) -> Edges\n\nReturns an iterator over all segments in tri. This includes both interior and boundary segments. If you only want  interior segments, then see get_interior_segments,\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_generator","page":"Iterators","title":"DelaunayTriangulation.each_generator","text":"each_boundary_polygon(vorn::VoronoiTessellation) -> KeySet\n\nReturns an iterator over the boundary polygon indices of vorn.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_polygon_vertex","page":"Iterators","title":"DelaunayTriangulation.each_polygon_vertex","text":"each_polygon_vertex(vor::VoronoiTessellation) -> UnitRange\n\nReturns an iterator over each polygon point index of vor.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_unbounded_polygon","page":"Iterators","title":"DelaunayTriangulation.each_unbounded_polygon","text":"each_polygon(vor::VoronoiTessellation) -> Set\n\nReturns an iterator over the polygon indices of vor.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_polygon","page":"Iterators","title":"DelaunayTriangulation.each_polygon","text":"each_polygon(vor::VoronoiTessellation) -> ValueIterator\n\nReturns an iterator over each set of polygon vertices of vor.\n\n\n\n\n\n","category":"function"},{"location":"api/iterators/#DelaunayTriangulation.each_polygon_index","page":"Iterators","title":"DelaunayTriangulation.each_polygon_index","text":"each_polygon_index(vor::VoronoiTessellation) -> KeySet\n\nReturns an iterator over the polygon indices of vor.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#Triangulation-Statistics","page":"Triangulation Statistics","title":"Triangulation Statistics","text":"","category":"section"},{"location":"api/statistics/#DelaunayTriangulation.IndividualTriangleStatistics","page":"Triangulation Statistics","title":"DelaunayTriangulation.IndividualTriangleStatistics","text":"IndividualTriangleStatistics{T}\n\nStruct storing statistics of a single triangle.\n\nFields\n\narea::T: The area of the triangle.\nlengths::NTuple{3,T}: The lengths of the edges of the triangle, given in sorted order. \ncircumcenter::NTuple{2,T}: The circumcenter of the triangle.\ncircumradius::T: The circumradius of the triangle.\nangles::NTuple{3, T}: The angles of the triangle, given in sorted order.\nradius_edge_ratio::T: The ratio of the circumradius to the shortest edge length.\nedge_midpoints::NTuple{3,NTuple{2,T}}: The midpoints of the edges of the triangle.\naspect_ratio::T: The ratio of the inradius to the circumradius.\ninradius::T: The inradius of the triangle.\nperimeter::T: The perimeter of the triangle.\ncentroid::NTuple{2,T}: The centroid of the triangle.\noffcenter::NTuple{2,T}: The offcenter of the triangle with radius-edge ratio cutoff β=1. See this paper.\nsink::NTuple{2,T}: The sink of the triangle relative to the parent triangulation. See this paper.\n\nConstructors\n\nThe constructor is \n\nIndividualTriangleStatistics(p, q, r, sink = (NaN, NaN))\n\nwhere p, q, and r are the coordinates of the triangle given in  counter-clockwise order. sink is the triangle's sink. This must be provided  separately since it is only computed relative to a triangulation, and so requires  vertices rather than coordinates; see triangle_sink.\n\nExtended help\n\nThe relevant functions used for computing these statistics are \n\nsquared_triangle_lengths\ntriangle_area\ntriangle_circumcenter\ntriangle_circumradius\ntriangle_radius_edge_ratio\ntriangle_edge_midpoints\ntriangle_perimeter\ntriangle_inradius\ntriangle_aspect_ratio\ntriangle_centroid\ntriangle_angles\ntriangle_offcenter\ntriangle_sink.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#DelaunayTriangulation.triangle_area","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_area","text":"triangle_area(p, q, r) -> Number\n\nReturns the signed area of a triangle (p, q, r). The area is positive if (p, q, r) is positively oriented.\n\n\n\n\n\ntriangle_area(ℓ₁²::Number, ℓ₂²::Number, ℓ₃²::Number) -> Number\n\nCompute the area of a triangle given the squares of its edge lengths. The edges should be sorted so that  ℓ₁² ≤ ℓ₂² ≤ ℓ₃². If there are precision issues that cause the area to be negative, then the area is set to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_circumradius","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_circumradius","text":"triangle_circumradius(A, ℓmin², ℓmed², ℓmax²) -> Number\n\nComputes the circumradius of a triangle with area A and squared edge lengths ℓmin² ≤ ℓmed² ≤ ℓmax². The circumradius is given by \n\nr = dfracell_minell_textmedell_max4A\n\n\n\n\n\ntriangle_circumradius(p, q, r) -> Number\n\nComputes the circumradius of the triangle with coordinates (p, q, r). \n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_perimeter","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_perimeter","text":"triangle_perimeter(ℓmin::Number, ℓmed::Number, ℓmax::Number) -> Number\n\nComputes the perimeter of a triangle with edge lengths ℓmin ≤ ℓmed ≤ ℓmax. The perimeter is given by \n\nP = ell_min + ell_textmed + ell_max\n\n\n\n\n\ntriangle_perimeter(p, q, r) -> Number\n\nComputes the perimeter of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_inradius","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_inradius","text":"triangle_inradius(A, perimeter) -> Number\n\nComputes the inradius of a triangle with area A and perimeter perimeter. The inradius is given by\n\nr_i = dfrac2AP\n\nwhere P is the perimeter.\n\n\n\n\n\ntriangle_inradius(p, q, r) -> Number\n\nComputes the inradius of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_aspect_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_aspect_ratio","text":"triangle_aspect_ratio(inradius::Number, circumradius::Number) -> Number\n\nComputes the aspect ratio of a triangle with inradius inradius and circumradius circumradius. The aspect ratio is given by\n\ntau = dfracr_ir\n\nwhere r_i is the inradius and r is the circumradius.\n\n\n\n\n\ntriangle_aspect_ratio(p, q, r) -> Number\n\nComputes the aspect ratio of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_radius_edge_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_radius_edge_ratio","text":"triangle_radius_edge_ratio(circumradius::Number, ℓmin::Number) -> Number\n\nComputes the radius-edge ratio of a triangle with circumradius circumradius and minimum edge length ℓmin, given by \n\nrho = dfracrell_min\n\nwhere r is the circumradius and ell_min is the shortest edge length.\n\n\n\n\n\ntriangle_radius_edge_ratio(p, q, r) -> Number\n\nComputes the radius-edge ratio of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_centroid","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_centroid","text":"triangle_centroid(p, q, r) -> (Number, Number)\n\nComputes the centroid of a triangle with vertices p, q, and r, given by\n\nc = dfracp + q + r3\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_angles","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_angles","text":"triangle_angles(p, q, r) -> (Number, Number, Number)\n\nComputes the angles of a triangle with vertices p, q, and r. The formula for, say, the angle at p is given by \n\ntheta_1 = arctanleft(dfrac2Aleft(p - qright)cdotleft(p - rright)right)\n\nwhere A is the area of the triangle. The angles are returned in sorted order.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_lengths","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_lengths","text":"triangle_lengths(p, q, r) -> (Number, Number, Number)\n\nComputes the lengths of the edges of the triangle with coordinates p, q, r. The lengths are returned in sorted order.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_circumcenter","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_circumcenter","text":"triangle_circumcenter(p, q, r, A=triangle_area(p, q, r)) -> (Number, Number)\n\nComputes the circumcenter of the triangle with coordinates (p, q, r). The circumcenter is given by \n\nc_x = r_x + dfracd_11d_22 - d_12d_214A quad c_y = r_y + dfrace_11e_22 - e_12e_214A\n\nwhere d_11 = p - r_2^2, d_12 = p_y - r_y, d_21 = q - r_2^2, d_22 = q_y - r_y, e_11 = p_x - r_x e_12 = d_11, e_21 = q_x - r_x, and e_22 = d_21.\n\n\n\n\n\ntriangle_circumcenter(tri::Triangulation, T) -> (Number, Number)\n\nComputes the circumcenter of the triangle T in the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_offcenter","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_offcenter","text":"triangle_offcenter(p, q, r, c₁=triangle_circumcenter(p, q, r), β=1.0) -> (Number, Number)\n\nComputes the off-center of the triangle (p, q, r).\n\nArguments\n\np, q, r: The coordinates of the triangle, given in counter-clockwise order.\nc₁=triangle_circumcenter(p, q, r): The circumcenter of the triangle.\nβ=1.0: The radius-edge ratio cutoff. \n\nOutput\n\ncx: The x-coordinate of the off-center.\ncy: The y-coordinate of the off-center.\n\ndanger: Difference in definitions\nIn the original paper, the off-center is defined to instead  be the circumcenter if it the triangle pqc₁ has radius-edge ratio less than β. Here, we just let the off-center be the point c so that pqc has radius-edge ratio of exactly β.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_edge_midpoints","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_edge_midpoints","text":"triangle_edge_midpoints(p, q, r) -> (Number, Number), (Number, Number), (Number, Number)\n\nComputes the midpoints of the edges of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_sink","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_sink","text":"triangle_sink(tri::Triangulation, T; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Number, Number)\n\nComputes the sink of the triangle T in tri. See this paper for more information. Use the predicates argument to control how predicates are computed.\n\nExtended help\n\nSinks were introduced in this paper. For a given triangle T, the sink of  T is defined as follows:\n\nIf c, the circumcenter of T, is in the interior of T, then the sink of T is T.\nIf T is a boundary triangle, then the sink of T is T.\nIf neither 1 or 2, then the sink is defined as the sink of the triangle V, where V is the triangle adjoining the edge of T which intersects the line mc, where m is the centroid of T.\n\nIn cases where the triangulation has holes, this definition can lead to loops. In such a case, we just pick one of the triangles  in the loop as the sink triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_orthocenter","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_orthocenter","text":"triangle_orthocenter(tri::Triangulation, T) -> NTuple{2, Number}\n\nFinds the triangle orthocenter of T. In particular, the point (ox, oy) equidistant from each of the  points of T with respect to the power distance.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.triangle_orthoradius_squared","page":"Triangulation Statistics","title":"DelaunayTriangulation.triangle_orthoradius_squared","text":"triangle_orthoradius_squared(p, q, r, a, b, c) -> Number\n\nComputes the squared orthoradius of the triangle (p, q, r) with weights a, b, and c.  Note that this number may be negative.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.TriangulationStatistics","page":"Triangulation Statistics","title":"DelaunayTriangulation.TriangulationStatistics","text":"TriangulationStatistics{T,V,I}\n\nA struct containing statistics about a triangulation. \n\nFields\n\nnum_vertices::I: The number of vertices in the triangulation.\nnum_solid_vertices::I: The number of solid vertices in the triangulation.\nnum_ghost_vertices::I: The number of ghost vertices in the triangulation.\nnum_edges::I: The number of edges in the triangulation.\nnum_solid_edges::I: The number of solid edges in the triangulation.\nnum_ghost_edges::I: The number of ghost edges in the triangulation.\nnum_triangles::I: The number of triangles in the triangulation.\nnum_solid_triangles::I: The number of solid triangles in the triangulation.\nnum_ghost_triangles::I: The number of ghost triangles in the triangulation.\nnum_boundary_segments::I: The number of boundary segments in the triangulation.\nnum_interior_segments::I: The number of interior segments in the triangulation.\nnum_segments::I: The number of segments in the triangulation.\nnum_convex_hull_vertices::I: The number of vertices on the convex hull of the triangulation.\nsmallest_angle::V: The smallest angle in the triangulation.\nlargest_angle::V: The largest angle in the triangulation.\nsmallest_area::V: The smallest area of a triangle in the triangulation.\nlargest_area::V: The largest area of a triangle in the triangulation.\nsmallest_radius_edge_ratio::V: The smallest radius-edge ratio of a triangle in the triangulation.\nlargest_radius_edge_ratio::V: The largest radius-edge ratio of a triangle in the triangulation.\narea::V: The total area of the triangulation.\nindividual_statistics::Dict{T,IndividualTriangleStatistics{V}}: A map from triangles in the triangulation to their individual statistics. See IndividualTriangleStatistics.\n\nConstructors\n\nTo construct these statistics, use statistics, which you call as statistics(tri::Triangulation).\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#DelaunayTriangulation.statistics","page":"Triangulation Statistics","title":"DelaunayTriangulation.statistics","text":"statistics(tri::Triangulation) -> TriangulationStatistics\n\nReturns a TriangulationStatistics object containing statistics about the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.num_boundary_segments","page":"Triangulation Statistics","title":"DelaunayTriangulation.num_boundary_segments","text":"num_boundary_segments(stats::TriangulationStatistics)\n\nReturns the numboundarysegments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.num_interior_segments","page":"Triangulation Statistics","title":"DelaunayTriangulation.num_interior_segments","text":"num_interior_segments(stats::TriangulationStatistics)\n\nReturns the numinteriorsegments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.num_segments","page":"Triangulation Statistics","title":"DelaunayTriangulation.num_segments","text":"num_segments(stats::TriangulationStatistics)\n\nReturns the num_segments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.num_convex_hull_vertices","page":"Triangulation Statistics","title":"DelaunayTriangulation.num_convex_hull_vertices","text":"num_convex_hull_vertices(stats::TriangulationStatistics)\n\nReturns the numconvexhull_vertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_smallest_angle","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_smallest_angle","text":"get_smallest_angle(stats::TriangulationStatistics)\n\nReturns the smallest_angle field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_largest_angle","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_largest_angle","text":"get_largest_angle(stats::TriangulationStatistics)\n\nReturns the largest_angle field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_smallest_area","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_smallest_area","text":"get_smallest_area(stats::TriangulationStatistics)\n\nReturns the smallest_area field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_largest_area","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_largest_area","text":"get_largest_area(stats::TriangulationStatistics)\n\nReturns the largest_area field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_smallest_radius_edge_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_smallest_radius_edge_ratio","text":"get_smallest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the smallestradiusedge_ratio field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_largest_radius_edge_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_largest_radius_edge_ratio","text":"get_largest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the largestradiusedge_ratio field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_individual_statistics","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_individual_statistics","text":"get_individual_statistics(stats::TriangulationStatistics)\n\nReturns the individual_statistics field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_lengths","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_lengths","text":"get_lengths(stats::TriangulationStatistics, T)\n\nReturns the lengths field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_circumcenter","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_circumcenter","text":"get_circumcenter(stats::TriangulationStatistics, T)\n\nReturns the circumcenter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_circumradius","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_circumradius","text":"get_circumradius(stats::TriangulationStatistics, T)\n\nReturns the circumradius field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_angles","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_angles","text":"get_angles(stats::TriangulationStatistics, T)\n\nReturns the angles field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_radius_edge_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_radius_edge_ratio","text":"get_radius_edge_ratio(stats::TriangulationStatistics, T)\n\nReturns the radiusedgeratio field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_edge_midpoints","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_edge_midpoints","text":"get_edge_midpoints(stats::TriangulationStatistics, T)\n\nReturns the edge_midpoints field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_aspect_ratio","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_aspect_ratio","text":"get_aspect_ratio(stats::TriangulationStatistics, T)\n\nReturns the aspect_ratio field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_inradius","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_inradius","text":"get_inradius(stats::TriangulationStatistics, T)\n\nReturns the inradius field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_perimeter","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_perimeter","text":"get_perimeter(stats::TriangulationStatistics, T)\n\nReturns the perimeter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_offcenter","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_offcenter","text":"get_offcenter(stats::TriangulationStatistics, T)\n\nReturns the offcenter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_sink","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_sink","text":"get_sink(stats::TriangulationStatistics, T)\n\nReturns the sink field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_minimum_angle","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_minimum_angle","text":"get_minimum_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the minimum angle of T from stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_maximum_angle","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_maximum_angle","text":"get_maximum_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the maximum angle of T from stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_median_angle","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_median_angle","text":"get_median_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the median angle of T from stats.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#DelaunayTriangulation.get_all_stat","page":"Triangulation Statistics","title":"DelaunayTriangulation.get_all_stat","text":"get_all_stat(stats::TriangulationStatistics, stat::Symbol) -> Vector\n\nReturns a vector of the statistic stat for each triangle in stats.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#Triangulation-Operations","page":"Triangulation Operations","title":"Triangulation Operations","text":"","category":"section"},{"location":"api/operations/#DelaunayTriangulation.add_boundary_information!","page":"Triangulation Operations","title":"DelaunayTriangulation.add_boundary_information!","text":"add_boundary_information!(tri::Triangulation)\n\nUpdates tri so that the ghost triangle information defined by the boundary nodes in tri is added to the triangulation. \n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.add_ghost_triangles!","page":"Triangulation Operations","title":"DelaunayTriangulation.add_ghost_triangles!","text":"add_ghost_triangles!(tri::Triangulation)\n\nAdds all the ghost triangles to tri.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.add_point!","page":"Triangulation Operations","title":"DelaunayTriangulation.add_point!","text":"add_point!(c::RepresentativeCoordinates, p)\n\nTreating c as an arithmetic average, updates the coordinates of c to include p.\n\n\n\n\n\nadd_point!(tri::Triangulation, new_point; kwargs...) -> Triangle\nadd_point!(tri::Triangulation, x, y; kwargs...) -> Triangle\n\nArguments\n\ntri::Triangulation: The Triangulation.\nnew_point: The point to be added to the triangulation. The second method uses (x, y) to represent the new point instead. If new_point is an integer, then the point added is get_point(tri, new_point).\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\npoint_indices=each_solid_vertex(tri): The indices of the points to be used in the find_triangle algorithm for selecting the initial point.\nm=default_num_samples(length(point_indices)): The number of samples (without replacement) to be used in the find_triangle algorithm for selecting the initial point.\ntry_points=(): Additional points to try for selecting the initial point, in addition to the m sampled.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to be used in find_triangle.\ninitial_search_point=integer_type(tri)(select_initial_point(tri, new_point; point_indices, m, try_points, rng)): The initial point to be used in find_triangle.\nupdate_representative_point=false: Whether to update the representative point of the triangulation after adding the new point. \nstore_event_history=Val(false): Whether to store the event history of the triangulation from adding the new point. \nevent_history=nothing: The event history of the triangulation from adding the new point. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\nconcavity_protection=false: Whether to use concavity protection for finding V below. See concavity_protection_check. This is only needed if your triangulation is not convex. \nV=find_triangle(tri, get_point(tri, new_point); m=nothing, point_indices=nothing, try_points=nothing, k=initial_search_point, concavity_protection, rng): The positively oriented triangle containing the point being added.\n\nwarning: Non-convex domains\nIn cases where your triangulation is not convex and !concavity_protection, this V may not be correct, and you may encounter errors - errors either during add_point! or separately when  you try to use the triangulation. In such cases, you should set concavity_protection=true to ensure that V is correct.\n\npeek=Val(false): Whether the point should actually be added into the triangulation, or just 'peeked' at so that the events that would occur from its addition can be added into event_history.\n\nOutputs\n\nThe triangulation is updated in-place, but we do return \n\nV: The triangle containing the point being added.\n\nwarn: Convex hull\nIn cases where (x, y) is outside of the triangulation, it will be added successfully but note that  the convex_hull field of tri will no longer be accurate. You can use convex_hull! to fix it.\n\n\n\n\n\nadd_point!(tri::Triangulation, x, y, w; kwargs...)\n\nAdds the point (x, y) into tri with weight w. This function requires that add_weight! is defined on the weights stored in tri. The kwargs match those from add_point!(tri::Triangulation, ::Any).\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.add_segment!","page":"Triangulation Operations","title":"DelaunayTriangulation.add_segment!","text":"add_segment!(tri::Triangulation, segment; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())\nadd_segment!(tri::Triangulation, i, j; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())\n\nAdds segment = (i, j) to tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegment: The segment to add. The second method uses (i, j) to represent the segment instead.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nrng::AbstractRNG=Random.default_rng(): The RNG object.\n\nOutputs\n\nThere is no output, but tri will be updated so that it now contains segment.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.add_triangle!","page":"Triangulation Operations","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T, V...)\nadd_triangle!(T, i, j, k)\n\nAdd the triangles V... or V = (i, j, k) to the collection of triangles T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (4, 5, 6)))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> add_triangle!(T, (7, 8, 9));\n\njulia> add_triangle!(T, (10, 11, 12), (13, 14, 15));\n\njulia> add_triangle!(T, 16, 17, 18);\n\njulia> T\nSet{Tuple{Int64, Int64, Int64}} with 6 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (4, 5, 6)\n  (13, 14, 15)\n  (16, 17, 18)\n  (1, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.clear_empty_features!","page":"Triangulation Operations","title":"DelaunayTriangulation.clear_empty_features!","text":"clear_empty_features!(tri::Triangulation)\n\nClears all empty features from the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.delete_ghost_triangles!","page":"Triangulation Operations","title":"DelaunayTriangulation.delete_ghost_triangles!","text":"delete_ghost_triangles!(tri::Triangulation)\n\nDeletes all the ghost triangles from tri.\n\nwarning: Ghost vertices\nGhost vertices are still used in the keys of the Adjacent2Vertex  of tri, and are still present in the Graph. If you want to delete the  ghost vertex keys from the Adjacent2Vertex, you need to use  delete_adjacent2vertex!. For deleting the ghost vertices from the  Graph, you need delete_ghost_vertices_from_graph!. Additionally,  edges in Adjacent can still map to ghost vertices. If you also want to delete  those, you need to filter through the values of the Adjacent map  that are ghost vertices, and use delete_adjacent!.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.delete_holes!","page":"Triangulation Operations","title":"DelaunayTriangulation.delete_holes!","text":"delete_holes!(tri::Triangulation)\n\nDeletes all the exterior faces to the boundary nodes specified in the triangulation tri.\n\nExtended help\n\nThis function works in several stages:\n\nFirst, find_all_points_to_delete is used to identify all points in the exterior faces.\nOnce all the points to delete have been found, all the associated triangles are found using find_all_triangles_to_delete, taking care for any incorrectly identified triangles and points. \nOnce the correct set of triangles to delete has been found, they are deleted using delete_all_exterior_triangles!.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.get_surrounding_polygon","page":"Triangulation Operations","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(cache::TriangulationCache) -> Vector{Vertex}\n\nReturns the polygon surrounding the triangulation stored in cache.\n\n\n\n\n\nget_surrounding_polygon(vor::VoronoiTessellation, i) -> Vector{Vertex}\n\nGets the polygon surrounding the generator with index i in vor. \n\nYou shouldn't need to use this, see get_polygon instead.\n\n\n\n\n\nget_surrounding_polygon(tri::Triangulation, u; skip_ghost_vertices=false) -> Vector\n\nReturns the counter-clockwise sequence of neighbours of u in tri.\n\nArguments\n\ntri::Triangulation: Triangulation.\nu: The vertex.\n\nKeyword Arguments\n\nskip_ghost_vertices=false: Whether to skip ghost vertices in the returned polygon. \n\nOutputs\n\nS: The surrounding polygon. This will not be circular, meaning S[begin] ≠ S[end].  In case u is an exterior ghost vertex, the returned polygon is a clockwise list of vertices for   the associated boundary curve. If you do not have ghost triangles and you try to get the surrounding polygon  of a ghost vertex, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.delete_point!","page":"Triangulation Operations","title":"DelaunayTriangulation.delete_point!","text":"delete_point!(c::RepresentativeCoordinates, p)\n\nTreating c as an arithmetic average, updates the coordinates of c to exclude p.\n\n\n\n\n\ndelete_point!(tri::Triangulation, vertex; kwargs...)\n\nDeletes the vertex of tri, retriangulating the cavity formed by the surrounding polygon of vertex using  triangulate_convex.\n\nIt is not possible to delete vertices that are on the boundary, are ghost vertices, or adjoin a segment of tri.  See also check_delete_point_args.\n\nwarn: Point deletion\nThis function will not actually delete the corresponding coordinates from get_points(tri), nor will it remove  the associated weight from get_weights(tri).\n\nArguments\n\ntri::Triangulation: Triangulation.\nvertex: The vertex to delete.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_event_history=Val(false): Whether to store the event history of the triangulation from deleting the point. \nevent_history=nothing: The event history of the triangulation from deleting the point. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use for the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.delete_triangle!","page":"Triangulation Operations","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(V, T...)\ndelete_triangle!(V, i, j, k)\n\nDelete the triangles T... from the collection of triangles V.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)))\nSet{Tuple{Int64, Int64, Int64}} with 5 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (4, 5, 6)\n  (13, 14, 15)\n  (1, 2, 3)\n\njulia> delete_triangle!(V, (6, 4, 5))\nSet{Tuple{Int64, Int64, Int64}} with 4 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (13, 14, 15)\n  (1, 2, 3)\n\njulia> delete_triangle!(V, (10, 11, 12), (1, 2, 3))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (7, 8, 9)\n  (13, 14, 15)\n\njulia> delete_triangle!(V, 8, 9, 7)\nSet{Tuple{Int64, Int64, Int64}} with 1 element:\n  (13, 14, 15)\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.flip_edge!","page":"Triangulation Operations","title":"DelaunayTriangulation.flip_edge!","text":"flip_edge!(tri::Triangulation, i, j, store_event_history=Val(false), event_history=nothing)\nflip_edge!(tri::Triangulation, i, j, k, ℓ, store_event_history=Val(false), event_history=nothing)\n\nFlips the edge between vertices i and j in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the edge to flip.\nj: The second vertex of the edge to flip.\nk: The vertex k = get_adjacent(tri, j, i). This is only used in the second method.\nℓ: The vertex ℓ = get_adjacent(tri, i, j). This is only used in the second method.\nstore_event_history=Val(false): Whether to store the event history of the flip. \nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object. This storage is done using store_flip_edge_history!.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\nwarning: Invalid flips\nIf (i, j, k, ℓ), where ℓ = get_adjacent(tri, i, j) and k = get_adjacent(tri, j, i), is not a convex quadrilateral, then this edge flip will make the triangulation non-planar.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.legalise_edge!","page":"Triangulation Operations","title":"DelaunayTriangulation.legalise_edge!","text":"legalise_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nLegalises the edge (i, j) and other neighbouring edges in tri if they are illegal, assuming the vertex r  was just added into a triangle that contains (i, j). flip_edge! is used.\n\nSee also is_legal.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the edge to legalise.\nj: The second vertex of the edge to legalise.\nr: The vertex that was just added into a triangle that contains (i, j).\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\nwarning: Invalid event histories\nEdge flipping can lead to event_history having triangles both in event_history.added_triangles and event_history.deleted_triangles. To get around this, we only store in these fields the triangles necessary to allow undo_insertion! to work, so that at a triangle that might have appeared in both will only appear in one.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.lock_convex_hull!","page":"Triangulation Operations","title":"DelaunayTriangulation.lock_convex_hull!","text":"lock_convex_hull!(tri::Triangulation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nLocks the convex hull of the unconstrained triangulation tri so that it is now treated as a constrained triangulation  with boundary given by its convex hull.\n\nThe random number generator (used inside add_segment! can be provided with the rng keyword argument, and similarly for predicates.\n\nwarning: Warning\nIf an edge is encountered along the convex hull that contains a segment from tri.interior_segments, then this edge will be deleted from tri.interior_segments; this will be undone from unlock_convex_hull!,  possibly splitting the segments in case they were split before unlocking.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.unlock_convex_hull!","page":"Triangulation Operations","title":"DelaunayTriangulation.unlock_convex_hull!","text":"unlock_convex_hull!(tri::Triangulation; reconstruct=false)\n\nUnlocks the convex hull of the constrained triangulation tri so that it is now treated as an unconstrained triangulation, assuming that it was locked using lock_convex_hull!. If reconstruct = true, then the  convex hull of tri will be reconstructed from the boundary nodes of tri. This is useful if, for example,  you have split some of the boundary edges during mesh refinement.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.split_edge!","page":"Triangulation Operations","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(tree::BoundaryRTree, i, j, r)\n\nSplits the diametral bounding box associated with (i, j) into two new boxes associated  with the diametral circles of (i, r) and (j, r).\n\n\n\n\n\nsplit_edge!(enricher::BoundaryEnricher, i, j, r, update_boundary_nodes = Val(true), update_segments = Val(true), is_interior = is_segment(enricher, i, j))\n\nUpdates the fields of enricher after splitting an edge (i, j) at the rth vertex. The update_boundary_nodes argument  can be used to avoid inserting an additional boundary node when boundary_nodes was already updated somewhere else (e.g., we need this for mesh refinement which already updates the boundary_nodes which is aliased with the same field in the enricher). The same  point goes for update_segments which can be used to avoid inserting an additional segment when segments was already updated somewhere else. The is_interior argument can be used to specify whether the edge is an interior segment or a boundary edge. \n\nSee also split_boundary_edge! and split_interior_segment!.\n\n\n\n\n\nsplit_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nSplits the edge (i, j) in tri at the vertex r. For the triangulation to be valid after this splitting, it is assumed that r is collinear with,  or at least very close to collinear with, the edge (i, j).\n\nSee also legalise_split_edge! and complete_split_edge_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.    \ni: The first vertex of the edge to split.\nj: The second vertex of the edge to split.\nr: The vertex to split the edge at.\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\nwarning: Handling unoriented edges\nThe triangulation will only be updated as if (i, j) has been split rather than also (j, i). You will need to call split_edge! again with (j, i) if you want to split that edge as well.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.complete_split_edge_and_legalise!","page":"Triangulation Operations","title":"DelaunayTriangulation.complete_split_edge_and_legalise!","text":"complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nGiven a triangulation tri, an edge (i, j), and a point r, splits both (i, j) and (j, i) at r using split_edge! and then subsequently legalises the new edges with legalise_split_edge!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the edge to split.\nj: The second vertex of the edge to split.\nr: The vertex to split the edge at.\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.split_triangle!","page":"Triangulation Operations","title":"DelaunayTriangulation.split_triangle!","text":"split_triangle!(tri::Triangulation, args::RefinementArguments, T) -> Certificate\n\nSplits a bad triangle T of tri to improve its quality.\n\nArguments\n\ntri::Triangulation: The Triangulation to split a triangle of.\nargs::RefinementArguments: The RefinementArguments for the refinement.\nT: The triangle to split.\n\nOutput\n\ncert: A Certificate indicating whether the split was successful or not. In particular, returns one of:\nCert.SuccessfulInsertion: The triangle was split successfully.\nCert.EncroachmentFailure: The triangle was not split successfully as the newly inserted point encroached upon a segment.\nCert.PrecisionFailure: The triangle was not split successfully due to precision issues.\n\n\n\n\n\nsplit_triangle!(tri::Triangulation, i, j, k, r)\n\nSplits the triangle (i, j, k) at the vertex r, assumed to be inside the triangle. \n\nSee also legalise_split_triangle! and complete_split_triangle_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the triangle.\nj: The second vertex of the triangle.\nk: The third vertex of the triangle.\nr: The vertex to split the triangle at.\n\nOutputs\n\nThere is no output, but tri will be updated so that it now contains the triangles (i, j, r), (j, k, r), and (k, i, r).\n\n\n\n\n\n","category":"function"},{"location":"api/operations/#DelaunayTriangulation.complete_split_triangle_and_legalise!","page":"Triangulation Operations","title":"DelaunayTriangulation.complete_split_triangle_and_legalise!","text":"complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)\n\nSplits the triangle (i, j, k) at the vertex r, assumed to be inside the triangle, and legalises the newly added edges in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the triangle.\nj: The second vertex of the triangle.\nk: The third vertex of the triangle.\nr: The vertex to split the triangle at.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"api/curves/#DelaunayTriangulation.AbstractParametricCurve","page":"Curves","title":"DelaunayTriangulation.AbstractParametricCurve","text":"abstract type AbstractParametricCurve <: Function end\n\nAbstract type for representing a parametric curve parametrised over 0 ≤ t ≤ 1. The curves represented by this  abstract type should not be self-intersecting, with the exception of allowing for closed curves.\n\nThe structs that subtype this abstract type must implement are:\n\ndifferentiate.\ntwice_differentiate.\nthrice_differentiate (only if you have not manually defined total_variation).\nThe struct must be callable so that c(t), where c an instance of the struct, returns the associated value of the curve at t.\nIf the struct does not implement point_position_relative_to_curve, then the struct must implement get_closest_point. Alternatively,  rather than implementing get_closest_point, the struct should have a lookup_table field as a Vector{NTuple{2,Float64}}, which returns values on the curve at a set of points,   where lookup_table[i] is the value of the curve at t = (i - 1) / (length(lookup_table) - 1).\n\nFunctions that are defined for all AbstractParametricCurve subtypes are:\n\narc_length\ncurvature\ntotal_variation\n\nnote: Efficiently computing the total variation\nThe curves in this package evaluate the total variation not by evaluating the integral itself, but by taking care of the changes in orientation in the curve to efficiently compute it. This is done by using the orientation markers of the curves, obtained using orientation_markers, that stored in the field  orientation_markers of these curves. The function marked_total_variation is then used to evaluate it. You may like to consider using these functions for  any curve you wish to implement yourself, using e.g. the BezierCurve struct's implementation as a reference.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.LineSegment","page":"Curves","title":"DelaunayTriangulation.LineSegment","text":"LineSegment <: AbstractParametricCurve\n\nCurve for representing a line segment, parametrised over 0 ≤ t ≤ 1. This curve can be using  line_segment(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\nfirst::NTuple{2,Float64}: The first point of the line segment.\nlast::NTuple{2,Float64}: The last point of the line segment.\nlength::Float64: The length of the line segment.\n\nConstructor\n\nYou can construct a LineSegment using \n\nLineSegment(first, last)\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.CircularArc","page":"Curves","title":"DelaunayTriangulation.CircularArc","text":"CircularArc <: AbstractParametricCurve\n\nCurve for representing a circular arc, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using circular_arc(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\ncenter::NTuple{2,Float64}: The center of the arc.\nradius::Float64: The radius of the arc.\nstart_angle::Float64: The angle of the initial point of the arc, in radians.\nsector_angle::Float64: The angle of the sector of the arc, in radians. This is given by end_angle - start_angle, where end_angle is the angle at last, and so might be negative for negatively oriented arcs.\nfirst::NTuple{2,Float64}: The first point of the arc.\nlast::NTuple{2,Float64}: The last point of the arc.\npqr::NTuple{3, NTuple{2, Float64}}: Three points on the circle through the arc. This is needed for point_position_relative_to_curve.\n\nwarning: Orientation\nThe angles start_angle and end_angle should be setup such that start_angle > end_angle implies a positively oriented arc,  and start_angle < end_angle implies a negatively oriented arc. Moreover, they must be in [0°, 2π°).\n\nConstructor\n\nYou can construct a CircularArc using \n\nCircularArc(first, last, center; positive=true)\n\nIt is up to you to ensure that first and last are equidistant from center - the radius used will be the  distance between center and first. The positive keyword argument is used to determine if the  arc is positively oriented or negatively oriented.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.EllipticalArc","page":"Curves","title":"DelaunayTriangulation.EllipticalArc","text":"EllipticalArc <: AbstractParametricCurve\n\nCurve for representing an elliptical arc, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated using elliptical_arc(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\ncenter::NTuple{2,Float64}: The center of the ellipse.\nhorz_radius::Float64: The horizontal radius of the ellipse. \nvert_radius::Float64: The vertical radius of the ellipse.\nrotation_scales::NTuple{2,Float64}: If θ is the angle of rotation of the ellipse, then this is (sin(θ), cos(θ)).\nstart_angle::Float64: The angle of the initial point of the arc measured from center, in radians. This angle is measured from the center prior to rotating the ellipse.\nsector_angle::Float64: The angle of the sector of the arc, in radians. This is given by end_angle - start_angle, where end_angle is the angle at last, and so might be negative for negatively oriented arcs.\nfirst::NTuple{2,Float64}: The first point of the arc.\nlast::NTuple{2,Float64}: The last point of the arc.\n\nConstructor\n\nYou can construct an EllipticalArc using \n\nEllipticalArc(first, last, center, major_radius, minor_radius, rotation; positive=true)\n\nwhere rotation is the angle of rotation of the ellipse, in degrees. The positive keyword argument is used to determine if the  arc is positively oriented or negatively oriented.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.BezierCurve","page":"Curves","title":"DelaunayTriangulation.BezierCurve","text":"BezierCurve <: AbstractParametricCurve\n\nCurve for representing a Bezier curve, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated using bezier_curve(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nA good reference on Bezier curves is this.\n\nSee also BSpline and CatmullRomSpline.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\ndanger: Interpolation\nRemember that Bezier curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. If you want an interpolation curve, use CatmullRomSpline.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the Bezier curve. The curve goes through the first and last control points, but not the intermediate ones.\ncache::Vector{NTuple{2,Float64}}: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Casteljau's algorithm. \nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the Bezier curve, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nwarning: Concurrency\nThe cache is not thread-safe, and so you should not evaluate this curve in parallel.\n\nConstructor\n\nYou can construct a BezierCurve using \n\nBezierCurve(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps=100 controls how many time points in [0, 1] are used for the lookup table. The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.BSpline","page":"Curves","title":"DelaunayTriangulation.BSpline","text":"BSpline <: AbstractParametricCurve\n\nCurve for representing a BSpline, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using b_spline(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nSee also BezierCurve and CatmullRomSpline.\n\nOur implementation of a BSpline is based on https://github.com/thibauts/b-spline.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\ndanger: Interpolation\nRemember that B-spline curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. For an interpolating spline, see CatmullRomSpline.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the BSpline. The curve goes through the first and last control points, but not the intermediate ones. \nknots::Vector{Int}: The knots of the BSpline. You should not modify or set this field directly (in particular, do not expect any support for non-uniform B-splines).\ncache::Vector{NTuple{2,Float64}}: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Boor's algorithm.\nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the B-spline curve, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nConstructor\n\nYou can construct a BSpline using \n\nBSpline(control_points::Vector{NTuple{2,Float64}}; degree=3, lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps is used to build the lookup table for the curve. Note that the default  degree=3 corresponds to a cubic B-spline curve. The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.CatmullRomSpline","page":"Curves","title":"DelaunayTriangulation.CatmullRomSpline","text":"CatmullRomSpline <: AbstractParametricCurve\n\nCurve for representing a Catmull-Rom spline, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using catmull_rom_spline(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFor information on these splines, see e.g. this article and this article. Additionally, this article lists some nice properties of these splines.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\nnote: Extension\nTypically, Catmull-Rom splines are defined on segments of four control points, and drawn between the two interior control points. This creates an issue in that the first and last control points will not be joined to the spline. To overcome this, we extend the spline to the left and right during the evaluation of a spline, using the fields left and right defined below. The rules used for extending these points come from CatmullRom.jl, which extrapolates based on a Thiele-like cubic polynomial.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the Catmull-Rom spline. The curve goes through each point.\nknots::Vector{Float64}: The parameter values of the Catmull-Rom spline. The ith entry of this vector corresponds to the t-value associated with the ith control point.   With an alpha parameter α, these values are given by knots[i+1] = knots[i] + dist(control_points[i], control_points[i+1])^α, where knots[1] = 0,   and the vector is the normalised by dividing by knots[end].\nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the Catmull-Rom spline, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\nalpha::Float64: The alpha parameter of the Catmull-Rom spline. This controls the type of the parametrisation, where alpha = 0 corresponds to uniform parametrisation,   alpha = 1/2 corresponds to centripetal parametrisation, and alpha = 1 corresponds to chordal parametrisation. Must be in [0, 1]. For reasons similar to what we describe for tension below, we only support    alpha = 1/2 for now. (If you do really want to change it, use the _alpha keyword argument in the constructor.)\ntension::Float64: The tension parameter of the Catmull-Rom spline. This controls the tightness of the spline, with tension = 0 being the least tight, and tension = 1 leading to straight lines between the control points. Must be in [0, 1].   You can not currently set this to anything except 0.0 due to numerical issues with boundary refinement. (For example, equivariation splits are not possible if tension=1 since   the curve is piecewise linear in that case, and for tension very close to 1, the equivariation split is not always between the provided times. If you really want to change it, then you   can use the _tension keyword argument in the constructor - but be warned that this may lead to numerical issues and potentially infinite loops.)\nleft::NTuple{2,Float64}: The left extension of the spline. This is used to evaluate the spline on the first segment.\nright::NTuple{2,Float64}: The right extension of the spline. This is used to evaluate the spline on the last segment.\nlengths::Vector{Float64}: The lengths of the individual segments of the spline.\nsegments::Vector{CatmullRomSplineSegment}: The individual segments of the spline.\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nConstructor\n\nTo construct a CatmullRomSpline, use \n\nCatmullRomSpline(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps is used to build the lookup table for the curve, with lookup_steps giving the number of time points in [0, 1] used for the lookup table.  The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"api/curves/#DelaunayTriangulation.arc_length","page":"Curves","title":"DelaunayTriangulation.arc_length","text":"arc_length(c::AbstractParametricCurve) -> Float64\narc_length(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns the arc length of the [AbstractParametricCurve] c. The second method returns the arc length in the interval [t₁, t₂], where 0 ≤ t₁ ≤ t₂ ≤ 1.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.differentiate","page":"Curves","title":"DelaunayTriangulation.differentiate","text":"differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.twice_differentiate","page":"Curves","title":"DelaunayTriangulation.twice_differentiate","text":"twice_differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the second derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.thrice_differentiate","page":"Curves","title":"DelaunayTriangulation.thrice_differentiate","text":"thrice_differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the third derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.curvature","page":"Curves","title":"DelaunayTriangulation.curvature","text":"curvature(c::AbstractParametricCurve, t) -> Float64\n\nReturns the curvature of the [AbstractParametricCurve] c at t.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.total_variation","page":"Curves","title":"DelaunayTriangulation.total_variation","text":"total_variation(c::AbstractParametricCurve) -> Float64\ntotal_variation(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns the total variation of a curve c, or the subcurve over [t₁, t₂] with 0 ≤ t₁ ≤ t₂ ≤ 1, defined as the integral of the absolute curvature over this interval. (This is also known as the total absolute curvature.)\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.point_position_relative_to_curve","page":"Curves","title":"DelaunayTriangulation.point_position_relative_to_curve","text":"point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] e::AbstractParametricCurve, p) -> Certificate\n\nReturns the position of the point p relative to the curve c. This function returns a [Certificate]:\n\nLeft: p is to the left of c.\nRight: p is to the right of c.\nOn: p is on c.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\npoint_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] L::LineSegment, p) -> Certificate\n\nReturns the position of p relative to L, returning a Certificate:\n\nLeft: p is to the left of L.\nRight: p is to the right of L.\nOn: p is on L.\n\nSee also point_position_relative_to_line.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\npoint_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] enricher::BoundaryEnricher, curve_index, p) -> Certificate\n\nReturns a Certificate which is \n\nLeft: If p is to the left of the curve_indexth curve.\nRight: If p is to the right of the curve_indexth curve.\nOn: If p is on the curve_indexth curve.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.get_closest_point","page":"Curves","title":"DelaunayTriangulation.get_closest_point","text":"get_closest_point(b::AbstractParametricCurve p) -> (Float64, NTuple{2,Float64})\n\nReturns the t-value and the associated point q on the curve b that is nearest to p using a binary search. The search is done until the  binary search interval is smaller than 1e-12. This function will only work if the curve b has a lookup table.\n\ndanger: Loops\nThis function is only tested on loop-free curves. It is not guaranteed to work on curves with loops. Moreover, for this function to be accurate,  you want the lookup table in b to be sufficiently dense.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.get_equidistant_split","page":"Curves","title":"DelaunayTriangulation.get_equidistant_split","text":"get_equidistant_split(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns a value of t such that the arc length along c from t₁ to t is equal to the arc length along c from t to t₂.  Uses the bisection method to compute the t-value.\n\n\n\n\n\nget_equidistant_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -> Float64\n\nReturns the equidistant split of the curve_indexth curve between t₁ and t₂.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.get_equivariation_split","page":"Curves","title":"DelaunayTriangulation.get_equivariation_split","text":"get_equivariation_split(c::AbstractParametricCurve, t₁, t₂) -> Float64, Float64\n\nReturns a value of t such that the total variation of c from t₁ to t is equal to the total variation of c from t to t₂. Uses the bisection method to compute the t-value. Also returns the new total variation of the two pieces.\n\n\n\n\n\nget_equivariation_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -> Float64, Float64\n\nReturns the equivariation split of the curve_indexth curve between t₁ and t₂. Also returns the total variation of the two pieces.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.get_inverse","page":"Curves","title":"DelaunayTriangulation.get_inverse","text":"get_inverse(c::AbstractParametricCurve, p) -> Float64\n\nGiven a point p on c, returns the t-value such that c(t) ≈ p.\n\n\n\n\n\nget_inverse(enricher::BoundaryEnricher, curve_index, q) -> Float64\n\nReturns the inverse of the curve_indexth curve at q.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.angle_between","page":"Curves","title":"DelaunayTriangulation.angle_between","text":"angle_between(c₁::AbstractParametricCurve, c₂::AbstractParametricCurve) -> Float64\n\nGiven two curves c₁ and c₂ such that c₁(1) == c₂(0), returns the angle between the two curves, treating the interior of the  curves as being left of both.\n\n\n\n\n\nangle_between(L₁::LineSegment, L₂::LineSegment) -> Float64\n\nReturns the angle between L₁ and L₂, assuming that L₁.last == L₂.first (this is not checked). For consistency with  If the segments are part of some domain, then the line segments should be oriented so that the interior is to the left of both segments.\n\n\n\n\n\nangle_between(enricher::BoundaryEnricher, curve_index1, curve_index2) -> Float64\n\nEvaluates angle_between on the curves with indices curve_index1 and curve_index2 in enricher.\n\n\n\n\n\nangle_between(p, q) -> Number\n\nReturns the angle between the vectors p and q in radians, treating q as the base. See this article. The returned angle is in [0, 2π).\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.get_circle_intersection","page":"Curves","title":"DelaunayTriangulation.get_circle_intersection","text":"get_circle_intersection(c::AbstractParametricCurve, t₁, t₂, r) -> (Float64, NTuple{2,Float64})\n\nGiven a circle centered at c(t₁) with radius r, finds the first intersection of the circle with  the curve after t₁ and less than t₂. It is assumed that such an intersection exists. The returned value  is (t, q), where t is the parameter value of the intersection and q is the point of intersection.\n\n\n\n\n\nget_circle_intersection(enricher::BoundaryEnricher, curve_index, t₁, t₂, r) -> (Float64, NTuple{2,Float64})\n\nFinds the intersection of the curve_indexth curve with the circle centered at the curve evaluated at t₁ with radius r. The argument  t₂ defines the end of the subcurve to consider. The returned tuple is (t, p) where t is the parameter value of the intersection and p is the point of intersection.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.orientation_markers","page":"Curves","title":"DelaunayTriangulation.orientation_markers","text":"orientation_markers(c::AbstractParametricCurve; steps=200, iters=50, tol=1e-5) -> Vector{Float64}\n\nFinds all orientation markers of the AbstractParametricCurve c. These are points t where any of the following  conditions hold (not necessarily simultaneously), letting c(t) = (x(t), y(t)):\n\nx'(t) = 0\ny'(t) = 0\nκ(t; x) = 0, where κ(t; x) is the curvature of the component function x(t)\nκ(t; y) = 0, where κ(t; y) is the curvature of the component function y(t)\nκ(t) = 0, where κ is the curvature of c(t)\n\nNote that the third and fourth conditions give all the inflection points of the component functions, and similarly for the fifth condition.\n\nSee also horizontal_turning_points, vertical_turning_points, horizontal_inflection_points, vertical_inflection_points, and inflection_points.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  inflection points.\n\nArguments\n\nc::AbstractParametricCurve: The AbstractParametricCurve.\n\nKeyword Arguments\n\nsteps=200: The number of equally spaced points to use for initialising Newton's method.\niters=50: How many iterations to use for Newton's method.\ntol=1e-5: The tolerance used for determining if two t-values are the same.\n\nOutput\n\nmarkers::Vector{Float64}: The t-values of the orientation markers of b. The returned vector is sorted, and also includes the   endpoints 0 and 1; any t-values outside of [0, 1] are discarded, and multiplicity   of any t is not considered (so the t-values in the returned vector are unique). These values can be used to split the curve into monotone pieces, meaning   the orientation is monotone. These markers also guarantee that, over any monotone piece, the orientation changes by an angle of at most π/2.\n\n\n\n\n\n","category":"function"},{"location":"api/curves/#DelaunayTriangulation.marked_total_variation","page":"Curves","title":"DelaunayTriangulation.marked_total_variation","text":"marked_total_variation(b::AbstractParametricCurve, t₁, t₂)\n\nReturns the total variation of the curve b over the interval [t₁, t₂] using the orientation markers of b.\n\n\n\n\n\n","category":"function"},{"location":"math/centroidal/#Centroidal-Voronoi-Tessellations","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"","category":"section"},{"location":"math/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"We now discuss centroidal Voronoi tessellations. These are tessellations in which the generator of each Voronoi polygon is given by the polygon's centroid. The algorithm we use for this is very simple. Suppose we have a point set mathcal P and we want to compute the centroidal Voronoi tessellation of mathcal P, denoted mathcal Cmathcal V(mathcal P). We do the following:","category":"page"},{"location":"math/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"Let mathcal P = mathcal P.\nCompute the clippped Voronoi tessellation tildemathcal V(mathcal P) = mathcal V(mathcal P) cap mathcal Cmathcal H(mathcal P).\nThen, until terminating, we:\nFor each generator v_i in mathcal P not on the boundary, move v_i to the centroid v_i of mathcal V_i(mathcal P).\nCompute delta = max_i p_i - p_i, i.e. the maximum displacement of a point.\nIf delta  varepsilon, terminate. Otherwise, set mathcal P = v_1 ldots v_n and go to step 2 after computing tildemathcal V(mathcal P) once again.. Here, varepsilon is some displacement tolerance. In this package, we default to varepsilon = 10^-4, where h is the maximum edge length of the bounding box box tildemathcal V(mathcal P).","category":"page"},{"location":"math/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"That is the entire description of the algorithm. We give an example of this below.","category":"page"},{"location":"math/centroidal/","page":"Centroidal Voronoi Tessellations","title":"Centroidal Voronoi Tessellations","text":"(Image: )","category":"page"},{"location":"math/delaunay/#Delaunay-Triangulations","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"","category":"section"},{"location":"math/delaunay/#Triangulations","page":"Delaunay Triangulations","title":"Triangulations","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"We start this section by introducing what Delaunay triangulations actually are. To precisely define a Delaunay triangulation first requires a few other definitions, so we will spare some of these exact details. Roughly speaking, a triangulation is a partition of a set of points mathcal P subseteq mathbb R^2 in the plane into non-overlapping triangles, such that the union of the triangles is the convex hull of the points and any two triangles intersect either at a common edge or not at all.[1] Here, a convex hull is the smallest convex set containing all the points. We will use mathcal T(mathcal P) to denote any triangulation of mathcal P, and mathcal Cmathcal H(mathcal P) to denote the convex hull of mathcal P. It is possible to show that any given mathcal P will have a triangulation.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"[1]: This is not the only possible definition of a triangulation. We could also define mathcal T(mathcal P) to be a maximal planar subdivision whose vertex set is mathcal P, where a maximal planar subdivision is a planar graph such that no edge can be added without intersecting other existing edges. With this definition though, there is some extra work to be done to show that the boundary of mathcal T(mathcal P) is indeed mathcal Cmathcal H(mathcal P). To see this, take some edge e_ij on the boundary mathcal T(mathcal P). To argue that e_ij is on the boundary of mathcal Cmathcal H(mathcal P), we argue by contradiction. Suppose that e_ij is not on the boundary of mathcal Cmathcal H(mathcal P). Then either e_ij is inside of mathcal Cmathcal H(mathcal P), or it is on the outside. It of course cannot be outside of mathcal Cmathcal H(mathcal P) since there would have to be some edge e_kl that is inside of mathcal Cmathcal H(mathcal P) that intersects e_ij, which is a contradiction to the maximal planarity. So, e_ij has to be inside. This implies that there is some space to the side of mathcal T(mathcal P) near e_ij that is not contained inside mathcal Cmathcal H(mathcal P), but this implies that there is a line segment that would have to go outside of the convex hull, which is a contradiction. Thus, e_ij must be on the boundary, and so each edge of mathcal T(mathcal P)'s boundary is on the boundary of mathcal Cmathcal H(mathcal P), meaning partialmathcal T(mathcal P) = mathcal Cmathcal H(mathcal P), where partialmathcal T(mathcal P) is the boundary of mathcal T(mathcal P).","category":"page"},{"location":"math/delaunay/#Delaunay-Property","page":"Delaunay Triangulations","title":"Delaunay Property","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"There are several ways to motivate the Delaunay property, but here we will just skip straight to the definition. We have two definitions to make first, relative to some point set mathcal P:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"A triangle T is said to be Delaunay if its open circumcircle contains no points of mathcal P in its interior. Note that this does not prohibit points from being on the boundary of the circumcircle.\nAn edge e is said to be Delaunay if its diametral circle contains no points of mathcal P in its interior. Here, the diametral circle of an edge e is the circle whose diameter is the edge e.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"With these definitions, we say that a triangulation mathcal T(mathcal P) is a Delaunay triangulation, and write mathcal Dmathcal T(mathcal P), if each triangle T in mathcal T(mathcal P) is Delaunay. Note that mathcal Dmathcal T(mathcal P) is not necessarily unique if there are cocircular vertices. If we adjust the above definitions to instead require that the closed circumcircles contain no points in mathcal P other than those from T, meaning T is strongly Delaunay, then the triangulation would instead be unique. It is possible to show the following fact, known as the Delaunay lemma: Given a triangulation mathcal T(mathcal P) of a point set, the following three statements are equivalent:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"We have mathcal T(mathcal P) = mathcal Dmathcal T(mathcal P).\nEvery edge in mathcal T is Delaunay.\nEvery edge in mathcal T is locally Delaunay. Here, locally Delaunay means that e is either (1) an edge of fewer than two triangles in mathcal T, or (2) an edge of exactly two triangles T_1 and T_2 and the open circumcircle of T_2 contains no vertex of T_1.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Below we show an example of Delaunay triangulation.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"We can see that the circumcircles of the triangles contain no points in their interior. This is a Delaunay triangulation.","category":"page"},{"location":"math/delaunay/#Bowyer-Watson-Algorithm","page":"Delaunay Triangulations","title":"Bowyer-Watson Algorithm","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Let us now discuss how we actually construct a Delaunay triangulation. The algorithm we use is the famous Bowyer-Watson algorithm, an incremental algorithm that builds the Delaunay triangulation one at a time. Suppose we have started with some initial triangulation mathcal Dmathcal T(mathcal P_0), where mathcal P_0 subseteq mathcal P, and we want to add in some point p, giving mathcal Dmathcal T(mathcal P_0 cup p). To do this, we:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Find one triangle whose open circumdisk contains p.\nFind all the other triangles by a depth-first search in the triangulation.\nDelete all the triangles containing p in their circumcircle, leaving behind a polyhedral cavity.\nFor each edge of this cavity, adjoin the vertices to p to create a new triangle.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"This procedure will give us mathcal Dmathcal T(mathcal P_0 cup p). Let's consider an example of this procedure. ","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"In the above figure, we are considering insertion the red point into the triangulation. We then then all triangles whose circumcircles contain this red point, shown in blue. Deleting these triangles leaves behind a cavity shown in the third figure. Finally, connecting the vertices of the cavity to the red point gives the final triangulation.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Of course, this procedure is hiding away many important details and leaves more questions than answers:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"How do we find a triangle containing the point in its circumdisk?\nHow do we perform a depth-first search to find all the triangles?\nHow do we determine if a point is inside a circumcircle?\nWhat happens if the point is outside of the triangulation?\nHow do we initialise the triangulation?","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Let's address all these questions.","category":"page"},{"location":"math/delaunay/#Point-Location","page":"Delaunay Triangulations","title":"Point Location","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"The problem of finding a triangle containing a point in its circumdisk is related to point location. Here, our point location problem is: Given a point p, find a triangle T in mathcal Dmathcal T(mathcal P) containing p; note that finding a triangle containing p will be the same as finding a triangle containing p in its circumdisk. We use a jump and march algorithm for this, following the work of Mücke et al. (1999). The basic idea is simple: To find a triangle T containing a point p, start from some point q and walk along the triangulation in the direction of the line qp until such a triangle is found. here is an example:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"The algorithm draws a line connecting some initial point q and the search point p, as shown in red, and then marches along triangles until p is found, traversing the blue triangles shown above. ","category":"page"},{"location":"math/delaunay/#Depth-First-Search","page":"Delaunay Triangulations","title":"Depth-First Search","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"We also need to discuss how a depth-first search is used to find all the triangles containing the point p in their circumcircles, using the triangle T found from point location for initialising the search. The idea is reasonably simple. Let's consider a single edge of T = T_ijk, say e_ij, assuming for now that e_ij is not a boundary edge so that there exists a triangle T_jiell that adjoins e_ij. If the circumcircle of T_jiell contains p, then in addition to deleting T_ijk from the triangulation we also know that T_jiell can be deleted. If instead T_jiell does not contain p in its circumcircle, we know that e_ij is an edge of the final cavity and we can thus add T_ijr to the triangulation, where r is the vertex associated with the point p. We apply this method of searching across edges to each other edge of T_ijk, and then to each edge of the triangles found in these searches, until all triangles containing p in their circumcircles are found.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"The problem of finding the vertex ell is also an important issue. To address this, we define a map mathcal A colon mathcal E to mathcal V, called the adjacent map, that takes an edge e_ij to a vertex ell such that T_ijell is a triangle in the triangulation. This map is used to find the vertex ell in the above search. We define mathcal A(e_ij) = emptyset if there is no such ell.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Let us now make this search algorithm more concrete. In code, omitting many details, we could implement this as ","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"function add_point!(pᵣ,  Tᵢⱼₖ)\n    delete_triangle!(Tᵢⱼₖ)\n    dig_cavity!(pᵣ, eᵢⱼ)\n    dig_cavity!(pᵣ, eⱼₖ)\n    dig_cavity!(pᵣ, eₖᵢ)\n    return\nend\nfunction dig_cavity!(pᵣ, eᵢⱼ)\n    ℓ = get_adjacent(eⱼᵢ)\n    x === ∅ && return # the triangle was already deleted \n    if in_circle(pᵣ, Tᵢⱼₗ) # Tᵢⱼₖ and Tⱼᵢₗ are not Delaunay \n        delete_triangle!(Tⱼᵢₗ)\n        dig_cavity!(pᵣ, eᵢₗ)\n        dig_cavity!(pᵣ, eₗⱼ)\n    else # eᵢⱼ is an edge of the polygonal cavity \n        add_triangle!(Tᵣᵢⱼ)\n    end \n    return\nend","category":"page"},{"location":"math/delaunay/#Incircle-Predicate","page":"Delaunay Triangulations","title":"Incircle Predicate","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"To determine if a point is inside a triangle's circumcircle, we need to use a predicate. The in_circle predicate is used for this. In particular:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"textin_circle(a b c d) = beginvmatrix a_x  a_y  a_x^2 + a_y^2  1  b_x  b_y  b_x^2 + b_y^2  1  c_x  c_y  c_x^2 + c_y^2  1  d_x  d_y  d_x^2 + d_y^2  1 endvmatrix ","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"can be used to determine the position of a point d relative to a triangle T_abc's circumcircle: If the determinant is positive, then d is inside the circumcircle; if it is negative, then d is outside the circumcircle; and if it is zero, then d is on the circumcircle. This predicate is used in the above search algorithm to determine if a point is inside a circumcircle. We use ExactPredicates.jl for this predicate.","category":"page"},{"location":"math/delaunay/#Exterior-Points","page":"Delaunay Triangulations","title":"Exterior Points","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"When a point is outside of the triangulation, notice that there will be no triangle containing p, and so our point location step will fail. To overcome this, we need what is known as a ghost vertex, which is a point out at infinity that all edges on the boundary share an edge with. In order for us to work with this, we need to understand how to treat the circumcircle of such a triangle with a point out at infinity, called a ghost vertex. Let g denote the ghost vertex, and let T_ijg be a ghost triangle. To get this triangle's circumcircle, imagine some point on the side of e_ij and dragging it slowly out to infinity. In the limit, the circle eventually becomes a straight line, and so the circumcircle of T_ijg should be considered as the oriented outer halfplane of e_ij: The union of the halfplane on the side of e_ij away from the triangulation's interior and the open edge e_ij. Using this definition, we can say that a ghost triangle T_ijg should be deleted if p falls in the oriented outer halfplane of e_ij. To determine this position, we can use the orient predicate, defined as:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"textorient(a b c) = beginvmatrix a_x  a_y  1  b_x  b_y  1  c_x  c_y  1 endvmatrix","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"which says that c is on the right of the line ab if the determinant is positive, on the left if it is negative, and on the line if it is zero. ","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Let us consider an example.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"In this example, we are interested in the ghost triangle associated with the blue edge. The oriented outer halfplane for this edge can be defined simply as H = (x y)  mathbb R^2  y  1  (x y)  mathbb R^2  0  x  1 y = 1. Using this definition, we see that the red point is not in H, the magenta point is in H (in fact, it is exactly on partial H, where partial H denotes the boundary of H), the black point is in H, and the green point is not in H.","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Now that we have a way of identifying when ghost triangles should be deleted, we need a way to uniquely associate an exterior point with a ghost triangle. To do this, we associate with the triangulation a central point, typically the centroid when the triangulation is constructed, that each ghost edge e_ig is oriented with. In particular, take some vertex v_i on the boundary of the triangulation so that e_ig is a ghost edge. We treat the ghost edge e_ig as a ray emnating from p_i out to infinity, oriented in the direction of the central point. Using this definition, we are able to split the region of space outside of the triangulation into a non-overlapping set of convex sets. Consider the example below:","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"The ghost edges are the blue lines, and the central point is the red dot. With this definition, we therefore see that we can uniquely each region in space with a triangle - be it a ghost triangle or a real (solid) triangle.","category":"page"},{"location":"math/delaunay/#Initialising-the-Triangulation","page":"Delaunay Triangulations","title":"Initialising the Triangulation","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"The initialisation of the triangulation is simple. We pick three points p_i, p_j, and p_k at random, ordering them so that they define a positively oriented triangle. We add T_ijk into the triangulation, initialise the adjacent map mathcal A, add the ghost triangles T_jig, T_kij, and T_kji, and initialise the central point as c = (p_i + p_j + p_k)  3.","category":"page"},{"location":"math/delaunay/#Putting-Everything-Together","page":"Delaunay Triangulations","title":"Putting Everything Together","text":"","category":"section"},{"location":"math/delaunay/","page":"Delaunay Triangulations","title":"Delaunay Triangulations","text":"Now having all these pieces of the algorithm together, the Bowyer-Watson algorithm can be implemented. The order of the points that we insert into the triangulation is random. Rather than rewrite the algorithm, we just note that the simple description we initially gave is still accurate, but of course the internal details have a lot of complications.","category":"page"},{"location":"api/overview/#Overview","page":"Section Overview","title":"Overview","text":"","category":"section"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"This section provides docstrings for all functions in the public API, split into sections. If you want a written description of some of the main features of this package, see the manual. We will describe the following:","category":"page"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"Data Structures: Some of the main data structures used in this package.\nTriangulations: Functions for creating and working with triangulations.\nTriangulation Operations: Functions for modifying triangulations.\nVoronoi Tessellations: Functions for creating and working with Voronoi tessellations.\nConvex Hull: Functions for creating convex hulls.\nCurves: Functions for defining curves for use with curve-bounded domains.\nIterators: Functions for iterating over triangulation and tessellation features.\nPoint Location: Functions for performing point location.\nPredicates: Functions for computing geometric predicates.\nTriangulation Statistics: Functions for computing statistics about triangulations.\nPrimitive Interfaces: Functions for defining primitive interfaces.\nOther: Other functions that don't fit into the above categories.","category":"page"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"We emphasise that a function having a docstring does NOT guarantee it being in the public API - only it being listed here will guarantee this.","category":"page"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"We also note that, for more structs such as Triangulation and VoronoiTessellations, their fields are not intended to be in the public API. Rather, their  associated accessor functions are intended to be used, e.g. prefer get_X(tri) instead of tri.X for tri::Triangulation.","category":"page"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"Each section will first start with the list of all functions to be listed, and then the docstrings of those functions will be given. There will be some docstrings that fit into multiple categories, in which case one is chosen. Here is an index of all the functions listed in the above pages.","category":"page"},{"location":"api/overview/","page":"Section Overview","title":"Section Overview","text":"Pages = [\"convex_hull.md\", \"curves.md\", \"data_structures.md\", \"iterators.md\", \"operations.md\", \"other.md\", \"point_location.md\", \"predicates.md\", \"primitives.md\", \"statistics.md\", \"triangulation.md\", \"voronoi.md\"]","category":"page"},{"location":"applications/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"For our first application, we consider applying Voronoi tessellations to interpolation. The discussion here is based on the implementation of what is known as natural neighbour interpolation in NaturalNeighbours.jl. NaturalNeighbours.jl considers a diverse set of interpolants for this purpose, but here we will focus only on a single interpolant (called the Sibson() interpolant in NaturalNeighbours.jl).","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"The problem we are considering is as follows: Given some data mathcal D = (vb x_i z_i)_i=1^m subseteq mathbb R^2 times mathbb R, we want to construct a smooth interpolant f colon mathcal Cmathcal H(X) to mathbb R of the data, where X = vb x_1 ldots vb x_m, such that f(vb x_i) = z_i for all i = 1 ldots m.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"One idea to interpolate this data would be to use a piecewise linear interpolant, obtained by defining, inside each triangle T in mathcal Dmathcal T(X), a piecewise linear interpolant using the data points at each of the three vertices. One problem with this is that mathcal Dmathcal T(X) does not depend continuously on X, meaning that small perturbations of a data point can lead to topological changes in the triangulation. One way around this is to instead use the Voronoi tessellation to guide the tessellation, since mathcal V(X) does depend continuously on X. We give an example of this below, where we show how mathcal Dmathcal T(X) may change significant after a small perturbation while mathcal V(X) does not at the same time.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"using DelaunayTriangulation #hide\nusing CairoMakie #hide\nA, B, C, D, E, F, G, H = (0.3, 1.1), (-0.1, 0.8), (0.2, 0.3), (0.6, 0.2), (0.8, 0.8), (0.3, 0.9), (0.5503600264347, 0.6814266789918), (1.1, 0.5) #hide\nG2 = (0.5496217775447, 0.7146478790414) #hide\nfig = Figure() #hide\nax = Axis(fig[1, 1], width = 400, height = 400, title = \"Original\") #hide\nxlims!(ax, -0.2, 1.3) #hide\nylims!(ax, 0.1, 1.2) #hide\npoints = [A, B, C, D, E, F, G, H] #hide\ntriplot!(ax, points, show_points = true) #hide\nscatter!(ax, [G], color = :red, markersize = 14) #hide\nhidedecorations!(ax) #hide\nax2 = Axis(fig[2, 1], width = 400, height = 400) #hide\nvoronoiplot!(ax2, points, clip = (-0.2, 1.3, 0.1, 1.2)) #hide\nxlims!(ax2, -0.2, 1.3) #hide\nylims!(ax2, 0.1, 1.2) #hide\nscatter!(ax2, [G], color = :red, markersize = 14) #hide\nhidedecorations!(ax2) #hide\nax3 = Axis(fig[1, 2], width = 400, height = 400, title = \"Perturbed\") #hide\npoints = [A, B, C, D, E, F, G2, H] #hide\ntriplot!(ax3, points, show_points = true) #hide\nhidedecorations!(ax3) #hide\nxlims!(ax3, -0.2, 1.3) #hide\nylims!(ax3, 0.1, 1.2) #hide\nscatter!(ax3, [G2], color = :red, markersize = 14) #hide\nax4 = Axis(fig[2, 2], width = 400, height = 400) #hide\nvoronoiplot!(ax4, points, clip = (-0.2, 1.3, 0.1, 1.2)) #hide\nscatter!(ax4, [G2], color = :red, markersize = 14) #hide\nxlims!(ax4, -0.2, 1.3) #hide\nylims!(ax4, 0.1, 1.2) #hide\nhidedecorations!(ax4) #hide\nresize_to_layout!(fig) #hide\nfig #hide","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"This observation motivates the use of the Voronoi tessellation to guide the interpolation.","category":"page"},{"location":"applications/interpolation/#Natural-Neighbours","page":"Interpolation","title":"Natural Neighbours","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Let us start by defining natural neighbours. Consider two Voronoi polygons mathcal V_i and mathcal V_j, and let mathcal F_ij = mathcal V_i cap mathcal V_j. If mathcal F_ij neq emptyset, we say that vb x_i and vb x_j are natural neighbours in X. For a point vb  in X, we denote its set of natural neighbours by N(vb x) subseteq X, and the corresponding indices by N_i = j  vb x_j in N(vb x_i).","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"We use natural neighbours to guide our representation of points. In particular, we use natural neighbour coordinates, which are defined as follows: For a point vb x in X, a vector boldsymbollambda are called a set of natural neighbour coordinates if lambda_i geq 0 for each i, boldsymbollambda is continuous with respect to vb x, and lambda_i  0 iff vb x_i in N(vb x).","category":"page"},{"location":"applications/interpolation/#Sibsonian-Interpolation","page":"Interpolation","title":"Sibsonian Interpolation","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Here, for boldsymbollambda we will discuss Sibsonian coordinates. To define these coordinates, take mathcal V(X) and consider what happens when a new point vb x_0 is added into it. This new point creates a new tessellation mathcal V(X cup vb x_0), where all the tiles that change in the new tessellation compared to mathcal V(vb X) are those in N(vb x_0). We let A(vb x_0) be the area of the new tile created by vb x_0, and let A(vb x_i) be the area of the intersection between the original tile for vb x_i and the new tile from vb x_0. The Sibson coordinates are then","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"lambda_i(vb x_0) = fracA(vb x_i)A(vb x_0)","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Using this definition of Sibsonian coordinates, the Sibson interpolant is defined by","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"f(vb x_0) = sum_i in N_0 lambda_i(vb x_0)z_i","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"This interpolant is C^1 continuous in mathcal Cmathcal H(X) setminus X, with derivative discontinuities at the data sites.","category":"page"},{"location":"applications/interpolation/#Implementation","page":"Interpolation","title":"Implementation","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Let us now implement the Sibson interpolant. We note that, in this implementation, we ignore some edge cases; these are handled properly in the implementation in NaturalNeighbours.jl. Moreover, our implementation will not be the most efficient, but will be enough for the purposes of this demonstration. We assume that all points are contained in the interior of mathcal Cmathcal H(X).","category":"page"},{"location":"applications/interpolation/#Bowyer-Watson-envelope","page":"Interpolation","title":"Bowyer-Watson envelope","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"The first issue to deal with in our implementation is the computation of the Bowyer-Watson envelope. For a point vb x, its Bowyer-Watson envelope is the boundary of the set of all triangles in mathcal Dmathcal T(X) whose circumcircles contain vb x. This envelope tells us the region in which any changes to the triangulation and to the tessellation can occur. A reasonably straight forward way to implement this is to simply add vb x into mathcal Dmathcal T(X) and take all the triangles containing vb x as a vertex in mathcal Dmathcal T(X cup vb x). We then remove vb x from mathcal Dmathcal T(X cup vb x). We implement this below.[1]","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"[1]: This is more expensive than we need. In NaturalNeighbours.jl, we use the peek keyword in triangulate to avoid making any changes to the triangulation itself, and use the InsertionEventHistory to track all changes made.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"using DelaunayTriangulation\nfunction compute_envelope(tri::Triangulation, point)\n    r = DelaunayTriangulation.num_points(tri)\n    x, y = getxy(point)\n    add_point!(tri, x, y)\n    envelope_vertices = DelaunayTriangulation.get_surrounding_polygon(tri, r + 1)\n    push!(envelope_vertices, envelope_vertices[begin])\n    envelope_points = [get_point(tri, i) for i in envelope_vertices]\n    delete_point!(tri, r + 1)\n    DelaunayTriangulation.pop_point!(tri)\n    return envelope_vertices, envelope_points\nend","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Let's now check that this function works.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"using CairoMakie\nusing StableRNGs\nusing ElasticArrays\nrng = StableRNG(999)\npoints = ElasticMatrix(randn(rng, 2, 50)) # so that the points are mutable\ntri = triangulate(points; rng)\nenvelope_vertices, envelope_points = compute_envelope(tri, (0.5, 0.5))\n\nfig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], width = 400, height = 400)\ntriplot!(ax, tri, show_points = true)\nax2 = Axis(fig[1, 2], width = 400, height = 400)\nadd_point!(tri, 0.5, 0.5)\ntriplot!(ax2, tri, show_points = true)\npoly!(ax2, envelope_points, color = (:red, 0.2))\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"As we can see, the red region we have computed from our envelope is indeed the envelope we need.","category":"page"},{"location":"applications/interpolation/#Computing-the-Sibsonian-coordinates","page":"Interpolation","title":"Computing the Sibsonian coordinates","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"When we are interpolating at a point vb x, remember that we need to know the area of the Voronoi polygon that would be produced when vb x is inserted into mathcal V(X). To compute this area, we need to know how we can compute it using the Bowyer-Watson envelope. Remember that the Voronoi polygons are obtained by drawing lines between the circumcenters of neighbouring triangles. This can be done using the Bowyer-Watson envelope: The edges of the envelope, together with the new point, define the triangles that would be produced if it were to be added into the triangulation, and so we can join the circumcenters of these triangles to compute the new Voronoi polygon. We can then use this polygon, together with the original tessellation, to compute the Sibsonian coordinates.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Let us first discuss the area of the Voronoi polygons in N(vb x) (vb x's natural neighbours, i.e. the vertices of the envelope) before vb x is inserted. We only need to compute the part of the area that is contained within the envelope, since everything outside of that envelope is unchanged. If we included the entire area, then the area that we subtract off for the intersection we compute later would just cancel it out anyway. Let's zoom in on the envelope and consider a specific example of how we can do this computation.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"fig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], width = 400, height = 400)\ntriplot!(ax, tri, show_points = true)\nlines!(ax, envelope_points, color = :red)\nj = 7 # example vertex\nv = envelope_vertices[j]\nscatter!(ax, [get_point(tri, v)], color = :blue)\nfirst_neighbour = envelope_vertices[j - 1]\nnext_triangle = get_adjacent(tri, first_neighbour, v)\nnext_triangle_2 = get_adjacent(tri, v, envelope_vertices[j + 1])\nlast_neighbour = envelope_vertices[j + 1]\npolygon_points = [\n    get_point(tri, v),\n    (get_point(tri, v) .+ get_point(tri, last_neighbour)) ./ 2,\n    DelaunayTriangulation.triangle_circumcenter(tri, (v, envelope_vertices[j + 1], next_triangle_2)),\n    DelaunayTriangulation.triangle_circumcenter(tri, (first_neighbour, v, next_triangle)),\n    (get_point(tri, v) .+ get_point(tri, first_neighbour)) ./ 2,\n]\npoly!(ax, polygon_points, color = (:blue, 0.5), strokecolor = :blue, strokewidth = 2)\nxlims!(ax, -0.5, 1.4)\nylims!(ax, -0.15, 1.4)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"The relevant polygon is shown above in blue, associated with the generator shown by the blue point. We need to compute the area of this polygon. This is simple using the shoelace formula. Our implementation of this is given below.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"function polygon_area(points) # this is the first formula in the \"Other formulae\" section of the above Wikipedia article\n    n = DelaunayTriangulation.num_points(points)\n    p, q, r, s = get_point(points, 1, 2, n, n - 1)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    sx, sy = getxy(s)\n    area = px * (qy - ry) + rx * (py - sy)\n    for i in 2:(n - 1)\n        p, q, r = get_point(points, i, i + 1, i - 1)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        rx, ry = getxy(r)\n        area += px * (qy - ry)\n    end\n    return area / 2\nend\nfunction pre_insertion_area(tri::Triangulation, i, envelope_vertices) # area from the envelope[i]th generator\n    poly_points = NTuple{2, Float64}[]\n    u = envelope_vertices[i]\n    prev_index = i == 1 ? length(envelope_vertices) - 1 : i - 1\n    next_index = i == length(envelope_vertices) ? 1 : i + 1\n    first_neighbour = envelope_vertices[prev_index]\n    last_neighbour = envelope_vertices[next_index]\n    v = last_neighbour\n    (ux, uy), (vx, vy) = get_point(tri, u, v)\n    mx1, my1 = (ux + vx) / 2, (uy + vy) / 2\n    push!(poly_points, (mx1, my1))\n    while v ≠ first_neighbour\n        w = get_adjacent(tri, u, v)\n        cx, cy = DelaunayTriangulation.triangle_circumcenter(tri, (u, v, w))\n        push!(poly_points, (cx, cy))\n        v = w\n    end\n    vx, vy = get_point(tri, v)\n    mx, my = (ux + vx) / 2, (uy + vy) / 2\n    push!(poly_points, (mx, my), (mx1, my1))\n    return polygon_area(poly_points)\nend","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"The details for the post-insertion area are similar, but now the triangles that we take the circumcenters of are those where the edges instead join with the inserted vertex. The function we use is below.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"function post_insertion_area(tri::Triangulation, i, envelope_vertices, point)\n    u = envelope_vertices[i]\n    prev_index = i == 1 ? length(envelope_vertices) - 1 : i - 1\n    next_index = i == length(envelope_vertices) ? 1 : i + 1\n    first_neighbour = envelope_vertices[prev_index]\n    last_neighbour = envelope_vertices[next_index]\n    p, q, r = get_point(tri, u, first_neighbour, last_neighbour)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    mpq = (px + qx) / 2, (py + qy) / 2\n    mpr = (px + rx) / 2, (py + ry) / 2\n    g1 = DelaunayTriangulation.triangle_circumcenter(p, r, point)\n    !all(isfinite, g1) && return NaN # point is one of p and r, i.e. we are interpolating at a data site\n    g2 = DelaunayTriangulation.triangle_circumcenter(q, p, point)\n    !all(isfinite, g2) && return NaN\n    points = (mpq, mpr, g1, g2, mpq)\n    return polygon_area(points)\nend","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Now that we can compute the pre- and post-insertion areas, we can start computing the Sibsonian coordinates.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"function compute_sibson_coordinates(tri::Triangulation, envelope_vertices, point)\n    coordinates = zeros(length(envelope_vertices) - 1)\n    w = 0.0\n    for i in firstindex(envelope_vertices):(lastindex(envelope_vertices) - 1)\n        pre = max(0.0, pre_insertion_area(tri, i, envelope_vertices))\n        post = max(0.0, post_insertion_area(tri, i, envelope_vertices, point))\n        if isnan(post) # need to return the the vector λ = [1] since we are exactly at a data site\n            return [1.0]\n        end\n        coordinates[i] = max(pre - post, 0.0) # take care of any precision issues\n        w += coordinates[i]\n    end\n    coordinates ./= w\n    return coordinates\nend","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"This function gives our boldsymbollambda vector. Notice that, in the computation of these coordinates, we need needed to have mathcal V(X) directly or make use of the data z_i.","category":"page"},{"location":"applications/interpolation/#Evaluating-the-Sibsonian-interpolant","page":"Interpolation","title":"Evaluating the Sibsonian interpolant","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Now we can evaluate our Sibson interpolant. The following function does this for us.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"function evaluate_sibson_interpolant(tri::Triangulation, z, point)\n    envelope_vertices, _ = compute_envelope(tri, point)\n    λ = compute_sibson_coordinates(tri, envelope_vertices, point)\n    if length(λ) == 1\n        for i in each_solid_vertex(tri)\n            get_point(tri, i) == point && return z[i]\n        end\n    else\n        itp = 0.0\n        for (λ, k) in zip(λ, envelope_vertices)\n            itp += λ * z[k]\n        end\n        return itp\n    end\nend","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Let's now use this function to interpolate some data.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"f = (x, y) -> sin(x * y) - cos(x - y) * exp(-(x - y)^2)\ntrit = triangulate_rectangle(0.0, 1.0, 0.0, 1.0, 30, 30)\nzz = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(trit)]\nxx = LinRange(0.001, 0.999, 20) # handling points on the boundary requires more care than we have discussed here\nyy = LinRange(0.001, 0.999, 20)\nfig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], xlabel = L\"x\", ylabel = L\"y\", title = \"True function\", titlealign = :left, width = 400, height = 400)\ncontourf!(ax, xx, yy, f.(xx, yy'))\nax2 = Axis(fig[1, 2], xlabel = L\"x\", ylabel = L\"y\", title = \"Interpolant\", titlealign = :left, width = 400, height = 400)\nzi = [evaluate_sibson_interpolant(trit, zz, (xᵢ, yᵢ)) for xᵢ in xx, yᵢ in yy]\ncontourf!(ax2, xx, yy, zi)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"Works perfectly!","category":"page"},{"location":"applications/interpolation/#Just-the-code","page":"Interpolation","title":"Just the code","text":"","category":"section"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"using DelaunayTriangulation\nfunction compute_envelope(tri::Triangulation, point)\n    r = DelaunayTriangulation.num_points(tri)\n    x, y = getxy(point)\n    add_point!(tri, x, y)\n    envelope_vertices = DelaunayTriangulation.get_surrounding_polygon(tri, r + 1)\n    push!(envelope_vertices, envelope_vertices[begin])\n    envelope_points = [get_point(tri, i) for i in envelope_vertices]\n    delete_point!(tri, r + 1)\n    DelaunayTriangulation.pop_point!(tri)\n    return envelope_vertices, envelope_points\nend\n\nusing CairoMakie\nusing StableRNGs\nusing ElasticArrays\nrng = StableRNG(999)\npoints = ElasticMatrix(randn(rng, 2, 50)) # so that the points are mutable\ntri = triangulate(points; rng)\nenvelope_vertices, envelope_points = compute_envelope(tri, (0.5, 0.5))\n\nfig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], width = 400, height = 400)\ntriplot!(ax, tri, show_points = true)\nax2 = Axis(fig[1, 2], width = 400, height = 400)\nadd_point!(tri, 0.5, 0.5)\ntriplot!(ax2, tri, show_points = true)\npoly!(ax2, envelope_points, color = (:red, 0.2))\nresize_to_layout!(fig)\nfig\n\nfig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], width = 400, height = 400)\ntriplot!(ax, tri, show_points = true)\nlines!(ax, envelope_points, color = :red)\nj = 7 # example vertex\nv = envelope_vertices[j]\nscatter!(ax, [get_point(tri, v)], color = :blue)\nfirst_neighbour = envelope_vertices[j - 1]\nnext_triangle = get_adjacent(tri, first_neighbour, v)\nnext_triangle_2 = get_adjacent(tri, v, envelope_vertices[j + 1])\nlast_neighbour = envelope_vertices[j + 1]\npolygon_points = [\n    get_point(tri, v),\n    (get_point(tri, v) .+ get_point(tri, last_neighbour)) ./ 2,\n    DelaunayTriangulation.triangle_circumcenter(tri, (v, envelope_vertices[j + 1], next_triangle_2)),\n    DelaunayTriangulation.triangle_circumcenter(tri, (first_neighbour, v, next_triangle)),\n    (get_point(tri, v) .+ get_point(tri, first_neighbour)) ./ 2,\n]\npoly!(ax, polygon_points, color = (:blue, 0.5), strokecolor = :blue, strokewidth = 2)\nxlims!(ax, -0.5, 1.4)\nylims!(ax, -0.15, 1.4)\nresize_to_layout!(fig)\nfig\n\nfunction polygon_area(points) # this is the first formula in the \"Other formulae\" section of the above Wikipedia article\n    n = DelaunayTriangulation.num_points(points)\n    p, q, r, s = get_point(points, 1, 2, n, n - 1)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    sx, sy = getxy(s)\n    area = px * (qy - ry) + rx * (py - sy)\n    for i in 2:(n - 1)\n        p, q, r = get_point(points, i, i + 1, i - 1)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        rx, ry = getxy(r)\n        area += px * (qy - ry)\n    end\n    return area / 2\nend\nfunction pre_insertion_area(tri::Triangulation, i, envelope_vertices) # area from the envelope[i]th generator\n    poly_points = NTuple{2, Float64}[]\n    u = envelope_vertices[i]\n    prev_index = i == 1 ? length(envelope_vertices) - 1 : i - 1\n    next_index = i == length(envelope_vertices) ? 1 : i + 1\n    first_neighbour = envelope_vertices[prev_index]\n    last_neighbour = envelope_vertices[next_index]\n    v = last_neighbour\n    (ux, uy), (vx, vy) = get_point(tri, u, v)\n    mx1, my1 = (ux + vx) / 2, (uy + vy) / 2\n    push!(poly_points, (mx1, my1))\n    while v ≠ first_neighbour\n        w = get_adjacent(tri, u, v)\n        cx, cy = DelaunayTriangulation.triangle_circumcenter(tri, (u, v, w))\n        push!(poly_points, (cx, cy))\n        v = w\n    end\n    vx, vy = get_point(tri, v)\n    mx, my = (ux + vx) / 2, (uy + vy) / 2\n    push!(poly_points, (mx, my), (mx1, my1))\n    return polygon_area(poly_points)\nend\n\nfunction post_insertion_area(tri::Triangulation, i, envelope_vertices, point)\n    u = envelope_vertices[i]\n    prev_index = i == 1 ? length(envelope_vertices) - 1 : i - 1\n    next_index = i == length(envelope_vertices) ? 1 : i + 1\n    first_neighbour = envelope_vertices[prev_index]\n    last_neighbour = envelope_vertices[next_index]\n    p, q, r = get_point(tri, u, first_neighbour, last_neighbour)\n    px, py = getxy(p)\n    qx, qy = getxy(q)\n    rx, ry = getxy(r)\n    mpq = (px + qx) / 2, (py + qy) / 2\n    mpr = (px + rx) / 2, (py + ry) / 2\n    g1 = DelaunayTriangulation.triangle_circumcenter(p, r, point)\n    !all(isfinite, g1) && return NaN # point is one of p and r, i.e. we are interpolating at a data site\n    g2 = DelaunayTriangulation.triangle_circumcenter(q, p, point)\n    !all(isfinite, g2) && return NaN\n    points = (mpq, mpr, g1, g2, mpq)\n    return polygon_area(points)\nend\n\nfunction compute_sibson_coordinates(tri::Triangulation, envelope_vertices, point)\n    coordinates = zeros(length(envelope_vertices) - 1)\n    w = 0.0\n    for i in firstindex(envelope_vertices):(lastindex(envelope_vertices) - 1)\n        pre = max(0.0, pre_insertion_area(tri, i, envelope_vertices))\n        post = max(0.0, post_insertion_area(tri, i, envelope_vertices, point))\n        if isnan(post) # need to return the the vector λ = [1] since we are exactly at a data site\n            return [1.0]\n        end\n        coordinates[i] = max(pre - post, 0.0) # take care of any precision issues\n        w += coordinates[i]\n    end\n    coordinates ./= w\n    return coordinates\nend\n\nfunction evaluate_sibson_interpolant(tri::Triangulation, z, point)\n    envelope_vertices, _ = compute_envelope(tri, point)\n    λ = compute_sibson_coordinates(tri, envelope_vertices, point)\n    if length(λ) == 1\n        for i in each_solid_vertex(tri)\n            get_point(tri, i) == point && return z[i]\n        end\n    else\n        itp = 0.0\n        for (λ, k) in zip(λ, envelope_vertices)\n            itp += λ * z[k]\n        end\n        return itp\n    end\nend\n\nf = (x, y) -> sin(x * y) - cos(x - y) * exp(-(x - y)^2)\ntrit = triangulate_rectangle(0.0, 1.0, 0.0, 1.0, 30, 30)\nzz = [f(x, y) for (x, y) in DelaunayTriangulation.each_point(trit)]\nxx = LinRange(0.001, 0.999, 20) # handling points on the boundary requires more care than we have discussed here\nyy = LinRange(0.001, 0.999, 20)\nfig = Figure(fontsize = 24)\nax = Axis(fig[1, 1], xlabel = L\"x\", ylabel = L\"y\", title = \"True function\", titlealign = :left, width = 400, height = 400)\ncontourf!(ax, xx, yy, f.(xx, yy'))\nax2 = Axis(fig[1, 2], xlabel = L\"x\", ylabel = L\"y\", title = \"Interpolant\", titlealign = :left, width = 400, height = 400)\nzi = [evaluate_sibson_interpolant(trit, zz, (xᵢ, yᵢ)) for xᵢ in xx, yᵢ in yy]\ncontourf!(ax2, xx, yy, zi)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"","category":"page"},{"location":"applications/interpolation/","page":"Interpolation","title":"Interpolation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/constrained_multipolygon/#Constrained-Triangulation","page":"Disjoint Domains","title":"Constrained Triangulation","text":"","category":"section"},{"location":"tutorials/constrained_multipolygon/#Disjoint-Domains","page":"Disjoint Domains","title":"Disjoint Domains","text":"","category":"section"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"Now we consider an example where we are triangulating disjoint domains. The way to setup these domains is similar to the previous tutorials, with the outer boundaries being counter-clockwise, and all the interior boundaries clockwise (and other interiors inside interiors counter-clockwise, etc., if you please). Here is a simple example.","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"using DelaunayTriangulation\nusing CairoMakie\n\nθ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2, Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    global cx\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\ntri = triangulate(points; boundary_nodes = boundary_nodes)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"Here is another example.","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"C = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [\n    [\n        K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n        O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n        H5, I5, J5, K5,\n    ],\n]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\ntri = triangulate(points; boundary_nodes = nodes)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/constrained_multipolygon/#Just-the-code","page":"Disjoint Domains","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"using DelaunayTriangulation\nusing CairoMakie\n\nθ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2, Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    global cx\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\ntri = triangulate(points; boundary_nodes = boundary_nodes)\nfig, ax, sc = triplot(tri)\nfig\n\nC = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [\n    [\n        K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n        O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n        H5, I5, J5, K5,\n    ],\n]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\ntri = triangulate(points; boundary_nodes = nodes)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"","category":"page"},{"location":"tutorials/constrained_multipolygon/","page":"Disjoint Domains","title":"Disjoint Domains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/operations_split_triangle/#Triangulation-Operations","page":"Triangle Splitting","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_split_triangle/#Triangle-Splitting","page":"Triangle Splitting","title":"Triangle Splitting","text":"","category":"section"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"As we briefly discussed in the legalise_edge! tutorial, it is sometimes useful to put a point inside of an existing triangle, and then to connect all the vertices of that triangle to that new point, thereby splitting that triangle into three new triangles. This is called triangle splitting.","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"Let us give an example.","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)]\np = (0.2, 0.5)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"The blue point shows the point we want to add into the triangulation using split_triangle!. To use this, we provide (1) the index of the point in points and (2) the triangle that the point is in. The index of the point will be 4 after pushing p into points, and in this simple example the triangle that p is in is (1, 2, 3).","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"push!(points, p)\nr = length(points)\ni, j, k = 1, 2, 3\nsplit_triangle!(tri, i, j, k, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"See the legalise_edge! tutorial for more discussion about restoring the Delaunay property of the triangulation after using split_triangle!.","category":"page"},{"location":"tutorials/operations_split_triangle/#Just-the-code","page":"Triangle Splitting","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)]\np = (0.2, 0.5)\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nscatter!(ax, [p], markersize = 14)\nfig\n\npush!(points, p)\nr = length(points)\ni, j, k = 1, 2, 3\nsplit_triangle!(tri, i, j, k, r)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"","category":"page"},{"location":"tutorials/operations_split_triangle/","page":"Triangle Splitting","title":"Triangle Splitting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation for DelaunayTriangulation.jl. Click here to go back to the GitHub repository.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a package for computing Delaunay triangulations and Voronoi tessellations of points in two dimensions, amongst many other features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Unconstrained and constrained Delaunay triangulations, supporting many types of domains.\nWeighted Delaunay triangulations.\nComputation of Voronoi tessellations, clipped Voronoi tessellations where the Voronoi tiles get clipped to a convex polygon, and centroidal Voronoi tessellations where each Voronoi tile's generator is the tile's centroid.\nPower diagrams.\nMesh refinement, with support for custom angle and area constraints, as well as refinement of curve-bounded domains.\nDynamic point insertion, point deletion, and segment insertion, amongst many other operations.\nComputation of convex hulls.\nTriangulation of convex polygons.\nPoint location.\nComputation of the pole of inaccessibility.\nThe interface for defining geometric primitives is fully customisable.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To ensure that the algorithms are robust, by default we make use of AdaptivePredicates.jl to use  adaptive arithmetic for all geometric predicates in this package. This choice can be configured, allowing for the additional choices of ExactPredicates.jl or no adaptive or exact arithmetic at all; see here. Much of the work in this package is derived from the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you would like to make an issue or contribute, please see the CONTRIBUTION.md file in the repository. For feature requests, please see the discussions tab.","category":"page"},{"location":"#Documentation-Structure","page":"Introduction","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation for this package is broken into several sections.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials: These are examples that introduce the functionality of the package, demonstrating how to perform many operations. \nManual: Some particular descriptions of how certain things work in the package, such as representing boundaries and working with the triangulation and tessellation data structures. \nAPI Reference: This section lists docstrings for all functions in the public API.\nExtended Reference: This section is for providing more details about the internals of the package, meaning not in the public API.The material in this section is subject to change across any version, but may be useful for you to understand how certain functions work. For example, all utility functions are documented here.\nMathematical Details: This section is for describing in detail the mathematics that underpins the algorithms in this package, for example walking you through the theory behind the algorithm for computing constrained Delaunay triangulations. \nExample Applications: In case you want to use this package for some of your applications, it might be useful to see how it has been applied in certain situations. Only a few applications are considered here, but more could be added in the future.\nTerminology: This section provides a short description of some of the terminology used throughout the package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you would also like to see how DelaunayTriangulation.jl is used in other packages, see FiniteVolumeMethod.jl (solving 2D PDEs) and NaturalNeighbours.jl (scattered data interpolation).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you see anything missing in any of these sections, or anything you think could be improved, feel free to file an issue.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install DelaunayTriangulation.jl using the package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg \nPkg.add(\"DelaunayTriangulation\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively, the Pkg REPL can be used (accessed by typing ] at the julia> prompt):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add DelaunayTriangulation","category":"page"},{"location":"#Citing-DelaunayTriangulation.jl","page":"Introduction","title":"Citing DelaunayTriangulation.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use DelaunayTriangulation.jl, please cite it. There is a JOSS paper published at https://doi.org/10.21105/joss.0717. The BibTeX entry for this paper is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{VandenHeuvel2024DelaunayTriangulation,\n    author = {VandenHeuvel, Daniel J.},\n    doi = {10.21105/joss.07174},\n    journal = {Journal of Open Source Software},\n    month = sep,\n    number = {101},\n    pages = {7174},\n    title = {{DelaunayTriangulation.jl: A Julia package for Delaunay triangulations and Voronoi tessellations in the plane}},\n    url = {https://joss.theoj.org/papers/10.21105/joss.07174},\n    volume = {9},\n    year = {2024}\n}","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DelaunayTriangulation.jl is provided under a MIT license.","category":"page"},{"location":"#Similar-Packages","page":"Introduction","title":"Similar Packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is not the only Delaunay triangulation package available. Some others are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"VoronoiDelaunay.jl: A pure Julia library that constructs planar triangulations and tessellations like in this package, although no support for constrained triangulations / mesh refinement or clipped / centroid tessellations. Restricts points to 1 2 times 1 2.\nVoronoiCells.jl: A pure Julia library that extends VoronoiDelaunay.jl. This package provides useful tools for constructing and working with Voronoi tessellations. Supports clipping Voronoi cells to a specified rectangle. Like VoronoiDelaunay.jl, restricts points to 1 2 times 1 2.\nDelaunay.jl: Wraps Python's main Delaunay triangulation library, scipy.spatial.Delaunay, for computing Delaunay triangulations in mathbb R^N. I don't believe constrained triangulations or mesh refinement is available here.\nMiniQhull.jl: Wraps Qhull for computing unconstrained Delaunay triangulations in mathbb R^N. No support is provided for mesh refinement.\nDirectQhull.jl: Similar to MiniQhull.jl, although also provides support for convex hulls and Voronoi tessellations from Qhull.\nDelaunator.jl: A pure Julia library modelled after the JavaScript Delaunator library. This package can construct unconstrained triangulations of planar point sets. No support is available for constrained triangulations or mesh refinement, although support exists for computing the dual Voronoi tessellation. Centroidal tessellations are not implemented, although the Voronoi cells can be clipped to a bounding box. \nTriangleMesh.jl, Triangulate.jl, Triangle.jl: Interfaces to Shewchuk's Triangle library.\nTetGen.jl: This is for Delaunay tetrahedralisation, wrapping TetGen.\nGMT.jl: A wrapper of GMT, allowing for unconstrained Delaunay triangulations in two dimensions, and for spherical triangulation, i.e. triangulation of points lying on a sphere.\nQuickhull.jl: A pure Julia library for unconstrained triangulations, Voronoi tessellations, and convex hulls in N dimensions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition to these Julia packages, software packages in other programming languages are available, such as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Triangle: A C library for generating (constrained) Delaunay triangulations, Voronoi tessellations, and refined meshes. Also supports weighted triangulations. As mentioned above, there is a Julia interface to this library through TriangleMesh.jl, Triangulate.jl, or Triangle.jl. \nCGAL: A C++ library which, among many other features relevant in computational geometry, supports Delaunay triangulations, spherical triangulations, periodic triangulations, constrained triangulations, 3D Delaunay triangulations, Voronoi tessellations, mesh refinement, surface triangulations, and more.\nGmsh: Gmsh is a finite element mesh generator with many features, providing constrained Delaunay triangulations (or, in addition to triangles, elements can also be mixed with e.g. squares) and mesh refinement with many options. Provides a set of meshing algorithms to choose from. Supports both 2D and 3D meshing. In addition to simple segments, you can also provide curves for boundaries and surfaces in the 3D case. Has interfaces in several languages, including Gmsh.jl.\nSciPy: A Python library providing Delaunay triangulations, Voronoi tessellations, and convex hulls in mathbb R^N. Does not support constrained triangulations or mesh refinement.\nMATLAB: MATLAB has built-in functions for Delaunay triangulations and Voronoi tessellations in two and three dimensions. Additionally, it supports constrained triangulations and mesh refinement.\nQhull: A C library for computing Delaunay triangulations, Voronoi tessellations, and convex hulls in mathbb R^N. No support is provided for constrained triangulations or mesh refinement, but it does provide furthest-site Delaunay triangulations and furthest-site Voronoi tessellations. The packages MiniQhull.jl and DirectQhull.jl wrap Qhull for use in Julia.\nDelaunator: A JavaScript library that provides support for fast construction of two-dimensional unconstrained Delaunay triangulations.\nSpade: A Rust library providing support for Delaunay triangulations and constrained Delaunay triangulations, mesh refinement, and Voronoi tessellations in the plane. \nAcute: A C library that builds on top of Shewchuk's Triangle library, being the first of its kind to not only allow for minimum angle constraints in mesh refinement, but also for maximum angle constraints.\nTinfour: A Java library for Delaunay triangulations and constrained Delaunay triangulations in the plane, with a lot of features for interpolation.\nJTS: A Java library which, among many other features for working with vectory geometries, supports Delaunay triangulations, constrained Delaunay triangulations, mesh refinement (at least to make a conformal triangulation), and Voronoi tessellations.\nVoro++: A C++ library for constructing Voronoi tessellations, power diagrams, and clipped tessellations. \nStellar: A C library for constructing three-dimensional Delaunay triangulations, providing the ability to efficiently refine the mesh.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Compared to all these other libraries, and only in the context of planar triangulations, DelaunayTriangulation.jl is one of the most developed in terms of the features provided, except possibly with the exception of CGAL and Gmsh who provide many features although neither are in the public domain (CGAL being GPL v3+ and Gmsh being GPL v2+), unlike DelaunayTriangulation.jl which is MIT licensed. A tabular comparison of all these packages is given below (focusing only on two dimensional meshing). If there are any errors in this comparison, please let me know. Also please note that the features listed are not intended to be exhaustive, but rather to give a general idea of the capabilities of each package, and certainly not all software packages are listed here. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Comparison)","category":"page"},{"location":"math/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"math/overview/","page":"Overview","title":"Overview","text":"This section gives some mathematical details for the algorithms in this package. Not all details of the algorithms will be provided in these discussions, only those sufficient for understanding the algorithms themselves. We only discuss a specific set of algorithms in this package where extra mathematical details could be useful. For example, we do not give a section on point location since there the math is reasonably straightforward, as described in the triangulation section, and the main complexity is just on getting a working implementation. We do not talk about e.g. how we manually compute convex hulls without a triangulation since they are not a main focus in any part of this package (even though we do provide a function for it). Our discussion in these sections follows several references:","category":"page"},{"location":"math/overview/","page":"Overview","title":"Overview","text":"The book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2012). This is a great book that discusses in detail the algorithms for Delaunay triangulations and mesh generation.\nThe book Computational Geometry: Algorithms and Applications by de Berg, Cheong, Kreveld, and Overmars (2008, 3d). This book is a great reference for computational geometry in general. \nThe PhD thesis Delaunay Refinement Mesh Generation of Curve-bounded Domains by Serge Gosselin (2009). This thesis discusses the algorithms for mesh refinement in detail, and is the basis of our implementation of mesh refinement for curve-bounded domains. Another good reference for this topic is the PhD thesis Delaunay refinement for curved complexes by Adriano Lisboa (2008).\nThe paper Triangle: Engineering a 2D quality mesh generator and Delaunay triangulator by Shewchuk (2005) is a great paper discussing constrained Delaunay refinement. Similarly, Shewchuk's PhD thesis (1997) is a great reference.\nShewchuk's paper Adaptive precision floating-point arithmetic and fast robust geometric predicates is a good reference regarding the necessity of, and construction of, fast robust geometric predicates, as well as his lecture notes.\nThe paper Fast segment insertion and incremental construction of constrained Delaunay triangulations by Shewchuk and Brown (2015) is where our implementation of constrained Delaunay triangulations comes from.\nThe resource A Primer on Bézier Curves by Pomax is a great resource for understanding Bézier curves and their properties. Similarly, The NURBs Book by Piegl and Tiller (1997) is a great reference for implementing BSplines. \nThe website https://www.mvps.org/directx/articles/catmull/ by Robert Dunlop (last updated 2005) was useful for understanding Catmull Rom splines, as well as https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html by Mika Rananen (2018). Lastly, the notes by Christopher Twigg, https://www.cs.cmu.edu/~fp/courses/graphics/asst5/catmullRom.pdf, were helpful.\nThe paper Fast randomized point location without preprocessing in two- and three-dimensional Delaunay triangulations by Mücke, Saias, and Zhu (1999) is where our point location algorithm comes from.\nThe paper Where and how Chew's second Delaunay refinement algorithm works by Rand (2011) discusses Chew's algorithm for mesh refinement, originally introduced by Shew in 1993 in _Guaranteed-quality mesh generation for curved surfaces.\nThe paper Delaunay refinement by corner lopping is another good reference for mesh refinement on curved domains.\nThe paper Guaranteed-quality triangular mesh generation for domains with curved boundaries was our initial reference for triangulating curved-bounded domains, although now we only source it for ideas on implementing curves generically.\nThe resource https://www.bartoszsypytkowski.com/r-tree/ by Bartosz Sypytkowski was useful for understanding and properly implementing R-Trees, as was the code in SpatialIndexing.jl.\nThe paper Efficient computation of clipped Voronoi diagram for mesh generation by Yan, Wang, Lévy, and Liu (2013) is a good reference for clipped Voronoi tessellations.\nThe Wikipedia article for the Sutherland-Hodgman algorithm is a good resource for understanding and implementing it, as is the article for the Liang-Barsky algorithm.","category":"page"},{"location":"tutorials/operations_segment_insertion/#Triangulation-Operations","page":"Edge Insertion","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_segment_insertion/#Segment-Insertion","page":"Edge Insertion","title":"Segment Insertion","text":"","category":"section"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"This tutorial shows how we can add segments into a triangulation. First, load the packages we need:","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"Let us now define our initial triangulation.","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"points = [\n    (0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0),\n    (0.9, 0.9), (0.5, 0.5), (0.2, 0.5), (0.5, 0.8),\n]\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"To add a segment, we use add_segment!, providing the vertices for the points that a segment should be added between. Let us add a segment between (0.0, 0.0) and (1.0, 1.0), which corresponds to vertices 1 and 3.","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"add_segment!(tri, 1, 3)\nfig, ax, sc = triplot(tri, show_constrained_edges = true)\nfig","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"Of course, this changed nothing since the segment was already there. We do note, though, that if we look at the constrained edges","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"get_interior_segments(tri)","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"then we notice that the segment (1, 3) was converted into the segments (1, 6), (5, 3), and (5, 6). This is because the segment (1, 3) crossed through other vertices, and so the algorithm automatically breaks down the segments into a sequence of connected collinear segments.","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"Now we add a segment that was not already there.","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"add_segment!(tri, 1, 8)\nfig, ax, sc = triplot(tri, show_constrained_edges = true)\nfig","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"Currently, the segments that you add must not intersect at an angle (they can be collinear with other edges as we have demonstrated above). To see what happens if we do this:","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"add_segment!(tri, 8, 2)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"The other constrained edge was partially removed.","category":"page"},{"location":"tutorials/operations_segment_insertion/#Just-the-code","page":"Edge Insertion","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0),\n    (0.9, 0.9), (0.5, 0.5), (0.2, 0.5), (0.5, 0.8),\n]\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nfig\n\nadd_segment!(tri, 1, 3)\nfig, ax, sc = triplot(tri, show_constrained_edges = true)\nfig\n\nget_interior_segments(tri)\n\nadd_segment!(tri, 1, 8)\nfig, ax, sc = triplot(tri, show_constrained_edges = true)\nfig\n\nadd_segment!(tri, 8, 2)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"","category":"page"},{"location":"tutorials/operations_segment_insertion/","page":"Edge Insertion","title":"Edge Insertion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"terminology/#Terminology","page":"Terminology","title":"Terminology","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Here is a short table describing some terminology used throughout the package. Note that these definitions are only for two dimensions.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Term Definition\nTriangulation A subdivision of a point set mathcal P into a set of non-intersecting triangles. (To be more precise, it is the maximal planar subdivision of mathcal P whose vertex set is mathcal P.)\nTessellation A complete tiling of a plane by non-overlapping polygons.\nGhost A geometric object is a ghost if it is referring to, or is related to, a point at infinity, such as a ghost vertex, ghost edge, or a ghost triangle.\nSolid A geometric object is solid if it is not a ghost.\nVertex A vertex v_k is the integer associated to some point p_k in a given point set mathcal P.\nPoint A point p is some coordinate (x y) in the plane mathbb R^2.\nEdge An edge e_ij is a tuple of vertices e_ij = (i j) referring to two connected points in the plane; whether the order of the edge matters depends on the context.\nTriangle A triangle T_ijk is an ordered triplet of vertices T_ijk = (i j k) defining edges e_ij, e_jk, and e_ki in the plane representing a triangle.\nSegment A segment is an edge e_ij that is constrained to the plane, i.e. it cannot be replaced (except by other collinear segments, provided e_ij remains a union of its replacements).\nBoundary The set of lines covering a given domain.\nPole of Inaccessibility The point that is furthest from a given boundary.\nGraph A graph is a pair mathcal G = (mathcal V mathcal E), where mathcal V is the set of vertices and mathcal E is the set of edges; whether the orientation of the edges matters depends on the context.\nAdjacent An adjacent map is a map mathcal A colon mathcal E to mathcal V from edges mathcal E to vertices mathcal V, such that an edge e_ij is mapped to a vertex v_k according to some geometrical relationship, e.g. for Delaunay triangulations the vertex v_k is such that T_ijk is a positively oriented triangle in the triangulation.\nAdjacent2Vertex An adjacent-to-vertex map is a map mathcal A^dagger colon mathcal V to mathcal S subseteq mathcal E from vertices mathcal V to a set of edges mathcal S subseteq mathcal E that together define triangles in the plane, e.g. for Delaunay triangulations each edge e_jk in mathcal S associated with a vertex v_i define a positively oriented triangle T_ijk.\nBowyer Watson The name given to the algorithm used for computing unconstrained Delaunay triangulations; see here.\nDelaunay The namesake of the Delaunay triangulation.\nVoronoi The namesake of the Voronoi tessellation.\nDelaunay Property The Delaunay property refers to both triangles and edges. Given a point set mathcal P, a triangle T_ijk is Delaunay if p_i p_j p_k in mathcal P and its open circumcircle, C_ijk, contains no points in mathcal P. An edge e_ij is Delaunay if p_i p_j in mathcal P and its open circumcircle is empty.\nDelaunay Triangulation Given a point set mathcal P and a triangulation mathcal T(mathcal P) of mathcal P, if each triangle T_ijk in mathcal P(mathcal P) is Delaunay then the triangulation is said to be a Delaunay triangulation, denoted mathcal Dmathcal T(mathcal P).\nVoronoi Polygon Given a point set mathcal P and a generator v_i, the Voronoi polygon (also called a cell) mathcal V_i of v_i is defined by mathcal V_i = p in mathbb R^2 forall q in mathcal P p - p_i leq q - p, meaning each point in the polygon is as close to the generator p_i as to any other generator in mathcal P.\nVoronoi Tessellation The Voronoi tessellation (or diagram) of a point set mathcal P, denoted mathcal V(mathcal P), is the union of all the Voronoi polygons of each generator p in mathcal P and their boundaries.\nCircumcircle Given a triangle T_ijk, its circumcircle C_ijk is the unique circle going through p_i, p_j, and p_k.\nCircumradius Given a triangle T_ijk, its circumradius is the radius of its circumcircle C_ijk.\nCircumcenter Given a triangle T_ijk, its circumcenter c is the center of its circumcircle C_ijk.\nDiametral Circle Given an edge e_ij, its diametral circle is the circle which has e_ij as its diameter.\nDiametral Lens Given a lens angle theta and an edge e_ij, its diametral lens is defined as follows: Draw a line from p_i towards some point q which is left of e_ij and on e_ij's perpendicular bisector ell, such that the line is at an angle of theta with e_ij. Now do the same for a point r right of e_ij. The intersection of the circles through the points p_i, p_j, q and p_i, p_j, r, respectively, defines the diametral lens with angle theta.\nConvex Hull The convex hull of a point set mathcal P, denoted mathcal Cmathcal H(mathcal P), is the smallest convex set containing mathcal P.\nCurve A curve can either refer to the a single connected part of a boundary, or to a parametric curve defining a section of a boundary.\nSection A portion of a boundary curve.\nRefinement The process of improving the quality of a triangulation by splitting segments and triangles.\nRadius-edge Ratio The radius-edge ratio of a triangle T_ijk is rell_min, where r is T_ijk's circumradius and ell_min is the length of its shortest edge.\nInradius The inradius of a triangle T_ijk is the radius of the largest circle that can be inscribed inside T_ijk.\nCentroid The centroid of a point set mathcal P is the mean of all the points, i.e. the centroid is c = (1mathcal P)sum_pin mathcal P p. For a polygon, the centroid is a bit more complicated.\nSink The sink S_ijk of a triangle T_ijk in some triangulation mathcal T(mathcal P) is defined as follows: If its circumcenter c is inside T_ijk, then its sink is S_ijk = T_ijk; if T_ijk is on the boundary of mathcal T(mathcal P), then S_ijk = T_ijk; if neither of the first two conditions are true, then S_ijk is the sink of V, where V is the triangle adjoining the edge of T_ijk which intersects the line from T_ijk's circumcenter to its centroid.\nGenerator Given a Voronoi polygon mathcal V_i, its generator is the associated vertex v_i. The point p_i could also be called the generator.\nPredicate A predicate is some test of a geometrical property.\nCertificate A certificate is the result returned from a predicate.\nOrientation Orientation refers to the arrangement of a given set of points in the plane defining a boundary. The boundary is said to be positively oriented if you could walk along the points and also have the interior on the left, negatively oriented if the interior would be on the right. If the boundary is a straight line, the orientation is said to be degenerate.\nSteiner Point A Steiner point is a point inserted into a triangulation that was not in the originally provided point set, e.g. points inserted during mesh refinement.\nPredicate Kernel A predicate kernel refers to a method for computing predicates.","category":"page"},{"location":"tutorials/convex/#Triangulating-Convex-Polygons","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"","category":"section"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"In this tutorial, we show how we can triangulate convex polygons. The function triangulate_convex is used for this. Let us start with a simple example.","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (10.0, 12.0), (7.0, 11.0), (8.0, 6.0),\n    (10.0, 3.0), (14.0, 5.0), (15.0, 10.0),\n    (13.0, 12.0),\n]\nS = 1:7\ntri = triangulate_convex(points, 1:7)","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"This tri is our triangulation of the convex polygon. The first input is the set of points, and S defines the vertices to take from these points and their order, which must be provided in a counter-clockwise order. Note that points does not have to contain only the points of the polygon, since S will be used to define the points needed.","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Let us give a larger example. For simplicity, we triangulate a a discretised circle.","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"θ = LinRange(0, 2π, 5000) |> collect\npop!(θ)\nx = cos.(θ)\ny = sin.(θ)\npoints = tuple.(x, y)\nS = 1:4999 # can also be [1:4999; 1], if you want the array to be circular\ntri = triangulate_convex(points, S)","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Here is a comparison of the time it takes to triangulate this using triangulate_convex or triangulate.","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"using BenchmarkTools\n@benchmark triangulate_convex($points, $S)","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"@benchmark triangulate($points)","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"For the smaller example that we started with above, triangulate_convex is also faster, although not by much (≈15.10 μs versus ≈10.7 μs).","category":"page"},{"location":"tutorials/convex/#Just-the-code","page":"Triangulating Convex Polygons","title":"Just the code","text":"","category":"section"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    (10.0, 12.0), (7.0, 11.0), (8.0, 6.0),\n    (10.0, 3.0), (14.0, 5.0), (15.0, 10.0),\n    (13.0, 12.0),\n]\nS = 1:7\ntri = triangulate_convex(points, 1:7)\n\nfig, ax, sc = triplot(tri)\nfig\n\nθ = LinRange(0, 2π, 5000) |> collect\npop!(θ)\nx = cos.(θ)\ny = sin.(θ)\npoints = tuple.(x, y)\nS = 1:4999 # can also be [1:4999; 1], if you want the array to be circular\ntri = triangulate_convex(points, S)\n\nfig, ax, sc = triplot(tri)\nfig\n\nusing BenchmarkTools\n@benchmark triangulate_convex($points, $S)\n\n@benchmark triangulate($points)","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"","category":"page"},{"location":"tutorials/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"This page was generated using Literate.jl.","category":"page"},{"location":"extended/data_structures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"Here we list the internal data structures used throughout the package, along with functions related to working with the respective data structures.","category":"page"},{"location":"extended/data_structures/#MaxPriorityQueue","page":"Data Structures","title":"MaxPriorityQueue","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The MaxPriorityQueue is our implementation of a maximum priority queue; see, for example, the wikipedia page. The MaxPriorityQueue works similarly to the priority queue in DataStructures.jl. This struct is used for determining which triangles and edges to prioritise during mesh refinement, as well as which cells to prioritise during the quadtree construction for the pole of inaccessibility. ","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.MaxPriorityQueue","page":"Data Structures","title":"DelaunayTriangulation.MaxPriorityQueue","text":"MaxPriorityQueue{K, V}\n\nStruct for a max priority queue. \n\nFields\n\ndata::Vector{Pair{K, V}}: The data of the queue, stored in a vector of key-value pairs mapping elements to their priority.\nmap::Dict{K, Int}: A dictionary mapping elements to their index in the data vector.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.first-Tuple{DelaunayTriangulation.MaxPriorityQueue}","page":"Data Structures","title":"Base.first","text":"first(queue::MaxPriorityQueue) -> Pair{K, V}\n\nReturns the element with the highest priority in a queue, without removing it from queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.getindex-Tuple{DelaunayTriangulation.MaxPriorityQueue, Any}","page":"Data Structures","title":"Base.getindex","text":"getindex(queue::MaxPriorityQueue, key) \nqueue[key]\n\nReturns the priority of the element with key key in a queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.haskey-Tuple{DelaunayTriangulation.MaxPriorityQueue, Any}","page":"Data Structures","title":"Base.haskey","text":"haskey(queue::MaxPriorityQueue, key) -> Bool\n\nReturns true if the queue has an element with key key.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.MaxPriorityQueue}","page":"Data Structures","title":"Base.isempty","text":"isempty(queue::MaxPriorityQueue) -> Bool\n\nReturns true if the queue is empty.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.length-Tuple{DelaunayTriangulation.MaxPriorityQueue}","page":"Data Structures","title":"Base.length","text":"Base.length(queue::MaxPriorityQueue) -> Int\n\nReturns the number of elements in queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.popfirst!-Tuple{DelaunayTriangulation.MaxPriorityQueue}","page":"Data Structures","title":"Base.popfirst!","text":"popfirst!(queue::MaxPriorityQueue{K, V}) where {K, V} -> Pair{K, V}\n\nRemoves and returns the element with the highest priority from the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.push!-Tuple{DelaunayTriangulation.MaxPriorityQueue, Pair}","page":"Data Structures","title":"Base.push!","text":"push!(queue::MaxPriorityQueue, pair)\n\nAdds the key-value pair pair to the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.setindex!-Union{Tuple{V}, Tuple{K}, Tuple{DelaunayTriangulation.MaxPriorityQueue{K, V}, Any, Any}} where {K, V}","page":"Data Structures","title":"Base.setindex!","text":"setindex!(queue::MaxPriorityQueue, priority, key)\nqueue[key] = priority\n\nSets the priority of the element with key key in a queue to priority, or adds the element to the queue if it is not already present.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.fix_down!-Tuple{DelaunayTriangulation.MaxPriorityQueue, Int64}","page":"Data Structures","title":"DelaunayTriangulation.fix_down!","text":"fix_down!(queue::MaxPriorityQueue, k)\n\nFixes the queue after decreasing the value of one of its elements by percolating downwards.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.fix_up!-Tuple{DelaunayTriangulation.MaxPriorityQueue, Int64}","page":"Data Structures","title":"DelaunayTriangulation.fix_up!","text":"fix_up!(queue::MaxPriorityQueue, k)\n\nFixes the queue after increasing the value of one of its elements by percolating upwards.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_children-Tuple{DelaunayTriangulation.MaxPriorityQueue, Any}","page":"Data Structures","title":"DelaunayTriangulation.has_children","text":"has_children(queue::MaxPriorityQueue, k) -> Bool\n\nReturns true if the element at index k has children in the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.hchildren-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.hchildren","text":"hchildren(k) -> Tuple{Int, Int}\n\nReturns the indices of the children of the element at index k in a heap.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.hleft-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.hleft","text":"hleft(k) -> Int\n\nReturns the index of the left child of the element at index k in a heap.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.hparent-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.hparent","text":"hparent(k) -> Int\n\nReturns the index of the parent of the element at index k in a heap.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.hright-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.hright","text":"hright(k) -> Int\n\nReturns the index of the right child of the element at index k in a heap.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_root-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.is_root","text":"is_root(k) -> Bool\n\nReturns true if the element at index k is the root of a heap.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.swap!-Tuple{DelaunayTriangulation.MaxPriorityQueue, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.swap!","text":"swap!(queue::MaxPriorityQueue, i, j)\n\nSwaps the elements at indices i and j in queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Queue","page":"Data Structures","title":"Queue","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The Queue is our implementation of a basic FIFO queue; see, for example, the wikipedia page. The implementation of a Queue in this package is very simple - it is just a vector. A block-based approach could also be implemented in the future, it just hasn't. The idea here is to avoid a dependency on DataStructures.jl. The Queue is used in a variety of places, such as during boundary enrichment in enrich_boundary! to determine which edges to process next.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Queue","page":"Data Structures","title":"DelaunayTriangulation.Queue","text":"Queue{T}\n\nStruct for a first-in first-out queue. \n\nnote: Performance\nUnder the hood, Queue simply uses a Vector. This may not be as optimised compared to other implementations, e.g. DataStructure.jl's block-based approach with a Dequeue.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.eltype-Union{Tuple{Type{DelaunayTriangulation.Queue{T}}}, Tuple{T}} where T","page":"Data Structures","title":"Base.eltype","text":"eltype(queue::Queue{T}) -> Type{T}\n\nReturns the type of elements stored in q.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.Queue}","page":"Data Structures","title":"Base.isempty","text":"isempty(queue::Queue) -> Bool\n\nReturns true if the queue is empty, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.length-Tuple{DelaunayTriangulation.Queue}","page":"Data Structures","title":"Base.length","text":"length(queue::Queue) -> Int\n\nReturns the number of elements in the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.popfirst!-Tuple{DelaunayTriangulation.Queue}","page":"Data Structures","title":"Base.popfirst!","text":"popfirst!(queue::Queue)\n\nRemoves the element from the front of the queue and returns it.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.push!-Tuple{DelaunayTriangulation.Queue, Any}","page":"Data Structures","title":"Base.push!","text":"push!(queue::Queue, item)\n\nAdds item to the end of the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.enqueue_all!-Tuple{DelaunayTriangulation.Queue, Any}","page":"Data Structures","title":"DelaunayTriangulation.enqueue_all!","text":"enqueue_all!(queue::Queue, data)\n\nAdds all data to the end of the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#BalancedBST","page":"Data Structures","title":"BalancedBST","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The BalancedBST is our implementation of a balanced binary search tree; see, for example, these notes. The BalancedBST is not currently used anywhere. Originally, it was intended for use with the Bentley-Ottman algorithm, but the complete algorithm is yet to be implemented; this algorithm was to be implemented to allow for users to provide intersecting segments that, through the algorithm, could be automatically split for the user. The BalancedBST implementation is fully functional for this purpose, the work in getting the actual algorithm up and going just has to be done.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.BalancedBST","page":"Data Structures","title":"DelaunayTriangulation.BalancedBST","text":"mutable struct BalancedBST{K}\n\nStruct representing a balanced binary search tree.\n\nFields\n\nroot::Union{Nothing,BalancedBSTNode{K}}: The root of the tree.\ncount::Int32: The number of nodes in the tree.\n\nwarning: Duplicate keys\nNodes with duplicate keys are not supported. If a duplicate key is inserted, the tree will not be modified.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BalancedBSTNode","page":"Data Structures","title":"DelaunayTriangulation.BalancedBSTNode","text":"mutable struct BalancedBSTNode{K}\n\nStruct representing a node in a balanced binary search tree.\n\nFields\n\nkey::K: The key associated with the node.\nheight::Int8: The height of the node.\ncount::Int32: The number of nodes in the subtree rooted at this node, including this node.\nparent::Union{Nothing,BalancedBSTNode{K}}: The parent of the node.\nleft::Union{Nothing,BalancedBSTNode{K}}: The left child of the node.\nright::Union{Nothing,BalancedBSTNode{K}}: The right child of the node.\n\nConstructor\n\nBalancedBSTNode(key::K) where {K}\n\nConstructs a new node with key key, height 1, and count 1. The parent, left child, and right child are set to nothing.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.delete!-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"Base.delete!","text":"delete!(tree::BalancedBST{K}, key::K) -> BalancedBST{K}\n\nDeletes the node in tree with key key if it exists. Returns tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.findfirst-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"Base.findfirst","text":"findfirst(tree::BalancedBST{K}, key::K) -> Union{Nothing,BalancedBSTNode{K}}\n\nReturns the node in tree with key key. If no such node exists, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.haskey-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"Base.haskey","text":"haskey(tree::BalancedBST{K}, key::K) -> Bool\n\nReturns true if tree has a node with key key, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.push!-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"Base.push!","text":"push!(tree::BalancedBST{K}, key::K)\n\nInserts key into tree if it is not already present.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._minimum-Tuple{Union{Nothing, DelaunayTriangulation.BalancedBSTNode}}","page":"Data Structures","title":"DelaunayTriangulation._minimum","text":"_minimum(node::Union{BalancedBSTNode,Nothing}) -> Union{BalancedBSTNode,Nothing}\n\nReturns the node with the minimum key in the subtree rooted at node. If node is nothing, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compute_balance-Tuple{Union{Nothing, DelaunayTriangulation.BalancedBSTNode}}","page":"Data Structures","title":"DelaunayTriangulation.compute_balance","text":"compute_balance(node::Union{Nothing,BalancedBSTNode{K}}) -> Int8\n\nComputes the balance of the subtree rooted at node. This is the difference between the left and right heights.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compute_count-Tuple{Union{Nothing, DelaunayTriangulation.BalancedBSTNode}}","page":"Data Structures","title":"DelaunayTriangulation.compute_count","text":"compute_count(node::Union{Nothing,BalancedBSTNode{K}}) -> Int32\n\nComputes the count of the subtree rooted at node, i.e. the number of nodes in the subtree rooted at node, including node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compute_height-Tuple{Union{Nothing, DelaunayTriangulation.BalancedBSTNode}}","page":"Data Structures","title":"DelaunayTriangulation.compute_height","text":"compute_height(node::Union{Nothing,BalancedBSTNode{K}}) -> Int8\n\nComputes the height of the subtree rooted at node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_node!-Tuple{DelaunayTriangulation.BalancedBSTNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_node!","text":"delete_node!(node::Union{Nothing,BalancedBSTNode{K}}, key::K) -> Union{Nothing,BalancedBSTNode{K}}\n\nDeletes the node with key key from the subtree rooted at node if it exists. Returns the new root of the subtree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_count-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_count","text":"get_count(node::Union{Nothing, BalancedBSTNode}) -> Int32\n\nReturns the count of node. If the node is nothing, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_count-Tuple{DelaunayTriangulation.BalancedBST}","page":"Data Structures","title":"DelaunayTriangulation.get_count","text":"get_count(tree::BalancedBST{K}) -> Int32\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_height-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_height","text":"get_height(node::Union{Nothing, BalancedBSTNode}) -> Int8\n\nReturns the height of node. If the node is nothing, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_key-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_key","text":"get_key(node::BalancedBSTNode{K}) -> K\n\nReturns the key associated with node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_left-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_left","text":"get_left(node::BalancedBSTNode) -> Union{Nothing, BalancedBSTNode}\n\nReturns the left child of node. If the node is nothing, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_parent","text":"get_parent(node::BalancedBSTNode) -> Union{Nothing, BalancedBSTNode}\n\nReturns the parent of node. If the node is nothing, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_right-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.get_right","text":"get_right(node::BalancedBSTNode) -> Union{Nothing, BalancedBSTNode}\n\nReturns the right child of node. If the node is nothing, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_root-Tuple{DelaunayTriangulation.BalancedBST}","page":"Data Structures","title":"DelaunayTriangulation.get_root","text":"get_root(tree::BalancedBST{K}) -> Union{Nothing,BalancedBSTNode{K}}\n\nReturns the root of tree. If tree is empty, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_left-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.has_left","text":"has_left(node::BalancedBSTNode) -> Bool\n\nReturns true if node has a left child, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_parent-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.has_parent","text":"has_parent(node::BalancedBSTNode) -> Bool\n\nReturns true if node has a parent, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_right-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.has_right","text":"has_right(node::BalancedBSTNode) -> Bool\n\nReturns true if node has a right child, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_root-Tuple{DelaunayTriangulation.BalancedBST}","page":"Data Structures","title":"DelaunayTriangulation.has_root","text":"has_root(tree::BalancedBST{K}) -> Bool\n\nReturns true if tree has a root, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.inorder-Union{Tuple{DelaunayTriangulation.BalancedBST{K}}, Tuple{K}} where K","page":"Data Structures","title":"DelaunayTriangulation.inorder","text":"inorder(tree::BalancedBST{K}) -> Vector{K}\n\nReturns the inorder traversal of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.insert_node!-Tuple{Nothing, Any}","page":"Data Structures","title":"DelaunayTriangulation.insert_node!","text":"insert_node!(node::Union{Nothing,BalancedBSTNode{K}}, key::K) -> Union{Nothing,BalancedBSTNode{K}}\n\nInserts key into the subtree rooted at node if it is not already present. Returns the new root of the subtree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.rotate_left!-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.rotate_left!","text":"rotate_left!(parent::BalancedBSTNode{K}) -> BalancedBSTNode{K}\n\nRotates a subtree rooted at parent to the left, returning the new root of the subtree. This local operation is used to preserve the binary search tree property after inserting or deleting a node. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.rotate_right!-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.rotate_right!","text":"rotate_right!(parent::BalancedBSTNode{K}) -> BalancedBSTNode{K}\n\nRotates a subtree rooted at parent to the right, returning the new root of the subtree. This local operation is used to preserve the binary search tree property after inserting or deleting a node. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_count!-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_count!","text":"set_count!(tree::BalancedBST{K}, count::Int32)\n\nSets the count of tree to count.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_count!-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.set_count!","text":"set_count!(node::BalancedBSTNode[, count = compute_count(node)])\n\nSets the count of node to count. If count is not provided, the count is computed using compute_count.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_height!-Tuple{DelaunayTriangulation.BalancedBSTNode}","page":"Data Structures","title":"DelaunayTriangulation.set_height!","text":"set_height!(node::BalancedBSTNode[, height = compute_height(node)])\n\nSets the height of node to height. If height is not provided, the height is computed using compute_height.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_key!-Tuple{DelaunayTriangulation.BalancedBSTNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_key!","text":"set_key!(node::BalancedBSTNode{K}, key::K)\n\nSets the key associated with node to key.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_left!-Tuple{DelaunayTriangulation.BalancedBSTNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_left!","text":"set_left!(node::BalancedBSTNode, left::Union{Nothing, BalancedBSTNode})\n\nSets the left child of node to left.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_parent!-Tuple{DelaunayTriangulation.BalancedBSTNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_parent!","text":"set_parent!(node::BalancedBSTNode, parent::Union{Nothing, BalancedBSTNode})\n\nSets the parent of node to parent. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_right!-Tuple{DelaunayTriangulation.BalancedBSTNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_right!","text":"set_right!(node::BalancedBSTNode, right::Union{Nothing, BalancedBSTNode})\n\nSets the right child of node to right.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_root!-Tuple{DelaunayTriangulation.BalancedBST, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_root!","text":"set_root!(tree::BalancedBST{K}, root::Union{Nothing,BalancedBSTNode{K}})\n\nSets the root of tree to root.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#RTree","page":"Data Structures","title":"RTree","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The RTree is our implementation of a simple RTree data structure, following heavily the original code in SpatialIndexing.jl. This tree is needed for triangulating curve-bounded domains. In particular, since the enrichment phase of triangulating a curve-bounded domain has no triangulation data structure that can be used for finding intersections between an edge's diametral circle and another vertex, the RTree is used to find these intersections.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.RTree","page":"Data Structures","title":"DelaunayTriangulation.RTree","text":"mutable struct RTree\n\nType for representing an R-tree with linear splitting.\n\nFields\n\nroot::Union{Branch,Leaf{Branch}}: The root of the R-tree.\nnum_elements::Int: The number of elements in the R-tree.\nbranch_cache::BranchCache: The cache of branch nodes.\ntwig_cache::TwigCache: The cache of twig nodes.\nleaf_cache::LeafCache: The cache of leaf nodes.\nfill_factor::Float64: The fill factor of the R-tree, i.e. the percentage of a node's capacity that should be filled after splitting.\nfree_cache::BitVector: A bit vector for keeping track of which indices in detached_cache are free.\ndetached_cache::Vector{Union{Branch,Leaf{Branch}}}: A cache of detached nodes, i.e. nodes that have been split from the R-tree. This is used for deleting nodes.\nintersection_cache::NTuple{2,IntersectionCache}: Cache used for identifying intersections. Each element of the Tuple is its own cache, allowing for up to    two intersection queries to be performed simultaneously. Note that this makes the R-tree non-thread-safe, and even non-safe when considering three or more    intersection queries simultaneously.\n\nConstructor\n\n    RTree(; size_limit=100, fill_factor=0.7)\n\nThe size_limit is the node capacity. All node types have the same capacity.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.InvalidBoundingBox","page":"Data Structures","title":"DelaunayTriangulation.InvalidBoundingBox","text":"InvalidBoundingBox\n\nA constant for representing an invalid rectangle, i.e. a rectangle with NaN endpoints.\n\n\n\n\n\n","category":"constant"},{"location":"extended/data_structures/#DelaunayTriangulation.InvalidBoundingInterval","page":"Data Structures","title":"DelaunayTriangulation.InvalidBoundingInterval","text":"InvalidBoundingInterval\n\nA constant for representing an invalid intervaBoundingInterval, i.e. an interval with NaN endpoints.\n\n\n\n\n\n","category":"constant"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractBoundingShape","page":"Data Structures","title":"DelaunayTriangulation.AbstractBoundingShape","text":"abstract type AbstractBoundingShape\n\nAbstract type for representing a bounding box.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractNode","page":"Data Structures","title":"DelaunayTriangulation.AbstractNode","text":"abstract type AbstractNode end\n\nAbstract type for representing a node in an R-tree.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BoundaryRTree","page":"Data Structures","title":"DelaunayTriangulation.BoundaryRTree","text":"BoundaryRTree{P}\n\nType for representing an R-tree of a boundary with an associated point set. The rectangular elements of the R-tree  are the bounding box of the diametral circles of the boundary edges.\n\nFields\n\ntree::RTree: The R-tree.\npoints::P: The point set.\n\nConstructors\n\nBoundaryRTree(points)\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BoundingBox","page":"Data Structures","title":"DelaunayTriangulation.BoundingBox","text":"BoundingBox <: AbstractBoundingShape\n\nType for representing an axis-aligned bounding box, represented as a pair of interval I and J so that the bounding box is I × J.\n\nFields\n\nx::BoundingInterval: The interval for the x-axis.\ny::BoundingInterval: The interval for the y-axis.\n\nConstructors\n\nBoundingBox(x::BoundingInterval, y::BoundingInterval)\nBoundingBox(a::Float64, b::Float64, c::Float64, d::Float64) = BoundingBox(BoundingInterval(a, b), BoundingInterval(c, d))\nBoundingBox(p::NTuple{2,<:Number}) = BoundingBox(p[1], p[1], p[2], p[2])\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BoundingInterval","page":"Data Structures","title":"DelaunayTriangulation.BoundingInterval","text":"BoundingInterval <: AbstractBoundingShape\n\nType for representing a bounding interval [a, b].\n\nFields\n\na::Float64: The left endpoint.\nb::Float64: The right endpoint.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.Branch","page":"Data Structures","title":"DelaunayTriangulation.Branch","text":"mutable struct Branch <: AbstractNode\n\nType for representing a branch node in an R-tree.\n\nFields\n\nparent::Union{Branch, Nothing}: The parent of the branch node.\nbounding_box::BoundingBox: The bounding box of the branch node.\nchildren::Union{Vector{Branch},Vector{Leaf{Branch}}}: The children of the branch node.\nlevel::Int: The level of the branch node.\n\nConstructor\n\nBranch(parent::Union{Branch,Nothing}=nothing, ::Type{C}=Branch) where {C<:AbstractNode} = new(parent, InvalidBoundingBox, C[], 1)\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BranchCache","page":"Data Structures","title":"DelaunayTriangulation.BranchCache","text":"BranchCache\n\nType for representing a cache of branch nodes.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.DiametralBoundingBox","page":"Data Structures","title":"DelaunayTriangulation.DiametralBoundingBox","text":"DiametralBoundingBox\n\nType for representing a bounding box generated from an edge's diametral circle.\n\nFields\n\nbounding_box::BoundingBox: The bounding box.\nedge::NTuple{2,Int}: The generator edge.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.Leaf","page":"Data Structures","title":"DelaunayTriangulation.Leaf","text":"mutable struct Leaf <: AbstractNode\n\nType for representing a leaf node in an R-tree.\n\ndanger: Type parametrisation\nTechnically, this type should be referred to by Leaf{Branch}. Due to a lack of support for mutually recursive types or  forward declarations, we have a parametric type in this struct's definition since Branch is not yet defined. In particular,  Leaf is not a concrete type, whereas Leaf{Branch} is.\n\nFields\n\nparent::Union{Branch, Nothing}: The parent of the leaf node.\nbounding_box::BoundingBox: The bounding box of the leaf node.\nchildren::Vector{DiametralBoundingBox}: The children of the leaf node.\n\nConstructor\n\nLeaf(parent::Union{Branch,Nothing}=nothing) = Leaf{Branch}(parent, InvalidBoundingBox, DiametralBoundingBox[])\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.LeafCache","page":"Data Structures","title":"DelaunayTriangulation.LeafCache","text":"LeafCache\n\nType for representing a cache of leaf nodes.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.NodeCache","page":"Data Structures","title":"DelaunayTriangulation.NodeCache","text":"NodeCache{Node,Child}\n\nType for representing a cache of nodes whose children are of type Child. This is used for caching nodes that are detached from the R-tree, e.g. when a node is split.\n\nFields\n\ncache::Vector{Node}: The cache of nodes.\nsize_limit::Int: The maximum number of nodes that can be cached.\n\nConstructor\n\nNodeCache{Node,Child}(size_limit::Int) where {Node,Child} = new{Node,Child}(Node[], size_limit)\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.RTreeIntersectionCache","page":"Data Structures","title":"DelaunayTriangulation.RTreeIntersectionCache","text":"RTreeIntersectionCache\n\nType for representing a cache used for identifying intersections in an R-tree.\n\nFields\n\nnode_indices::Vector{Int}: A cache of indices used for identifying intersections.\nneed_tests::BitVector: A BitVector cache for keeping track of which indices in node_indices need to be tested for intersections. \n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.RTreeIntersectionIterator","page":"Data Structures","title":"DelaunayTriangulation.RTreeIntersectionIterator","text":"RTreeIntersectionIterator\n\nType for representing an iterator over the elements in an R-tree that intersect with a bounding box.\n\nFields\n\ntree::RTree: The R-tree.\nbounding_box::BoundingBox: The bounding box to test for intersections with.\ncache::RTreeIntersectionCache: The cache used for identifying intersections.    \n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.RTreeIntersectionIteratorState","page":"Data Structures","title":"DelaunayTriangulation.RTreeIntersectionIteratorState","text":"RTreeIntersectionIteratorState\n\nThe state of an RTreeIntersectionIterator.\n\nFields\n\nleaf::Leaf{Branch}: The current leaf node.\nnode_indices::Vector{Int}: The indices of the current node at each level.\nneed_tests::BitVector: A BitVector cache for keeping track of which indices in node_indices need to be tested for intersections.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.TwigCache","page":"Data Structures","title":"DelaunayTriangulation.TwigCache","text":"TwigCache\n\nType for representing a cache of twig nodes, i.e. branch nodes at level 2.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.:∩-Tuple{DelaunayTriangulation.BoundingBox, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"Base.:∩","text":"intersect(r1::BoundingBox, r2::BoundingBox) -> BoundingBox\nr1::BoundingBox ∩ r2::BoundingBox -> BoundingBox\n\nReturns the intersection of r1 and r2. If the intersection is empty, returns InvalidBoundingBox.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.:∩-Tuple{DelaunayTriangulation.BoundingInterval, DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.:∩","text":"intersect(I::BoundingInterval, J::BoundingInterval) -> BoundingInterval\nI::BoundingInterval ∩ J::BoundingInterval -> BoundingInterval\n\nReturns the intersection of I and J. If the intersection is empty, returns InvalidBoundingInterval.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.:∪-Tuple{DelaunayTriangulation.BoundingBox, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"Base.:∪","text":"union(r1::BoundingBox, r2::BoundingBox) -> BoundingBox\nr1::BoundingBox ∪ r2::BoundingBox -> BoundingBox\n\nReturns the union of r1 and r2, i.e. the smallest bounding box that contains both r1 and r2.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.:∪-Tuple{DelaunayTriangulation.BoundingInterval, DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.:∪","text":"union(I::BoundingInterval, J::BoundingInterval) -> BoundingInterval\nI::BoundingInterval ∪ J::BoundingInterval -> BoundingInterval\n\nReturns the union of I and J, combining their bounds; i.e. the smallest interval that contains both I and J.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.delete!-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any}","page":"Data Structures","title":"Base.delete!","text":"delete!(tree::BoundaryRTree, i, j)\n\nDeletes the bounding box of the diametral circle of the edge between i and j in tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.in-Tuple{DelaunayTriangulation.BoundingBox, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"Base.in","text":"in(r1::BoundingBox, r2::BoundingBox) -> Bool\nr1::BoundingBox ∈ r2::BoundingBox -> Bool\n\nTests whether r1 is in r2.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.in-Tuple{DelaunayTriangulation.BoundingInterval, DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.in","text":"in(I::BoundingInterval, J::BoundingInterval) -> Bool\nI::BoundingInterval ∈ J::BoundingInterval -> Bool\n\nTests whether the interval I is in the interval J.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.in-Tuple{Float64, DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.in","text":"in(a::Float64, I::BoundingInterval) -> Bool\na::Float64 ∈ I::BoundingInterval -> Bool\n\nTests whether a is in I.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.in-Tuple{Tuple{var\"#s14\", var\"#s14\"} where var\"#s14\"<:Number, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"Base.in","text":"in(p::NTuple{2,<:Number}, r::BoundingBox) -> Bool\np::NTuple{2,<:Number} ∈ r::BoundingBox -> Bool\n\nTests whether p is in r.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.insert!-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any}","page":"Data Structures","title":"Base.insert!","text":"insert!(tree::BoundaryRTree, i, j) -> Bool\n\nInserts the diametral circle of the edge between i and j into tree. Returns true if the tree's bounding boxes had to be adjusted and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"Base.isempty","text":"isempty(r::BoundingBox) -> Bool\n\nReturns true if r is empty, i.e. if r.x or r.y is empty.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.isempty","text":"isempty(I::BoundingInterval) -> Bool\n\nReturns true if I is empty, i.e. if I.a or I.b is NaN or if length(I) < 0.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"Base.isempty","text":"isempty(cache::NodeCache) -> Bool\n\nReturns true if cache is empty.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.length-Tuple{DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"Base.length","text":"length(I::BoundingInterval) -> Float64\n\nReturns the length of the interval I.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.length-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"Base.length","text":"length(cache::NodeCache) -> Int\n\nReturns the number of nodes in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.pop!-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"Base.pop!","text":"pop!(cache::NodeCache) -> Node\n\nRemoves and returns the last node in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.push!-Tuple{DelaunayTriangulation.NodeCache, Any}","page":"Data Structures","title":"Base.push!","text":"push!(cache::NodeCache, node)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.setindex!-Tuple{DelaunayTriangulation.Branch, Any, Integer}","page":"Data Structures","title":"Base.setindex!","text":"setindex!(branch::Branch, child, i::Integer)\nbranch[i] = child\n\nSets the ith child of branch to be child, also updating the parent of child to be branch.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_child!-Tuple{DelaunayTriangulation.AbstractNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_child!","text":"add_child!(node::AbstractNode, child)\n\nAdds child to node, i.e. appends child to the children of node via push!.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.bounding_box-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.bounding_box","text":"bounding_box(points, i, j) -> DiametralBoundingBox\n\nReturns the bounding box of the diametral circle of the points points[i] and points[j] with generator edge (i, j), returned as an DiametralBoundingBox.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.bounding_box-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.bounding_box","text":"bounding_box(points) -> BoundingBox\n\nGets the bounding box for a set of points.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.bounding_box-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.bounding_box","text":"bounding_box(tree::BoundaryRTree, i, j) -> DiametralBoundingBox\n\nReturns the bounding box of the diametral circle of the edge between i and j in tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.bounding_box-Tuple{NTuple{N, T} where {N, T}, NTuple{N, T} where {N, T}, NTuple{N, T} where {N, T}}","page":"Data Structures","title":"DelaunayTriangulation.bounding_box","text":"bounding_box(p::NTuple, q::NTuple, r::NTuple) -> BoundingBox\n\nReturns the bounding box of the points p, q and r.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.bounding_box-Tuple{Tuple{var\"#s13\", var\"#s13\"} where var\"#s13\"<:Number, Number}","page":"Data Structures","title":"DelaunayTriangulation.bounding_box","text":"bounding_box(center, radius) -> BoundingBox\n\nReturns the bounding box of the circle (center, radius).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.cache_node!","page":"Data Structures","title":"DelaunayTriangulation.cache_node!","text":"cache_node!(tree::RTree, node::AbstractNode)\n\nCaches node in into tree's node caches.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.cache_node!-Tuple{DelaunayTriangulation.NodeCache, Any}","page":"Data Structures","title":"DelaunayTriangulation.cache_node!","text":"cache_node!(cache::NodeCache, node)\n\nCaches node in cache if cache is not full. Otherwise, does nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.decrement_num_elements!-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.decrement_num_elements!","text":"decrement_num_elements!(tree::RTree)\n\nDecrements the number of elements in tree by 1.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.diametral_circle-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.diametral_circle","text":"diametral_circle(p, q) -> (NTuple{2,Float64}, Float64)\n\nReturns the circle with diameter pq.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.expand","page":"Data Structures","title":"DelaunayTriangulation.expand","text":"expand(box::BoundingBox, perc=0.10) -> BoundingBox\n\nExpands the bounding box box by a factor perc in each direction.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.find_position_in_parent-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.find_position_in_parent","text":"find_position_in_parent(node::AbstractNode) -> Int\n\nReturns the position of node in its parent's children. If node has no parent, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_area-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_area","text":"get_area(r::BoundingBox) -> Float64\n\nReturns the area of r, i.e. hspan(r) * vspan(r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bl_corner-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_bl_corner","text":"get_bl_corner(r::BoundingBox) -> NTuple{2,Float64}\n\nReturns the bottom-left corner of r.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bounding_box-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.get_bounding_box","text":"get_bounding_box(node::AbstractNode) -> BoundingBox\n\nReturns the bounding box of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bounding_box-Tuple{DelaunayTriangulation.DiametralBoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_bounding_box","text":"get_bounding_box(id_bounding_box::DiametralBoundingBox) -> BoundingBox\n\nReturns the bounding box of id_bounding_box.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bounding_box-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_bounding_box","text":"get_bounding_box(tree::RTree) -> BoundingBox\n\nReturns the bounding box of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_branch_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_branch_cache","text":"get_branch_cache(tree::RTree) -> BranchCache\n\nReturns the branch cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_child-Tuple{DelaunayTriangulation.AbstractNode, Integer}","page":"Data Structures","title":"DelaunayTriangulation.get_child","text":"get_child(node::AbstractNode, i::Integer) -> AbstractNode\n\nReturns the ith child of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_child_type-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.get_child_type","text":"get_child_type(node::AbstractNode) -> Union{Type{Leaf}, Type{Branch}}\n\nReturns the type of the children of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_children-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.get_children","text":"get_children(node::AbstractNode) -> Vector\n\nReturns the children of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_detached_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_detached_cache","text":"get_detached_cache(tree::RTree) -> Vector{Union{Branch,Leaf{Branch}}}\n\nReturns the detached cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_edge-Tuple{DelaunayTriangulation.DiametralBoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_edge","text":"get_edge(id_bounding_box::DiametralBoundingBox) -> NTuple{2,Int}\n\nReturns the generator edge of id_bounding_box.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_fill_factor-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_fill_factor","text":"get_fill_factor(tree::RTree) -> Float64\n\nReturns the fill factor of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_free_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_free_cache","text":"get_free_cache(tree::RTree) -> BitVector\n\nReturns the free cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_height-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_height","text":"get_height(tree::RTree) -> Int\n\nReturns the height of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_intersection_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_intersection_cache","text":"get_intersection_cache(tree::RTree) -> NTuple{2,RTreeIntersectionCache}\n\nReturns the intersection cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::BoundaryRTree, i, j, k; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with the bounding box of the triangle (i, j, k). cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::BoundaryRTree, i, j; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with the diametral circle of the edge between i and j. cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.BoundaryRTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::BoundaryRTree, i; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with the ith vertex. cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.BoundaryRTree, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::BoundaryRTree, bbox::BoundingBox; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with bbox. cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_leaf_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_leaf_cache","text":"get_leaf_cache(tree::RTree) -> LeafCache\n\nReturns the leaf cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_level","page":"Data Structures","title":"DelaunayTriangulation.get_level","text":"get_level(node::AbstractNode) -> Int\n\nReturns the level of node. If node is a leaf, returns 1.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_min_nodes-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_min_nodes","text":"get_min_nodes(tree::RTree) -> Int\n\nReturns the minimum number of nodes that a node in tree can have.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_need_tests-Tuple{DelaunayTriangulation.RTreeIntersectionCache}","page":"Data Structures","title":"DelaunayTriangulation.get_need_tests","text":"get_need_tests(cache::RTreeIntersectionCache) -> BitVector\n\nReturns the need_tests cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_node_indices-Tuple{DelaunayTriangulation.RTreeIntersectionCache}","page":"Data Structures","title":"DelaunayTriangulation.get_node_indices","text":"get_node_indices(cache::RTreeIntersectionCache) -> Vector{Int}\n\nReturns the node indices of cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.get_parent","text":"get_parent(node::AbstractNode) -> Union{Branch, Nothing}\n\nReturns the parent of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_root-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_root","text":"get_root(tree::RTree) -> Union{Branch,Leaf{Branch}}\n\nReturns the root of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_size_limit-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"DelaunayTriangulation.get_size_limit","text":"get_size_limit(cache::NodeCache) -> Int\n\nReturns the size limit of cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_size_limit-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_size_limit","text":"get_size_limit(tree::RTree) -> Int\n\nReturns the size limit of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_state-Tuple{DelaunayTriangulation.RTreeIntersectionIteratorState}","page":"Data Structures","title":"DelaunayTriangulation.get_state","text":"get_state(state::RTreeIntersectionIteratorState) -> DiametralBoundingBox\n\nReturns the current element in state.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_tr_corner-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.get_tr_corner","text":"get_tr_corner(r::BoundingBox) -> NTuple{2,Float64}\n\nReturns the top-right corner of r.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_twig_cache-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.get_twig_cache","text":"get_twig_cache(tree::RTree) -> TwigCache\n\nReturns the twig cache of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_children-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.has_children","text":"has_children(node::AbstractNode) -> Bool\n\nReturns true if node has children.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_parent-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.has_parent","text":"has_parent(node::AbstractNode) -> Bool\n\nReturns true if node has a parent.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.hspan-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.hspan","text":"hspan(r::BoundingBox) -> Float64\n\nReturns the horizontal span of r, i.e. length(r.x).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.increment_num_elements!-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.increment_num_elements!","text":"increment_num_elements!(tree::RTree)\n\nIncrements the number of elements in tree by 1.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_full-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.is_full","text":"is_full(node::AbstractNode, tree::RTree) -> Bool\n\nReturns true if node is full, i.e. if num_children(node) ≥ get_size_limit(tree).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_full-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"DelaunayTriangulation.is_full","text":"is_full(cache::NodeCache) -> Bool\n\nReturns true if cache is full, i.e. if length(cache) ≥ get_size_limit(cache).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_root-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.is_root","text":"is_root(node::AbstractNode, tree::RTree) -> Bool\n\nReturns true if node is the root of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_touching-Tuple{DelaunayTriangulation.BoundingBox, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.is_touching","text":"is_touching(r1::BoundingBox, r2::BoundingBox) -> Bool\n\nTests whether r1 and r2 are touching, i.e. if they share a common boundary. This only considers interior touching.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.midpoint-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.midpoint","text":"midpoint(r::BoundingBox) -> NTuple{2,Float64}\n\nReturns the center of r.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.midpoint-Tuple{DelaunayTriangulation.BoundingInterval}","page":"Data Structures","title":"DelaunayTriangulation.midpoint","text":"midpoint(I::BoundingInterval) -> Float64\n\nReturns the midpoint of I.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_children-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.num_children","text":"num_children(node::AbstractNode) -> Int\n\nReturns the number of children of node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_elements-Tuple{DelaunayTriangulation.RTree}","page":"Data Structures","title":"DelaunayTriangulation.num_elements","text":"num_elements(tree::RTree) -> Int\n\nReturns the number of elements in tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.pop_child!-Tuple{DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.pop_child!","text":"pop_child!(node::AbstractNode)\n\nRemoves the last child of node via pop!.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_bounding_box!-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.set_bounding_box!","text":"set_bounding_box!(node::AbstractNode, bounding_box::BoundingBox)\n\nSets the bounding box of node to be bounding_box.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_child!-Tuple{DelaunayTriangulation.AbstractNode, Any, Integer}","page":"Data Structures","title":"DelaunayTriangulation.set_child!","text":"set_child!(parent_node::AbstractNode, child_node, i::Integer)\n\nSets the ith child of parent_node to be child_node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_level!-Tuple{DelaunayTriangulation.Branch, Integer}","page":"Data Structures","title":"DelaunayTriangulation.set_level!","text":"set_level!(branch::Branch, level::Integer)\n\nSets the level of branch to be level.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_parent!-Tuple{DelaunayTriangulation.AbstractNode, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_parent!","text":"set_parent!(child_node::AbstractNode, parent_node::AbstractNode)\n\nSets the parent of child_node to be parent_node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_root!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.AbstractNode}","page":"Data Structures","title":"DelaunayTriangulation.set_root!","text":"set_root!(tree::RTree, node::AbstractNode)\n\nSets the root of tree to be node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.spawn_branch!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.BoundingBox, Any}","page":"Data Structures","title":"DelaunayTriangulation.spawn_branch!","text":"spawn_branch!(tree::RTree, bounding_box::BoundingBox, level) -> Branch\n\nReturns a new branch node with bounding box bounding_box and level level from tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.spawn_leaf!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.spawn_leaf!","text":"spawn_leaf!(tree::RTree, bounding_box::BoundingBox) -> Leaf{Branch}\n\nReturns a new leaf node with bounding box bounding_box from tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.spawn_node!-Tuple{DelaunayTriangulation.NodeCache}","page":"Data Structures","title":"DelaunayTriangulation.spawn_node!","text":"spawn_node!(cache::NodeCache{Node}) where {Node} -> Node\n\nReturns a node from cache. If cache is empty, returns a new node.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.spawn_node!-Union{Tuple{N}, Tuple{DelaunayTriangulation.RTree, Type{N}, DelaunayTriangulation.BoundingBox, Any}} where N","page":"Data Structures","title":"DelaunayTriangulation.spawn_node!","text":"spawn_node!(tree::RTree, ::Type{N}, [bounding_box::BoundingBox], level) where {N} -> N\n\nReturns a new node of type N with bounding box bounding_box and level level from tree. If  bounding_box is not provided, it is replaced with InvalidBoundingBox.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.split_edge!-Tuple{DelaunayTriangulation.BoundaryRTree, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(tree::BoundaryRTree, i, j, r)\n\nSplits the diametral bounding box associated with (i, j) into two new boxes associated  with the diametral circles of (i, r) and (j, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.vspan-Tuple{DelaunayTriangulation.BoundingBox}","page":"Data Structures","title":"DelaunayTriangulation.vspan","text":"vspan(r::BoundingBox) -> Float64\n\nReturns the vertical span of r, i.e. length(r.y).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.QueryResult","page":"Data Structures","title":"DelaunayTriangulation.QueryResult","text":"QueryResult\n\nAn enum type for representing the result of an intersection query, with instances:\n\nContains: The bounding box contains the element.\nIntersects: The bounding box intersects the element.\nOutside: The bounding box is outside the element.\n\n\n\n\n\n","category":"module"},{"location":"extended/data_structures/#PolygonHierarchy","page":"Data Structures","title":"PolygonHierarchy","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The PolygonHierarchy is a data structure used for representing hierarchical information about a set of polygons, such as the piecewise linear approximation of a curve-bounded domain's boundary. This structure is implemented as a collection of directed trees, where the disjoint trees each represent the disjoint parts of a domain, and the root of each tree contains the boundary curves of all the boundaries that are inside this tree.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.PolygonHierarchy","page":"Data Structures","title":"DelaunayTriangulation.PolygonHierarchy","text":"PolygonHierarchy{I}\n\nStruct used to define a polygon hierarchy. The hierarchy is represented as a forest of PolygonTrees.\n\ndanger: Overlapping polygons\nThe polygons must not intersect any other polygon's boundaries.\n\nFields\n\npolygon_orientations::BitVector: A BitVector of length n where n is the number of polygons in the hierarchy. The ith entry is true if the ith polygon is positively oriented, and false otherwise.\nbounding_boxes::Vector{BoundingBox}: A Vector of BoundingBoxs of length n where n is the number of polygons in the hierarchy. The ith entry is the BoundingBox of the ith polygon.\ntrees::Dict{I,PolygonTree{I}}: A Dict mapping the index of a polygon to its PolygonTree. The keys of trees are the roots of each individual tree, i.e. the outer-most polygons.\nreorder_cache::Vector{PolygonTree{I}}: A Vector used for caching trees to be deleted in reorder_subtree!.\n\nnote: One-based indexing\nNote that the vector definitions for polygon_orientations and bounding_boxes are treating the curves with the assumption that they are  enumerated in the order 1, 2, 3, ....\n\nConstructor\n\nPolygonHierarchy{I}() where {I}\n\nConstructs a PolygonHierarchy with no polygons.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.PolygonTree","page":"Data Structures","title":"DelaunayTriangulation.PolygonTree","text":"mutable struct PolygonTree{I}\n\nA tree structure used to define a polygon hierarchy.\n\nFields\n\nparent::Union{Nothing,PolygonTree{I}}: The parent of the tree. If nothing, then the tree is the root.\nchildren::Set{PolygonTree{I}}: The children of the tree.\nindex::I: The index of the tree. This is the index associated with the polygon.\nheight::Int: The height of the tree. This is the number of polygons in the tree that index is inside of. The root has height 0.\n\nConstructor\n\nPolygonTree{I}(parent::Union{Nothing,PolygonTree{I}}, index, height) where {I}\n\nConstructs a PolygonTree with parent, index, and height, and no children.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_child!-Tuple{DelaunayTriangulation.PolygonTree, DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.add_child!","text":"add_child!(tree::PolygonTree, child::PolygonTree)\n\nAdds child to tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_polygon_hierarchy-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.construct_polygon_hierarchy","text":"construct_polygon_hierarchy(points, boundary_nodes, boundary_curves; IntegerType=Int, n=4096) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of boundary_nodes that define a curve-bounded domain  from the curves in boundary_curves. Uses polygonise to fill in the boundary curves.\n\nArguments\n\npoints: The point set.\nboundary_nodes: The boundary nodes. These should be the output from convert_boundary_curves!.\nboundary_curves: The boundary curves. These should be the output from convert_boundary_curves!.\n\nKeyword Arguments\n\nIntegerType=Int: The integer type to use for indexing the polygons.\nn=4096: The number of points to use for filling in the boundary curves in polygonise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_polygon_hierarchy-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.construct_polygon_hierarchy","text":"construct_polygon_hierarchy(points, boundary_nodes; IntegerType=Int) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of boundary_nodes that define a set of piecewise  linear curves. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_polygon_hierarchy-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.construct_polygon_hierarchy","text":"construct_polygon_hierarchy(points; IntegerType=Int) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of points. This defines a hierarchy with a single polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_child!-Tuple{DelaunayTriangulation.PolygonTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_child!","text":"delete_child!(tree::PolygonTree, child::PolygonTree)\n\nDeletes child from tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_tree!-Tuple{DelaunayTriangulation.PolygonHierarchy, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_tree!","text":"delete_tree!(hierarchy::PolygonHierarchy, index)\n\nDeletes the PolygonTree of the indexth polygon in hierarchy. The index must be associated with an exterior polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.expand_bounds!","page":"Data Structures","title":"DelaunayTriangulation.expand_bounds!","text":"expand_bounds!(hierarchy::PolygonHierarchy, perc=0.10) -> PolygonHierarchy\n\nExpands the bounding boxes of hierarchy by a factor of perc in each direction.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.find_tree-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.find_tree","text":"find_tree(hierarchy::PolygonHierarchy, points, boundary_nodes, p) -> Union{Nothing,PolygonTree}\n\nFinds a tree in hierarchy containing p.\n\nArguments\n\nhierarchy::PolygonHierarchy: The PolygonHierarchy to search.\npoints: The point set.\nboundary_nodes: The boundary nodes.\np: The point to test the trees of hierarchy against.\n\nOutput\n\nnothing if p is not inside any tree in hierarchy, and the PolygonTree containing p otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.find_tree-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any, DelaunayTriangulation.PolygonTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.find_tree","text":"find_tree(hierarchy::PolygonHierarchy, points, boundary_nodes, tree::PolygonTree, p) -> PolygonTree\n\nFinds a tree in hierarchy containing p that is a child of tree, assuming p is inside tree.\n\nArguments\n\nhierarchy::PolygonHierarchy: The PolygonHierarchy to search.\npoints: The point set.\nboundary_nodes: The boundary nodes.\ntree::PolygonTree: The PolygonTree to search, assuming p is inside tree.\np: The point to test the children of tree against.\n\nOutput\n\ntree if p is inside tree but none of its children, and a child containing p otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bounding_box-Tuple{DelaunayTriangulation.PolygonHierarchy, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_bounding_box","text":"get_bounding_box(hierarchy::PolygonHierarchy, index) -> BoundingBox\n\nReturns the bounding box of the indexth polygon in hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_bounding_boxes-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_bounding_boxes","text":"get_bounding_boxes(hierarchy::PolygonHierarchy) -> Vector{BoundingBox}\n\nReturns the bounding boxes of hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_children-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.get_children","text":"get_children(tree::PolygonTree) -> Set{PolygonTree}\n\nReturns the children of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_exterior_curve_indices-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_exterior_curve_indices","text":"get_exterior_curve_indices(hierarchy::PolygonHierarchy) -> KeySet\n\nReturns the indices of the exterior curves of hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_height-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.get_height","text":"get_height(tree::PolygonTree) -> Int\n\nReturns the height of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_index-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.get_index","text":"get_index(tree::PolygonTree{I}) -> I\n\nReturns the index of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.get_parent","text":"get_parent(tree::PolygonTree) -> Union{Nothing,PolygonTree}\n\nReturns the parent of tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_orientation-Tuple{DelaunayTriangulation.PolygonHierarchy, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_orientation","text":"get_polygon_orientation(hierarchy::PolygonHierarchy, index) -> Bool\n\nReturns the polygon orientation of the indexth polygon in hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_orientations-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_orientations","text":"get_polygon_orientations(hierarchy::PolygonHierarchy) -> BitVector\n\nReturns the polygon orientations of hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_positive_curve_indices-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_positive_curve_indices","text":"get_positive_curve_indices(hierarchy::PolygonHierarchy) -> Generator\n\nReturns the indices of the positively oriented curves of hierarchy as a generator, i.e.  as a lazy result.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_reorder_cache-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_reorder_cache","text":"get_reorder_cache(hierarchy::PolygonHierarchy) -> Vector{PolygonTree{I}}\n\nReturns the reorder cache of hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_tree-Tuple{DelaunayTriangulation.PolygonHierarchy, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_tree","text":"get_tree(hierarchy::PolygonHierarchy, index) -> PolygonTree{I}\n\nReturns the PolygonTree of the indexth polygon in hierarchy. The index must be associated with  an exterior polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_trees-Tuple{DelaunayTriangulation.PolygonHierarchy}","page":"Data Structures","title":"DelaunayTriangulation.get_trees","text":"get_trees(hierarchy::PolygonHierarchy) -> Dict{I,PolygonTree{I}}\n\nReturns the trees of hierarchy, mapping the index of an exterior polygon to its PolygonTree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_children-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.has_children","text":"has_children(tree::PolygonTree) -> Bool\n\nReturns true if tree has children, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_parent-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.has_parent","text":"has_parent(tree::PolygonTree) -> Bool\n\nReturns true if tree has a parent, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.increase_depth!-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.increase_depth!","text":"increase_depth!(tree::PolygonTree)\n\nIncreases the height of tree and all of its children by 1.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_in_tree-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any, DelaunayTriangulation.PolygonTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_in_tree","text":"is_in_tree(hierarchy::PolygonHierarchy, points, boundary_nodes, tree::PolygonTree, p) -> Bool\n\nTests if the point p is inside tree.\n\nArguments\n\nhierarchy::PolygonHierarchy: The PolygonHierarchy containing tree.\npoints: The point set.\nboundary_nodes: The boundary nodes.\ntree::PolygonTree: The PolygonTree to test p against.\np: The point to test.\n\nOutput\n\ntrue if p is inside tree, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_children-Tuple{DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.num_children","text":"has_children(tree::PolygonTree) -> Bool\n\nReturns true if tree has children, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reorder_hierarchy!-Union{Tuple{I}, Tuple{DelaunayTriangulation.PolygonHierarchy{I}, Any, Any, DelaunayTriangulation.PolygonTree}} where I","page":"Data Structures","title":"DelaunayTriangulation.reorder_hierarchy!","text":"reorder_hierarchy!(hierarchy::PolygonHierarchy, points, boundary_nodes, new_tree::PolygonTree)\n\nGiven a new_tree that is not contained inside any other polygon in hierarchy, adds it into hierarchy. The existing trees are  checked to see if they are contained inside new_tree, and if so, they are added as children of new_tree and removed from hierarchy.\n\nArguments\n\nhierarchy::PolygonHierarchy: The PolygonHierarchy to add new_tree to.\npoints: The point set.\nboundary_nodes: The boundary nodes.\nnew_tree::PolygonTree: The PolygonTree to add to hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reorder_subtree!-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any, DelaunayTriangulation.PolygonTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.reorder_subtree!","text":"reorder_subtree!(hierarchy::PolygonHierarchy, points, boundary_nodes, tree::PolygonTree, new_tree)\n\nGiven a new_tree contained inside tree, adds it into hierarchy. The children of tree are reordered if necessary, in case  they are now contained inside new_tree.\n\nArguments\n\nhierarchy::PolygonHierarchy: The PolygonHierarchy to add new_tree to.\npoints: The point set.\nboundary_nodes: The boundary nodes.\ntree::PolygonTree: The PolygonTree to add new_tree to.\nnew_tree::PolygonTree: The PolygonTree to add to hierarchy and tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_bounding_box!-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_bounding_box!","text":"set_bounding_box!(hierarchy::PolygonHierarchy, index, bounding_box)\n\nSets the bounding box of the indexth polygon in hierarchy to bounding_box. If index is greater than the length of the bounding boxes vector, the vector is resized.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_height!-Tuple{DelaunayTriangulation.PolygonTree, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_height!","text":"set_height!(tree::PolygonTree, height::Int)\n\nSets the height of tree to height.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_orientation!-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_orientation!","text":"set_orientation!(hierarchy::PolygonHierarchy, index, orientation)\n\nSets the polygon orientation of the indexth polygon in hierarchy to orientation. If index is greater than the length of the polygon orientations vector, the vector is resized.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_parent!-Tuple{DelaunayTriangulation.PolygonTree, DelaunayTriangulation.PolygonTree}","page":"Data Structures","title":"DelaunayTriangulation.set_parent!","text":"set_parent!(tree::PolygonTree, parent::PolygonTree)\n\nSets the parent of tree to parent.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_tree!-Tuple{DelaunayTriangulation.PolygonHierarchy, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_tree!","text":"set_tree!(hierarchy::PolygonHierarchy, index, tree)\n\nSets the PolygonTree of the indexth polygon in hierarchy to tree, or adds it if it is not an existing key.  The index must be associated with an exterior polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Adjacent","page":"Data Structures","title":"Adjacent","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The Adjacent data structure is used for mapping edges to vertices (for triangulations) or polygons (for tessellations). The Adjacent structure itself is in the public API, as is get_adjacent.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Adjacent-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.Adjacent","text":"Adjacent{IntegerType, EdgeType}\n\nStruct for storing adjacency relationships for a triangulation.\n\nFields\n\nadjacent::Dict{EdgeType, IntegerType}\n\nThe map taking edges (u, v) to w such that (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\nConstructors\n\nAdjacent{IntegerType, EdgeType}()\nAdjacent(adjacent::Dict{EdgeType, IntegerType})\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(adj::Adjacent, uv, w)\nadd_adjacent!(adj::Adjacent, u, v, w)\n\nAdds the adjacency relationship (u, v, w) to adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent{Int64, NTuple{2, Int64}}();\n\njulia> DelaunayTriangulation.add_adjacent!(adj, 1, 2, 3)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 1 entry:\n  (1, 2) => 3\n\njulia> DelaunayTriangulation.add_adjacent!(adj, (2, 3), 1)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 2 entries:\n  (1, 2) => 3\n  (2, 3) => 1\n\njulia> DelaunayTriangulation.add_adjacent!(adj, 3, 1, 2)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, u, v, w)\nadd_triangle!(adj::Adjacent, T)\n\nAdds the adjacency relationships defined from the triangle T = (u, v, w) to adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent{Int32, NTuple{2, Int32}}();\n\njulia> add_triangle!(adj, 1, 2, 3)\nAdjacent{Int32, Tuple{Int32, Int32}}, with map:\nDict{Tuple{Int32, Int32}, Int32} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> add_triangle!(adj, 6, -1, 7)\nAdjacent{Int32, Tuple{Int32, Int32}}, with map:\nDict{Tuple{Int32, Int32}, Int32} with 6 entries:\n  (1, 2)  => 3\n  (3, 1)  => 2\n  (6, -1) => 7\n  (-1, 7) => 6\n  (2, 3)  => 1\n  (7, 6)  => -1\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(adj::Adjacent, uv)\ndelete_adjacent!(adj::Adjacent, u, v)\n\nDeletes the edge uv from adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent(Dict((2, 7) => 6, (7, 6) => 2, (6, 2) => 2, (17, 3) => -1, (-1, 5) => 17, (5, 17) => -1));\n\njulia> DelaunayTriangulation.delete_adjacent!(adj, 2, 7)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 5 entries:\n  (-1, 5) => 17\n  (17, 3) => -1\n  (6, 2)  => 2\n  (5, 17) => -1\n  (7, 6)  => 2\n\njulia> DelaunayTriangulation.delete_adjacent!(adj, (6, 2))\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (-1, 5) => 17\n  (17, 3) => -1\n  (5, 17) => -1\n  (7, 6)  => 2\n\njulia> DelaunayTriangulation.delete_adjacent!(adj, 5, 17)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (-1, 5) => 17\n  (17, 3) => -1\n  (7, 6)  => 2\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, u, v, w)\ndelete_triangle!(adj::Adjacent, T)\n\nDeletes the adjacency relationships defined from the triangle T = (u, v, w) from adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent{Int32, NTuple{2, Int32}}();\n\njulia> add_triangle!(adj, 1, 6, 7);\n\njulia> add_triangle!(adj, 17, 3, 5);\n\njulia> adj\nAdjacent{Int32, Tuple{Int32, Int32}}, with map:\nDict{Tuple{Int32, Int32}, Int32} with 6 entries:\n  (17, 3) => 5\n  (1, 6)  => 7\n  (6, 7)  => 1\n  (7, 1)  => 6\n  (5, 17) => 3\n  (3, 5)  => 17\n\njulia> delete_triangle!(adj, 3, 5, 17)\nAdjacent{Int32, Tuple{Int32, Int32}}, with map:\nDict{Tuple{Int32, Int32}, Int32} with 3 entries:\n  (1, 6) => 7\n  (6, 7) => 1\n  (7, 1) => 6\n\njulia> delete_triangle!(adj, 7, 1, 6)\nAdjacent{Int32, Tuple{Int32, Int32}}, with map:\nDict{Tuple{Int32, Int32}, Int32}()\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent) -> Dict\n\nReturns the adjacent map of adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> d = Dict((1, 2) => 3, (2, 3) => 1, (3, 1) => 2);\n\njulia> adj = DelaunayTriangulation.Adjacent(d)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj)\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj) == d\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent{I, E}, uv::E) -> Vertex\nget_adjacent(adj::Adjacent{I, E}, u, v) -> Vertex\n\nReturns the vertex w such that (u, v, w) is a positively oriented triangle in the underlying triangulation, or ∅ if no such triangle exists.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent(Dict((1, 2) => 3, (2, 3) => 1, (3, 1) => 2, (4, 5) => -1))\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (4, 5) => -1\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj, 4, 5)\n-1\n\njulia> get_adjacent(adj, (3, 1))\n2\n\njulia> get_adjacent(adj, (1, 2))\n3\n\njulia> get_adjacent(adj, 17, 5)\n0\n\njulia> get_adjacent(adj, (1, 6))\n0\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Adjacent2Vertex","page":"Data Structures","title":"Adjacent2Vertex","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The Adjacent2Vertex data structure is used for mapping vertices to edges for triangulations. The Adjacent2Vertex structure itself is in the public API, as is get_adjacent2vertex.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Adjacent2Vertex-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.Adjacent2Vertex","text":"Adjacent2Vertex{IntegerType, EdgesType}\n\nStruct for connectivity information about edges relative to vertices for a triangulation.\n\nFields\n\nadjacent2vertex::Dict{IntegerType, EdgesType}\n\nThe map taking w to the set of all (u, v) such that (u, v, w) is a positively oriented triangle in the underlying triangle.\n\nConstructors\n\nAdjacent2Vertex{IntegerType, EdgesType}()\nAdjacent2Vertex(adj2v::Dict{IntegerType, EdgesType})\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_adjacent2vertex!-Union{Tuple{Es}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent2Vertex{I, Es}, Any, Any}} where {I, Es}","page":"Data Structures","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(adj2v::Adjacent2Vertex, w, uv)\nadd_adjacent2vertex!(adj2v::Adjacent2Vertex, w, u, v)\n\nAdds the edge uv to the set of edges E such that (u, v, w) is a positively oriented triangle in the underlying triangulation for each (u, v) ∈ E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex{Int64, Set{NTuple{2, Int64}}}()\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}}()\n\njulia> DelaunayTriangulation.add_adjacent2vertex!(adj2v, 1, (2, 3))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 1 entry:\n  1 => Set([(2, 3)])\n\njulia> DelaunayTriangulation.add_adjacent2vertex!(adj2v, 1, 5, 7)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 1 entry:\n  1 => Set([(5, 7), (2, 3)])\n\njulia> DelaunayTriangulation.add_adjacent2vertex!(adj2v, 17, (5, -1))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  17 => Set([(5, -1)])\n  1  => Set([(5, 7), (2, 3)])\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj2v::Adjacent2Vertex, u, v, w)\nadd_triangle!(adj2v::Adjacent2Vertex, T)\n\nAdds the relationships defined by the triangle T = (u, v, w) into adj2v.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex{Int32, Set{NTuple{2, Int32}}}()\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}}()\n\njulia> add_triangle!(adj2v, 17, 5, 8)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 3 entries:\n  5  => Set([(8, 17)])\n  8  => Set([(17, 5)])\n  17 => Set([(5, 8)])\n\njulia> add_triangle!(adj2v, 1, 5, 13)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 5 entries:\n  5  => Set([(8, 17), (13, 1)])\n  13 => Set([(1, 5)])\n  8  => Set([(17, 5)])\n  17 => Set([(5, 8)])\n  1  => Set([(5, 13)])\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Data Structures","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj2v::Adjacent2Vertex)\n\nDeletes all vertices w from adj2v such that get_adjacent2vertex(adj2v, w) is empty.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex{Int64, Set{NTuple{2, Int64}}}()\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}}()\n\njulia> add_triangle!(adj2v, 1, 2, 3)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 3 entries:\n  2 => Set([(3, 1)])\n  3 => Set([(1, 2)])\n  1 => Set([(2, 3)])\n\njulia> delete_triangle!(adj2v, 2, 3, 1)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 3 entries:\n  2 => Set()\n  3 => Set()\n  1 => Set()\n\njulia> DelaunayTriangulation.clear_empty_keys!(adj2v)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}}()\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w, uv)\ndelete_adjacent2vertex!(adj2v::Adjacent2Vertex, w, u, v)\n\nDeletes the edge uv from the set of edges E such that (u, v, w) is a positively oriented triangle in the underlying triangulation for each (u, v) ∈ E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(Dict(1 => Set(((2, 3), (5, 7), (8, 9))), 5 => Set(((1, 2), (7, 9), (8, 3)))))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(1, 2), (8, 3), (7, 9)])\n  1 => Set([(8, 9), (5, 7), (2, 3)])\n\njulia> DelaunayTriangulation.delete_adjacent2vertex!(adj2v, 5, 8, 3)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(1, 2), (7, 9)])\n  1 => Set([(8, 9), (5, 7), (2, 3)])\n\njulia> DelaunayTriangulation.delete_adjacent2vertex!(adj2v, 1, (2, 3))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(1, 2), (7, 9)])\n  1 => Set([(8, 9), (5, 7)])\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w)\n\nDeletes the vertex w from adj2v.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(Dict(1 => Set(((2, 3), (5, 7))), 5 => Set(((-1, 2), (2, 3)))))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(-1, 2), (2, 3)])\n  1 => Set([(5, 7), (2, 3)])\n\njulia> DelaunayTriangulation.delete_adjacent2vertex!(adj2v, 1)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 1 entry:\n  5 => Set([(-1, 2), (2, 3)])\n\njulia> DelaunayTriangulation.delete_adjacent2vertex!(adj2v, 5)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}}()\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj2v::Adjacent2Vertex, u, v, w)\ndelete_triangle!(adj2v::Adjacent2Vertex, T)\n\nDeletes the relationships defined by the triangle T =(u, v, w) from adj2v.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex{Int32, Set{NTuple{2, Int32}}}()\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}}()\n\njulia> add_triangle!(adj2v, 1, 2, 3)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 3 entries:\n  2 => Set([(3, 1)])\n  3 => Set([(1, 2)])\n  1 => Set([(2, 3)])\n\njulia> add_triangle!(adj2v, 17, 5, 2)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 5 entries:\n  5  => Set([(2, 17)])\n  2  => Set([(3, 1), (17, 5)])\n  17 => Set([(5, 2)])\n  3  => Set([(1, 2)])\n  1  => Set([(2, 3)])\n\njulia> delete_triangle!(adj2v, 5, 2, 17)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 5 entries:\n  5  => Set()\n  2  => Set([(3, 1)])\n  17 => Set()\n  3  => Set([(1, 2)])\n  1  => Set([(2, 3)])\n\njulia> delete_triangle!(adj2v, 2, 3, 1)\nAdjacent2Vertex{Int32, Set{Tuple{Int32, Int32}}} with map:\nDict{Int32, Set{Tuple{Int32, Int32}}} with 5 entries:\n  5  => Set()\n  2  => Set()\n  17 => Set()\n  3  => Set()\n  1  => Set()\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex, w) -> Edges\n\nReturns the set of edges E such that (u, v, w) is a positively oriented triangle in the underlying triangulation for each (u, v) ∈ E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(Dict(1 => Set(((2, 3), (5, 7), (8, 9))), 5 => Set(((1, 2), (7, 9), (8, 3)))))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(1, 2), (8, 3), (7, 9)])\n  1 => Set([(8, 9), (5, 7), (2, 3)])\n\njulia> get_adjacent2vertex(adj2v, 1)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (8, 9)\n  (5, 7)\n  (2, 3)\n\njulia> get_adjacent2vertex(adj2v, 5)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (8, 3)\n  (7, 9)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex) -> Dict\n\nReturns the adjacent2vertex map of adj2v.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e1 = Set(((1, 2), (5, 3), (7, 8)));\n\njulia> e2 = Set(((2, 3), (13, 5), (-1, 7)));\n\njulia> d = Dict(9 => e1, 6 => e2);\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(d)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  6 => Set([(13, 5), (-1, 7), (2, 3)])\n  9 => Set([(1, 2), (7, 8), (5, 3)])\n\njulia> get_adjacent2vertex(adj2v)\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  6 => Set([(13, 5), (-1, 7), (2, 3)])\n  9 => Set([(1, 2), (7, 8), (5, 3)])\n\njulia> get_adjacent2vertex(adj2v) == d\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Graph","page":"Data Structures","title":"Graph","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The Graph data structure is used for storing connectivity information about vertices in a triangulation. The Graph structure itself is in the public API, as is get_graph and get_neighbours.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Graph-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.Graph","text":"Graph{IntegerType}\n\nStruct for storing neighbourhood relationships between vertices in a triangulation. This is an undirected graph.\n\nFields\n\nvertices::Set{IntegerType}\n\nThe set of vertices in the underlying triangulation.\n\nedges::Set{NTuple{2, IntegerType}}\n\nThe set of edges in the underlying triangulation.\n\nneighbours::Dict{IntegerType, Set{IntegerType}}\n\nThe map taking vertices u to the set of all v such that (u, v) is an edge in the underlying triangulation.\n\nConstructors\n\nGraph{IntegerType}()\nGraph(vertices::Set{IntegerType}, edges::Set{NTuple{2, IntegerType}}, neighbours::Dict{IntegerType, Set{IntegerType}})\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation._delete!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation._delete!","text":"_delete!(G::Graph, u, v)\n\nDeletes the neighbour v from u in G. If the neighbours of u are empty once v is deleted, then u is also deleted from the vertex set.\n\nwarning: Undirected graph\nEven though the graph is undirected, this function only deletes v from the neighbours of u. If you want to delete u from the neighbours of v, you should call delete_neighbour!(G, v, u).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_edge!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(G::Graph, u, v)\n\nAdds the edge (u, v) to G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(G::Graph, u, v...)\n\nAdds the neighbours v... to u in G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Graph, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, u, v, w)\nadd_triangle!(G::Graph, T)\n\nAdds the neighbourhood relationships defined by the triangle T = (u, v, w) to the graph G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_vertex!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(G::Graph, u...)\n\nAdds the vertices u... to G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.clear_empty_vertices!-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.clear_empty_vertices!","text":"clear_empty_vertices!(G::Graph)\n\nDeletes all empty vertices from G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_edge!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(G::Graph, u, v)\n\nDeletes the edge (u, v) from G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_ghost_vertices_from_graph!-Union{Tuple{DelaunayTriangulation.Graph{I}}, Tuple{I}} where I","page":"Data Structures","title":"DelaunayTriangulation.delete_ghost_vertices_from_graph!","text":"delete_ghost_vertices!(G::Graph)\n\nDeletes all ghost vertices from G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(G::Graph, u, v...)\n\nDeletes the neighbours v... from u in G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Graph, Integer, Integer, Integer}","page":"Data Structures","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, u, v, w)\ndelete_triangle!(G::Graph, T)\n\nDeletes the neighbourhood relationships defined by the triangle T = (u, v, w) from the graph G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_vertex!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(G::Graph, u...)\n\nDeletes the vertices u... from G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_edges-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.get_edges","text":"get_edges(graph::Graph) -> Set{NTuple{2, Vertex}}\n\nReturns the set of edges in graph.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph, u) -> Set{Vertex}\n\nReturns the set of neighbours of u in G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(graph::Graph) -> Dict{Vertex, Set{Vertex}}\n\nReturns the neighbours map of graph.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(graph::Graph) -> Set{Vertex}\n\nReturns the set of vertices in graph.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_ghost_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.has_ghost_vertices","text":"has_ghost_vertices(G::Graph) -> Bool\n\nReturns true if G has ghost vertices, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_vertex-Tuple{DelaunayTriangulation.Graph, Any}","page":"Data Structures","title":"DelaunayTriangulation.has_vertex","text":"has_vertex(G::Graph, u) -> Bool\n\nReturns true if u is a vertex in G, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.num_edges","text":"num_edges(G::Graph) -> Integer\n\nReturns the number of edges in G. The   edges (i, j) and (j, i) are counted as one edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Data Structures","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(G::Graph, u) -> Integer\n\nReturns the number of neighbours of u in G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Data Structures","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(G::Graph) -> Integer\n\nReturns the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Curves","page":"Data Structures","title":"Curves","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"There are many data structures used to define the curves we provide in this package, all subtyping the AbstractParametricCurve type. This type, and its subtypes, are all in the public API with the exception of PiecewiseLinear.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractParametricCurve-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.AbstractParametricCurve","text":"abstract type AbstractParametricCurve <: Function end\n\nAbstract type for representing a parametric curve parametrised over 0 ≤ t ≤ 1. The curves represented by this  abstract type should not be self-intersecting, with the exception of allowing for closed curves.\n\nThe structs that subtype this abstract type must implement are:\n\ndifferentiate.\ntwice_differentiate.\nthrice_differentiate (only if you have not manually defined total_variation).\nThe struct must be callable so that c(t), where c an instance of the struct, returns the associated value of the curve at t.\nIf the struct does not implement point_position_relative_to_curve, then the struct must implement get_closest_point. Alternatively,  rather than implementing get_closest_point, the struct should have a lookup_table field as a Vector{NTuple{2,Float64}}, which returns values on the curve at a set of points,   where lookup_table[i] is the value of the curve at t = (i - 1) / (length(lookup_table) - 1).\n\nFunctions that are defined for all AbstractParametricCurve subtypes are:\n\narc_length\ncurvature\ntotal_variation\n\nnote: Efficiently computing the total variation\nThe curves in this package evaluate the total variation not by evaluating the integral itself, but by taking care of the changes in orientation in the curve to efficiently compute it. This is done by using the orientation markers of the curves, obtained using orientation_markers, that stored in the field  orientation_markers of these curves. The function marked_total_variation is then used to evaluate it. You may like to consider using these functions for  any curve you wish to implement yourself, using e.g. the BezierCurve struct's implementation as a reference.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.LineSegment-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.LineSegment","text":"LineSegment <: AbstractParametricCurve\n\nCurve for representing a line segment, parametrised over 0 ≤ t ≤ 1. This curve can be using  line_segment(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\nfirst::NTuple{2,Float64}: The first point of the line segment.\nlast::NTuple{2,Float64}: The last point of the line segment.\nlength::Float64: The length of the line segment.\n\nConstructor\n\nYou can construct a LineSegment using \n\nLineSegment(first, last)\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.CircularArc-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.CircularArc","text":"CircularArc <: AbstractParametricCurve\n\nCurve for representing a circular arc, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using circular_arc(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\ncenter::NTuple{2,Float64}: The center of the arc.\nradius::Float64: The radius of the arc.\nstart_angle::Float64: The angle of the initial point of the arc, in radians.\nsector_angle::Float64: The angle of the sector of the arc, in radians. This is given by end_angle - start_angle, where end_angle is the angle at last, and so might be negative for negatively oriented arcs.\nfirst::NTuple{2,Float64}: The first point of the arc.\nlast::NTuple{2,Float64}: The last point of the arc.\npqr::NTuple{3, NTuple{2, Float64}}: Three points on the circle through the arc. This is needed for point_position_relative_to_curve.\n\nwarning: Orientation\nThe angles start_angle and end_angle should be setup such that start_angle > end_angle implies a positively oriented arc,  and start_angle < end_angle implies a negatively oriented arc. Moreover, they must be in [0°, 2π°).\n\nConstructor\n\nYou can construct a CircularArc using \n\nCircularArc(first, last, center; positive=true)\n\nIt is up to you to ensure that first and last are equidistant from center - the radius used will be the  distance between center and first. The positive keyword argument is used to determine if the  arc is positively oriented or negatively oriented.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EllipticalArc-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.EllipticalArc","text":"EllipticalArc <: AbstractParametricCurve\n\nCurve for representing an elliptical arc, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated using elliptical_arc(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFields\n\ncenter::NTuple{2,Float64}: The center of the ellipse.\nhorz_radius::Float64: The horizontal radius of the ellipse. \nvert_radius::Float64: The vertical radius of the ellipse.\nrotation_scales::NTuple{2,Float64}: If θ is the angle of rotation of the ellipse, then this is (sin(θ), cos(θ)).\nstart_angle::Float64: The angle of the initial point of the arc measured from center, in radians. This angle is measured from the center prior to rotating the ellipse.\nsector_angle::Float64: The angle of the sector of the arc, in radians. This is given by end_angle - start_angle, where end_angle is the angle at last, and so might be negative for negatively oriented arcs.\nfirst::NTuple{2,Float64}: The first point of the arc.\nlast::NTuple{2,Float64}: The last point of the arc.\n\nConstructor\n\nYou can construct an EllipticalArc using \n\nEllipticalArc(first, last, center, major_radius, minor_radius, rotation; positive=true)\n\nwhere rotation is the angle of rotation of the ellipse, in degrees. The positive keyword argument is used to determine if the  arc is positively oriented or negatively oriented.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BezierCurve-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.BezierCurve","text":"BezierCurve <: AbstractParametricCurve\n\nCurve for representing a Bezier curve, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated using bezier_curve(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nA good reference on Bezier curves is this.\n\nSee also BSpline and CatmullRomSpline.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\ndanger: Interpolation\nRemember that Bezier curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. If you want an interpolation curve, use CatmullRomSpline.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the Bezier curve. The curve goes through the first and last control points, but not the intermediate ones.\ncache::Vector{NTuple{2,Float64}}: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Casteljau's algorithm. \nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the Bezier curve, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nwarning: Concurrency\nThe cache is not thread-safe, and so you should not evaluate this curve in parallel.\n\nConstructor\n\nYou can construct a BezierCurve using \n\nBezierCurve(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps=100 controls how many time points in [0, 1] are used for the lookup table. The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.BSpline-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.BSpline","text":"BSpline <: AbstractParametricCurve\n\nCurve for representing a BSpline, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using b_spline(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nSee also BezierCurve and CatmullRomSpline.\n\nOur implementation of a BSpline is based on https://github.com/thibauts/b-spline.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\ndanger: Interpolation\nRemember that B-spline curves are not interpolation curves. They only go through the first and last control points, but not the intermediate ones. For an interpolating spline, see CatmullRomSpline.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the BSpline. The curve goes through the first and last control points, but not the intermediate ones. \nknots::Vector{Int}: The knots of the BSpline. You should not modify or set this field directly (in particular, do not expect any support for non-uniform B-splines).\ncache::Vector{NTuple{2,Float64}}: A cache of the points on the curve. This is used to speed up evaluation of the curve using de Boor's algorithm.\nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the B-spline curve, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nConstructor\n\nYou can construct a BSpline using \n\nBSpline(control_points::Vector{NTuple{2,Float64}}; degree=3, lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps is used to build the lookup table for the curve. Note that the default  degree=3 corresponds to a cubic B-spline curve. The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.CatmullRomSpline-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.CatmullRomSpline","text":"CatmullRomSpline <: AbstractParametricCurve\n\nCurve for representing a Catmull-Rom spline, parametrised over 0 ≤ t ≤ 1. This curve can be evaluated  using catmull_rom_spline(t) and returns a tuple (x, y) of the coordinates of the point on the curve at t.\n\nFor information on these splines, see e.g. this article and this article. Additionally, this article lists some nice properties of these splines.\n\ndanger: Loops\nThis curve is only tested on loop-free curves (and closed curves that otherwise have no self-intersections). It is not guaranteed to work on curves with loops, especially for finding the nearest point on the curve to a given point.\n\nnote: Extension\nTypically, Catmull-Rom splines are defined on segments of four control points, and drawn between the two interior control points. This creates an issue in that the first and last control points will not be joined to the spline. To overcome this, we extend the spline to the left and right during the evaluation of a spline, using the fields left and right defined below. The rules used for extending these points come from CatmullRom.jl, which extrapolates based on a Thiele-like cubic polynomial.\n\nFields\n\ncontrol_points::Vector{NTuple{2,Float64}}: The control points of the Catmull-Rom spline. The curve goes through each point.\nknots::Vector{Float64}: The parameter values of the Catmull-Rom spline. The ith entry of this vector corresponds to the t-value associated with the ith control point.   With an alpha parameter α, these values are given by knots[i+1] = knots[i] + dist(control_points[i], control_points[i+1])^α, where knots[1] = 0,   and the vector is the normalised by dividing by knots[end].\nlookup_table::Vector{NTuple{2,Float64}}: A lookup table for the Catmull-Rom spline, used for finding the point on the curve closest to a given point. The ith entry of the lookup table  corresponds to the t-value i / (length(lookup_table) - 1).\nalpha::Float64: The alpha parameter of the Catmull-Rom spline. This controls the type of the parametrisation, where alpha = 0 corresponds to uniform parametrisation,   alpha = 1/2 corresponds to centripetal parametrisation, and alpha = 1 corresponds to chordal parametrisation. Must be in [0, 1]. For reasons similar to what we describe for tension below, we only support    alpha = 1/2 for now. (If you do really want to change it, use the _alpha keyword argument in the constructor.)\ntension::Float64: The tension parameter of the Catmull-Rom spline. This controls the tightness of the spline, with tension = 0 being the least tight, and tension = 1 leading to straight lines between the control points. Must be in [0, 1].   You can not currently set this to anything except 0.0 due to numerical issues with boundary refinement. (For example, equivariation splits are not possible if tension=1 since   the curve is piecewise linear in that case, and for tension very close to 1, the equivariation split is not always between the provided times. If you really want to change it, then you   can use the _tension keyword argument in the constructor - but be warned that this may lead to numerical issues and potentially infinite loops.)\nleft::NTuple{2,Float64}: The left extension of the spline. This is used to evaluate the spline on the first segment.\nright::NTuple{2,Float64}: The right extension of the spline. This is used to evaluate the spline on the last segment.\nlengths::Vector{Float64}: The lengths of the individual segments of the spline.\nsegments::Vector{CatmullRomSplineSegment}: The individual segments of the spline.\norientation_markers::Vector{Float64}: The orientation markers of the curve. These are defined so that the orientation of the curve is monotone between any two consecutive markers. The first and last markers are always 0 and 1, respectively. See orientation_markers.\n\nConstructor\n\nTo construct a CatmullRomSpline, use \n\nCatmullRomSpline(control_points::Vector{NTuple{2,Float64}}; lookup_steps=5000, kwargs...)\n\nThe keyword argument lookup_steps is used to build the lookup table for the curve, with lookup_steps giving the number of time points in [0, 1] used for the lookup table.  The kwargs... are keyword arguments passed to orientation_markers.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.twice_differentiate-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.twice_differentiate","text":"twice_differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the second derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.total_variation-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.total_variation","text":"total_variation(c::AbstractParametricCurve) -> Float64\ntotal_variation(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns the total variation of a curve c, or the subcurve over [t₁, t₂] with 0 ≤ t₁ ≤ t₂ ≤ 1, defined as the integral of the absolute curvature over this interval. (This is also known as the total absolute curvature.)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.thrice_differentiate-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.thrice_differentiate","text":"thrice_differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the third derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.differentiate-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.differentiate","text":"differentiate(c::AbstractParametricCurve, t) -> NTuple{2, Float64}\n\nEvaluates the derivative of c at t.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.arc_length-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.arc_length","text":"arc_length(c::AbstractParametricCurve) -> Float64\narc_length(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns the arc length of the [AbstractParametricCurve] c. The second method returns the arc length in the interval [t₁, t₂], where 0 ≤ t₁ ≤ t₂ ≤ 1.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#Base.reverse-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"Base.reverse","text":"reverse(curve::AbstractParametricCurve) -> AbstractParametricCurve\n\nReturns an AbstractParametricCurve that reverses the orientation of curve. In particular,  c(t) = c̄(1-t) for all t in [0, 1], where c is the original curve and c̄ is the reversed curve.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._get_interval_for_get_circle_intersection-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation._get_interval_for_get_circle_intersection","text":"_get_interval_for_get_circle_intersection(c::AbstractParametricCurve, t₁, t₂, r) -> (Float64, Float64, NTuple{2, Float64})\n\nGiven a circle centered at c(t₁) with radius r, finds an initial interval for get_circle_intersection to perform bisection on to find a point of intersection. The returned interval is (tᵢ, tⱼ),  where tᵢ is the parameter value of the first point in the interval and tⱼ  is the parameter value of the last point in the interval. (The interval does not have to be sorted.) The third returned value is p = c(t₁).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.angle_between-Tuple{DelaunayTriangulation.AbstractParametricCurve, DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.angle_between","text":"angle_between(c₁::AbstractParametricCurve, c₂::AbstractParametricCurve) -> Float64\n\nGiven two curves c₁ and c₂ such that c₁(1) == c₂(0), returns the angle between the two curves, treating the interior of the  curves as being left of both.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.convert_lookup_idx-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any}","page":"Data Structures","title":"DelaunayTriangulation.convert_lookup_idx","text":"convert_lookup_idx(b::AbstractParametricCurve, i) -> Float64\n\nConverts the index i of the lookup table of the curve b to the corresponding t-value.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.curvature-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any}","page":"Data Structures","title":"DelaunayTriangulation.curvature","text":"curvature(c::AbstractParametricCurve, t) -> Float64\n\nReturns the curvature of the [AbstractParametricCurve] c at t.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circle_intersection-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_circle_intersection","text":"get_circle_intersection(c::AbstractParametricCurve, t₁, t₂, r) -> (Float64, NTuple{2,Float64})\n\nGiven a circle centered at c(t₁) with radius r, finds the first intersection of the circle with  the curve after t₁ and less than t₂. It is assumed that such an intersection exists. The returned value  is (t, q), where t is the parameter value of the intersection and q is the point of intersection.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_closest_point-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_closest_point","text":"get_closest_point(b::AbstractParametricCurve p) -> (Float64, NTuple{2,Float64})\n\nReturns the t-value and the associated point q on the curve b that is nearest to p using a binary search. The search is done until the  binary search interval is smaller than 1e-12. This function will only work if the curve b has a lookup table.\n\ndanger: Loops\nThis function is only tested on loop-free curves. It is not guaranteed to work on curves with loops. Moreover, for this function to be accurate,  you want the lookup table in b to be sufficiently dense.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_equidistant_split-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_equidistant_split","text":"get_equidistant_split(c::AbstractParametricCurve, t₁, t₂) -> Float64\n\nReturns a value of t such that the arc length along c from t₁ to t is equal to the arc length along c from t to t₂.  Uses the bisection method to compute the t-value.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_equivariation_split-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_equivariation_split","text":"get_equivariation_split(c::AbstractParametricCurve, t₁, t₂) -> Float64, Float64\n\nReturns a value of t such that the total variation of c from t₁ to t is equal to the total variation of c from t to t₂. Uses the bisection method to compute the t-value. Also returns the new total variation of the two pieces.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_inverse-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_inverse","text":"get_inverse(c::AbstractParametricCurve, p) -> Float64\n\nGiven a point p on c, returns the t-value such that c(t) ≈ p.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_lookup_table-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.has_lookup_table","text":"has_lookup_table(c::AbstractParametricCurve) -> Bool\n\nReturns true if c has a lookup table, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.horizontal_inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.horizontal_inflection_points","text":"horizontal_inflection_points(c::AbstractParametricCurve; steps=200, iters = 50, tol = 1e-5) -> Vector{Float64}\n\nReturns points t such that x''(t) = 0 and 0 ≤ t ≤ 1, where x'' is the second derivative of the x-coordinate of c. This function uses Newton's method to find the roots of x''. Note that these are only technically inflection points if x'''(t) ≠ 0 at these points, but this is not checked.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  inflection points.\n\nArguments\n\nc::AbstractParametricCurve: The curve to find the horizontal inflection points of.\n\nKeyword Arguments\n\nsteps=200: The number of t-values to use for seeding Newton's method. In particular, Newton's method is run for each initial value in LinRange(0, 1, steps).\niters=50: The number of iterations to run Newton's method for.\ntol=1e-5: The tolerance to use for uniquetol. Also used for deciding whether a root is a valid root, i.e. if abs(x''(t)) > tol for a found root t, then t is not a valid root and is rejected.\n\nOutput\n\nt: All inflection points, given in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.horizontal_turning_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.horizontal_turning_points","text":"horizontal_turning_points(c::AbstractParametricCurve; steps=200, iters = 50, tol = 1e-5) -> Vector{Float64}\n\nReturns points t such that x'(t) = 0 and 0 ≤ t ≤ 1, where x' is the derivative of the x-coordinate of c. This function uses Newton's method to find the roots of x'.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  turning points.\n\nArguments\n\nc::AbstractParametricCurve: The curve to find the horizontal turning points of.\n\nKeyword Arguments\n\nsteps=200: The number of t-values to use for seeding Newton's method. In particular, Newton's method is run for each initial value in LinRange(0, 1, steps).\niters=50: The number of iterations to run Newton's method for.\ntol=1e-5: The tolerance to use for uniquetol. Also used for deciding whether a root is a valid root, i.e. if abs(x'(t)) > tol for a found root t, then t is not a valid root and is rejected.\n\nOutput\n\nt: All turning points, given in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.inflection_points","text":"inflection_points(c::AbstractParametricCurve; steps=200, iters = 50, tol = 1e-5) -> Vector{Float64}\n\nReturns points t such that κ(t) = 0 and 0 ≤ t ≤ 1, where κ is the curvature of c. This function uses Newton's method to find the roots of κ.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  inflection points.\n\nArguments\n\nc::AbstractParametricCurve: The curve to find the inflection points of.\n\nKeyword Arguments\n\nsteps=200: The number of t-values to use for seeding Newton's method. In particular, Newton's method is run for each initial value in LinRange(0, 1, steps).\niters=50: The number of iterations to run Newton's method for.\ntol=1e-5: The tolerance to use for uniquetol. Also used for deciding whether a root is a valid root, i.e. if abs(κ(t)) > tol for a found root t, then t is not a valid root and is rejected.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_curve_bounded-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.is_curve_bounded","text":"is_curve_bounded(c::AbstractParametricCurve) -> Bool\n\nReturns true if c is not a PiecewiseLinear curve. This is equivalent to !is_piecewise_linear(c).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_interpolating-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.is_interpolating","text":"is_interpolating(c::AbstractParametricCurve) -> Bool\n\nReturns true if c goes through all its control points, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_linear-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.is_linear","text":"is_linear(c::AbstractParametricCurve) -> Bool\n\nReturns true if c is LineSegment, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_piecewise_linear-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.is_piecewise_linear","text":"is_piecewise_linear(c::AbstractParametricCurve) -> Bool\n\nReturns true if c is PiecewiseLinear, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.marked_total_variation-Tuple{DelaunayTriangulation.AbstractParametricCurve, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.marked_total_variation","text":"marked_total_variation(b::AbstractParametricCurve, t₁, t₂)\n\nReturns the total variation of the curve b over the interval [t₁, t₂] using the orientation markers of b.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.orientation_markers-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.orientation_markers","text":"orientation_markers(c::AbstractParametricCurve; steps=200, iters=50, tol=1e-5) -> Vector{Float64}\n\nFinds all orientation markers of the AbstractParametricCurve c. These are points t where any of the following  conditions hold (not necessarily simultaneously), letting c(t) = (x(t), y(t)):\n\nx'(t) = 0\ny'(t) = 0\nκ(t; x) = 0, where κ(t; x) is the curvature of the component function x(t)\nκ(t; y) = 0, where κ(t; y) is the curvature of the component function y(t)\nκ(t) = 0, where κ is the curvature of c(t)\n\nNote that the third and fourth conditions give all the inflection points of the component functions, and similarly for the fifth condition.\n\nSee also horizontal_turning_points, vertical_turning_points, horizontal_inflection_points, vertical_inflection_points, and inflection_points.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  inflection points.\n\nArguments\n\nc::AbstractParametricCurve: The AbstractParametricCurve.\n\nKeyword Arguments\n\nsteps=200: The number of equally spaced points to use for initialising Newton's method.\niters=50: How many iterations to use for Newton's method.\ntol=1e-5: The tolerance used for determining if two t-values are the same.\n\nOutput\n\nmarkers::Vector{Float64}: The t-values of the orientation markers of b. The returned vector is sorted, and also includes the   endpoints 0 and 1; any t-values outside of [0, 1] are discarded, and multiplicity   of any t is not considered (so the t-values in the returned vector are unique). These values can be used to split the curve into monotone pieces, meaning   the orientation is monotone. These markers also guarantee that, over any monotone piece, the orientation changes by an angle of at most π/2.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.point_position_relative_to_curve-Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.AbstractParametricCurve, Any}","page":"Data Structures","title":"DelaunayTriangulation.point_position_relative_to_curve","text":"point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] e::AbstractParametricCurve, p) -> Certificate\n\nReturns the position of the point p relative to the curve c. This function returns a [Certificate]:\n\nLeft: p is to the left of c.\nRight: p is to the right of c.\nOn: p is on c.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.process_roots_and_residuals!-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.process_roots_and_residuals!","text":"process_roots_and_residuals!(roots, residuals, tol) -> Vector{Float64}\n\nProcesses the roots and residuals of a root-finding algorithm. This function removes all NaN values from roots and residuals, sorts the roots in ascending order, and removes all roots with residuals greater than tol. The  returned vector is the vector of roots with duplicates (i.e. roots that are within tol of each other) removed.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.protect_against_bad_division!-NTuple{4, Any}","page":"Data Structures","title":"DelaunayTriangulation.protect_against_bad_division!","text":"protect_against_bad_division!(roots, residuals, val, i) -> Bool\n\nProtects against bad division in root-finding algorithms. This function checks if val is close to 0 or if roots[i] is outside of [0, 1]. If either of these conditions are true, then roots[i] and residuals[i] are set to NaN and true is returned. Otherwise, false is returned.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.vertical_inflection_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.vertical_inflection_points","text":"vertical_inflection_points(c::AbstractParametricCurve; steps=200, iters = 50, tol = 1e-5) -> Vector{Float64}\n\nReturns points t such that y''(t) = 0 and 0 ≤ t ≤ 1, where y'' is the second derivative of the y-coordinate of c. This function uses Newton's method to find the roots of y''. Note that these are only technically inflection points if y'''(t) ≠ 0 at these points, but this is not checked.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  inflection points.\n\nArguments\n\nc::AbstractParametricCurve: The curve to find the vertical inflection points of.\n\nKeyword Arguments\n\nsteps=200: The number of t-values to use for seeding Newton's method. In particular, Newton's method is run for each initial value in LinRange(0, 1, steps).\niters=50: The number of iterations to run Newton's method for.\ntol=1e-5: The tolerance to use for uniquetol. Also used for deciding whether a root is a valid root, i.e. if abs(y''(t)) > tol for a found root t, then t is not a valid root and is rejected.\n\nOutput\n\nt: All inflection points, given in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.vertical_turning_points-Tuple{DelaunayTriangulation.AbstractParametricCurve}","page":"Data Structures","title":"DelaunayTriangulation.vertical_turning_points","text":"vertical_turning_points(c::AbstractParametricCurve; steps=200, iters = 50, tol = 1e-5) -> Vector{Float64}\n\nReturns points t such that y'(t) = 0 and 0 ≤ t ≤ 1, where y' is the derivative of the y-coordinate of c. This function uses Newton's method to find the roots of y'.\n\ndanger: High-degree curves\nFor curves of very high degree, such as Bezier curves with steps control points or greater, this function might fail to return all  turning points.\n\nArguments\n\nc::AbstractParametricCurve: The curve to find the vertical turning points of.\n\nKeyword Arguments\n\nsteps=200: The number of t-values to use for seeding Newton's method. In particular, Newton's method is run for each initial value in LinRange(0, 1, steps).\niters=50: The number of iterations to run Newton's method for.\ntol=1e-5: The tolerance to use for uniquetol. Also used for deciding whether a root is a valid root, i.e. if abs(y'(t)) > tol for a found root t, then t is not a valid root and is rejected.\n\nOutput\n\nt: All turning points, given in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.CatmullRomSplineSegment","page":"Data Structures","title":"DelaunayTriangulation.CatmullRomSplineSegment","text":"CatmullRomSplineSegment <: AbstractParametricCurve\n\nA single segment of a Camtull-Rom spline, representing by a cubic polynomial. Note that evaluating this curve will only  draw within the two interior control points of the spline.\n\nBased on this article.\n\nFields\n\na::NTuple{2,Float64}: The coefficient on t³.\nb::NTuple{2,Float64}: The coefficient on t².\nc::NTuple{2,Float64}: The coefficient on t.\nd::NTuple{2,Float64}: The constant in the polynomial.\np₁::NTuple{2,Float64}: The second control point of the segment.\np₂::NTuple{2,Float64}: The third control point of the segment.\n\nWith these fields, the segment is parametrised over 0 ≤ t ≤ 1 by q(t), where \n\nq(t) = at³ + bt² + ct + d,\n\nand q(0) = p₁ and q(1) = p₂, where the segment is defined by four control points p₀, p₁, p₂, and p₃.\n\nThis struct is callable, returning the interpolated point (x, y) at t as a NTuple{2,Float64}.\n\nConstructor\n\nTo construct this segment, use \n\ncatmull_rom_spline_segment(p₀, p₁, p₂, p₃, α, τ)\n\nHere, p₀, p₁, p₂, and p₃ are the four points of the segment (not a, b, c, and d), and α and τ are the parameters of the spline. The parameter α  controls the type of the parametrisation, where\n\nα = 0: Uniform parametrisation.\nα = 1/2: Centripetal parametrisation.\nα = 1: Chordal parametrisation.\n\nThe parameter τ is the tension, and controls the tightness of the segment. τ = 0 is the least tight, while τ = 1 leads to straight lines between the  control points. Both α and τ must be in [0, 1].\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.get_segment-Tuple{CatmullRomSpline, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_segment","text":"get_segment(c::CatmullRomSpline, t) -> (CatmullRomSplineSegment, Int)\n\nReturns the CatmullRomSplineSegment of the CatmullRomSpline c that contains the point at t. Also  returns the segment index. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.angle_between-Tuple{LineSegment, LineSegment}","page":"Data Structures","title":"DelaunayTriangulation.angle_between","text":"angle_between(L₁::LineSegment, L₂::LineSegment) -> Float64\n\nReturns the angle between L₁ and L₂, assuming that L₁.last == L₂.first (this is not checked). For consistency with  If the segments are part of some domain, then the line segments should be oriented so that the interior is to the left of both segments.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.point_position_relative_to_curve-Tuple{DelaunayTriangulation.AbstractPredicateKernel, LineSegment, Any}","page":"Data Structures","title":"DelaunayTriangulation.point_position_relative_to_curve","text":"point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] L::LineSegment, p) -> Certificate\n\nReturns the position of p relative to L, returning a Certificate:\n\nLeft: p is to the left of L.\nRight: p is to the right of L.\nOn: p is on L.\n\nSee also point_position_relative_to_line.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.PiecewiseLinear","page":"Data Structures","title":"DelaunayTriangulation.PiecewiseLinear","text":"PiecewiseLinear <: AbstractParametricCurve\n\nStruct for representing a piecewise linear curve. This curve should not be  interacted with or constructed directly. It only exists so that it can be  an AbstractParametricCurve. Instead, triangulations use this curve to  know that its boundary_nodes field should be used instead.\n\ndanger: Existing methods\nThis struct does have fields, namely points and boundary_nodes (and boundarynodes should be a contiguous section). These are only used so that  we can use this struct in [`anglebetween](@ref) easily. In particular, we need to allow  for evaluating this curve att=0and att=1, and similarly for differentiating the curve att=0and att=1. For this, we have defined, lettingLbe aPiecewiseLinearcurve,L(0)to return the first point  on the curve, and the last point otherwise (meaningL(h)is constant forh > 0`), and similarly for differentiation. Do NOT rely on the implementation of these methods.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#RepresentativeCoordinates","page":"Data Structures","title":"RepresentativeCoordinates","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a RepresentativeCoordinates struct for storing the representative coordinates used for interpreting ghost vertices.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.RepresentativeCoordinates","page":"Data Structures","title":"DelaunayTriangulation.RepresentativeCoordinates","text":"RepresentativeCoordinates{IntegerType, NumberType}\n\nA mutable struct for representing the coordinates of a representative point of polygon or a set of points. \n\nFields\n\nx::NumberType: The x-coordinate of the representative point.\ny::NumberType: The y-coordinate of the representative point.\nn::IntegerType: The number of points represented by the representative point.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_point!-Tuple{DelaunayTriangulation.RepresentativeCoordinates, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_point!","text":"add_point!(c::RepresentativeCoordinates, p)\n\nTreating c as an arithmetic average, updates the coordinates of c to include p.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compute_centroid!-Tuple{DelaunayTriangulation.RepresentativeCoordinates, Any}","page":"Data Structures","title":"DelaunayTriangulation.compute_centroid!","text":"compute_centroid!(c::RepresentativeCoordinates, points)\n\nComputes the centroid of points and stores the result in c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_point!-Tuple{DelaunayTriangulation.RepresentativeCoordinates, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_point!","text":"delete_point!(c::RepresentativeCoordinates, p)\n\nTreating c as an arithmetic average, updates the coordinates of c to exclude p.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getn-Tuple{DelaunayTriangulation.RepresentativeCoordinates}","page":"Data Structures","title":"DelaunayTriangulation.getn","text":"getn(c::RepresentativeCoordinates) -> Integer\n\nReturns the number of points represented by c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getx-Tuple{DelaunayTriangulation.RepresentativeCoordinates}","page":"Data Structures","title":"DelaunayTriangulation.getx","text":"getx(c::RepresentativeCoordinates) -> Number\n\nReturns the x-coordinate of c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.gety-Tuple{DelaunayTriangulation.RepresentativeCoordinates}","page":"Data Structures","title":"DelaunayTriangulation.gety","text":"gety(c::RepresentativeCoordinates) -> Number\n\nReturns the y-coordinate of c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reset!-Union{Tuple{DelaunayTriangulation.RepresentativeCoordinates{I, T}}, Tuple{T}, Tuple{I}} where {I, T}","page":"Data Structures","title":"DelaunayTriangulation.reset!","text":"reset!(c::RepresentativeCoordinates)\n\nResets the coordinates of c to zero.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.update_centroid_after_addition!","page":"Data Structures","title":"DelaunayTriangulation.update_centroid_after_addition!","text":"update_centroid_after_addition!(tri::Triangulation, curve_index, p)\n\nUpdates the centroid of the curve_indexth curve in tri after the addition of the point p.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#Cell","page":"Data Structures","title":"Cell","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a Cell struct for representing an individual square in a quadtree during the computation of the pole of inaccessibility.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Cell","page":"Data Structures","title":"DelaunayTriangulation.Cell","text":"Cell{T}\n\nA cell in a grid. The cell is a square with side length 2half_width. The cell is centered at (x, y). The cell is  assumed to live in a polygon.\n\nFields\n\nx::T\n\nThe x-coordinate of the center of the cell.\n\ny::T\n\nThe y-coordinate of the center of the cell.\n\nhalf_width::T\n\nThe half-width of the cell.\n\ndist::T\n\nThe distance from the center of the cell to the polygon.\n\nmax_dist::T\n\nThe maximum distance from the center of the cell to the polygon. This is dist + half_width * sqrt(2).\n\nConstructors\n\nCell(x::T, y::T, half_width::T, points, boundary_nodes)\n\nConstructs a cell with center (x, y) and half-width half_width. The cell is assumed to live in the polygon defined by points and boundary_nodes.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.getx-Tuple{DelaunayTriangulation.Cell}","page":"Data Structures","title":"DelaunayTriangulation.getx","text":"getx(c::Cell) -> Number\n\nReturns the x-coordinate of c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.gety-Tuple{DelaunayTriangulation.Cell}","page":"Data Structures","title":"DelaunayTriangulation.gety","text":"gety(c::Cell) -> Number\n\nReturns the y-coordinate of c.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#CellQueue","page":"Data Structures","title":"CellQueue","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a CellQueue struct for storing the Cells in a quadtree during the computation of the pole of inaccessibility.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.CellQueue","page":"Data Structures","title":"DelaunayTriangulation.CellQueue","text":"CellQueue{T}\n\nA struct representing the priority queue of Cells, used for sorting the cells in a grid according to their maximum distance.\n\nFields\n\nqueue::MaxPriorityQueue{Cell{T},T}: The priority queue of cells, sorting according to maximum distance.\n\nConstructors\n\nCellQueue{T}()\n\nConstructs a new CellQueue with elements of type Cell{T}.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.CellQueue}","page":"Data Structures","title":"Base.isempty","text":"isempty(queue::CellQueue) -> Bool\n\nReturns true if the queue is empty, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_next_cell!-Tuple{DelaunayTriangulation.CellQueue}","page":"Data Structures","title":"DelaunayTriangulation.get_next_cell!","text":"get_next_cell!(queue::CellQueue)\n\nReturns the next cell in the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.insert_cell!-Tuple{DelaunayTriangulation.CellQueue, DelaunayTriangulation.Cell}","page":"Data Structures","title":"DelaunayTriangulation.insert_cell!","text":"insert_cell!(queue::CellQueue, cell::Cell)\n\nInserts a cell into the queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#ConvexHull","page":"Data Structures","title":"ConvexHull","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a ConvexHull struct to represent a convex hull. This struct is in the public API.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.ConvexHull-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.ConvexHull","text":"ConvexHull{PointsType, IntegerType}\n\nStruct for representing a convex hull. See also convex_hull.\n\nFields\n\npoints::PointsType: The underlying point set.\nvertices::Vector{IntegerType}: The vertices of the convex hull, in counter-clockwise order. Defined so that vertices[begin] == vertices[end].\n\nConstructors\n\nConvexHull(points, vertices)\nconvex_hull(points; predicates=AdaptiveKernel(), IntegerType=Int)\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.get_points-Tuple{ConvexHull}","page":"Data Structures","title":"DelaunayTriangulation.get_points","text":"get_points(convex_hull::ConvexHull) -> Points\n\nReturns the underlying point set of convex_hull.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_vertices-Tuple{ConvexHull}","page":"Data Structures","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(convex_hull::ConvexHull) -> Vector{Vertices}\n\nReturns the vertices of convex_hull. These are given in counter-clockwise order, and  are defined so that the first and last vertices and equal.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Triangulation","page":"Data Structures","title":"Triangulation","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a Triangulation struct to represent a triangulation. This struct is in the public API.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Triangulation-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.Triangulation","text":"Triangulation{P,T,BN,W,I,E,Es,BC,BCT,BEM,GVM,GVR,BPL,C,BE}\n\nStruct representing a triangulation, as constructed by triangulate.\n\nnote: Field access\nAccessing the fields themselves using e.g. tri.field is not recommended and is not intended  to be in the public API. You should be using the  accessor functions, e.g. instead of tri.points do get_points(tri). Similarly, for the iterators, e.g. tri.triangles, each_triangle(tri) is recommended instead.\n\nFields\n\npoints::P\n\nThe point set of the triangulation. Please note that this may not necessarily correspond to each point  in the triangulation, e.g. some points may have been deleted - see each_solid_vertex for an iterator over  each vertex in the triangulation. \n\ntriangles::T\n\nThe triangles in the triangulation. Each triangle is oriented counter-clockwise. If your triangulation has ghost triangles, some of these triangles will contain ghost vertices (i.e., vertices with negative indices). Solid triangles can be iterated over using  each_solid_triangle.\n\nboundary_nodes::BN\n\nThe boundary nodes of the triangulation, if the triangulation is constrained; the assumed form of these boundary nodes is outlined  in the docs. If your triangulation is unconstrained, then boundary_nodes will be empty and the boundary should instead be inspected using the convex hull field, or alternatively you can see lock_convex_hull!.\n\ninterior_segments::Es\n\nConstrained segments appearing in the triangulation. These will only be those segments appearing off of the boundary. If your triangulation is unconstrained, then segments will be empty.\n\nall_segments::Es\n\nThis is similar to segments, except this includes both the interior segments and the boundary segments. If your triangulation is unconstrained, then all_segments will be empty.\n\nweights::W\n\nThe weights of the triangulation. If you are not using a weighted triangulation, this will be given by ZeroWeight(). Otherwise,  the weights must be such that get_weight(weights, i) is the weight for the ith vertex. The weights should have the same type as the  coordinates in points.\n\nadjacent::Adjacent{I,E}\n\nThe Adjacent map of the triangulation. This maps edges (u, v) to vertices w such that (u, v, w) is a positively  oriented triangle in triangles (up to rotation).\n\nadjacent2vertex::Adjacent2Vertex{I,Es}\n\nThe Adjacent2Vertex map of the triangulation. This maps vertices w to sets S such that (u, v, w) is a positively  oriented triangle in triangles (up to rotation) for all (u, v) ∈ S.\n\ngraph::Graph{I}\n\nThe Graph of the triangulation, represented as an undirected graph that defines all the neighbourhood information for the triangulation.\n\nboundary_curves::BC\n\nFunctions defining the boundary curves of the triangulation, incase you are triangulating a curve-bounded domain. By default, this will be an empty Tuple, indicating that the boundary is as specified in boundary_nodes - a piecewise linear curve. If you are triangulating a curve-bounded domain, then these will  be the parametric curves (see AbstractParametricCurve) you provided as a Tuple, where the ith element of the Tuple is associated with the ghost vertex -i, i.e. the ith section as indicated by  ghost_vertex_map. If the ith boundary was left was a sequence of edges, then the function will be a PiecewiseLinear().\n\nboundary_edge_map::BEM\n\nThis is a Dict from construct_boundary_edge_map that maps boundary edges (u, v) to their corresponding position in boundary_nodes.\n\nghost_vertex_map::GVM\n\nThis is a Dict that maps ghost vertices to their corresponding section in boundary_nodes, constructed by construct_ghost_vertex_map.\n\nghost_vertex_ranges::GVR\n\nThis is a Dict that maps ghost vertices to a range of all other ghost vertices that appear on the curve corresponding to the given ghost vertex,  constructed by construct_ghost_vertex_ranges.\n\nconvex_hull::ConvexHull{P,I}\n\nThe ConvexHull of the triangulation, which is the convex hull of the point set points.\n\nrepresentative_point_list::BPL\n\nThe Dict of points giving RepresentativeCoordinates for each boundary curve, or for the  convex hull if boundary_nodes is empty. These representative points are used for interpreting  ghost vertices.\n\npolygon_hierarchy::PolygonHierarchy{I}\n\nThe PolygonHierarchy of the boundary, defining the hierarchy of the boundary curves, giving information about which curves are contained in which other curves.\n\nboundary_enricher::BE\n\nThe BoundaryEnricher used for triangulating a curve-bounded domain. If the domain is not curve-bounded, this is nothing.\n\ncache::C\n\nA TriangulationCache used as a cache for add_segment! which requires a separate Triangulation structure for use. This will not contain any segments or boundary nodes. Also stores segments useful for lock_convex_hull! and unlock_convex_hull!.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.build_triangulation_from_data!","page":"Data Structures","title":"DelaunayTriangulation.build_triangulation_from_data!","text":"build_triangulation_from_data!(tri::Triangulation, triangles, boundary_nodes, delete_ghosts, predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nGiven an empty triangulation, tri, adds all the triangles and boundary_nodes into it. Use  delete_ghosts=true if you want to have all ghost triangles deleted afterwards.\n\nThe kernel argument determines how predicates are computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.edge_type-Union{Tuple{Triangulation{P, T, BN, W, I, E}}, Tuple{E}, Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}} where {P, T, BN, W, I, E}","page":"Data Structures","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing individual edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.edges_type-Union{Tuple{Triangulation{P, T, BN, W, I, E, Es}}, Tuple{Es}, Tuple{E}, Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}} where {P, T, BN, W, I, E, Es}","page":"Data Structures","title":"DelaunayTriangulation.edges_type","text":"edges_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing collections of edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation) -> Adjacent\n\nReturns the adjacency map of the triangulation. This is a map from each edge (u, v) to a vertex w such that (u, v, w)  is a positively oriented triangle in tri. \n\nSee also Adjacent.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation) -> Adjacent2Vertex\n\nReturns the Adjacent2Vertex map of the triangulation tri. This is a map from a vertex w to a set of  all edges (u, v) such that (u, v, w) is a positively oriented triangle in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_all_segments-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_all_segments","text":"get_all_segments(tri::Triangulation) -> Edges\n\nReturn all segments of the triangulation. This includes interior segments and boundary segments. Segments are  edges that are forced to be in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_curves-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_curves","text":"get_boundary_curves(tri::Triangulation) -> NTuple{N, Function}\n\nReturns the functions defining the boundaries of tri. If !is_curve_bounded(tri),  then this returns an empty Tuple. Otherwise, this returns a Tuple of functions, one for each section of the boundary,  where the ith element of the Tuple corresponds to the ith section of the boundary, which corresponds to the ghost vertex -i. For curves that are defined by boundary nodes rather than by a function, the function is PiecewiseLinear. For the other functions, these  are all defined by t -> NTuple{2, Number}, where t ∈ [0, 1] and the NTuple{2, Number} is the coordinate on the curve at that t.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation) -> Dict\n\nReturns the boundary edge map of the triangulation tri. This is a Dict that maps  a boundary edge (u, v) to its position in get_boundary_nodes(tri). In particular,  the returned value is a Tuple (position, index) so that boundary_nodes = get_boundary_nodes(tri, position) are the boundary nodes associated  with the section that (u, v) resides on, and u = get_boundary_nodes(boundary_nodes, index) and  v = get_boundary_nodes(boundary_nodes, index + 1).\n\nSee also construct_boundary_edge_map.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_enricher-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_enricher","text":"get_boundary_enricher(tri::Triangulation) -> BoundaryEnricher\n\nReturns the BoundaryEnricher of tri. If the domain is not curve-bounded, this is nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri::Triangulation) -> BoundaryNodes\n\nReturn the boundary nodes of the triangulation. This is only for triangulations with a constrained boundary. If the triangulation  has no constrained boundary, then the boundary is instead given by its convex hull and this function returns an empty vector. See  get_convex_hull.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_cache-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_cache","text":"get_cache(tri::Triangulation) -> TriangulationCache\n\nReturns the cache of tri. This is a TriangulationCache used as a cache for add_segment! which requires a separate Triangulation structure for use.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_convex_hull","text":"get_convex_hull(tri::Triangulation) -> ConvexHull\n\nReturns the convex hull of the points in tri. This is given as a ConvexHull object, where the vertices  are sorted counter-clockwise and defined so that the first and last vertices are equal.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_exterior_curve_indices-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_exterior_curve_indices","text":"get_exterior_curve_indices(tri::Triangulation) -> KeySet{Integer}\n\nReturns the set of all curve indices that correspond to exterior curves of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_ghost_vertex_map-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_ghost_vertex_map","text":"get_ghost_vertex_map(tri::Triangulation) -> Dict\n\nReturns the ghost vertex map of the triangulation tri. This is a Dict that maps ghost vertices  to their associated section in boundary_nodes. There are three cases; below, I is integer_type(tri):\n\nhas_multiple_curves(tri)\n\nReturns dict::Dict{I, NTuple{2, I}}, mapping ghost vertices i to Tuples (m, n) so that get_boundary_nodes(tri, m, n) are the boundary nodes associated with i,  i.e. the nth section of the mth curve is associated with the ghost vertex i.\n\nhas_multiple_sections(tri)\n\nReturns dict::Dict{I, I}, mapping ghost vertices i to n so that get_boundary_nodes(tri, n) are the boundary nodes associated with i, i.e. the nth section of the boundary is associated with the ghost vertex i.\n\notherwise\n\nReturns dict::Dict{I, A}, mapping the ghost vertex i to get_boundary_nodes(tri), where A = typeof(get_boundary_nodes(tri)).\n\nSee also construct_ghost_vertex_map.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_ghost_vertex_ranges-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_ghost_vertex_ranges","text":"get_ghost_vertex_ranges(tri::Triangulation) -> Dict\n\nReturns the ghost vertex ranges map of the triangulation tri. This is a Dict that maps ghost vertices i  to the range of all other ghost vertices associated with the curve that i is associated with. \n\nSee also construct_ghost_vertex_ranges.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_graph-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_graph","text":"get_graph(tri::Triangulation) -> Graph\n\nReturns the Graph of the triangulation tri. This is an undirected graph.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_incircle_cache-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_incircle_cache","text":"get_incircle_cache(tri::Triangulation) -> Tuple\n\nReturns the incircle cache stored in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_insphere_cache-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_insphere_cache","text":"get_insphere_cache(tri::Triangulation) -> Tuple\n\nReturns the insphere cache stored in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_interior_segments-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_interior_segments","text":"get_interior_segments(tri::Triangulation) -> Edges\n\nReturn the interior segments of the triangulation. These are segments that are forced to be in the triangulation -  they are not the same as edges.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_orient3_cache-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_orient3_cache","text":"get_orient3_cache(tri::Triangulation) -> Tuple\n\nReturns the orient3 cache stored in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_points-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_points","text":"get_points(tri::Triangulation) -> Points\n\nReturn the points of the triangulation. Note that this may include points not yet in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_hierarchy-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_hierarchy","text":"get_polygon_hierarchy(tri::Triangulation) -> PolygonHierarchy\n\nReturns the PolygonHierarchy of the boundary of tri. This defines the hierarchy of the boundary curves, giving information about which curves are contained in which other curves.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_positive_curve_indices-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_positive_curve_indices","text":"get_positive_curve_indices(tri::Triangulation) -> Generator\n\nReturns the indices of the positively oriented curves of hierarchy as a generator, i.e.  as a lazy result.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_representative_point_list-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_representative_point_list","text":"get_representative_point_list(tri::Triangulation) -> Dict\n\nReturns the Dict of RepresentativeCoordinates of tri, mapping curve indices i to the representative point for that  curve. These representative points are how we interpret ghost triangles relative to that curve.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangles-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_triangles","text":"get_triangles(tri::Triangulation) -> Triangles\n\nReturn the triangles of the triangulation. These triangles are all given in counter-clockwise order,  and may include ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_weights-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.get_weights","text":"get_weights(tri::Triangulation) -> Weights\n\nReturn the weights of the triangulation. These are the weights of the vertices of the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.integer_type-Union{Tuple{Triangulation{P, T, BN, W, I}}, Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}} where {P, T, BN, W, I}","page":"Data Structures","title":"DelaunayTriangulation.integer_type","text":"integer_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing vertices in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.number_type-Union{Tuple{Triangulation{P}}, Tuple{P}} where P","page":"Data Structures","title":"DelaunayTriangulation.number_type","text":"number_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing individual coordinates in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_type-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing individual triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangles_type-Union{Tuple{Triangulation{P, T}}, Tuple{T}, Tuple{P}} where {P, T}","page":"Data Structures","title":"DelaunayTriangulation.triangles_type","text":"triangle_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing collections of triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#TriangulationCache","page":"Data Structures","title":"TriangulationCache","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The TriangulationCache is what we store in the cache field of a triangulation.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.TriangulationCache","page":"Data Structures","title":"DelaunayTriangulation.TriangulationCache","text":"TriangulationCache{T,M,I,S,IC,OC,IS}\n\nA cache to be used as a field in Triangulation.\n\nFields\n\ntriangulation::T: The cached triangulation. This will only refer to an unconstrained triangulation,  meaning it cannot have any segments or boundary nodes. It will contain the weights. This   is used for constrained triangulations.\ntriangulation_2::T: An extra cached triangulation. This is needed for retriangulating fans for constrained triangulations.\nmarked_vertices::M: Marked vertices cache for use in constrained triangulations.\ninterior_segments_on_hull::I: Interior segments in the triangulation that also appear on the   convex hull of tri. This is needed for lock_convex_hull! in case the convex hull also contains   interior segments.\nsurrounding_polygon::S: The polygon surrounding the triangulation. This is needed for delete_point!.\nfan_triangles::F: Triangles in a fan. This is needed for sorting fans for constrained triangulations.\nincircle_cache::IC: Cache for incircle tests.\norient3_cache::OC: Cache for orient3 tests.\ninsphere_cache::IS: Cache for insphere tests.\n\nnote: Caches of caches\nThe triangulation cache itself does not have a cache. Instead, it stores a  TriangulationCache(nothing).\n\ndanger: Aliasing\nThe points of the cache's triangulation will be aliased to the points of the parent triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.empty!-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"Base.empty!","text":"empty!(cache::TriangulationCache)\n\nEmpties the cache by emptying the triangulation stored in it.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.empty_unconstrained_triangulation!-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.empty_unconstrained_triangulation!","text":"empty_unconstrained_triangulation!(tri::Triangulation)\n\nEmpties the triangulation tri by emptying its fields. Only works for unconstrained triangulaions.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_fan_triangles-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_fan_triangles","text":"get_fan_triangles(cache::TriangulationCache) -> Triangles\n\nReturns the triangles in a fan stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_incircle_cache-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_incircle_cache","text":"get_incircle_cache(cache::TriangulationCache) -> Tuple\n\nReturns the incircle cache stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_insphere_cache-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_insphere_cache","text":"get_insphere_cache(cache::TriangulationCache) -> Tuple\n\nReturns the insphere cache stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_interior_segments_on_hull-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_interior_segments_on_hull","text":"get_interior_segments_on_hull(cache::TriangulationCache) -> Set{Edge}\n\nReturns the interior segments on the convex hull of the triangulation stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_marked_vertices-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_marked_vertices","text":"get_marked_vertices(cache::TriangulationCache) -> Vector{Vertex}\n\nReturns the marked vertices stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_orient3_cache-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_orient3_cache","text":"get_orient3_cache(cache::TriangulationCache) -> Tuple\n\nReturns the orient3 cache stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_surrounding_polygon-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(cache::TriangulationCache) -> Vector{Vertex}\n\nReturns the polygon surrounding the triangulation stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangulation-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_triangulation","text":"get_triangulation(cache::TriangulationCache) -> Triangulation\n\nReturns the Triangulation stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangulation_2-Tuple{DelaunayTriangulation.TriangulationCache}","page":"Data Structures","title":"DelaunayTriangulation.get_triangulation_2","text":"get_triangulation_2(cache::TriangulationCache) -> Triangulation\n\nReturns the second Triangulation stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#BoundaryEnricher","page":"Data Structures","title":"BoundaryEnricher","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a BoundaryEnricher struct for storing information using during the enrichment phase of the triangulation of a curve-bounded domain.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.BoundaryEnricher","page":"Data Structures","title":"DelaunayTriangulation.BoundaryEnricher","text":"BoundaryEnricher{P,B,C,I,BM,S,E}\n\nStruct used for performing boundary enrichment on a curve-bounded boundary. \n\nSee also enrich_boundary!.\n\nFields\n\npoints::P: The point set. \nboundary_nodes::B: The boundary nodes.\nsegments::S: The segments.\nboundary_curves::C: The boundary curves.\npolygon_hierarchy::PolygonHierarchy{I}: The polygon hierarchy.\nparent_map::Dict{NTuple{2,I},I}: A map from an edge, represented as a Tuple, to the index of the parent curve in boundary_curves.\ncurve_index_map::Dict{I,I}: A map from a curve index to the index of the curve in boundary_curves.\nboundary_edge_map::B: A map from a boundary node to the index of the curve in boundary_curves that it belongs to. See construct_boundary_edge_map.\nspatial_tree::BoundaryRTree{P}: The BoundaryRTree used for spatial indexing.\nqueue::Queue{I}: A queue used for processing vertices during enrichment.\nsmall_angle_complexes::Dict{I,Vector{SmallAngleComplex{I}}}: A map from an apex vertex to a list of all curves that define a small angle complex associated with that apex vertex.\n\nThe first three fields should be those associated with convert_boundary_curves!.\n\nConstructor\n\nBoundaryEnricher(points, boundary_nodes; IntegerType=Int, n=4096, coarse_n=0)\n\nThis constructor will use convert_boundary_curves! to convert points and boundary_nodes into a set of boundary curves and modified boundary nodes suitable for enrichment. The boundary nodes  field will no longer aliased with the input boundary_nodes, although points will be. The polygon hierarchy is computed using construct_polygon_hierarchy. The argument n is used in polygonise for filling out the boundary temporarily in order to construct the PolygonHierarchy. The argument coarse_n defines the initial coarse discretisation  through coarse_discretisation!; the default n=0 means that the coarse discretisation will be performed until the maximum total variation of a subcurve is less than π/2.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.SmallAngleComplex","page":"Data Structures","title":"DelaunayTriangulation.SmallAngleComplex","text":"SmallAngleComplex{I}\n\nStruct for representing a small-angle complex.\n\nFields\n\napex::I: The apex vertex of the complex.\nmembers::Vector{SmallAngleComplexMember{I}}: The members of the complex.\n\nExtended help\n\nA small-angle complex is a set of curves that form a contiguous set of small angles, i.e. the angle between  each consecutive pair of curves is less than 60°. The apex of the complex is the vertex that is shared by all of the curves.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.SmallAngleComplexMember","page":"Data Structures","title":"DelaunayTriangulation.SmallAngleComplexMember","text":"SmallAngleComplexMember{I}\n\nStruct for representing a member of a small-angle complex.\n\nFields\n\nparent_curve::I: The index of the parent curve in the boundary curves assoicated with the member. If this is 0, then this is instead a member of a complex around an interior segment.\nnext_edge::I: The next vertex after the apex in the boundary nodes associated with the member.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.append!-Tuple{DelaunayTriangulation.SmallAngleComplex, DelaunayTriangulation.SmallAngleComplex}","page":"Data Structures","title":"Base.append!","text":"append!(complex::SmallAngleComplex, new_complex::SmallAngleComplex)\n\nAppends the members of new_complex onto the members of complex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.push!-Tuple{DelaunayTriangulation.SmallAngleComplex, DelaunayTriangulation.SmallAngleComplexMember}","page":"Data Structures","title":"Base.push!","text":"push!(complex::SmallAngleComplex, member::SmallAngleComplexMember)\n\nPushes member onto the members of complex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.angle_between-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.angle_between","text":"angle_between(enricher::BoundaryEnricher, curve_index1, curve_index2) -> Float64\n\nEvaluates angle_between on the curves with indices curve_index1 and curve_index2 in enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_curve_index_map!-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.construct_curve_index_map!","text":"construct_curve_index_map!(enricher::BoundaryEnricher)\n\nConstructs the curve index map for enricher, modifying the curve index map field in-place. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_parent_map!-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.construct_parent_map!","text":"construct_parent_map!(enricher::BoundaryEnricher)\n\nConstructs the parent map for enricher, modifying the parent map field in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_segment_map-Union{Tuple{I}, Tuple{Any, Any, Type{I}}} where I","page":"Data Structures","title":"DelaunayTriangulation.construct_segment_map","text":"construct_segment_map(segments, points, IntegerType) -> Dict{IntegerType, Vector{IntegerType}}\n\nReturns the segment map of segments. This is a map that maps a vertex to all vertices that share a segment with that vertex. Segments are stored twice. The vertices associated with a vertex are sorted counter-clockwise, using the points argument  to define the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_tree!-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.construct_tree!","text":"construct_tree!(enricher::BoundaryEnricher)\n\nConstructs the spatial tree for enricher, modifying the spatial tree field in-place. The parent map  must be correctly configured in order for this to be valid.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_edge!-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(boundary_enricher::BoundaryEnricher, i, j)\n\nDeletes the edge (i, j) in boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_boundary_edge-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.each_boundary_edge","text":"each_boundary_edge(enricher::BoundaryEnricher) -> KeySet\n\nReturns the set of keys in the parent map of enricher, i.e. each boundary edge in enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.eval_boundary_curve-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.eval_boundary_curve","text":"eval_boundary_curve(enricher::BoundaryEnricher, curve_index, t) -> NTuple{2,Float64}\n\nReturns the curve_indexth boundary curve at t.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_apex-Tuple{DelaunayTriangulation.SmallAngleComplex}","page":"Data Structures","title":"DelaunayTriangulation.get_apex","text":"get_apex(complex::SmallAngleComplex{I}) where {I} -> I\n\nReturns the apex of complex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_curve-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_curve","text":"get_boundary_curve(boundary_enricher::BoundaryEnricher, curve_index) -> AbstractParametricCurve\n\nReturns the curve_indexth curve from the boundary curves in boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_curves-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_curves","text":"get_boundary_curves(boundary_enricher::BoundaryEnricher{P,B,C}) -> C\n\nReturns the boundary curves associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_edge_map-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(boundary_enricher::BoundaryEnricher, i, j)\n\nReturns the value from the key (i, j) in the boundary edge map of boundary_enricher. The returned value is a Tuple  (position, index) so that boundary_nodes = get_boundary_nodes(get_boundary_nodes(boundary_enricher), position) are the boundary nodes associated  with the section that (i, j) resides on, and i = get_boundary_nodes(boundary_nodes, index) and  j = get_boundary_nodes(boundary_nodes, index + 1).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_edge_map-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(boundary_enricher::BoundaryEnricher{P,B,C,I,BM}) -> BM\n\nReturns the boundary edge map associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_nodes-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(boundary_enricher::BoundaryEnricher{P,B}) -> B\n\nReturns the boundary nodes associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circle_intersection-Tuple{DelaunayTriangulation.BoundaryEnricher, Vararg{Any, 4}}","page":"Data Structures","title":"DelaunayTriangulation.get_circle_intersection","text":"get_circle_intersection(enricher::BoundaryEnricher, curve_index, t₁, t₂, r) -> (Float64, NTuple{2,Float64})\n\nFinds the intersection of the curve_indexth curve with the circle centered at the curve evaluated at t₁ with radius r. The argument  t₂ defines the end of the subcurve to consider. The returned tuple is (t, p) where t is the parameter value of the intersection and p is the point of intersection.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_curve_index_map-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_curve_index_map","text":"get_curve_index_map(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> Dict{I,I}\n\nReturns the curve index map associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_equidistant_split-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_equidistant_split","text":"get_equidistant_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -> Float64\n\nReturns the equidistant split of the curve_indexth curve between t₁ and t₂.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_equivariation_split-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_equivariation_split","text":"get_equivariation_split(enricher::BoundaryEnricher, curve_index, t₁, t₂) -> Float64, Float64\n\nReturns the equivariation split of the curve_indexth curve between t₁ and t₂. Also returns the total variation of the two pieces.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_inverse-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_inverse","text":"get_inverse(enricher::BoundaryEnricher, curve_index, q) -> Float64\n\nReturns the inverse of the curve_indexth curve at q.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_members-Tuple{DelaunayTriangulation.SmallAngleComplex}","page":"Data Structures","title":"DelaunayTriangulation.get_members","text":"get_members(complex::SmallAngleComplex{I}) where {I} -> Vector{SmallAngleComplexMember{I}}\n\nReturns the members of complex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_minimum_edge_length-Tuple{DelaunayTriangulation.SmallAngleComplex, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_minimum_edge_length","text":"get_minimum_edge_length(complex::SmallAngleComplex, points) -> Float64\n\nReturns the minimum edge length in complex with respect to points.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_next_edge-Tuple{DelaunayTriangulation.SmallAngleComplexMember}","page":"Data Structures","title":"DelaunayTriangulation.get_next_edge","text":"get_next_edge(member::SmallAngleComplexMember{I}) where {I} -> I\n\nReturns the next edge of member.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent-Union{Tuple{I}, Tuple{C}, Tuple{B}, Tuple{P}, Tuple{DelaunayTriangulation.BoundaryEnricher{P, B, C, I}, Any, Any}} where {P, B, C, I}","page":"Data Structures","title":"DelaunayTriangulation.get_parent","text":"get_parent(boundary_enricher::BoundaryEnricher{P,B,C,I}, i::I, j::I) -> I\n\nReturns the parent of the edge (i, j) in boundary_enricher. If the edge is not in the parent map, then 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent_curve-Tuple{DelaunayTriangulation.SmallAngleComplexMember}","page":"Data Structures","title":"DelaunayTriangulation.get_parent_curve","text":"get_parent_curve(member::SmallAngleComplexMember{I}) where {I} -> I\n\nReturns the parent curve of member.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_parent_map-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_parent_map","text":"get_parent_map(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> Dict{NTuple{2,I},I}\n\nReturns the parent map associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_points-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_points","text":"get_points(boundary_enricher::BoundaryEnricher{P}) -> P\n\nReturns the point set associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_hierarchy-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_hierarchy","text":"get_polygon_hierarchy(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> PolygonHierarchy{I}\n\nReturns the polygon hierarchy associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_queue-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_queue","text":"get_queue(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> Queue{I}\n\nReturns the queue associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_segments-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_segments","text":"get_segments(boundary_enricher::BoundaryEnricher{P,B,C,I,BM,S}) -> S\n\nReturns the segments associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_small_angle_complexes","page":"Data Structures","title":"DelaunayTriangulation.get_small_angle_complexes","text":"get_small_angle_complexes(points, boundary_nodes, boundary_curves, segments=nothing; IntegerType=Int) -> Dict{IntegerType,Vector{SmallAngleComplex{IntegerType}}}\n\nReturns a map from an apex vertex to a list of all curves that define a small angle complex associated with that apex vertex.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_small_angle_complexes-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_small_angle_complexes","text":"get_small_angle_complex(boundary_enricher::BoundaryEnricher, apex) -> Vector{SmallAngleComplex}\n\nReturns the small angle complexes in boundary_enricher associated with apex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_small_angle_complexes-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_small_angle_complexes","text":"get_small_angle_complexes(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> Dict{I,Vector{SmallAngleComplex{I}}}\n\nReturns the small angle complexes associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_spatial_tree-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.get_spatial_tree","text":"get_spatial_tree(boundary_enricher::BoundaryEnricher{P,B,C,I}) -> RTree\n\nReturns the spatial tree associated with boundary_enricher.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_segments-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Data Structures","title":"DelaunayTriangulation.has_segments","text":"has_segments(boundary_enricher::BoundaryEnricher -> Bool\n\nReturns true if boundary_enricher has interior segments, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_linear-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_linear","text":"is_linear(enricher::BoundaryEnricher, curve_index) -> Bool\n\nReturns true if the curve_indexth curve in enricher is a LineSegment, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_piecewise_linear-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_piecewise_linear","text":"is_piecewise_linear(enricher::BoundaryEnricher, curve_index) -> Bool\n\nReturns true if the curve_indexth curve in enricher is piecewise linear, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_segment-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_segment","text":"is_segment(enricher::BoundaryEnricher, i, j) -> Bool\n\nReturns true if (i, j) or (j, i) is an interior segment of enricher, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_small_angle_complex_apex-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_small_angle_complex_apex","text":"is_small_angle_complex_apex(boundary_enricher::BoundaryEnricher, apex) -> Bool\n\nReturns true if apex is the apex of a small angle complex in boundary_enricher, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_small_angle_complex_member-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_small_angle_complex_member","text":"is_small_angle_complex_member(enricher::BoundaryEnricher, i, j) -> Bool, I, IntegerType, IntegerType\n\nReturns true if the edge (i, j) is a member of a small angle complex in enricher, and false otherwise. \n\nOutputs\n\nflag: true if the edge is a member of a small angle complex, and false otherwise.\napex: If the edge is a member of a small angle complex, then apex is the apex of the complex. Otherwise, apex is 0.\ncomplex_id: If the edge is a member of a small angle complex, then complex_id is the index of the complex in the list of complexes associated with apex. Otherwise, complex_id is 0.\nmember_id: If the edge is a member of a small angle complex, then member_id is the index of the member in the list of members associated with complex_id. Otherwise, member_id is 0.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.map_curve_index-Tuple{DelaunayTriangulation.BoundaryEnricher, Any}","page":"Data Structures","title":"DelaunayTriangulation.map_curve_index","text":"map_curve_index(boundary_enricher::BoundaryEnricher, curve_index) -> Integer\n\nReturns the curve index in boundary_enricher associated with curve_index.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.partition_members-Union{Tuple{I}, Tuple{Array{DelaunayTriangulation.SmallAngleComplex{I}, 1}, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.partition_members","text":"partition_members(complexes::Vector{SmallAngleComplex{I}}, points) where {I} -> Vector{SmallAngleComplex{I}}\n\nPartitions the members of each complex in complexes into a new set of complexes. The complexes in complexes are assumed to be sorted in a counter-clockwise order around the apex of each complex. The partitioning is done so that the original set of members are now correctly split into their own complexes, since the original complexes might not have formed a properly contiguous set of small angles.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.point_position_relative_to_curve-Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.point_position_relative_to_curve","text":"point_position_relative_to_curve([kernel::AbstractPredicateKernel=AdaptiveKernel(),] enricher::BoundaryEnricher, curve_index, p) -> Certificate\n\nReturns a Certificate which is \n\nLeft: If p is to the left of the curve_indexth curve.\nRight: If p is to the right of the curve_indexth curve.\nOn: If p is on the curve_indexth curve.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.polygonise-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.polygonise","text":"polygonise(points, boundary_nodes, boundary_curves; n=4096)\n\nFills out a set of points for a curve-bounded domain for use with PolygonHierarchy.\n\nwarning: Warning\nIf the boundary curves are complicated so that they take a lot of points in order to be accurately resolved, then you should increase  n.\n\nArguments\n\npoints: The point set.\nboundary_nodes: The boundary nodes.\nboundary_curves: The boundary curves.\n\nKeyword Arguments\n\nn=4096: The number of points to use for filling in each boundary curves.\n\nOutput\n\nnew_points: The points defining the filled out boundaries.\nnew_boundary_nodes: The boundary nodes associated with new_points.\n\nwarning: Aliasing\nIf the boundary is not curve bounded, then new_points and new_boundary_nodes remain aliased  with the input points and boundary_nodes.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reorient_edge-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.reorient_edge","text":"reorient_edge(enricher::BoundaryEnricher, i, j) -> NTuple{2,Integer}\n\nGiven an edge (i, j), reorients it so that it is correctly oriented with the boundary. If (i, j) is instead an interior segment rather than a boundary edge, then (i, j) is returned.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.replace_next_edge!-Tuple{DelaunayTriangulation.BoundaryEnricher, Vararg{Any, 4}}","page":"Data Structures","title":"DelaunayTriangulation.replace_next_edge!","text":"replace_next_edge!(enricher::BoundaryEnricher, apex, complex_id, member_id, next_edge)\n\nReplaces the next edge of the member_idth member of the complex_idth complex associated with apex with next_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.replace_next_edge!-Tuple{DelaunayTriangulation.SmallAngleComplex, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.replace_next_edge!","text":"replace_next_edge!(complex::SmallAngleComplex, member_id, next_edge)\n\nReplaces the next edge of the member_idth member of complex with next_edge. \n\nSee also replace_next_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.replace_next_edge-Union{Tuple{I}, Tuple{DelaunayTriangulation.SmallAngleComplexMember{I}, Any}} where I","page":"Data Structures","title":"DelaunayTriangulation.replace_next_edge","text":"replace_next_edge(member::SmallAngleComplexMember{I}, next_edge) where {I} -> SmallAngleComplexMember{I}\n\nReturns a new SmallAngleComplexMember with the same parent curve as member but with next_edge as the next edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.set_parent!-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.set_parent!","text":"set_parent!(boundary_enricher::BoundaryEnricher, i, j, k)\n\nSets the parent of the edge (i, j) in boundary_enricher to k.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.sort_members!-Tuple{DelaunayTriangulation.SmallAngleComplex, Any}","page":"Data Structures","title":"DelaunayTriangulation.sort_members!","text":"sort_members!(complex::SmallAngleComplex, points)\n\nSorts the members of complex in a counter-clockwise order around the apex of complex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.split_boundary_edge!","page":"Data Structures","title":"DelaunayTriangulation.split_boundary_edge!","text":"split_boundary_edge!(enricher::BoundaryEnricher, i, j, r, update_boundary_nodes = Val(true))\n\nUpdates the fields of enricher after splitting a boundary edge (i, j) at the rth vertex. The update_boundary_nodes argument can be used to avoid inserting an additional boundary node when boundary_nodes was already updated somewhere else (e.g., we need this for  mesh refinement which already updates the boundary_nodes which is aliased with the same field in the enricher). Note that not updating the  boundary nodes also implies that the boundary_edge_map will not be updated.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.split_edge!","page":"Data Structures","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(enricher::BoundaryEnricher, i, j, r, update_boundary_nodes = Val(true), update_segments = Val(true), is_interior = is_segment(enricher, i, j))\n\nUpdates the fields of enricher after splitting an edge (i, j) at the rth vertex. The update_boundary_nodes argument  can be used to avoid inserting an additional boundary node when boundary_nodes was already updated somewhere else (e.g., we need this for mesh refinement which already updates the boundary_nodes which is aliased with the same field in the enricher). The same  point goes for update_segments which can be used to avoid inserting an additional segment when segments was already updated somewhere else. The is_interior argument can be used to specify whether the edge is an interior segment or a boundary edge. \n\nSee also split_boundary_edge! and split_interior_segment!.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.split_interior_segment!","page":"Data Structures","title":"DelaunayTriangulation.split_interior_segment!","text":"split_interior_segment!(enricher::BoundaryEnricher, i, j, r, update_segments = Val(true))\n\nUpdates the fields of enricher after splitting an interior segment (i, j) at the rth vertex.  The update_segments argument can be used to avoid inserting an additional segment when segments was already updated somewhere else (e.g., we need this for mesh refinement which already updates the interior_segments which is aliased with the segments field in the enricher).\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.update_parent_map!-Tuple{DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.update_parent_map!","text":"update_parent_map!(boundary_enricher::BoundaryEnricher, i, j, k)\n\nReplaces the edge (i, j) in boundary_enricher with the edges (i, k) and (k, j) in the parent map.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#AbstractEach(Vertex/Edge/Triangle)-Iterators","page":"Data Structures","title":"AbstractEach(Vertex/Edge/Triangle) Iterators","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a variety of iterators for iterating over the vertices, edges, and triangles of a triangulation.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractEachEdge","page":"Data Structures","title":"DelaunayTriangulation.AbstractEachEdge","text":"AbstractEachEdge{E}\n\nAn abstract type for an iterator over edges in a triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractEachTriangle","page":"Data Structures","title":"DelaunayTriangulation.AbstractEachTriangle","text":"AbstractEachTriangle{T}\n\nAn abstract type for an iterator over triangles in a triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.AbstractEachVertex","page":"Data Structures","title":"DelaunayTriangulation.AbstractEachVertex","text":"AbstractEachVertex{V}\n\nAn abstract type for an iterator over vertices in a triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachGhostEdge","page":"Data Structures","title":"DelaunayTriangulation.EachGhostEdge","text":"EachGhostEdge{E,T}\n\nAn iterator over all ghost edges in a triangulation.\n\nFields\n\nedges::E: The iterator over all edges in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachGhostTriangle","page":"Data Structures","title":"DelaunayTriangulation.EachGhostTriangle","text":"EachGhostTriangle{V,T}\n\nAn iterator over all ghost triangles in a triangulation.\n\nFields\n\ntriangles::V: The iterator over all triangles in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachGhostVertex","page":"Data Structures","title":"DelaunayTriangulation.EachGhostVertex","text":"EachGhostVertex{V,T}\n\nAn iterator over all ghost vertices in a triangulation.\n\nFields\n\nvertices::V: The iterator over all vertices in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachSolidEdge","page":"Data Structures","title":"DelaunayTriangulation.EachSolidEdge","text":"EachSolidEdge{E,T}\n\nAn iterator over all solid edges in a triangulation.\n\nFields\n\nedges::E: The iterator over all edges in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachSolidTriangle","page":"Data Structures","title":"DelaunayTriangulation.EachSolidTriangle","text":"EachSolidTriangle{V,T}\n\nAn iterator over all solid triangles in a triangulation.\n\nFields\n\ntriangles::V: The iterator over all triangles in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.EachSolidVertex","page":"Data Structures","title":"DelaunayTriangulation.EachSolidVertex","text":"EachSolidVertex{V,T}\n\nAn iterator over all solid vertices in a triangulation.\n\nFields\n\nvertices::V: The iterator over all vertices in the triangulation.\ntri::T: The triangulation.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.each_edge-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_edge","text":"each_edge(tri::Triangulation) -> Edges\n\nReturns an iterator over all edges in tri. Note that, if has_ghost_triangles(tri), then some of these edges will be ghost edges.\n\nSee also each_solid_edge and each_ghost_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_ghost_edge-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_ghost_edge","text":"each_ghost_edge(tri::Triangulation) -> Edges\n\nReturns an iterator over all ghost edges in tri.\n\nSee also each_edge and each_solid_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_ghost_triangle","text":"each_ghost_triangle(tri::Triangulation) -> Triangles\n\nReturns an iterator over all ghost triangles in tri.\n\nSee also each_triangle and each_solid_triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_ghost_vertex-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_ghost_vertex","text":"each_ghost_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all ghost vertices in tri.\n\nSee also each_vertex and each_solid_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_point-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_point","text":"each_point(tri::Triangulation) -> Points\n\nReturns an iterator over all points in tri. \n\ndanger: Missing vertices\nIf tri has vertices that are not yet present in the triangulation, e.g. if you have deleted vertices or have  some submerged vertices in a weighted triangulation, then the corresponding points will still be present in this  iterator. It is recommended that you instead consider each_vertex, each_solid_vertex, or  each_ghost_vertex together with get_point to get the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_point_index-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(tri::Triangulation) -> Indices\n\nReturns an iterator over all point indices in tri.\n\ndanger: Missing vertices\nIf tri has vertices that are not yet present in the triangulation, e.g. if you have deleted vertices or have  some submerged vertices in a weighted triangulation, then the corresponding point indices will still be present in this  iterator. It is recommended that you instead consider each_vertex, each_solid_vertex, or  each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_solid_edge-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_solid_edge","text":"each_solid_edge(tri::Triangulation) -> Edges\n\nReturns an iterator over all solid edges in tri.\n\nSee also each_edge and each_ghost_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_solid_triangle","text":"each_solid_triangle(tri::Triangulation) -> Triangles\n\nReturns an iterator over all solid triangles in tri.\n\nSee also each_triangle and each_ghost_triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_solid_vertex-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_solid_vertex","text":"each_solid_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all solid vertices in tri. \n\nSee also each_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_triangle-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(tri::Triangulation) -> Triangles\n\nReturns an iterator over all triangles in tri. Note that, if has_ghost_triangles(tri), then some of these triangles will be ghost triangles.\n\nSee also each_solid_triangle and each_ghost_triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_vertex-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(tri::Triangulation) -> Set{Vertex}\n\nReturns an iterator over all vertices in tri. Note that, if has_ghost_triangles(tri), then some of these vertices will be ghost vertices.\n\nSee also each_solid_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#PointLocationHistory","page":"Data Structures","title":"PointLocationHistory","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We provide a means for storing the history of triangles encountered during point location, using a PointLocationHistory struct. The main motivation for this struct is for constrained triangulations.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.PointLocationHistory-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.PointLocationHistory","text":"PointLocationHistory{T,E,I}\n\nHistory from using find_triangle.\n\nFields\n\ntriangles::Vector{T}: The visited triangles. \ncollinear_segments::Vector{E}: Segments collinear with the original line pq using to jump.\ncollinear_point_indices::Vector{I}: This field contains indices to segments in collinear_segments that refer to points that were on the original segment, but there is no valid segment for them. We use manually fix this after the fact. For example, we could add an edge (1, 14), when really we mean something like (7, 14) which isn't a valid edge.\nleft_vertices::Vector{I}: Vertices from the visited triangles to the left of pq.\nright_verices::Vector{I}: Vertices from the visited triangles to the right of pq.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_edge!-Union{Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.PointLocationHistory{T, E}, Any, Any}} where {T, E}","page":"Data Structures","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(history::PointLocationHistory{T,E}, i, j)\n\nAdds the edge (i, j) to the collinear_segments field of history.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_index!-Tuple{DelaunayTriangulation.PointLocationHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_index!","text":"add_index!(history::PointLocationHistory, i)\n\nAdds the index i to the collinear_point_indices field of history.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_left_vertex!-Tuple{DelaunayTriangulation.PointLocationHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_left_vertex!","text":"add_left_vertex!(history::PointLocationHistory, i)\n\nAdds the vertex i to the left_vertices field of history.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_right_vertex!-Tuple{DelaunayTriangulation.PointLocationHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_right_vertex!","text":"add_right_vertex!(history::PointLocationHistory, j)\n\nAdds the vertex j to the right_vertices field of history.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-Union{Tuple{I}, Tuple{Ts}, Tuple{Ts, I, I, I}} where {Ts<:DelaunayTriangulation.PointLocationHistory, I<:Integer}","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(history::PointLocationHistory, i, j, k)\n\nAdds the triangle (i, j, k) to the triangles field of history.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.PointLocationHistory}","page":"Data Structures","title":"DelaunayTriangulation.num_edges","text":"num_edges(history::PointLocationHistory) -> Integer\n\nReturns the number of edges in history.collinear_segments.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#IndividualTriangleStatistics","page":"Data Structures","title":"IndividualTriangleStatistics","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We provide an IndividualTriangleStatistics struct for storing statistics about individual triangles in a triangulation. This struct is in the public API, as listed in the API.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.IndividualTriangleStatistics-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.IndividualTriangleStatistics","text":"IndividualTriangleStatistics{T}\n\nStruct storing statistics of a single triangle.\n\nFields\n\narea::T: The area of the triangle.\nlengths::NTuple{3,T}: The lengths of the edges of the triangle, given in sorted order. \ncircumcenter::NTuple{2,T}: The circumcenter of the triangle.\ncircumradius::T: The circumradius of the triangle.\nangles::NTuple{3, T}: The angles of the triangle, given in sorted order.\nradius_edge_ratio::T: The ratio of the circumradius to the shortest edge length.\nedge_midpoints::NTuple{3,NTuple{2,T}}: The midpoints of the edges of the triangle.\naspect_ratio::T: The ratio of the inradius to the circumradius.\ninradius::T: The inradius of the triangle.\nperimeter::T: The perimeter of the triangle.\ncentroid::NTuple{2,T}: The centroid of the triangle.\noffcenter::NTuple{2,T}: The offcenter of the triangle with radius-edge ratio cutoff β=1. See this paper.\nsink::NTuple{2,T}: The sink of the triangle relative to the parent triangulation. See this paper.\n\nConstructors\n\nThe constructor is \n\nIndividualTriangleStatistics(p, q, r, sink = (NaN, NaN))\n\nwhere p, q, and r are the coordinates of the triangle given in  counter-clockwise order. sink is the triangle's sink. This must be provided  separately since it is only computed relative to a triangulation, and so requires  vertices rather than coordinates; see triangle_sink.\n\nExtended help\n\nThe relevant functions used for computing these statistics are \n\nsquared_triangle_lengths\ntriangle_area\ntriangle_circumcenter\ntriangle_circumradius\ntriangle_radius_edge_ratio\ntriangle_edge_midpoints\ntriangle_perimeter\ntriangle_inradius\ntriangle_aspect_ratio\ntriangle_centroid\ntriangle_angles\ntriangle_offcenter\ntriangle_sink.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.distance_to_offcenter-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.distance_to_offcenter","text":"distance_to_offcenter(β, ℓ) -> Number\n\nGiven a triangle with shortest edge length ℓ, computes the distance from the edge to the offcenter of the triangle with radius-edge ratio cutoff β.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.make_shortest_edge_first-NTuple{4, Any}","page":"Data Structures","title":"DelaunayTriangulation.make_shortest_edge_first","text":"make_shortest_edge_first(p, q, r, idx) -> (NTuple{2, Number}, NTuple{2, Number}, NTuple{2, Number})\n\nGiven a triangle (p, q, r), rotate it (preserving orientation) so that the shortest edge is first.  The argument idx gives the index of the shortest edge, where idx == 1 means (p, q), idx == 2 means (q, r), and idx == 3 means (r, p).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.min_med_max-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.min_med_max","text":"min_med_max(a, b, c) -> (Number, Number, Number)\n\nReturns the arguments in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.select_shortest_edge_for_offcenter-NTuple{5, Any}","page":"Data Structures","title":"DelaunayTriangulation.select_shortest_edge_for_offcenter","text":"select_shortest_edge_for_offcenter(p, q, r, c, ℓ²) -> (NTuple{2, Number}, NTuple{2, Number}, NTuple{2, Number})\n\nGiven a triangle (p, q, r) with more than one edge attaining the shortest length, selects the appropriate shortest edge for triangle_offcenter.\n\nArguments\n\np: The first vertex of the triangle.\nq: The second vertex of the triangle.\nr: The third vertex of the triangle.\nc: The circumcenter of the triangle.\nℓ²: The squared shortest edge length.\n\nThe arguments should be so that (p, q, r) is positively oriented and ℓ² = |p - q|² is the squared shortest edge length.\n\nOutputs\n\nu: The first vertex of the rotated triangle. \nv: The second vertex of the rotated triangle.\nw: The third vertex of the rotated triangle.\n\nThese outputs (u, v, w) are a permutation of (p, q, r) (maintaining positive orientation) such that |m - c₁| is maximised over all other shortest edges,  where m = (u + v)/2. If there is no unique maximiser, then the output is the permutation that is lexicographically smallest (i.e., sorted by x and then by y).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.squared_triangle_lengths-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.squared_triangle_lengths","text":"squared_triangle_lengths(p, q, r) -> (Number, Number, Number)\n\nComputes the squared lengths of the edges of the triangle with coordinates p, q, r. The squared lengths are returned in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.squared_triangle_lengths_and_smallest_index-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.squared_triangle_lengths_and_smallest_index","text":"squared_triangle_lengths_and_smallest_index(p, q, r) -> (Number, Number, Number, Integer)\n\nComputes the squared lengths of the edges of the triangle with coordinates p, q, r. The squared lengths are returned in sorted order, and the index of the shortest edge is returned as well. Here,  the index refers to which edge in the order (p, q), (q, r), (q, p).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_angles-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_angles","text":"triangle_angles(p, q, r) -> (Number, Number, Number)\n\nComputes the angles of a triangle with vertices p, q, and r. The formula for, say, the angle at p is given by \n\ntheta_1 = arctanleft(dfrac2Aleft(p - qright)cdotleft(p - rright)right)\n\nwhere A is the area of the triangle. The angles are returned in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_area-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_area","text":"triangle_area(p, q, r) -> Number\n\nReturns the signed area of a triangle (p, q, r). The area is positive if (p, q, r) is positively oriented.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_area-Tuple{Number, Number, Number}","page":"Data Structures","title":"DelaunayTriangulation.triangle_area","text":"triangle_area(ℓ₁²::Number, ℓ₂²::Number, ℓ₃²::Number) -> Number\n\nCompute the area of a triangle given the squares of its edge lengths. The edges should be sorted so that  ℓ₁² ≤ ℓ₂² ≤ ℓ₃². If there are precision issues that cause the area to be negative, then the area is set to zero.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_aspect_ratio-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_aspect_ratio","text":"triangle_aspect_ratio(p, q, r) -> Number\n\nComputes the aspect ratio of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_aspect_ratio-Tuple{Number, Number}","page":"Data Structures","title":"DelaunayTriangulation.triangle_aspect_ratio","text":"triangle_aspect_ratio(inradius::Number, circumradius::Number) -> Number\n\nComputes the aspect ratio of a triangle with inradius inradius and circumradius circumradius. The aspect ratio is given by\n\ntau = dfracr_ir\n\nwhere r_i is the inradius and r is the circumradius.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_centroid-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_centroid","text":"triangle_centroid(p, q, r) -> (Number, Number)\n\nComputes the centroid of a triangle with vertices p, q, and r, given by\n\nc = dfracp + q + r3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_circumcenter","page":"Data Structures","title":"DelaunayTriangulation.triangle_circumcenter","text":"triangle_circumcenter(p, q, r, A=triangle_area(p, q, r)) -> (Number, Number)\n\nComputes the circumcenter of the triangle with coordinates (p, q, r). The circumcenter is given by \n\nc_x = r_x + dfracd_11d_22 - d_12d_214A quad c_y = r_y + dfrace_11e_22 - e_12e_214A\n\nwhere d_11 = p - r_2^2, d_12 = p_y - r_y, d_21 = q - r_2^2, d_22 = q_y - r_y, e_11 = p_x - r_x e_12 = d_11, e_21 = q_x - r_x, and e_22 = d_21.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_circumcenter-Tuple{Triangulation, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_circumcenter","text":"triangle_circumcenter(tri::Triangulation, T) -> (Number, Number)\n\nComputes the circumcenter of the triangle T in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_circumradius-NTuple{4, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_circumradius","text":"triangle_circumradius(A, ℓmin², ℓmed², ℓmax²) -> Number\n\nComputes the circumradius of a triangle with area A and squared edge lengths ℓmin² ≤ ℓmed² ≤ ℓmax². The circumradius is given by \n\nr = dfracell_minell_textmedell_max4A\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_circumradius-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_circumradius","text":"triangle_circumradius(p, q, r) -> Number\n\nComputes the circumradius of the triangle with coordinates (p, q, r). \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_edge_midpoints-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_edge_midpoints","text":"triangle_edge_midpoints(p, q, r) -> (Number, Number), (Number, Number), (Number, Number)\n\nComputes the midpoints of the edges of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_inradius-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_inradius","text":"triangle_inradius(p, q, r) -> Number\n\nComputes the inradius of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_inradius-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_inradius","text":"triangle_inradius(A, perimeter) -> Number\n\nComputes the inradius of a triangle with area A and perimeter perimeter. The inradius is given by\n\nr_i = dfrac2AP\n\nwhere P is the perimeter.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_lengths-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_lengths","text":"triangle_lengths(p, q, r) -> (Number, Number, Number)\n\nComputes the lengths of the edges of the triangle with coordinates p, q, r. The lengths are returned in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_offcenter","page":"Data Structures","title":"DelaunayTriangulation.triangle_offcenter","text":"triangle_offcenter(p, q, r, c₁=triangle_circumcenter(p, q, r), β=1.0) -> (Number, Number)\n\nComputes the off-center of the triangle (p, q, r).\n\nArguments\n\np, q, r: The coordinates of the triangle, given in counter-clockwise order.\nc₁=triangle_circumcenter(p, q, r): The circumcenter of the triangle.\nβ=1.0: The radius-edge ratio cutoff. \n\nOutput\n\ncx: The x-coordinate of the off-center.\ncy: The y-coordinate of the off-center.\n\ndanger: Difference in definitions\nIn the original paper, the off-center is defined to instead  be the circumcenter if it the triangle pqc₁ has radius-edge ratio less than β. Here, we just let the off-center be the point c so that pqc has radius-edge ratio of exactly β.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_orthocenter-Tuple{Triangulation, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_orthocenter","text":"triangle_orthocenter(tri::Triangulation, T) -> NTuple{2, Number}\n\nFinds the triangle orthocenter of T. In particular, the point (ox, oy) equidistant from each of the  points of T with respect to the power distance.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_orthoradius_squared-Tuple{Triangulation, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_orthoradius_squared","text":"triangle_orthoradius_squared(p, q, r, a, b, c) -> Number\n\nComputes the squared orthoradius of the triangle (p, q, r) with weights a, b, and c.  Note that this number may be negative.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_perimeter-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_perimeter","text":"triangle_perimeter(p, q, r) -> Number\n\nComputes the perimeter of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_perimeter-Tuple{Number, Number, Number}","page":"Data Structures","title":"DelaunayTriangulation.triangle_perimeter","text":"triangle_perimeter(ℓmin::Number, ℓmed::Number, ℓmax::Number) -> Number\n\nComputes the perimeter of a triangle with edge lengths ℓmin ≤ ℓmed ≤ ℓmax. The perimeter is given by \n\nP = ell_min + ell_textmed + ell_max\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_radius_edge_ratio-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_radius_edge_ratio","text":"triangle_radius_edge_ratio(p, q, r) -> Number\n\nComputes the radius-edge ratio of the triangle with coordinates (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_radius_edge_ratio-Tuple{Number, Number}","page":"Data Structures","title":"DelaunayTriangulation.triangle_radius_edge_ratio","text":"triangle_radius_edge_ratio(circumradius::Number, ℓmin::Number) -> Number\n\nComputes the radius-edge ratio of a triangle with circumradius circumradius and minimum edge length ℓmin, given by \n\nrho = dfracrell_min\n\nwhere r is the circumradius and ell_min is the shortest edge length.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_sink","page":"Data Structures","title":"DelaunayTriangulation.triangle_sink","text":"triangle_sink(tri::Triangulation, T; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Number, Number)\n\nComputes the sink of the triangle T in tri. See this paper for more information. Use the predicates argument to control how predicates are computed.\n\nExtended help\n\nSinks were introduced in this paper. For a given triangle T, the sink of  T is defined as follows:\n\nIf c, the circumcenter of T, is in the interior of T, then the sink of T is T.\nIf T is a boundary triangle, then the sink of T is T.\nIf neither 1 or 2, then the sink is defined as the sink of the triangle V, where V is the triangle adjoining the edge of T which intersects the line mc, where m is the centroid of T.\n\nIn cases where the triangulation has holes, this definition can lead to loops. In such a case, we just pick one of the triangles  in the loop as the sink triangle.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#TriangulationStatistics","page":"Data Structures","title":"TriangulationStatistics","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We also provide a function for computing statistics about a triangulation, using the TriangulationStatistics struct. This struct is in the public API, as listed in the API.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.TriangulationStatistics-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.TriangulationStatistics","text":"TriangulationStatistics{T,V,I}\n\nA struct containing statistics about a triangulation. \n\nFields\n\nnum_vertices::I: The number of vertices in the triangulation.\nnum_solid_vertices::I: The number of solid vertices in the triangulation.\nnum_ghost_vertices::I: The number of ghost vertices in the triangulation.\nnum_edges::I: The number of edges in the triangulation.\nnum_solid_edges::I: The number of solid edges in the triangulation.\nnum_ghost_edges::I: The number of ghost edges in the triangulation.\nnum_triangles::I: The number of triangles in the triangulation.\nnum_solid_triangles::I: The number of solid triangles in the triangulation.\nnum_ghost_triangles::I: The number of ghost triangles in the triangulation.\nnum_boundary_segments::I: The number of boundary segments in the triangulation.\nnum_interior_segments::I: The number of interior segments in the triangulation.\nnum_segments::I: The number of segments in the triangulation.\nnum_convex_hull_vertices::I: The number of vertices on the convex hull of the triangulation.\nsmallest_angle::V: The smallest angle in the triangulation.\nlargest_angle::V: The largest angle in the triangulation.\nsmallest_area::V: The smallest area of a triangle in the triangulation.\nlargest_area::V: The largest area of a triangle in the triangulation.\nsmallest_radius_edge_ratio::V: The smallest radius-edge ratio of a triangle in the triangulation.\nlargest_radius_edge_ratio::V: The largest radius-edge ratio of a triangle in the triangulation.\narea::V: The total area of the triangulation.\nindividual_statistics::Dict{T,IndividualTriangleStatistics{V}}: A map from triangles in the triangulation to their individual statistics. See IndividualTriangleStatistics.\n\nConstructors\n\nTo construct these statistics, use statistics, which you call as statistics(tri::Triangulation).\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.get_all_stat-Tuple{TriangulationStatistics, Symbol}","page":"Data Structures","title":"DelaunayTriangulation.get_all_stat","text":"get_all_stat(stats::TriangulationStatistics, stat::Symbol) -> Vector\n\nReturns a vector of the statistic stat for each triangle in stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_angles-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_angles","text":"get_angles(stats::TriangulationStatistics, T)\n\nReturns the angles field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_area-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_area","text":"get_area(stats::TriangulationStatistics, T)\n\nReturns the area field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_area-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_area","text":"get_area(stats::TriangulationStatistics)\n\nReturns the area field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_aspect_ratio-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_aspect_ratio","text":"get_aspect_ratio(stats::TriangulationStatistics, T)\n\nReturns the aspect_ratio field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_centroid-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(stats::TriangulationStatistics, T)\n\nReturns the centroid field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circumcenter-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_circumcenter","text":"get_circumcenter(stats::TriangulationStatistics, T)\n\nReturns the circumcenter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circumradius-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_circumradius","text":"get_circumradius(stats::TriangulationStatistics, T)\n\nReturns the circumradius field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_edge_midpoints-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_edge_midpoints","text":"get_edge_midpoints(stats::TriangulationStatistics, T)\n\nReturns the edge_midpoints field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_individual_statistics-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_individual_statistics","text":"get_individual_statistics(stats::TriangulationStatistics)\n\nReturns the individual_statistics field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_inradius-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_inradius","text":"get_inradius(stats::TriangulationStatistics, T)\n\nReturns the inradius field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_largest_angle-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_largest_angle","text":"get_largest_angle(stats::TriangulationStatistics)\n\nReturns the largest_angle field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_largest_area-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_largest_area","text":"get_largest_area(stats::TriangulationStatistics)\n\nReturns the largest_area field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_largest_radius_edge_ratio-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_largest_radius_edge_ratio","text":"get_largest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the largestradiusedge_ratio field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_lengths-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_lengths","text":"get_lengths(stats::TriangulationStatistics, T)\n\nReturns the lengths field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_maximum_angle-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_maximum_angle","text":"get_maximum_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the maximum angle of T from stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_median_angle-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_median_angle","text":"get_median_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the median angle of T from stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_minimum_angle-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_minimum_angle","text":"get_minimum_angle(stats::TriangulationStatistics, T) -> Float64\n\nReturns the minimum angle of T from stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_offcenter-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_offcenter","text":"get_offcenter(stats::TriangulationStatistics, T)\n\nReturns the offcenter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_perimeter-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_perimeter","text":"get_perimeter(stats::TriangulationStatistics, T)\n\nReturns the perimeter field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_radius_edge_ratio-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_radius_edge_ratio","text":"get_radius_edge_ratio(stats::TriangulationStatistics, T)\n\nReturns the radiusedgeratio field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_sink-Tuple{TriangulationStatistics, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_sink","text":"get_sink(stats::TriangulationStatistics, T)\n\nReturns the sink field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_smallest_angle-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_smallest_angle","text":"get_smallest_angle(stats::TriangulationStatistics)\n\nReturns the smallest_angle field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_smallest_area-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_smallest_area","text":"get_smallest_area(stats::TriangulationStatistics)\n\nReturns the smallest_area field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_smallest_radius_edge_ratio-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.get_smallest_radius_edge_ratio","text":"get_smallest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the smallestradiusedge_ratio field from the TriangulationStatistics stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_boundary_segments-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_boundary_segments","text":"num_boundary_segments(stats::TriangulationStatistics)\n\nReturns the numboundarysegments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_convex_hull_vertices-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_convex_hull_vertices","text":"num_convex_hull_vertices(stats::TriangulationStatistics)\n\nReturns the numconvexhull_vertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_edges-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_edges","text":"num_edges(stats::TriangulationStatistics)\n\nReturns the num_edges field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_ghost_edges-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(stats::TriangulationStatistics)\n\nReturns the numghostedges field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_ghost_triangles-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(stats::TriangulationStatistics)\n\nReturns the numghosttriangles field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_ghost_vertices-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_interior_segments-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_interior_segments","text":"num_interior_segments(stats::TriangulationStatistics)\n\nReturns the numinteriorsegments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_segments-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_segments","text":"num_segments(stats::TriangulationStatistics)\n\nReturns the num_segments field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_solid_edges-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(stats::TriangulationStatistics)\n\nReturns the numsolidedges field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_solid_triangles-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(stats::TriangulationStatistics)\n\nReturns the numsolidtriangles field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_solid_vertices-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_triangles-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(stats::TriangulationStatistics)\n\nReturns the num_triangles field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_vertices-Tuple{TriangulationStatistics}","page":"Data Structures","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(stats::TriangulationStatistics)\n\nReturns the num_vertices field from the TriangulationStatistics` stats.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.statistics-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.statistics","text":"statistics(tri::Triangulation) -> TriangulationStatistics\n\nReturns a TriangulationStatistics object containing statistics about the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#InsertionEventHistory","page":"Data Structures","title":"InsertionEventHistory","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"For mesh refinement we need a way to identify what happens to a triangulation after a point is added, in case we need to reverse the insertion. For this, we use InsertionEventHistory internally.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.InsertionEventHistory-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.InsertionEventHistory","text":"InsertionEventHistory{T,E}\n\nA data structure for storing the changes to the triangulation during the insertion of a point.\n\nFields\n\nadded_triangles::Set{T}: The triangles that were added.\ndeleted_triangles::Set{T}: The triangles that were deleted.\nadded_segments::Set{E}: The interior segments that were added.\ndeleted_segments::Set{E}: The interior segments that were deleted.\nadded_boundary_segments::Set{E}: The boundary segments that were added.\ndeleted_boundary_segments::Set{E}: The boundary segments that were deleted.\n\nConstructor\n\nThe default constructor is available, but we also provide \n\nInsertionEventHistory(tri::Triangulation)\n\nwhich will initialise this struct with empty, appropriately sizehint!ed, sets.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.empty!-Tuple{DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"Base.empty!","text":"empty!(events::InsertionEventHistory)\n\nEmpties events by emptying all of its fields.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_edge!-Tuple{DelaunayTriangulation.InsertionEventHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(events::InsertionEventHistory, e)\n\nAdd the edge e to the added_segments of events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.InsertionEventHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(events::InsertionEventHistory, T)\n\nAdd the triangle T to the added_triangles of events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_edge!-Tuple{DelaunayTriangulation.InsertionEventHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(events::InsertionEventHistory, e)\n\nAdd the edge e to the deleted_segments of events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.InsertionEventHistory, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(events::InsertionEventHistory, T)\n\nAdd the triangle T to the deleted_triangles of events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_added_boundary_segment-Tuple{DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.each_added_boundary_segment","text":"each_added_boundary_segment(events::InsertionEventHistory) -> Iterator\n\nReturns an iterator over the boundary segments that were added to the triangulation during the insertion of a point.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_added_segment-Tuple{DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.each_added_segment","text":"each_deleted_triangle(events::InsertionEventHistory) -> Iterator\n\nReturns an iterator over the triangles that were deleted from the triangulation during the insertion of a point.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_added_triangle-Tuple{DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.each_added_triangle","text":"each_added_triangle(events::InsertionEventHistory) -> Iterator\n\nReturns an iterator over the triangles that were added to the triangulation during the insertion of a point.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_segment_changes-Tuple{DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.has_segment_changes","text":"has_triangle_changes(events::InsertionEventHistory) -> Bool\n\nReturns true if there are any changes to the segments in events, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.split_boundary_edge!-Union{Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.InsertionEventHistory{T, E}, Any, Any, Any}} where {T, E}","page":"Data Structures","title":"DelaunayTriangulation.split_boundary_edge!","text":"split_boundary_edge!(events::InsertionEventHistory, u, v, new_point)\n\nAdd the edge (u, v) to the deleted_boundary_segments of events and add the edges (u, new_point) and (new_point, v) to the added_boundary_segments of events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_type-Union{Tuple{DelaunayTriangulation.InsertionEventHistory{T}}, Tuple{T}} where T","page":"Data Structures","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(::InsertionEventHistory{T}) where {T} = T\n\nReturns the type of the triangles in events, T.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.undo_boundary_segment_changes!-Tuple{Triangulation, DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.undo_boundary_segment_changes!","text":"undo_boundary_segment_changes!(tri::Triangulation, events::InsertionEventHistory)\n\nUndoes any changes to the boundary segments in tri that were made after an insertion event, as recorded in events, assuming the inserted vertex is num_points(tri).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.undo_insertion!","page":"Data Structures","title":"DelaunayTriangulation.undo_insertion!","text":"undo_insertion!(tri::Triangulation, events::InsertionEventHistory, pop=Val(true))\n\nUndoes the insertion of the most recent vertex into tri, assuming that its insertion history has been  recorded into events and the vertex is num_points(tri). \n\nIf you do not want to delete the latest vertex from the triangulation, set pop to Val(false).\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.undo_segment_changes!-Tuple{Triangulation, DelaunayTriangulation.InsertionEventHistory}","page":"Data Structures","title":"DelaunayTriangulation.undo_segment_changes!","text":"undo_segment_changes!(tri::Triangulation, events::InsertionEventHistory)\n\nUndoes any changes to the segments in tri that were made after an insertion event, as recorded in events.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#RefinementConstraints","page":"Data Structures","title":"RefinementConstraints","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"For mesh refinement, internally we store the user-provided constraints inside their own struct RefinementConstraints.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.RefinementConstraints","page":"Data Structures","title":"DelaunayTriangulation.RefinementConstraints","text":"RefinementConstraints{F}\n\nA struct for storing constraints for mesh refinement.\n\nFields\n\nmin_angle=0.0: The minimum angle of a triangle.\nmax_angle=180.0: The maximum angle of a triangle. \nmin_area=0.0: The minimum area of a triangle.\nmax_area=Inf: The maximum area of a triangle.\nmax_radius_edge_ratio=csd(min_angle) / 2: The maximum radius-edge ratio of a triangle. This is computed from min_angle - you cannot provide a value for it yourself. \nmax_points=typemax(Int): The maximum number of vertices allowed in the triangulation. Note that this refers to num_solid_vertices, not the amount returned by num_points.\nseiditous_angle=20.0: The inter-segment angle used to define seditious edges in degrees. Should not be substantially smaller than 20.0° or any greater than 60.0°.\ncustom_constraint::F=(tri, triangle) -> false: A custom constraint function. This should take a Triangulation and a triangle as arguments, and return true if the triangle violates the constraints and false otherwise.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.has_max_angle_constraint-Tuple{DelaunayTriangulation.RefinementConstraints}","page":"Data Structures","title":"DelaunayTriangulation.has_max_angle_constraint","text":"has_max_angle_constraint(constraints::RefinementConstraints) -> Bool\n\nReturn true if constraints has a maximum angle constraint, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.violates_custom_constraint-Union{Tuple{F}, Tuple{DelaunayTriangulation.RefinementConstraints{F}, Triangulation, Any}} where F","page":"Data Structures","title":"DelaunayTriangulation.violates_custom_constraint","text":"violates_custom_constraint(constraints::RefinementConstraints{F}, tri::Triangulation, T) where {F} -> Bool\n\nReturn true if T violates the custom constraint in constraints, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#RefinementQueue","page":"Data Structures","title":"RefinementQueue","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"The mesh refinement algorithm we use requires a method for prioritising which segments and triangles need to be split. Using a MaxPriorityQueue, so that large segments and large triangles are prioritised, we use a RefinementQueue internally to determine this ordering.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.RefinementQueue","page":"Data Structures","title":"DelaunayTriangulation.RefinementQueue","text":"RefinementQueue{T,E,F}\n\nStruct defining a pair of priority queues for encroached segments and poor-quality triangles. \n\nFields\n\nsegments::MaxPriorityQueue{E,F}: A priority queue of encroached segments, where the priorities are the squared edge lengths.\ntriangles::MaxPriorityQueue{T,F}: A priority queue of poor-quality triangles, where the priorities are the radius-edge ratios.\n\nConstructor\n\nThe default constructor is available, but we also provide \n\nRefinementQueue(tri::Triangulation)\n\nwhich will initialise this struct with empty queues with the appropriate types.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#Base.getindex-Union{Tuple{F}, Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.RefinementQueue{T, E, F}, T}} where {T, E, F}","page":"Data Structures","title":"Base.getindex","text":"getindex(queue::RefinementQueue{T,E,F}, triangle::T) -> F\nqueue[triangle] -> F\n\nReturn the radius-edge ratio of triangle in queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.haskey-Union{Tuple{F}, Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.RefinementQueue{T, E, F}, E}} where {T, E, F}","page":"Data Structures","title":"Base.haskey","text":"haskey(queue::RefinementQueue{T,E,F}, segment::E) -> Bool\n\nReturn true if queue has segment or its reverse, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.haskey-Union{Tuple{F}, Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.RefinementQueue{T, E, F}, T}} where {T, E, F}","page":"Data Structures","title":"Base.haskey","text":"haskey(queue::RefinementQueue{T,E,F}, triangle::T) -> Bool\n\nReturn true if queue has triangle or any of its counter-clockwise rotations, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.isempty-Tuple{DelaunayTriangulation.RefinementQueue}","page":"Data Structures","title":"Base.isempty","text":"isempty(queue::RefinementQueue) -> Bool\n\nReturn true if queue has no segments or triangles, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.setindex!-Union{Tuple{F}, Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.RefinementQueue{T, E, F}, Any, T}} where {T, E, F}","page":"Data Structures","title":"Base.setindex!","text":"setindex!(queue::RefinementQueue{T,E,F}, ρ::F, triangle::T) where {T,E,F}\nqueue[triangle] = ρ\n\nAdd a triangle to queue whose radius-edge ratio is ρ. If the triangle is already in the queue, its priority is updated to ρ.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Base.setindex!-Union{Tuple{F}, Tuple{E}, Tuple{T}, Tuple{DelaunayTriangulation.RefinementQueue{T, E, F}, F, E}} where {T, E, F}","page":"Data Structures","title":"Base.setindex!","text":"setindex!(queue::RefinementQueue{T,E,F}, ℓ²::F, segment::E) where {T,E,F}\nqueue[segment] = ℓ²\n\nAdd a segment to queue whose squared length is ℓ². If the segment is already in the queue, its priority is updated to ℓ.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_segments-Tuple{DelaunayTriangulation.RefinementQueue}","page":"Data Structures","title":"DelaunayTriangulation.has_segments","text":"has_segments(queue::RefinementQueue) -> Bool\n\nReturn true if queue has any segments, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_triangles-Tuple{DelaunayTriangulation.RefinementQueue}","page":"Data Structures","title":"DelaunayTriangulation.has_triangles","text":"has_triangles(queue::RefinementQueue) -> Bool\n\nReturn true if queue has any triangles, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.popfirst_segment!-Tuple{DelaunayTriangulation.RefinementQueue}","page":"Data Structures","title":"DelaunayTriangulation.popfirst_segment!","text":"popfirst_segment!(queue::RefinementQueue) -> Edge\n\nDequeue the next segment from queue, returning the segment and its squared length.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.popfirst_triangle!-Tuple{DelaunayTriangulation.RefinementQueue}","page":"Data Structures","title":"DelaunayTriangulation.popfirst_triangle!","text":"popfirst_triangle!(queue::RefinementQueue) -> (Triangle, Number)\n\nDequeue the next triangle from queue, returning the triangle and its radius-edge ratio.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#RefinementArguments","page":"Data Structures","title":"RefinementArguments","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"There are many arguments that need to be passed around during mesh refinement. To simplify this, we use a RefinementArguments struct internally.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.RefinementArguments","page":"Data Structures","title":"DelaunayTriangulation.RefinementArguments","text":"RefinementArguments{Q,C,H,I,E,T,R,P<:AbstractPredicateKernel}\n\nA struct for storing arguments for mesh refinement.\n\nFields\n\nqueue::Q: The RefinementQueue.\nconstraints::C: The RefinementConstraints.\nevents::H: The InsertionEventHistory.\nmin_steiner_vertex::I: The minimum vertex of a Steiner point. All vertices greater than or equal to this can be considered as Steiner vertices. \nsegment_list::Set{E}: The set of segments in the triangulation before refinement.\nsegment_vertices::Set{I}: Set of vertices that are vertices of segments in segment_list.\nmidpoint_split_list::Set{I}: Set of vertices that are centre-splits of encroached edges.\noffcenter_split_list::Set{I}: Set of vertices that are off-centre splits of encroached edges.\nuse_circumcenter::Bool: Whether to use circumcenters for Steiner points, or the more general approach of Erten and Üngör (2009).\nuse_lens::Bool: Whether to use diametral lens (true) or diametral circles (false) for the defining encroachment.\nsteiner_scale::T: The factor by which to scale the Steiner points closer to the triangle's shortest edge.\nlocked_convex_hull::Bool: Whether the convex hull of the triangulation had to be locked for refinement. \nhad_ghosts::Bool: Whether the triangulation initially had ghost triangles or not.\nrng::R: The random number generator.\nconcavity_protection::Bool: Whether to use concavity protection or not for find_triangle. Most likely not needed, but may help in pathological cases.\npredicates::P<:AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nConstructors\n\nIn addition to the default constructor, we provide \n\nRefinementArguments(tri::Triangulation; kwargs...)\n\nfor constructing this struct. This constructor will lock the convex hull and add ghost triangles to tri if needed (refine! will undo these changes once the refinement is finished))\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.RefinementArguments-Tuple{Triangulation}","page":"Data Structures","title":"DelaunayTriangulation.RefinementArguments","text":"RefinementArguments(tri::Triangulation; kwargs...) -> RefinementArguments\n\nInitialises the RefinementArguments for the given Triangulation, tri. The kwargs... match those from refine!.\n\nwarning: Mutation\nIf tri has no ghost triangles, it will be mutated so that it has them. Similarly, if the triangulation  has no constrained boundary, then the convex hull will be locked so that it is treated as a constrained  boundary. These changes will be undone in refine! once the refinement is finished.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_free-Tuple{DelaunayTriangulation.RefinementArguments, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_free","text":"is_free(args::RefinementArguments, u) -> Bool\n\nReturns true if u is a free vertex, and false otherwise. A free vertex is a Steiner vertex (meaning a non-input vertex) that is not part of a segment or subsegment.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_midpoint_split-Tuple{DelaunayTriangulation.RefinementArguments, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_midpoint_split","text":"is_midpoint_split(args::RefinementArguments, u) -> Bool\n\nReturns true if u is a midpoint of an encroached segment, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_offcenter_split-Tuple{DelaunayTriangulation.RefinementArguments, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_offcenter_split","text":"is_offcenter_split(args::RefinementArguments, u) -> Bool\n\nReturns true if u is an off-centre split of an encroached segment, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_segment_vertex-Tuple{DelaunayTriangulation.RefinementArguments, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_segment_vertex","text":"is_segment_vertex(args::RefinementArguments, u) -> Bool\n\nReturns true if u is a vertex of a segment, and false otherwise. Note that this excludes vertices of subsegments.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_subsegment-Tuple{DelaunayTriangulation.RefinementArguments, Any}","page":"Data Structures","title":"DelaunayTriangulation.is_subsegment","text":"is_subsegment(args::RefinementArguments, u, v) -> Bool\n\nReturns true if the edge (u, v) is a subsegment, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.keep_iterating-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}","page":"Data Structures","title":"DelaunayTriangulation.keep_iterating","text":"keep_iterating(tri::Triangulation, args::RefinementArguments) -> Bool\n\nReturns true if the refinement should continue, and false otherwise. The check is based on  whether the RefinementQueue is empty or not, and whether the number of points in the triangulation is less than or equal to the maximum number of points allowed by the RefinementConstraints.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.keep_splitting-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}","page":"Data Structures","title":"DelaunayTriangulation.keep_splitting","text":"keep_splitting(tri::Triangulation, args::RefinementArguments) -> Bool\n\nReturns true if more encroached segments need to be split, and false otherwise. The check is based on whether the segment queue in the RefinementQueue of args is empty or not, and whether the number of points in the triangulation is less than or equal to the maximum number of points allowed by the RefinementConstraints in args.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#VoronoiTessellation","page":"Data Structures","title":"VoronoiTessellation","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We use a VoronoiTessellation struct to represent a Voronoi tessellation. This struct is in the public API.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.VoronoiTessellation-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.VoronoiTessellation","text":"VoronoiTessellation{Tr<:Triangulation,P,I,T,S,E}\n\nStruct for representing a Voronoi tessellation.\n\nSee also voronoi.\n\nnote: Field access\nAccessing the fields themselves using e.g. vorn.field is not recommended and is not intended  to be in the public API. You should be using the  accessor functions, e.g. instead of vorn.adjacent do get_adjacent(vorn). Similarly, for the iterators, e.g. vorn.generators, each_generators(vorn) is recommended instead.\n\nnote: Power diagram\nIn the case that the underlying triangulation is weighted, then this struct represents the power diagram,  and instead of circumcenters the points are orthocenters computed with triangle_orthocenter.\n\nFields\n\ntriangulation::Tr: The underlying triangulation. The tessellation is dual to this triangulation,   although if the underlying triangulation is constrained then this is no longer the case (but it is   still used).\ngenerators::Dict{I,P}: A Dict that maps vertices of generators to coordinates. These are simply the   points present in the triangulation. A Dict is needed in case the triangulation is missing some points.\npolygon_points::Vector{P}: The points defining the coordinates of the polygons. The points are not guaranteed  to be unique if a circumcenter appears on the boundary or you are considering a clipped tessellation. (See also get_polygon_coordinates.)\npolygons::Dict{I,Vector{I}}: A Dict mapping polygon indices (which is the same as a generator vertex) to the vertices of a polygon. The polygons are given in   counter-clockwise order and the first and last vertices are equal.\ncircumcenter_to_triangle::Dict{I,T}: A Dict mapping a circumcenter index to the triangle that contains it. The triangles are sorted such that the   minimum vertex is last. \ntriangle_to_circumcenter::Dict{T,I}: A Dict mapping a triangle to its circumcenter index. The triangles are sorted such that the minimum vertex is last. \nunbounded_polygons::Set{I}: A Set of indices of the unbounded polygons. \ncocircular_circumcenters::S: A Set of indices of circumcenters that come from triangles that are cocircular with another triangle's vertices, and adjoin said triangles. \nadjacent::Adjacent{I,E}: The adjacent map. This maps an oriented edge to the polygon that it belongs to.\nboundary_polygons::Set{I}: A Set of indices of the polygons that are on the boundary of the tessellation. Only relevant for clipped   tessellations, otherwise see unbounded_polygons.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.add_adjacent!-Tuple{VoronoiTessellation, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(vor::VoronoiTessellation, ij, k)\nadd_adjacent!(vor::VoronoiTessellation, i, j, k)\n\nAdds the adjacency relationship (i, j) ⟹ k between the oriented edge (i, j) and polygon index k to the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_boundary_polygon!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_boundary_polygon!","text":"add_boundary_polygon!(vor::VoronoiTessellation, i)\n\nAdds the index i to the set of boundary polygons of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_polygon!-Tuple{VoronoiTessellation, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_polygon!","text":"add_polygon!(vor::VoronoiTessellation, B, i)\n\nAdds, or replaces, the polygon associated with the index i with B. B should be a counter-clockwise  sequence of vertices, with B[begin] == B[end].\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_polygon_adjacent!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_polygon_adjacent!","text":"add_polygon_adjacent!(vorn::VoronoiTessellation, polygon)\n\nAdds the adjacent polygons of the boundary edges of the polygon polygon to the adjacency list.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_unbounded_polygon!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_unbounded_polygon!","text":"add_unbounded_polygon!(vor::VoronoiTessellation, i)\n\nAdds the index i to the set of unbounded polygons of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex","text":"convert_to_edge_adjoining_ghost_vertex(vorn::VoronoiTessellation, e) -> Edge\n\nReturns the edge e if it is not a boundary edge, and the edge reverse(e) if it is a boundary edge. \n\nSee also is_boundary_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_adjacent!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(vor::VoronoiTessellation, ij)\ndelete_adjacent!(vor::VoronoiTessellation, i, j)\n\nDeletes the edge (i, j) from the adjacency map of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_polygon_adjacent!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_polygon_adjacent!","text":"delete_polygon!(vor::VoronoiTessellation, polygon)\n\nDeletes the adjacent polygons of the boundary edges of the polygon polygon from the adjacency list.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_unbounded_polygon!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_unbounded_polygon!","text":"delete_unbounded_polygon!(vor::VoronoiTessellation, i)\n\nDeletes the index i from the set of unbounded polygons of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_generator-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.each_generator","text":"each_boundary_polygon(vorn::VoronoiTessellation) -> KeySet\n\nReturns an iterator over the boundary polygon indices of vorn.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_polygon-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.each_polygon","text":"each_polygon(vor::VoronoiTessellation) -> ValueIterator\n\nReturns an iterator over each set of polygon vertices of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_polygon_index-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.each_polygon_index","text":"each_polygon_index(vor::VoronoiTessellation) -> KeySet\n\nReturns an iterator over the polygon indices of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_polygon_vertex-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.each_polygon_vertex","text":"each_polygon_vertex(vor::VoronoiTessellation) -> UnitRange\n\nReturns an iterator over each polygon point index of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_unbounded_polygon-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.each_unbounded_polygon","text":"each_polygon(vor::VoronoiTessellation) -> Set\n\nReturns an iterator over the polygon indices of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.edge_type-Union{Tuple{VoronoiTessellation{Tr, P, I, T, S, E}}, Tuple{E}, Tuple{S}, Tuple{T}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I, T, S, E}","page":"Data Structures","title":"DelaunayTriangulation.edge_type","text":"edge_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing individual edges in the Voronoi tessellation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(vor::VoronoiTessellation, ij) -> Index \nget_adjacent(vor::VoronoiTessellation, i, j) -> Index\n\nGets the polygon index associated with the oriented edge ij in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_adjacent-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(vorn::VoronoiTessellation) -> Adjacent{Index,Edge}\n\nGets the adjacency information of the Voronoi tessellation vorn as an Adjacent object. This object maps oriented edges  to the polygons that they belong to.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_area-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_area","text":"get_area(vor::VoronoiTessellation, i) -> Number\n\nGets the area of the ith Voronoi polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_polygons-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_polygons","text":"get_boundary_polygons(vorn::VoronoiTessellation) -> Set{Index}\n\nGets the boundary polygons of the Voronoi tessellation vorn as a Set of polygon indices.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_centroid-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(vor::VoronoiTessellation, i) -> NTuple{2, Number}\n\nGets the centroid of the ith Voronoi polygon, given as a Tuple of the form (x, y).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circumcenter_to_triangle-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_circumcenter_to_triangle","text":"get_circumcenter_to_triangle(vor::VoronoiTessellation, i) -> Triangle\n\nGets the triangle associated with the ith circumcenter. The triangle is sorted so that the minimum vertex is last.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_circumcenter_to_triangle-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_circumcenter_to_triangle","text":"get_circumcenter_to_triangle(vorn::VoronoiTessellation) -> Dict{Index,Triangle}\n\nGets the circumcenters of the Voronoi tessellation vorn as a Dict, mapping circumcenter indices to their corresponding triangles. The triangles are sorted so that the minimum vertex is last.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_cocircular_circumcenters-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_cocircular_circumcenters","text":"get_cocircular_circumcenters(vorn::VoronoiTessellation) -> Set\n\nGets the cocircular circumcenters of the Voronoi tessellation vorn as a Set of circumcenter indices. These are circumcenters  that come from triangles that are cocircular with another adjoining triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_generator-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_generator","text":"get_generator(vor::VoronoiTessellation, i) -> NTuple{2, Number}\nget_generator(vor::VoronoiTessellation, i...) -> NTuple{length(i), NTuple{2, Number}}\n\nGets the coordinates for the generators i..., returned as Tuples of the form (x, y) for each generator.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_generators-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_generators","text":"get_generators(vorn::VoronoiTessellation) -> Dict{Vertex,Point}\n\nGets the generators of the Voronoi tessellation vorn as a Dict, mapping vertices to their coordinates. These  coordinates are given as Tuples of the form (x, y).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_neighbouring_boundary_edges-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_neighbouring_boundary_edges","text":"get_neighbouring_boundary_edges(vorn::VoronoiTessellation, e) -> (Edge, Edge)\n\nGiven a boundary edge e, returns the edges left and right of e. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon","text":"get_polygon(vor::VoronoiTessellation, i) -> Vector{Vertex}\n\nGets the vector of vertices corresponding to the ith polygon, given in counter-clockwise order and  with the first and last vertices equal. To obtain the coordinates, see get_polygon_point.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_point-Tuple{VoronoiTessellation, Vararg{Any}}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_point","text":"get_polygon_point(vor::VoronoiTessellation, i) -> NTuple{2, Number}\nget_polygon_point(vor::VoronoiTessellation, i...) -> NTuple{length(i), NTuple{2, Number}}\n\nGets the coordinates corresponding to the vertices i... of the polygons, returned as Tuples of the form (x, y) for each vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygon_points-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_polygon_points","text":"get_polygon_points(vorn::VoronoiTessellation) -> Vector{Point}\n\nGets the polygon points of the Voronoi tessellation vorn. These are the vertices of the Voronoi polygons, and are given as Tuples of the form (x, y).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_polygons-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_polygons","text":"get_polygons(vorn::VoronoiTessellation) -> Dict{Index,Vector{Vertex}}\n\nGets the polygons of the Voronoi tessellation vorn as a Dict, mapping polygon indices to their vertices,  where the vertices refer to points in get_polygon_points(vorn). The vertices are given in counter-clockwise order  and the first and last vertices are equal. \n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_surrounding_polygon-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(vor::VoronoiTessellation, i) -> Vector{Vertex}\n\nGets the polygon surrounding the generator with index i in vor. \n\nYou shouldn't need to use this, see get_polygon instead.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangle_to_circumcenter-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_triangle_to_circumcenter","text":"get_triangle_to_circumcenter(vor::VoronoiTessellation, T) -> Index\n\nGets the circumcenter index associated with the triangle T. The triangle should be sorted so that the minimum vertex is last.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangle_to_circumcenter-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_triangle_to_circumcenter","text":"get_triangle_to_circumcenter(vorn::VoronoiTessellation) -> Dict{Triangle,Index}\n\nGets the triangles of the Voronoi tessellation vorn as a Dict, mapping triangle indices to their corresponding circumcenters. The circumcenters are given as their vertices, referring to points in get_polygon_points(vorn).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triangulation-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_triangulation","text":"get_triangulation(vorn::VoronoiTessellation) -> Triangulation\n\nGets the underlying triangulation of the Voronoi tessellation vorn.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_unbounded_polygons-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.get_unbounded_polygons","text":"get_unbounded_polygons(vorn::VoronoiTessellation) -> Set{Index}\n\nGets the unbounded polygons of the Voronoi tessellation vorn as a Set of polygon indices.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.has_polygon-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.has_polygon","text":"has_polygon(vor::VoronoiTessellation, i) -> Bool\n\nReturns true if the Voronoi tessellation vor has a polygon with index i.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.integer_type-Union{Tuple{VoronoiTessellation{Tr, P, I}}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I}","page":"Data Structures","title":"DelaunayTriangulation.integer_type","text":"integer_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing indices in the Voronoi tessellation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_weighted-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.is_weighted","text":"is_weighted(vorn::VoronoiTessellation) -> Bool\n\nReturns true if the Voronoi tessellation vorn is weighted, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_generators-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.num_generators","text":"num_generators(vor::VoronoiTessellation) -> Integer\n\nReturns the number of generators in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_polygon_vertices-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.num_polygon_vertices","text":"num_polygon_vertices(vor::VoronoiTessellation) -> Integer\n\nReturns the number of polygon vertices in the Voronoi tessellation vor. This might include duplicate vertices if get_polygon_points(vor) has duplicates.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_polygons-Tuple{VoronoiTessellation}","page":"Data Structures","title":"DelaunayTriangulation.num_polygons","text":"num_polygons(vor::VoronoiTessellation) -> Integer\n\nReturns the number of polygons in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.number_type-Union{Tuple{VoronoiTessellation{Tr, P}}, Tuple{P}, Tuple{Tr}} where {Tr, P}","page":"Data Structures","title":"DelaunayTriangulation.number_type","text":"number_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing individual coordinates in the Voronoi tessellation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.polygon_bounds","page":"Data Structures","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(vorn::VoronoiTessellation, unbounded_extension_factor=0.0; include_polygon_vertices=true) -> (Number, Number, Number, Number)\n\nGets the bounding box for the Voronoi tessellation vorn.\n\nArguments\n\nvorn::VoronoiTessellation: The Voronoi tessellation.\nunbounded_extension_factor=0.0: The factor by which to extend the bounding box for unbounded polygons.\n\nKeyword Arguments\n\ninclude_polygon_vertices=true: If true, then the bounding box will also include the polygon vertices. Otherwise, only the generators are included.\n\nOutput\n\nxmin: Given by xmin′ - unbounded_extension_factor * (xmin′ - xmin′), where xmin′ is the original minimum x-coordinate of the computed bounding box and similarly for xmax′.\nxmax: Given by xmax′ + unbounded_extension_factor * (xmax′ - xmax′), where xmax′ is the original maximum x-coordinate of the computed bounding box and similarly for xmin′.\nymin: Given by ymin′ - unbounded_extension_factor * (ymin′ - ymin′), where ymin′ is the original minimum y-coordinate of the computed bounding box and similarly for ymax′.\nymax: Given by ymax′ + unbounded_extension_factor * (ymax′ - ymax′), where ymax′ is the original maximum y-coordinate of the computed bounding box and similarly for ymin′.\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.polygon_features-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(vor::VoronoiTessellation, i) -> (Number, NTuple{2, Number})\n\nGets the area and centroid of the polygon with index i in vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.push_polygon_point!-Tuple{VoronoiTessellation, Any}","page":"Data Structures","title":"DelaunayTriangulation.push_polygon_point!","text":"push_polygon_point!(vor::VoronoiTessellation, p)\npush_polygon_point!(vor::VoronoiTessellation, x, y)\n\nAdds the point p = (x, y) into the vector of polygon points of vor.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_type-Union{Tuple{VoronoiTessellation{Tr, P, I, T}}, Tuple{T}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I, T}","page":"Data Structures","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing individual triangles in the Voronoi tessellation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Polygon","page":"Data Structures","title":"Polygon","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"We sometimes find it useful to use a specific Polygon struct for representing polygons.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.Polygon","page":"Data Structures","title":"DelaunayTriangulation.Polygon","text":"Polygon{T,V,P} <: AbstractVector{T}\n\nA struct for representing a polygon. The vertices are to be a counter-clockwise list of integers, where  the integers themselves refer to points in points.\n\nFields\n\nvertices::V: A list of integers that refer to points in points. The last vertex shokuld not be the same as the first.\npoints::P: A list of points.\n\nwarning: Aliasing\nIn the case where vertices[begin] ≠ vertices[end], the vertices field is exactly the same as the input vertices. Where  vertices[begin] = vertices[end], the vertices field is a view of vertices that excludes the last element.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#ShuffledPolygonLinkedList","page":"Data Structures","title":"ShuffledPolygonLinkedList","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"For computing constrained Delaunay triangulations, we use a ShuffledPolygonLinkedList struct to store the polygons involved.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.ShuffledPolygonLinkedList","page":"Data Structures","title":"DelaunayTriangulation.ShuffledPolygonLinkedList","text":"ShuffledPolygonLinkedList{I,T}\n\nData structure for representing a polygon as a doubly-linked list. In the  descriptions below, π is used to denote the shuffled_indices vector.\n\nFields\n\nnext::Vector{I}: The next vertices, so that next[π[i]] is the vertex after S[π[i]].\nprev::Vector{I}: The prev vertices, so that prev[π[i]] is the vertex before S[π[i]].\nshuffled_indices::Vector{I}: The shuffled indices of the vertices, so that S[π[i]] is the ith vertex.\nk::I: The number of vertices in the polygon.\nS::T: The vertices of the polygon. This should not be a circular vector, i.e. S[begin] ≠ S[end], and must use one-based indexing. Additionally,   the vertices must be provided in counter-clockwise order - this is NOT checked.\n\nConstructor\n\nTo construct this, use \n\nShuffledPolygonLinkedList(S::Vector; rng::Random.AbstractRNG=Random.default_rng())\n\nThe argument rng is used for shuffling the shuffled_indices vector.\n\n\n\n\n\n","category":"type"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_vertex!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(list::ShuffledPolygonLinkedList, i)\n\nDeletes the vertex S[πᵢ] from the linked list, where πᵢ = list.shuffled_indices[i]. This deletion is done symbolically rather than by mutating the vectors in list. In particular,  we perform\n\nnext[prev[πᵢ]] = next[πᵢ]\nprev[next[πᵢ]] = prev[πᵢ]\n\nwhich is the same as removing S[πᵢ] from the linked list.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_triplet-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Any}","page":"Data Structures","title":"DelaunayTriangulation.get_triplet","text":"get_triplet(list::ShuffledPolygonLinkedList, i) -> (Vertex, Vertex, Vertex)\n\nReturns (u, v, w) = (S[πᵢ], S[next[πᵢ]], S[prev[πᵢ]]), where πᵢ = list.shuffled_indices[i] and S = list.S.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reset!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList}","page":"Data Structures","title":"DelaunayTriangulation.reset!","text":"reset!(list::ShuffledPolygonLinkedList; rng::Random.AbstractRNG=Random.default_rng())\n\nResets the linked list, so that list.next[i] = mod1(i+1, list.k) and list.prev[i] = mod1(i-1, list.k), and also reshuffles the list.shuffled_indices vector.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.swap_permutation!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.swap_permutation!","text":"swap_permutation!(list::ShuffledPolygonLinkedList, i, j)\n\nReorders the permutation list.shuffled_indices of the linked list, swapping  πᵢ and πⱼ where πₖ = list.shuffled_indices[k].\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Points-(Primitive-Interface)","page":"Data Structures","title":"Points (Primitive Interface)","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"Here are functions that are used for defining and working with points in the package.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.set_point!-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.set_point!","text":"set_point!(points, i, x, y)\nset_point!(points, i, p) = set_point!(points, i, getx(p), gety(p))\n\nSets the point at index i in points to (x, y).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 3.0), (5.0, 17.0)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 17.0)\n\njulia> DelaunayTriangulation.set_point!(points, 1, 0.0, 0.0)\n(0.0, 0.0)\n\njulia> points\n2-element Vector{Tuple{Float64, Float64}}:\n (0.0, 0.0)\n (5.0, 17.0)\n\njulia> points = [1.0 2.0 3.0; 4.0 5.0 6.0]\n2×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n\njulia> DelaunayTriangulation.set_point!(points, 2, (17.3, 0.0))\n2-element view(::Matrix{Float64}, :, 2) with eltype Float64:\n 17.3\n  0.0\n\njulia> points\n2×3 Matrix{Float64}:\n 1.0  17.3  3.0\n 4.0   0.0  6.0\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.push_point!-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.push_point!","text":"push_point!(points, x, y)\npush_point!(points, p) = push_point!(points, getx(p), gety(p))\n\nPushes the point p = (x, y) into points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 3.0), (5.0, 1.0)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n\njulia> DelaunayTriangulation.push_point!(points, 2.3, 5.3)\n3-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n (2.3, 5.3)\n\njulia> DelaunayTriangulation.push_point!(points, (17.3, 5.0))\n4-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n (2.3, 5.3)\n (17.3, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.pop_point!-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.pop_point!","text":"pop_point!(points)\n\nPops the last point from points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (1.3, 5.3)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (1.3, 5.3)\n\njulia> DelaunayTriangulation.pop_point!(points) # returns the popped vector\n(1.3, 5.3)\n\njulia> points\n1-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.num_points-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.num_points","text":"num_points(points) -> Integer\n\nReturns the number of points in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 1.0), (2.3, 1.5), (0.0, -5.0)];\n\njulia> DelaunayTriangulation.num_points(points)\n3\n\njulia> points = [1.0 5.5 10.0 -5.0; 5.0 2.0 0.0 0.0];\n\njulia> DelaunayTriangulation.num_points(points)\n4\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.getpoint-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.getpoint","text":"getpoint(points, vertex) -> NTuple{2, Number}\n\nGet the point associated with vertex in points, returned as a Tuple of the coordinates.  If vertex is not an integer, then vertex is returned so that points and vertices can be easily mixed.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(0.3, 0.7), (1.3, 5.0), (5.0, 17.0)];\n\njulia> DelaunayTriangulation.getpoint(points, 2)\n(1.3, 5.0)\n\njulia> points = [0.3 1.3 5.0; 0.7 5.0 17.0];\n\njulia> DelaunayTriangulation.getpoint(points, 2)\n(1.3, 5.0)\n\njulia> DelaunayTriangulation.getpoint(points, (17.3, 33.0))\n(17.3, 33.0)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_point-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.get_point","text":"get_point(points, vertices...) -> NTuple{length(vertices), NTuple{2, Number}}\n\nGet the points associated with vertices in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0)];\n\njulia> get_point(points, 1)\n(1.0, 2.0)\n\njulia> get_point(points, 1, 2, 3, 4)\n((1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0))\n\njulia> points = [1.0 3.0 1.7 -5.0; 2.0 5.5 10.3 0.0];\n\njulia> get_point(points, 1)\n(1.0, 2.0)\n\njulia> get_point(points, 1, 2, 3, 4)\n((1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0))\n\njulia> typeof(ans)\nNTuple{4, Tuple{Float64, Float64}}\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.each_point_index-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(points) -> Iterator\n\nReturns an iterator over each point index in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (-5.0, 2.0), (2.3, 2.3)];\n\njulia> DelaunayTriangulation.each_point_index(points)\nBase.OneTo(3)\n\njulia> points = [1.0 -5.0 2.3; 2.0 2.0 2.3];\n\njulia> DelaunayTriangulation.each_point_index(points)\nBase.OneTo(3)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.each_point-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.each_point","text":"each_point(points) -> Iterator\n\nReturns an iterator over each point in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (5.0, 13.0)];\n\njulia> DelaunayTriangulation.each_point(points)\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (5.0, 13.0)\n\njulia> points = [1.0 5.0 17.7; 5.5 17.7 0.0];\n\njulia> DelaunayTriangulation.each_point(points)\n3-element ColumnSlices{Matrix{Float64}, Tuple{Base.OneTo{Int64}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1.0, 5.5]\n [5.0, 17.7]\n [17.7, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation._getx-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation._getx","text":"_getx(p) -> Float64\n\nGet the x-coordinate of p as a Float64.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.37, 0.7);\n\njulia> DelaunayTriangulation._getx(p)\n0.37\n\njulia> p = (0.37f0, 0.7f0);\n\njulia> DelaunayTriangulation._getx(p)\n0.3700000047683716\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._getxy-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation._getxy","text":"_getxy(p) -> NTuple{2, Float64}\n\nGet the coordinates of p as a Tuple of Float64s.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = [0.3, 0.5];\n\njulia> DelaunayTriangulation._getxy(p)\n(0.3, 0.5)\n\njulia> p = [0.3f0, 0.5f0];\n\njulia> DelaunayTriangulation._getxy(p)\n(0.30000001192092896, 0.5)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._getxyz-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation._getxyz","text":"_getxyz(p) -> NTuple{3, Float64}\n\nGiven a three-dimemsional p, returns its coordinates as a Tuple of Float64s.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._gety-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation._gety","text":"_gety(p) -> Float64\n\nGet the y-coordinate of p as a Float64.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.5, 0.5);\n\njulia> DelaunayTriangulation._gety(p)\n0.5\n\njulia> p = (0.5f0, 0.5f0);\n\njulia> DelaunayTriangulation._gety(p)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation._getz-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation._getz","text":"_getz(p) -> Float64\n\nGet the z-coordinate of p as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.find_duplicate_points-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.find_duplicate_points","text":"find_duplicate_points(points) -> Dict{Point, Vector{Int}}\n\nReturns a Dict of points that maps each duplicate point to a Vector of the indices of the duplicate points.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.find_point_index-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.find_point_index","text":"find_point_index(points, x, y) -> Integer\nfind_point_index(points, p) -> Integer\n\nReturns an index of a point in points that is equal to p = (x, y). If no such point exists, then 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getx-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getx","text":"getx(p) -> Number\n\nGet the x-coordinate of p.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.3, 0.7);\n\njulia> getx(p)\n0.3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getxy-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getxy","text":"getxy(p) -> NTuple{2, Number}\n\nGet the coordinates of p as a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = [0.9, 23.8];\n\njulia> getxy(p)\n(0.9, 23.8)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getxyz-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getxyz","text":"getxyz(p) -> NTuple{3, Number}\n\nGiven a three-dimensional p, returns its coordinates as a Tuple.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.gety-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.gety","text":"gety(p) -> Number\n\nGet the y-coordinate of p.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.9, 1.3);\n\njulia> gety(p)\n1.3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getz-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getz","text":"getz(p) -> Number\n\nGet the z-coordinate of p.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_planar-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.is_planar","text":"is_planar(points) -> Bool\n\nReturns true if all points in points are two-dimensional. The default definition is simply  all(is_point2, each_point(points)).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_point2-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.is_point2","text":"is_point2(p) -> Bool\n\nTests if p represents a point in the plane. By default, this returns the result of \n\neltype(p) <: Number && length(p) == 2\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.is_point3-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.is_point3","text":"is_point3(p) -> Bool\n\nTests if p represents a point in space. By default, this returns the result of \n\neltype(p) <: Number && length(p) == 3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.lexicographic_order-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.lexicographic_order","text":"lexicographic_order(points) -> Vector{Int}\n\nReturns a set of indices that give the lexicographic ordering of points, meaning the indices so that the points are sorted first by x and then by y.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 5.0), (0.0, 17.0), (0.0, 13.0), (5.0, 17.3), (3.0, 1.0), (5.0, -2.0)]\n6-element Vector{Tuple{Float64, Float64}}:\n (1.0, 5.0)\n (0.0, 17.0)\n (0.0, 13.0)\n (5.0, 17.3)\n (3.0, 1.0)\n (5.0, -2.0)\n\njulia> DelaunayTriangulation.lexicographic_order(points)\n6-element Vector{Int64}:\n 3\n 2\n 1\n 5\n 6\n 4\n\njulia> hcat(points, points[ans])\n6×2 Matrix{Tuple{Float64, Float64}}:\n (1.0, 5.0)   (0.0, 13.0)\n (0.0, 17.0)  (0.0, 17.0)\n (0.0, 13.0)  (1.0, 5.0)\n (5.0, 17.3)  (3.0, 1.0)\n (3.0, 1.0)   (5.0, -2.0)\n (5.0, -2.0)  (5.0, 17.3)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.mean_points","page":"Data Structures","title":"DelaunayTriangulation.mean_points","text":"mean_points(points[, vertices = each_point_index(points)]) -> NTuple{2, Number}\n\nReturns the mean of the points in points indexed by vertices,  given as a Tuple of the form (mean_x, mean_y).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (2.3, 5.0), (17.3, 5.3)]\n3-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (2.3, 5.0)\n (17.3, 5.3)\n\njulia> DelaunayTriangulation.mean_points(points)\n(6.866666666666667, 4.1000000000000005)\n\njulia> (1.0 + 2.3 + 17.3)/3, (2.0 + 5.0 + 5.3)/3\n(6.866666666666667, 4.1000000000000005)\n\njulia> points = [1.0 2.3 17.3; 2.0 5.0 5.3]\n2×3 Matrix{Float64}:\n 1.0  2.3  17.3\n 2.0  5.0   5.3\n\njulia> DelaunayTriangulation.mean_points(points)\n(6.866666666666667, 4.1000000000000005)\n\njulia> DelaunayTriangulation.mean_points(points, (1, 3))\n(9.15, 3.65)\n\njulia> (1.0 + 17.3)/2, (2.0 + 5.3)/2\n(9.15, 3.65)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.points_are_unique-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.points_are_unique","text":"points_are_unique(points) -> Bool\n\nReturns true if all points in points are unique.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [1.0 2.0 3.0 4.0 5.0; 0.0 5.5 2.0 1.3 17.0]\n2×5 Matrix{Float64}:\n 1.0  2.0  3.0  4.0   5.0\n 0.0  5.5  2.0  1.3  17.0\n\njulia> DelaunayTriangulation.points_are_unique(points)\ntrue\n\njulia> points[:, 4] .= points[:, 1];\n\njulia> DelaunayTriangulation.points_are_unique(points)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Edges-(Primitive-Interface)","page":"Data Structures","title":"Edges (Primitive Interface)","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"Here are functions that are used for defining and working with edges in the package.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.random_edge-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.random_edge","text":"random_edge([rng], E) -> E\n\nGet a random edge from E.\n\nExamples\n\njulia> using DelaunayTriangulation, StableRNGs\n\njulia> E = Set(((1,2),(10,15),(23,20)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (23, 20)\n  (10, 15)\n\njulia> rng = StableRNG(123);\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(10, 15)\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(10, 15)\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(23, 20)\n\njulia> DelaunayTriangulation.random_edge(E)\n(1, 2)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.each_edge-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.each_edge","text":"each_edge(E) -> Iterator\n\nGet an iterator over the edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1,2),(1,3),(2,-1)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (1, 3)\n  (2, -1)\n\njulia> each_edge(E)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (1, 3)\n  (2, -1)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.contains_edge-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.contains_edge","text":"contains_edge(i, j, E) -> Bool\ncontains_edge(e, E) -> Bool\n\nCheck if E contains the edge e = (i, j).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1,3),(17,3),(1,-1)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, -1)\n  (17, 3)\n  (1, 3)\n\njulia> DelaunayTriangulation.contains_edge((1, 2), E)\nfalse\n\njulia> DelaunayTriangulation.contains_edge((17, 3), E)\ntrue\n\njulia> DelaunayTriangulation.contains_edge(3, 17, E) # order\nfalse\n\njulia> E = [[1,2],[5,13],[-1,1]]\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [5, 13]\n [-1, 1]\n\njulia> DelaunayTriangulation.contains_edge(1, 2, E)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_edge-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.construct_edge","text":"construct_edge(::Type{E}, i, j) where {E} -> E\n\nConstruct an edge of type E from vertices i and j.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.construct_edge(NTuple{2,Int}, 2, 5)\n(2, 5)\n\njulia> DelaunayTriangulation.construct_edge(Vector{Int32}, 5, 15)\n2-element Vector{Int32}:\n  5\n 15\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.add_edge!-Tuple{Any, Vararg{Any}}","page":"Data Structures","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(E, e...)\n\nAdd the edges e... to E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1,5),(17,10),(5,3)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (5, 3)\n  (17, 10)\n  (1, 5)\n\njulia> DelaunayTriangulation.add_edge!(E, (3, 2))\n\njulia> E\nSet{Tuple{Int64, Int64}} with 4 elements:\n  (3, 2)\n  (5, 3)\n  (17, 10)\n  (1, 5)\n\njulia> DelaunayTriangulation.add_edge!(E, (1, -3), (5, 10), (1, -1))\n\njulia> E\nSet{Tuple{Int64, Int64}} with 7 elements:\n  (3, 2)\n  (5, 10)\n  (1, -3)\n  (1, -1)\n  (5, 3)\n  (17, 10)\n  (1, 5)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.add_to_edges!-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.add_to_edges!","text":"add_to_edges!(E, e)\n\nAdd the edge e to E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1, 2),(3,5)))\nSet{Tuple{Int64, Int64}} with 2 elements:\n  (1, 2)\n  (3, 5)\n\njulia> DelaunayTriangulation.add_to_edges!(E, (1, 5))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (3, 5)\n  (1, 5)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compare_unoriented_edge_collections-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.compare_unoriented_edge_collections","text":"compareunorientededge_collections(E, F) -> Bool\n\nTests if the edge collections E and F are equal, ignoring edge orientation.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compare_unoriented_edges-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.compare_unoriented_edges","text":"compare_unoriented_edges(u, v) -> Bool\n\nCompare the unoriented edges u and v, i.e. compare the vertices of u and v in any order.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> u = (1, 3);\n\njulia> v = (5, 3);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\nfalse\n\njulia> v = (1, 3);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\ntrue\n\njulia> v = (3, 1);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.contains_unoriented_edge-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.contains_unoriented_edge","text":"contains_unoriented_edge(e, E) -> Bool\n\nCheck if E contains the unoriented edge e, i.e. check if E contains the edge e or reverse_edge(e).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_edge!-Tuple{Any, Vararg{Any}}","page":"Data Structures","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(E, e...)\n\nDelete the edges e... from E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(([1,2],[10,15],[1,-1],[13,23],[1,5]))\nSet{Vector{Int64}} with 5 elements:\n  [10, 15]\n  [1, 5]\n  [1, 2]\n  [1, -1]\n  [13, 23]\n\njulia> DelaunayTriangulation.delete_edge!(E, [10,15])\n\njulia> E\nSet{Vector{Int64}} with 4 elements:\n  [1, 5]\n  [1, 2]\n  [1, -1]\n  [13, 23]\n\njulia> DelaunayTriangulation.delete_edge!(E, [1,5], [1, -1])\n\njulia> E\nSet{Vector{Int64}} with 2 elements:\n  [1, 2]\n  [13, 23]\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_from_edges!-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_from_edges!","text":"delete_from_edges!(E, e)\n\nDelete the edge e from E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(([1,2],[5,15],[17,10],[5,-1]))\nSet{Vector{Int64}} with 4 elements:\n  [17, 10]\n  [5, 15]\n  [5, -1]\n  [1, 2]\n\njulia> DelaunayTriangulation.delete_from_edges!(E, [5, 15])\nSet{Vector{Int64}} with 3 elements:\n  [17, 10]\n  [5, -1]\n  [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_unoriented_edge!-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_unoriented_edge!","text":"delete_unoriented_edge!(E, e)\n\nDelete the unoriented edge e from E, i.e. delete both the edge e and reverse_edge(e).\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.edge_type-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.edge_type","text":"edge_type(E) -> DataType\n\nGet the type of edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = Set(((1,2),(2,3),(17,5)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (17, 5)\n  (2, 3)\n\njulia> DelaunayTriangulation.edge_type(e)\nTuple{Int64, Int64}\n\njulia> e = [[1,2],[3,4],[17,3]]\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n [17, 3]\n\njulia> DelaunayTriangulation.edge_type(e)\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.edge_vertices-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.edge_vertices","text":"edge_vertices(e) -> NTuple{2, Vertex}\n\nGet the vertices of e\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 5);\n\njulia> edge_vertices(e)\n(1, 5)\n\njulia> e = [23, 50];\n\njulia> edge_vertices(e)\n(23, 50)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.edges_are_disjoint-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.edges_are_disjoint","text":"edges_are_disjoint(e, e′) -> Bool\n\nReturns true if e and e′ have any shared vertex, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.initial-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.initial","text":"initial(e) -> Vertex\n\nGet the initial vertex of e.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 3);\n\njulia> DelaunayTriangulation.initial(e)\n1\n\njulia> e = [2, 5];\n\njulia> DelaunayTriangulation.initial(e)\n2\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_edges-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.num_edges","text":"num_edges(E) -> Integer\n\nGet the number of edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = [(1, 2), (3, 4), (1, 5)];\n\njulia> num_edges(e)\n3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.reverse_edge-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.reverse_edge","text":"reverse_edge(e) -> Edge\n\nGet the edge with the vertices of e in reverse order.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (17, 3);\n\njulia> DelaunayTriangulation.reverse_edge(e)\n(3, 17)\n\njulia> e = [1, 2];\n\njulia> DelaunayTriangulation.reverse_edge(e)\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.terminal-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.terminal","text":"terminal(e) -> Vertex\n\nGet the terminal vertex of e.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 7);\n\njulia> DelaunayTriangulation.terminal(e)\n7\n\njulia> e = [2, 13];\n\njulia> DelaunayTriangulation.terminal(e)\n13\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Triangles-(Primitive-Interface)","page":"Data Structures","title":"Triangles (Primitive Interface)","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"Here are functions that are used for defining and working with triangles in the package.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_edges-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.triangle_edges","text":"triangle_edges(T) -> NTuple{3, Edge}\ntriangle_edges(i, j, k) -> NTuple{3, Edge}\n\nGet the edges of T = (i, j, k) as a Tuple, in particular \n\n((i, j), (j, k), (k, i)).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = (1, 2, 3);\n\njulia> DelaunayTriangulation.triangle_edges(T)\n((1, 2), (2, 3), (3, 1))\n\njulia> DelaunayTriangulation.triangle_edges(1, 2, 3)\n((1, 2), (2, 3), (3, 1))\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.sort_triangle-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.sort_triangle","text":"sort_triangle(T) -> Triangle\nsort_triangle(i, j, k) -> Triangle\n\nSort the triangle T = (i, j, k) so that its last vertex is the smallest,  respecting the orientation of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.sort_triangle((1, 5, 3))\n(5, 3, 1)\n\njulia> DelaunayTriangulation.sort_triangle((1, -1, 2))\n(2, 1, -1)\n\njulia> DelaunayTriangulation.sort_triangle((3, 2, 1))\n(3, 2, 1)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.each_triangle-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(T) -> Iterator\n\nReturn an iterator over the triangles in T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (-1, 5, 10), (17, 13, 18)));\n\njulia> each_triangle(T)\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (-1, 5, 10)\n  (1, 2, 3)\n  (17, 13, 18)\n\njulia> T = [[1, 2, 3], [10, 15, 18], [1, 5, 6]];\n\njulia> each_triangle(T)\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [10, 15, 18]\n [1, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_triangle!-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(V, T...)\ndelete_triangle!(V, i, j, k)\n\nDelete the triangles T... from the collection of triangles V.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)))\nSet{Tuple{Int64, Int64, Int64}} with 5 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (4, 5, 6)\n  (13, 14, 15)\n  (1, 2, 3)\n\njulia> delete_triangle!(V, (6, 4, 5))\nSet{Tuple{Int64, Int64, Int64}} with 4 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (13, 14, 15)\n  (1, 2, 3)\n\njulia> delete_triangle!(V, (10, 11, 12), (1, 2, 3))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (7, 8, 9)\n  (13, 14, 15)\n\njulia> delete_triangle!(V, 8, 9, 7)\nSet{Tuple{Int64, Int64, Int64}} with 1 element:\n  (13, 14, 15)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.contains_triangle-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(T, V) -> (Triangle, Bool)\n\nCheck if the collection of triangles V contains the triangle T up to rotation. The Triangle returned is the triangle in V that is equal to T up to rotation,  or T if no such triangle exists. The Bool is true if V contains T, and false otherwise.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (7, 8, 9)\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.contains_triangle((1, 2, 3), V)\n((1, 2, 3), true)\n\njulia> DelaunayTriangulation.contains_triangle((2, 3, 1), V)\n((1, 2, 3), true)\n\njulia> DelaunayTriangulation.contains_triangle((10, 18, 9), V)\n((10, 18, 9), false)\n\njulia> DelaunayTriangulation.contains_triangle(9, 7, 8, V)\n((7, 8, 9), true)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_triangle-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.construct_triangle","text":"construct_triangle(::Type{T}, i, j, k) where {T} -> Triangle\n\nConstruct a triangle of type T from vertices i, j, and k.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.construct_triangle(NTuple{3,Int}, 1, 2, 3)\n(1, 2, 3)\n\njulia> DelaunayTriangulation.construct_triangle(Vector{Int32}, 1, 2, 3)\n3-element Vector{Int32}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.add_triangle!-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T, V...)\nadd_triangle!(T, i, j, k)\n\nAdd the triangles V... or V = (i, j, k) to the collection of triangles T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (4, 5, 6)))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> add_triangle!(T, (7, 8, 9));\n\njulia> add_triangle!(T, (10, 11, 12), (13, 14, 15));\n\njulia> add_triangle!(T, 16, 17, 18);\n\njulia> T\nSet{Tuple{Int64, Int64, Int64}} with 6 elements:\n  (7, 8, 9)\n  (10, 11, 12)\n  (4, 5, 6)\n  (13, 14, 15)\n  (16, 17, 18)\n  (1, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.add_to_triangles!-Union{Tuple{VT}, Tuple{Ts}, Tuple{Ts, VT}} where {Ts, VT}","page":"Data Structures","title":"DelaunayTriangulation.add_to_triangles!","text":"add_to_triangles!(T, V)\n\nAdd the triangle V to the collection of triangles T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (17, 8, 9)));\n\njulia> DelaunayTriangulation.add_to_triangles!(T, (1, 5, 12))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (1, 5, 12)\n  (1, 2, 3)\n  (17, 8, 9)\n\njulia> DelaunayTriangulation.add_to_triangles!(T, (-1, 3, 6))\nSet{Tuple{Int64, Int64, Int64}} with 4 elements:\n  (1, 5, 12)\n  (1, 2, 3)\n  (17, 8, 9)\n  (-1, 3, 6)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compare_triangle_collections-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.compare_triangle_collections","text":"compare_triangle_collections(T, V) -> Bool\n\nCompare the collections of triangles T and V by comparing their triangles according to compare_triangles.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)));\n\njulia> V = [[2, 3, 1], [4, 5, 6], [9, 7, 8]];\n\njulia> DelaunayTriangulation.compare_triangle_collections(T, V)\ntrue\n\njulia> V[1] = [17, 19, 20];\n\njulia> DelaunayTriangulation.compare_triangle_collections(T, V)\nfalse\n\njulia> V = [[1, 2, 3], [8, 9, 7]];\n\njulia> DelaunayTriangulation.compare_triangle_collections(T, V)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.compare_triangles-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.compare_triangles","text":"compare_triangles(T, V) -> Bool\n\nCompare the triangles T and V by comparing their vertices up to rotation.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T1 = (1, 5, 10);\n\njulia> T2 = (17, 23, 20);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\nfalse\n\njulia> T2 = (5, 10, 1);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\ntrue\n\njulia> T2 = (10, 1, 5);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\ntrue\n\njulia> T2 = (10, 5, 1);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Vararg{Any, 4}}, Tuple{Type{V}, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where V","page":"Data Structures","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(::Type{V}, i, j, k, points) where {V} -> V\n\nConstruct a triangle of type V from vertices i, j, and k such that the triangle is positively oriented, using points for the coordinates.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0)];\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(NTuple{3, Int}, 1, 2, 3, points)\n(2, 1, 3)\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(NTuple{3, Int}, 2, 3, 1, points)\n(3, 2, 1)\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(NTuple{3, Int}, 2, 1, 3, points)\n(2, 1, 3)\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(NTuple{3, Int}, 3, 2, 1, points)\n(3, 2, 1)\n\njulia> points = [(1.0, 1.0), (2.5, 2.3), (17.5, 23.0), (50.3, 0.0), (-1.0, 2.0), (0.0, 0.0), (5.0, 13.33)];\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(Vector{Int}, 5, 3, 2, points)\n3-element Vector{Int64}:\n 3\n 5\n 2\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(Vector{Int}, 7, 1, 2, points)\n3-element Vector{Int64}:\n 7\n 1\n 2\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(Vector{Int}, 7, 2, 1, points)\n3-element Vector{Int64}:\n 2\n 7\n 1\n\njulia> DelaunayTriangulation.construct_positively_oriented_triangle(Vector{Int}, 5, 4, 3, points)\n3-element Vector{Int64}:\n 5\n 4\n 3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_from_triangles!-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_from_triangles!","text":"delete_from_triangles!(T, V)\n\nDelete the triangle V from the collection of triangles T. Only deletes V if V is in T up to rotation.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (7, 8, 9)\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.delete_from_triangles!(V, (4, 5, 6))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (7, 8, 9)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.delete_from_triangles!(V, (9, 7, 8))\nSet{Tuple{Int64, Int64, Int64}} with 1 element:\n  (1, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.geti-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.geti","text":"geti(T) -> Vertex\n\nGet the first vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.geti((1, 2, 3))\n1\n\njulia> DelaunayTriangulation.geti([2, 5, 1])\n2\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getj-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getj","text":"getj(T) -> Vertex\n\nGet the second vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.getj((5, 6, 13))\n6\n\njulia> DelaunayTriangulation.getj([10, 19, 21])\n19\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.getk-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.getk","text":"getk(T) -> Vertex\n\nGet the third vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.getk((1,2,3))\n3\n\njulia> DelaunayTriangulation.getk([1,2,3])\n3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_triangles-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(T) -> Integer\n\nGet the number of triangles in T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T1, T2, T3 = (1, 5, 10), (17, 23, 10), (-1, 10, 5);\n\njulia> T = Set((T1, T2, T3));\n\njulia> num_triangles(T)\n3\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.rotate_triangle-Union{Tuple{V}, Tuple{N}, Tuple{V, Val{N}}} where {N, V}","page":"Data Structures","title":"DelaunayTriangulation.rotate_triangle","text":"rotate_triangle(T, rotation) -> Triangle\n\nRotate the vertices of T by rotation. In particular, if  T = (i, j, k):\n\nrotation = 0: (i, j, k)\nrotation = 1: (j, k, i)\nrotation = 2: (k, i, j)\nOtherwise, return rotate_triangle(T, rotation % 3).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = (1, 2, 3)\n(1, 2, 3)\n\njulia> DelaunayTriangulation.rotate_triangle(T, 0)\n(1, 2, 3)\n\njulia> DelaunayTriangulation.rotate_triangle(T, 1)\n(2, 3, 1)\n\njulia> DelaunayTriangulation.rotate_triangle(T, 2)\n(3, 1, 2)\n\njulia> DelaunayTriangulation.rotate_triangle(T, 3)\n(1, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.sort_triangles-Tuple{Ts} where Ts","page":"Data Structures","title":"DelaunayTriangulation.sort_triangles","text":"sort_triangles(T) -> Triangle\n\nSort the triangles in T so that the first vertex of each triangle is the largest, respecting the orientation of the triangles. See sort_triangle.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 3, 2), (5, 2, 3), (10, 1, 13), (-1, 10, 12), (10, 1, 17), (5, 8, 2)))\nSet{Tuple{Int64, Int64, Int64}} with 6 elements:\n  (5, 8, 2)\n  (10, 1, 13)\n  (10, 1, 17)\n  (5, 2, 3)\n  (1, 3, 2)\n  (-1, 10, 12)\n\njulia> DelaunayTriangulation.sort_triangles(T)\nSet{Tuple{Int64, Int64, Int64}} with 6 elements:\n  (13, 10, 1)\n  (3, 5, 2)\n  (10, 12, -1)\n  (5, 8, 2)\n  (17, 10, 1)\n  (3, 2, 1)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Data Structures","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(::Type{T}) -> DataType\n\nGet the triangle type of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.triangle_type(Set{NTuple{3,Int64}})\nTuple{Int64, Int64, Int64}\n\njulia> DelaunayTriangulation.triangle_type(Vector{NTuple{3,Int32}})\nTuple{Int32, Int32, Int32}\n\njulia> DelaunayTriangulation.triangle_type(Vector{Vector{Int64}})\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.triangle_vertices-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.triangle_vertices","text":"triangle_vertices(T) -> NTuple{3, Vertex}\n\nReturns the vertices of T as a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> triangle_vertices((1, 5, 17))\n(1, 5, 17)\n\njulia> triangle_vertices([5, 18, 23]) # -> tuple\n(5, 18, 23)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#Boundary-Nodes-(Primitive-Interface)","page":"Data Structures","title":"Boundary Nodes (Primitive Interface)","text":"","category":"section"},{"location":"extended/data_structures/","page":"Data Structures","title":"Data Structures","text":"Here are functions that are used for defining and working with boundary nodes in the package.","category":"page"},{"location":"extended/data_structures/#DelaunayTriangulation.has_multiple_sections-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.has_multiple_sections","text":"has_multiple_sections(boundary_nodes) -> Bool\n\nCheck if boundary_nodes has multiple sections.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.has_multiple_sections([1, 2, 3, 1])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_sections([[1, 2, 3], [3, 4, 1]])\ntrue\n\njulia> DelaunayTriangulation.has_multiple_sections([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.has_multiple_curves-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(boundary_nodes) -> Bool\n\nCheck if boundary_nodes has multiple curves.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.has_multiple_curves([1, 2, 3, 1])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_curves([[1, 2, 3], [3, 4, 1]])\nfalse\n\njulia> DelaunayTriangulation.has_multiple_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_section_index-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.get_section_index","text":"get_section_index(dict, ghost_vertex) -> Int\nget_section_index(ghost_vertex) -> Int\n\nGiven a Dict from construct_ghost_vertex_map and a ghost_vertex, returns the index of the section corresponding to that ghost vertex. The second method maps ghost_vertex to itself if it is an Integer, 1 if it is a Vector, and  ghost_vertex[2] if it is a Tuple. \n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_section_index((2, 3)) # 3rd section of the 2nd curve\n3\n\njulia> DelaunayTriangulation.get_section_index(4)\n4\n\njulia> DelaunayTriangulation.get_section_index([1, 2, 3, 4, 5, 1])\n1\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])     \nDict{Int64, Tuple{Int64, Int64}} with 4 entries:\n  -1 => (1, 1)\n  -3 => (2, 2)\n  -2 => (2, 1)\n  -4 => (2, 3)\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -1)\n1\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -2)\n1\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -3)\n2\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -4)\n3\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_curve_index-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(dict, ghost_vertex) -> Int\nget_curve_index(ghost_vertex) -> Int\n\nGiven a Dict from construct_ghost_vertex_map and a ghost_vertex, returns the index of the curve corresponding to that ghost vertex. The second method  maps ghost_vertex to 1 if it is an Integer or a Vector, and ghost_vertex[1] if it is a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_curve_index(-1)\n1\n\njulia> DelaunayTriangulation.get_curve_index((5, 3))\n5\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])\nDict{Int64, Tuple{Int64, Int64}} with 4 entries:\n  -1 => (1, 1)\n  -3 => (2, 2)\n  -2 => (2, 1)\n  -4 => (2, 3)\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -1)\n1\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -2)\n2\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -3)\n2\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -4)\n2\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.get_boundary_nodes-extended-data_structures","page":"Data Structures","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(boundary_nodes, mnℓ...)\n\nGiven a collection of boundary_nodes, returns the specified component of the collection. There are several forms for the methods:\n\nget_boundary_nodes(boundary_nodes, m): If boundary_nodes has multiple curves, this returns the mth curve. If boundary_nodes has multiple sections, this returns the mth section. Otherwise, this returns the mth boundary node.\nget_boundary_nodes(boundary_nodes, m, n): If boundary_nodes has multiple curves, this returns the nth section of the mth curve. Otherwise, if boundary_nodes has multiple sections, this returns the nth boundary node of the mth section.\nget_boundary_nodes(boundary_nodes, (m, n)): This is equivalent to get_boundary_nodes(boundary_nodes, m, n).\nget_boundary_nodes(boundary_nodes::A, ::A): This just returns boundary_nodes.  \n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 2)\n2-element Vector{Vector{Int64}}:\n [6, 7, 8, 9]\n [9, 10, 6]\n\njulia> get_boundary_nodes([[1, 2, 3, 4], [4, 5, 1]], 1)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> get_boundary_nodes([1, 2, 3, 4, 5, 6, 1], 4)\n4\n\njulia> get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 1, 2)\n3-element Vector{Int64}:\n 4\n 5\n 1\n\njulia> get_boundary_nodes([[1, 2, 3, 4], [4, 5, 6, 1]], 2, 3)\n6\n\njulia> get_boundary_nodes([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 5, 1])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 1\n\n\n\n\n\n","category":"function"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_boundary_edge_map-Union{Tuple{E}, Tuple{I}, Tuple{A}, Tuple{A, Type{I}}, Tuple{A, Type{I}, Type{E}}} where {A, I, E}","page":"Data Structures","title":"DelaunayTriangulation.construct_boundary_edge_map","text":"construct_boundary_edge_map(boundary_nodes::A, IntegerType::Type{I}=number_type(boundary_nodes), EdgeType::Type{E}=NTuple{2,IntegerType}) where {A,I,E} -> Dict\n\nConstructs a map that takes boundary edges in boundary_nodes to a Tuple giving the edge's position  in boundary_nodes. In particular, if dict = construct_boundary_edge_map(boundary_nodes), then dict[e] = (pos, ℓ) so that bn = get_boundary_nodes(boundary_nodes, pos) gives the boundary nodes  associated with the section that e lives on, and get_boundary_nodes(bn, ℓ) is the first vertex of e.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.construct_boundary_edge_map([17, 18, 15, 4, 3, 17])\nDict{Tuple{Int64, Int64}, Tuple{Vector{Int64}, Int64}} with 5 entries:\n  (18, 15) => ([17, 18, 15, 4, 3, 17], 2)\n  (3, 17)  => ([17, 18, 15, 4, 3, 17], 5)\n  (17, 18) => ([17, 18, 15, 4, 3, 17], 1)\n  (4, 3)   => ([17, 18, 15, 4, 3, 17], 4)\n  (15, 4)  => ([17, 18, 15, 4, 3, 17], 3)\n\njulia> DelaunayTriangulation.construct_boundary_edge_map([[5, 17, 3, 9], [9, 18, 13, 1], [1, 93, 57, 5]])\nDict{Tuple{Int64, Int64}, Tuple{Int64, Int64}} with 9 entries:\n  (18, 13) => (2, 2)\n  (17, 3)  => (1, 2)\n  (9, 18)  => (2, 1)\n  (13, 1)  => (2, 3)\n  (3, 9)   => (1, 3)\n  (93, 57) => (3, 2)\n  (5, 17)  => (1, 1)\n  (57, 5)  => (3, 3)\n  (1, 93)  => (3, 1)\n\njulia> DelaunayTriangulation.construct_boundary_edge_map([[[2, 5, 10], [10, 11, 2]], [[27, 28, 29, 30], [30, 31, 85, 91], [91, 92, 27]]])\nDict{Tuple{Int64, Int64}, Tuple{Tuple{Int64, Int64}, Int64}} with 12 entries:\n  (92, 27) => ((2, 3), 2)\n  (2, 5)   => ((1, 1), 1)\n  (11, 2)  => ((1, 2), 2)\n  (10, 11) => ((1, 2), 1)\n  (30, 31) => ((2, 2), 1)\n  (91, 92) => ((2, 3), 1)\n  (29, 30) => ((2, 1), 3)\n  (31, 85) => ((2, 2), 2)\n  (27, 28) => ((2, 1), 1)\n  (5, 10)  => ((1, 1), 2)\n  (28, 29) => ((2, 1), 2)\n  (85, 91) => ((2, 2), 3)\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_map-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I","page":"Data Structures","title":"DelaunayTriangulation.construct_ghost_vertex_map","text":"construct_ghost_vertex_map(boundary_nodes::A, IntegerType::Type{I}=number_type(boundary_nodes)) where {A,I} -> Dict\n\nGiven a set of boundary_nodes, returns a Dict that maps ghost vertices to their associated section in boundary_nodes. There are three cases:\n\nhas_multiple_curves(boundary_nodes)\n\nReturns dict::Dict{I, NTuple{2, I}}, mapping ghost vertices i to Tuples (m, n) so that get_boundary_nodes(boundary_nodes, m, n) are the boundary nodes associated with i,  i.e. the nth section of the mth curve is associated with the ghost vertex i.\n\nhas_multiple_sections(boundary_nodes)\n\nReturns dict::Dict{I, I}, mapping ghost vertices i to n so that get_boundary_nodes(boundary_nodes, n) are the boundary nodes associated with i, i.e. the nth section of the boundary is associated with the ghost vertex i.\n\notherwise\n\nReturns dict::Dict{I, A}, mapping the ghost vertex i to boundary_nodes.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([1, 2, 3, 4, 5, 1])\nDict{Int64, Vector{Int64}} with 1 entry:\n  -1 => [1, 2, 3, 4, 5, 1]\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[17, 29, 23, 5, 2, 1], [1, 50, 51, 52], [52, 1]])\nDict{Int64, Int64} with 3 entries:\n  -1 => 1\n  -3 => 3\n  -2 => 2\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])\nDict{Int64, Tuple{Int64, Int64}} with 4 entries:\n  -1 => (1, 1)\n  -3 => (2, 2)\n  -2 => (2, 1)\n  -4 => (2, 3)\n\nExtended help\n\nThis map can be useful for iterating over all boundary nodes. For example, you can iterate  over all sections of a boundary using:\n\ngv_map = construct_ghost_vertex_map(boundary_nodes)\nfor (ghost_vertex, section) in gv_map \n    nodes = get_boundary_nodes(boundary_nodes, section)\n    # do something with nodes\nend\n\nThis works for any form of boundary_nodes.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_ranges-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I","page":"Data Structures","title":"DelaunayTriangulation.construct_ghost_vertex_ranges","text":"construct_ghost_vertex_ranges(boundary_nodes::A, IntegerType::Type{I}=number_type(boundary_nodes)) where {A,I} -> Dict\n\nGiven a set of boundary_nodes, returns a Dict that maps ghost vertices to  the range of all ghost vertices that the corresponding boundary curve could correspond to.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> boundary_nodes = [\n                  [\n                      [1, 2, 3, 4], [4, 5, 6, 1]\n                  ],\n                  [\n                      [18, 19, 20, 25, 26, 30]\n                  ],\n                  [\n                      [50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]\n                  ]\n              ]\n3-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3, 4], [4, 5, 6, 1]]\n [[18, 19, 20, 25, 26, 30]]\n [[50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]]\n\njulia> DelaunayTriangulation.construct_ghost_vertex_ranges(boundary_nodes)\nDict{Int64, UnitRange{Int64}} with 7 entries:\n  -5 => -7:-4\n  -1 => -2:-1\n  -7 => -7:-4\n  -3 => -3:-3\n  -2 => -2:-1\n  -4 => -7:-4\n  -6 => -7:-4\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.delete_boundary_node!-Tuple{Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(boundary_nodes, pos)\n\nDeletes the boundary node at the position pos from boundary_nodes. Here, pos[1] is such that get_boundary_nodes(boundary_nodes, pos[1]) is the section that the node will be deleted from, and pos[2] gives the position of the array to delete from. In particular, \n\ndelete_boundary_node!(boundary_nodes, pos)\n\nis the same as\n\ndeleteat!(get_boundary_nodes(boundary_nodes, pos[1]), pos[2])\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> boundary_nodes = [71, 25, 33, 44, 55, 10];\n\njulia> DelaunayTriangulation.delete_boundary_node!(boundary_nodes, (boundary_nodes, 4))\n5-element Vector{Int64}:\n 71\n 25\n 33\n 55\n 10\n\njulia> boundary_nodes = [[7, 13, 9, 25], [25, 26, 29, 7]];\n\njulia> DelaunayTriangulation.delete_boundary_node!(boundary_nodes, (2, 3))\n2-element Vector{Vector{Int64}}:\n [7, 13, 9, 25]\n [25, 26, 7]\n\njulia> boundary_nodes = [[[17, 23, 18, 25], [25, 26, 81, 91], [91, 101, 17]], [[1, 5, 9, 13], [13, 15, 1]]];\n\njulia> DelaunayTriangulation.delete_boundary_node!(boundary_nodes, ((2, 2), 2))\n2-element Vector{Vector{Vector{Int64}}}:\n [[17, 23, 18, 25], [25, 26, 81, 91], [91, 101, 17]]\n [[1, 5, 9, 13], [13, 1]]\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.each_boundary_node-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.each_boundary_node","text":"each_boundary_node(boundary_nodes) -> Iterator\n\nReturns an iterator that goves over each node in boundary_nodes. It is assumed that boundary_nodes represents a single section or a single contiguous boundary; if you do want to loop over every boundary nodes for a boundary  with multiple sections, you should to see the result from construct_ghost_vertex_map.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.each_boundary_node([7, 8, 19, 2, 17])\n5-element Vector{Int64}:\n  7\n  8\n 19\n  2\n 17\n\njulia> DelaunayTriangulation.each_boundary_node([7, 8, 19, 2, 17, 7])\n6-element Vector{Int64}:\n  7\n  8\n 19\n  2\n 17\n  7\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.get_skeleton-Union{Tuple{I}, Tuple{Any, Type{I}}} where I","page":"Data Structures","title":"DelaunayTriangulation.get_skeleton","text":"get_skeleton(boundary_nodes, IntegerType) -> empty(boundary_nodes)\n\nGiven a set of boundary nodes, returns the empty skeleton of the boundary nodes. This is essentially empty applied to boundary_nodes, but with vertices of type IntegerType. This is mainly needed for convert_boundary_curves!. You will need to implement a new method for this  if you want your custom boundary node interface to be supported for curve-bounded domains.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.insert_boundary_node!-Tuple{Any, Any, Any}","page":"Data Structures","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(boundary_nodes, pos, node)\n\nInserts a boundary node node into boundary_nodes at the position  pos. Here, pos[1] is such that get_boundary_nodes(boundary_nodes, pos[1]) is the section that the node will be inserted onto, and pos[2] gives the position of the array to insert node into. In particular, \n\ninsert_boundary_node!(boundary_nodes, pos, node)\n\nis the same as \n\ninsert!(get_boundary_nodes(boundary_nodes, pos[1]), pos[2], node)\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> boundary_nodes = [1, 2, 3, 4, 5, 1];\n\njulia> DelaunayTriangulation.insert_boundary_node!(boundary_nodes, (boundary_nodes, 4), 23)\n7-element Vector{Int64}:\n  1\n  2\n  3\n 23\n  4\n  5\n  1\n\njulia> boundary_nodes = [[7, 13, 9, 25], [25, 26, 29, 7]];\n\njulia> DelaunayTriangulation.insert_boundary_node!(boundary_nodes, (2, 1), 57)\n2-element Vector{Vector{Int64}}:\n [7, 13, 9, 25]\n [57, 25, 26, 29, 7]\n\njulia> boundary_nodes = [[[17, 23, 18, 25], [25, 26, 81, 91], [91, 101, 17]], [[1, 5, 9, 13], [13, 15, 1]]];\n\njulia> DelaunayTriangulation.insert_boundary_node!(boundary_nodes, ((1, 3), 3), 1001)\n2-element Vector{Vector{Vector{Int64}}}:\n [[17, 23, 18, 25], [25, 26, 81, 91], [91, 101, 1001, 17]]\n [[1, 5, 9, 13], [13, 15, 1]]\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_boundary_edges-Tuple{AbstractVector}","page":"Data Structures","title":"DelaunayTriangulation.num_boundary_edges","text":"num_boundary_edges(boundary_nodes) -> Integer\n\nGet the number of boundary edges in boundary_nodes, assuming that boundary_nodes defines a  boundary with only one curve and a single section.\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_curves-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.num_curves","text":"num_curves(boundary_nodes) -> Integer\n\nGet the number of curves in boundary_nodes.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.num_curves([1, 2, 3, 1])\n1\n\njulia> DelaunayTriangulation.num_curves([[1, 2, 3], [3, 4, 1]])\n1\n\njulia> DelaunayTriangulation.num_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\n2\n\n\n\n\n\n","category":"method"},{"location":"extended/data_structures/#DelaunayTriangulation.num_sections-Tuple{Any}","page":"Data Structures","title":"DelaunayTriangulation.num_sections","text":"num_sections(boundary_nodes) -> Integer\n\nAssuming boundary_nodes has only one curve, get the number of sections in boundary_nodes.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.num_sections([1, 2, 3, 4, 5, 1])\n1\n\njulia> DelaunayTriangulation.num_sections([[1, 2, 3, 4], [4, 5, 1]])\n2\n\njulia> DelaunayTriangulation.num_sections([[1, 2, 3], [3, 4, 5, 6, 7, 8], [8, 9], [9, 1]])\n4\n\n\n\n\n\n","category":"method"},{"location":"tutorials/operations_vertex_insertion_deletion/#Triangulation-Operations","page":"Vertex Insertion and Deletion","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_vertex_insertion_deletion/#Vertex-Insertion-and-Deletion","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"","category":"section"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"This tutorial demonstrates how to insert and delete vertices from a triangulation while maintaining the Delaunay property of the triangulation. First, load the packages we need:","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"Let us now define our initial triangulation.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"points = [(0.0, 0.0), (2.0, 0.0), (1.0, 2.0)]\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"Note that we use a structure for points that is mutable so that points can be pushed into it.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"We now want to insert a vertex into the triangulation. To do this, we use add_point! and provide the coordinates of the new point. There is a method which uses the index of the vertex rather than the coordinates, but we don't use that here as the points to be added are not already in points. Here, we add a point at (1.0, 0.5).","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"add_point!(tri, 1.0, 0.5)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"This is still a valid Delaunay triangulation, unsurprisingly due to the small number of points. We can also add points that are outside of the triangulation:","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"add_point!(tri, 0.0, 1.0)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"One important thing to note here is that, if not for the ghost triangles inside tri, adding a point outside of the triangulation would not work. Here is an example of this failing.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"delete_ghost_triangles!(tri)\ntry #hide\n    add_point!(tri, 2.0, 1.5)\ncatch e #hide\n    println(e) #hide\nend #hide","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"This is a BoundsError, because the triangulation has had to walk into the boundary but failed to find any ghost triangles. Anytime you need to perform some operation including a point outside of the boundary, you need to be sure that you have ghost triangles, which you can query using DelaunayTriangulation.has_ghost_triangles.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"DelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"add_ghost_triangles!(tri)","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"DelaunayTriangulation.has_ghost_triangles(tri)","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"Another issue is that the convex hull is not updated as we add (or delete) points for performance reasons:","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"get_convex_hull_vertices(tri)","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"If we do want to fix the convex hull, we can use convex_hull!(tri).","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"convex_hull!(tri)\nfig, ax, sc = triplot(tri, show_convex_hull = true)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"We now have the same triangulation that we would have had if we had done triangulate on this set of points originally. To now push this further, let's add in a bunch of random points.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"rng = StableRNG(123)\nfor _ in 1:1000\n    new_point = 2rand(rng, 2)\n    add_point!(tri, new_point)\nend\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"Let us now demonstrate how to delete points. To do this, we use delete_point!. This function takes vertices rather than coordinates, identifying the corresponding point in points by its index. Let us demonstrate this operation by deleting all points within a distance of 1/2 around (1.0, 1.0).","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"vertices_to_delete = Iterators.filter(each_solid_vertex(tri)) do i\n    p = get_point(tri, i)\n    r2 = (getx(p) - 1.0)^2 + (gety(p) - 1.0)^2\n    return r2 < 1 / 2^2\nend\nfor i in vertices_to_delete\n    delete_point!(tri, i)\nend\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"Note that in this situation, points still contains those points that we have now deleted. This is the reason to be careful about using, say, DelaunayTriangulation.each_point rather than each_solid_vertex. This triangulation is also still Delaunay.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/#Just-the-code","page":"Vertex Insertion and Deletion","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\npoints = [(0.0, 0.0), (2.0, 0.0), (1.0, 2.0)]\ntri = triangulate(points)\nfig, ax, sc = triplot(tri)\nfig\n\nadd_point!(tri, 1.0, 0.5)\nfig, ax, sc = triplot(tri)\nfig\n\nadd_point!(tri, 0.0, 1.0)\nfig, ax, sc = triplot(tri)\nfig\n\ndelete_ghost_triangles!(tri)\n    add_point!(tri, 2.0, 1.5)\n\nDelaunayTriangulation.has_ghost_triangles(tri)\n\nadd_ghost_triangles!(tri)\n\nDelaunayTriangulation.has_ghost_triangles(tri)\n\nget_convex_hull_vertices(tri)\n\nconvex_hull!(tri)\nfig, ax, sc = triplot(tri, show_convex_hull = true)\nfig\n\nrng = StableRNG(123)\nfor _ in 1:1000\n    new_point = 2rand(rng, 2)\n    add_point!(tri, new_point)\nend\nfig, ax, sc = triplot(tri)\nfig\n\nvertices_to_delete = Iterators.filter(each_solid_vertex(tri)) do i\n    p = get_point(tri, i)\n    r2 = (getx(p) - 1.0)^2 + (gety(p) - 1.0)^2\n    return r2 < 1 / 2^2\nend\nfor i in vertices_to_delete\n    delete_point!(tri, i)\nend\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"","category":"page"},{"location":"tutorials/operations_vertex_insertion_deletion/","page":"Vertex Insertion and Deletion","title":"Vertex Insertion and Deletion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"applications/pde_discretisation/#Solving-PDEs","page":"Solving PDEs","title":"Solving PDEs","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"For our next application, we consider solving PDEs. In particular, we focus on the discretisation of a domain on which a PDE can be solved. The method we discuss here is the basis of the package FiniteVolumeMethod.jl.","category":"page"},{"location":"applications/pde_discretisation/#Problem-Statement","page":"Solving PDEs","title":"Problem Statement","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"For this discussion, we will focus solely on solving a mean exit time problem of the form","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"beginaligned\nDgrad^2 T(vb x) = -1 quad vb x in Omega \nT(vb x) = 0 quad vb x in partial Omega\nendaligned","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"where T is the mean exit time, meaning the average amount of time it takes a particle to leave Omega through partialOmega starting at vb x; D is the diffusivity; and Omega is the domain of interest.[1] For this discussion, we will let Omega be an annulus so that Omega = (r theta)  1  r  2 0  theta  2pi. We will exploit the linearity in this problem to express its solution as being approximated by some linear system of the form vb Avb T = vb b, but we note that for most PDEs nonlinear solvers are required.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"[1]: See this example for more detail.","category":"page"},{"location":"applications/pde_discretisation/#Discretisation-of-the-Domain","page":"Solving PDEs","title":"Discretisation of the Domain","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Now let's discuss the discretisation of Omega. The aim is to decompose Omega into a collection of triangles mathcal T_i such that Omega = cup_imathcal T_i. We will then approximate the solution T on each triangle mathcal T_i by a piecewise linear function. For this decomposition, we simply use mathcal Dmathcal T(Omega), where mathcal Dmathcal T(Omega) is some Delaunay triangulation of points in Omega with partialmathcal Dmathcal T(Omega) = partialOmega. Here is our discretisation of our annulus.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\nrng = StableRNG(123)\nR₁ = 1.0\nR₂ = 2.0\nouter_circle = CircularArc((R₂, 0.0), (R₂, 0.0), (0.0, 0.0))\ninner_circle = CircularArc((R₁, 0.0), (R₁, 0.0), (0.0, 0.0), positive = false)\npoints = NTuple{2, Float64}[]\ntri = triangulate(points; rng, boundary_nodes = [[[outer_circle]], [[inner_circle]]])\nA = 2π * (R₂^2 - R₁^2)\nrefine!(tri; max_area = 2.0e-3A, min_angle = 33.0, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"applications/pde_discretisation/#Discretisation-of-the-PDE","page":"Solving PDEs","title":"Discretisation of the PDE","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Now let's determine how we can use the discretisation above to solve the PDE. Central to this approach is the idea of a control volume around each point. In particular, connect the centroids of each triangle to the midpoints of the edges of the triangle. This defines a collection of polygons Omega_i around each point vb x_i, as shown below in blue.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"points = NTuple{2, Float64}[] #hide\nfor T in each_solid_triangle(tri) #hide\n    u, v, w = triangle_vertices(T) #hide\n    p, q, r = get_point(tri, u, v, w) #hide\n    c = DelaunayTriangulation.triangle_centroid(p, q, r) #hide\n    push!(points, c, (p .+ q) ./ 2, c, (q .+ r) ./ 2, c, (r .+ p) ./ 2) #hide\nend #hide\nlinesegments!(ax, points, color = :blue) #hide\nfig #hide","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Consider a particular control volume Omega_i. We integrate our PDE over this domain, writing grad^2 = grad vdot grad and use the divergence theorem:","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"beginaligned\nDiint_Omega_i grad^2 T(vb x) dd A = -iint_Omega_i dd A \nDoint_partialOmega_i grad T(vb x) vdot vun dd s = -A_i\nendaligned","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"where vun is the outward normal to Omega_i and A_i is the area of Omega_i. Now, let mathcal E_i be the set of edges defining partialOmega_i so that partialOmega_i = cup_sigmainmathcal E_i sigma. Thus,","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Dsum_sigmainmathcal E_iint_sigma grad T(vb x) vdot vun dd s = -A_i","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Now we want to approximate each int_sigma grad T(vb x) vdot vun  dd s. First, we use a midpoint approximation to give","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"int_sigma grad T(vb x) vdot vun dd s approx leftgrad T(vb x_sigma) vdot vun_sigmaright L_sigma","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"where vb x_sigma is the midpoint of sigma, and vun_sigma is the normal to sigma. Now, to approximate grad T(vb x_sigma), we use a piecewise linear approximation to T on each triangle. In particular, suppose vb x_sigma is inside some triangle mathcal T_k. We use a linear shape function inside mathcal T_k for approximating T, writing","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"T(vb x) = alpha_k x + beta_k y + gamma_k quad vb x in mathcal T_k","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Using Cramer's rule, we can determine alpha_k, beta_k, and gamma_k in terms of the values of T at the vertices of mathcal T_k. In particular,","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"beginaligned\nalpha_k = s_k 11 T_k1 + s_k 12 T_k2 + s_k 13 T_k3 \nbeta_k = s_k 21 T_k1 + s_k 22 T_k2 + s_k 23 T_k3 \ngamma_k = s_k 31 T_k1 + s_k 32 T_k2 + s_k 33 T_k3\nendaligned","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"where","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"beginaligned\nvb S_k = frac1Delta_k beginbmatrix y_k2 - y_k3  y_k3 - y_k1  y_k1 - y_k2  x_k3 - x_k2  x_k1 - x_k3  x_k2 - x_k1  x_k2y_k3 - x_k3y_k2  x_k3y_k1 - x_k1y_k3  x_k1y_k2 - x_k2y_k1 endbmatrix \nDelta_k = x_k1y_k2-x_k2y_k1-x_k1y_k3+x_k3y_k1+x_k2y_k3-x_k3y_k2\nendaligned","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"With this approximation, grad T(vb x_sigma) approx (alpha_k beta_k)^mathsf Tmkern-15mu. Thus, have","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"fracDA_isum_sigma in mathcal E_i leftleft(s_k 11n_sigma^x + s_k 21n_sigma^yright)T_k1 + left(s_k 12n_sigma^x + s_k 22n_sigma^yright)T_k2 + left(s_k 13n_sigma^x + s_k23n_sigma^yright)T_k3rightL_sigma = -1","category":"page"},{"location":"applications/pde_discretisation/#Building-a-Matrix-System","page":"Solving PDEs","title":"Building a Matrix System","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Notice that the equation above is linear in the unknowns T_ki. Thus, we can write this as a matrix system vb Avb T = vb b. Consider the ith row of vb A. This row corresponds to the control volume Omega_i and is given by vb a_i^mathsf Tmkern-15mu, where the non-zero terms of vb a_i correspond to the vertices of the triangles that make up Omega_i. The corresponding value of b_i in vb b is simply -1. For handling the boundaries, we will instead let vb a_i = vb e_i for any nodes vb x_i on the boundary, where vb e_i = (0 ldots 1 ldots 0) is the ith standard basis vector, and b_i = 0. The solution to this system will give us the mean exit time T.","category":"page"},{"location":"applications/pde_discretisation/#Implementation","page":"Solving PDEs","title":"Implementation","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Let's now implement these ideas. Some details of this implementation, like how we efficient loop over the mesh for building the system by using edges rather than vertices, have been skipped and are described in more detail here.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"using LinearAlgebra\nusing SparseArrays\nfunction solve_met_problem(tri::Triangulation, D)\n    # To start, we need to build a map that takes the vertices from tri\n    # into a range of consecutive integers, since not all vertices are used.\n    vertex_map = Dict{Int, Int}()\n    inverse_vertex_map = Dict{Int, Int}()\n    cur_idx = 1\n    for i in DelaunayTriangulation.each_point_index(tri)\n        if DelaunayTriangulation.has_vertex(tri, i)\n            vertex_map[i] = cur_idx\n            inverse_vertex_map[cur_idx] = i\n            cur_idx += 1\n        end\n    end\n    # Next, we need to build up what we need from the geometry.\n    nv = num_solid_vertices(tri)\n    nt = num_solid_triangles(tri)\n    cv_volumes = zeros(nv)\n    Ttype = DelaunayTriangulation.triangle_type(tri)\n    shape_function_coefficients = Dict{Ttype, NTuple{9, Float64}}()\n    cv_edge_midpoints = Dict{Ttype, NTuple{3, NTuple{2, Float64}}}()\n    cv_edge_normals = Dict{Ttype, NTuple{3, NTuple{2, Float64}}}()\n    cv_edge_lengths = Dict{Ttype, NTuple{3, Float64}}()\n    sizehint!.((cv_volumes, shape_function_coefficients, cv_edge_midpoints, cv_edge_normals, cv_edge_lengths), nt)\n    for T in each_solid_triangle(tri)\n        u, v, w = triangle_vertices(T)\n        p, q, r = get_point(tri, u, v, w)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        rx, ry = getxy(r)\n        cx, cy = (px + qx + rx) / 3, (py + qy + ry) / 3\n        m₁x, m₁y = (px + qx) / 2, (py + qy) / 2\n        m₂x, m₂y = (qx + rx) / 2, (qy + ry) / 2\n        m₃x, m₃y = (rx + px) / 2, (ry + py) / 2\n        # Connect the centroid to each vertex, and all the midpoints to each other\n        pcx, pcy = cx - px, cy - py\n        qcx, qcy = cx - qx, cy - qy\n        rcx, rcy = cx - rx, cy - ry\n        m₁₃x, m₁₃y = m₁x - m₃x, m₁y - m₃y\n        m₂₁x, m₂₁y = m₂x - m₁x, m₂y - m₁y\n        m₃₂x, m₃₂y = m₃x - m₂x, m₃y - m₂y\n        # Get the sub-control volume areas\n        S₁ = 1 / 2 * abs(pcx * m₁₃y - pcy * m₁₃x)\n        S₂ = 1 / 2 * abs(qcx * m₂₁y - qcy * m₂₁x)\n        S₃ = 1 / 2 * abs(rcx * m₃₂y - rcy * m₃₂x)\n        cv_volumes[vertex_map[u]] += S₁\n        cv_volumes[vertex_map[v]] += S₂\n        cv_volumes[vertex_map[w]] += S₃\n        # Now get the shape function coefficients\n        Δ = qx * ry - qy * rx - px * ry + rx * py + px * qy - qx * py\n        s₁ = (qy - ry) / Δ\n        s₂ = (ry - py) / Δ\n        s₃ = (py - qy) / Δ\n        s₄ = (rx - qx) / Δ\n        s₅ = (px - rx) / Δ\n        s₆ = (qx - px) / Δ\n        s₇ = (qx * ry - rx * qy) / Δ\n        s₈ = (rx * py - px * ry) / Δ\n        s₉ = (px * qy - qx * py) / Δ\n        shape_function_coefficients[T] = (s₁, s₂, s₃, s₄, s₅, s₆, s₇, s₈, s₉)\n        # Get the midpoints\n        m₁c = (m₁x + cx) / 2, (m₁y + cy) / 2\n        m₂c = (m₂x + cx) / 2, (m₂y + cy) / 2\n        m₃c = (m₃x + cx) / 2, (m₃y + cy) / 2\n        cv_edge_midpoints[T] = (m₁c, m₂c, m₃c)\n        # Now get the normal vectors on the control volume edges\n        e₁x, e₁y = cx - m₁x, cy - m₁y\n        e₂x, e₂y = cx - m₂x, cy - m₂y\n        e₃x, e₃y = cx - m₃x, cy - m₃y\n        ℓ₁ = norm((e₁x, e₁y))\n        ℓ₂ = norm((e₂x, e₂y))\n        ℓ₃ = norm((e₃x, e₃y))\n        cv_edge_lengths[T] = (ℓ₁, ℓ₂, ℓ₃)\n        n₁ = e₁y / ℓ₁, -e₁x / ℓ₁\n        n₂ = e₂y / ℓ₂, -e₂x / ℓ₂\n        n₃ = e₃y / ℓ₃, -e₃x / ℓ₃\n        cv_edge_normals[T] = (n₁, n₂, n₃)\n    end\n    # Now we can build A\n    A = zeros(nv, nv)\n    for T in each_solid_triangle(tri)\n        u, v, w = triangle_vertices(T)\n        p, q, r = get_point(tri, u, v, w)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = shape_function_coefficients[T]\n        for (edge_index, e₁₂) in enumerate(DelaunayTriangulation.triangle_edges(T))\n            e₁, e₂ = edge_vertices(e₁₂)\n            x, y = cv_edge_midpoints[T][edge_index]\n            nx, ny = cv_edge_normals[T][edge_index]\n            ℓ = cv_edge_lengths[T][edge_index]\n            Dℓ = D * ℓ\n            a123 = (\n                Dℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dℓ * (s₁₃ * nx + s₂₃ * ny),\n            )\n            e1_is_bnd = DelaunayTriangulation.is_boundary_node(tri, e₁)[1]\n            e2_is_bnd = DelaunayTriangulation.is_boundary_node(tri, e₂)[1]\n            for vert in 1:3\n                e1_is_bnd || (A[vertex_map[e₁], vertex_map[(u, v, w)[vert]]] += a123[vert] / cv_volumes[vertex_map[e₁]])\n                e2_is_bnd || (A[vertex_map[e₂], vertex_map[(u, v, w)[vert]]] -= a123[vert] / cv_volumes[vertex_map[e₂]])\n            end\n        end\n    end\n    Asp = sparse(A)\n    # Now we can build b\n    b = zeros(nv)\n    for i in each_solid_vertex(tri)\n        if !DelaunayTriangulation.is_boundary_node(tri, i)[1]\n            b[vertex_map[i]] = -1.0\n        else\n            A[vertex_map[i], vertex_map[i]] = 1.0 # b[i] is already 0\n        end\n    end\n    # Now solve and return the solution\n    T = A \\ b\n    filled_out_T = zeros(DelaunayTriangulation.num_points(tri)) # make sure that T[i] actually refers to the vertex i\n    for i in 1:nv\n        filled_out_T[inverse_vertex_map[i]] = T[i]\n    end\n    return filled_out_T\nend","category":"page"},{"location":"applications/pde_discretisation/#Solving-the-System","page":"Solving PDEs","title":"Solving the System","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"Let's now solve this problem, taking D = 625 times 10^-4.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"D = 6.25e-4\nT = solve_met_problem(tri, D)\nfig, ax, sc = tricontourf(tri, T, levels = 0:5:200, extendhigh = :auto)\nfig","category":"page"},{"location":"applications/pde_discretisation/#Just-the-code","page":"Solving PDEs","title":"Just the code","text":"","category":"section"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\nrng = StableRNG(123)\nR₁ = 1.0\nR₂ = 2.0\nouter_circle = CircularArc((R₂, 0.0), (R₂, 0.0), (0.0, 0.0))\ninner_circle = CircularArc((R₁, 0.0), (R₁, 0.0), (0.0, 0.0), positive = false)\npoints = NTuple{2, Float64}[]\ntri = triangulate(points; rng, boundary_nodes = [[[outer_circle]], [[inner_circle]]])\nA = 2π * (R₂^2 - R₁^2)\nrefine!(tri; max_area = 2.0e-3A, min_angle = 33.0, rng)\nfig, ax, sc = triplot(tri)\nfig\n\n\nusing LinearAlgebra\nusing SparseArrays\nfunction solve_met_problem(tri::Triangulation, D)\n    # To start, we need to build a map that takes the vertices from tri\n    # into a range of consecutive integers, since not all vertices are used.\n    vertex_map = Dict{Int, Int}()\n    inverse_vertex_map = Dict{Int, Int}()\n    cur_idx = 1\n    for i in DelaunayTriangulation.each_point_index(tri)\n        if DelaunayTriangulation.has_vertex(tri, i)\n            vertex_map[i] = cur_idx\n            inverse_vertex_map[cur_idx] = i\n            cur_idx += 1\n        end\n    end\n    # Next, we need to build up what we need from the geometry.\n    nv = num_solid_vertices(tri)\n    nt = num_solid_triangles(tri)\n    cv_volumes = zeros(nv)\n    Ttype = DelaunayTriangulation.triangle_type(tri)\n    shape_function_coefficients = Dict{Ttype, NTuple{9, Float64}}()\n    cv_edge_midpoints = Dict{Ttype, NTuple{3, NTuple{2, Float64}}}()\n    cv_edge_normals = Dict{Ttype, NTuple{3, NTuple{2, Float64}}}()\n    cv_edge_lengths = Dict{Ttype, NTuple{3, Float64}}()\n    sizehint!.((cv_volumes, shape_function_coefficients, cv_edge_midpoints, cv_edge_normals, cv_edge_lengths), nt)\n    for T in each_solid_triangle(tri)\n        u, v, w = triangle_vertices(T)\n        p, q, r = get_point(tri, u, v, w)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        rx, ry = getxy(r)\n        cx, cy = (px + qx + rx) / 3, (py + qy + ry) / 3\n        m₁x, m₁y = (px + qx) / 2, (py + qy) / 2\n        m₂x, m₂y = (qx + rx) / 2, (qy + ry) / 2\n        m₃x, m₃y = (rx + px) / 2, (ry + py) / 2\n        # Connect the centroid to each vertex, and all the midpoints to each other\n        pcx, pcy = cx - px, cy - py\n        qcx, qcy = cx - qx, cy - qy\n        rcx, rcy = cx - rx, cy - ry\n        m₁₃x, m₁₃y = m₁x - m₃x, m₁y - m₃y\n        m₂₁x, m₂₁y = m₂x - m₁x, m₂y - m₁y\n        m₃₂x, m₃₂y = m₃x - m₂x, m₃y - m₂y\n        # Get the sub-control volume areas\n        S₁ = 1 / 2 * abs(pcx * m₁₃y - pcy * m₁₃x)\n        S₂ = 1 / 2 * abs(qcx * m₂₁y - qcy * m₂₁x)\n        S₃ = 1 / 2 * abs(rcx * m₃₂y - rcy * m₃₂x)\n        cv_volumes[vertex_map[u]] += S₁\n        cv_volumes[vertex_map[v]] += S₂\n        cv_volumes[vertex_map[w]] += S₃\n        # Now get the shape function coefficients\n        Δ = qx * ry - qy * rx - px * ry + rx * py + px * qy - qx * py\n        s₁ = (qy - ry) / Δ\n        s₂ = (ry - py) / Δ\n        s₃ = (py - qy) / Δ\n        s₄ = (rx - qx) / Δ\n        s₅ = (px - rx) / Δ\n        s₆ = (qx - px) / Δ\n        s₇ = (qx * ry - rx * qy) / Δ\n        s₈ = (rx * py - px * ry) / Δ\n        s₉ = (px * qy - qx * py) / Δ\n        shape_function_coefficients[T] = (s₁, s₂, s₃, s₄, s₅, s₆, s₇, s₈, s₉)\n        # Get the midpoints\n        m₁c = (m₁x + cx) / 2, (m₁y + cy) / 2\n        m₂c = (m₂x + cx) / 2, (m₂y + cy) / 2\n        m₃c = (m₃x + cx) / 2, (m₃y + cy) / 2\n        cv_edge_midpoints[T] = (m₁c, m₂c, m₃c)\n        # Now get the normal vectors on the control volume edges\n        e₁x, e₁y = cx - m₁x, cy - m₁y\n        e₂x, e₂y = cx - m₂x, cy - m₂y\n        e₃x, e₃y = cx - m₃x, cy - m₃y\n        ℓ₁ = norm((e₁x, e₁y))\n        ℓ₂ = norm((e₂x, e₂y))\n        ℓ₃ = norm((e₃x, e₃y))\n        cv_edge_lengths[T] = (ℓ₁, ℓ₂, ℓ₃)\n        n₁ = e₁y / ℓ₁, -e₁x / ℓ₁\n        n₂ = e₂y / ℓ₂, -e₂x / ℓ₂\n        n₃ = e₃y / ℓ₃, -e₃x / ℓ₃\n        cv_edge_normals[T] = (n₁, n₂, n₃)\n    end\n    # Now we can build A\n    A = zeros(nv, nv)\n    for T in each_solid_triangle(tri)\n        u, v, w = triangle_vertices(T)\n        p, q, r = get_point(tri, u, v, w)\n        s₁₁, s₁₂, s₁₃, s₂₁, s₂₂, s₂₃, s₃₁, s₃₂, s₃₃ = shape_function_coefficients[T]\n        for (edge_index, e₁₂) in enumerate(DelaunayTriangulation.triangle_edges(T))\n            e₁, e₂ = edge_vertices(e₁₂)\n            x, y = cv_edge_midpoints[T][edge_index]\n            nx, ny = cv_edge_normals[T][edge_index]\n            ℓ = cv_edge_lengths[T][edge_index]\n            Dℓ = D * ℓ\n            a123 = (\n                Dℓ * (s₁₁ * nx + s₂₁ * ny),\n                Dℓ * (s₁₂ * nx + s₂₂ * ny),\n                Dℓ * (s₁₃ * nx + s₂₃ * ny),\n            )\n            e1_is_bnd = DelaunayTriangulation.is_boundary_node(tri, e₁)[1]\n            e2_is_bnd = DelaunayTriangulation.is_boundary_node(tri, e₂)[1]\n            for vert in 1:3\n                e1_is_bnd || (A[vertex_map[e₁], vertex_map[(u, v, w)[vert]]] += a123[vert] / cv_volumes[vertex_map[e₁]])\n                e2_is_bnd || (A[vertex_map[e₂], vertex_map[(u, v, w)[vert]]] -= a123[vert] / cv_volumes[vertex_map[e₂]])\n            end\n        end\n    end\n    Asp = sparse(A)\n    # Now we can build b\n    b = zeros(nv)\n    for i in each_solid_vertex(tri)\n        if !DelaunayTriangulation.is_boundary_node(tri, i)[1]\n            b[vertex_map[i]] = -1.0\n        else\n            A[vertex_map[i], vertex_map[i]] = 1.0 # b[i] is already 0\n        end\n    end\n    # Now solve and return the solution\n    T = A \\ b\n    filled_out_T = zeros(DelaunayTriangulation.num_points(tri)) # make sure that T[i] actually refers to the vertex i\n    for i in 1:nv\n        filled_out_T[inverse_vertex_map[i]] = T[i]\n    end\n    return filled_out_T\nend\n\nD = 6.25e-4\nT = solve_met_problem(tri, D)\nfig, ax, sc = tricontourf(tri, T, levels = 0:5:200, extendhigh = :auto)\nfig","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"","category":"page"},{"location":"applications/pde_discretisation/","page":"Solving PDEs","title":"Solving PDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/constrained/#Constrained-Delaunay-Triangulations","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Now we introduce constrained Delaunay triangulations. Constrained Delaunay triangulations are similar to Delaunay triangulations mathcal Dmathcal T(mathcal P), except with the additional requirement that a provided set of segments mathcal S are constrained to be part of the triangulation, giving a triangulation denoted mathcal Dmathcal T(mathcal P mathcal S).","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"An important concept for defining constrained Delaunay triangulations is that of visibility. We say that two points p and q are visible to each other if the open line segment pq does not intersect any other segment in mathcal Dmathcal T(mathcal P mathcal S). We see that a triangle T in mathcal Dmathcal T(mathcal P mathcal S) is constrained Delaunay if its open circumcircle contains no point in mathcal P that is visible from any point inside T. Using this definition, we can thus define the constrained Delaunay triangulation of mathcal P with respect to mathcal S as the triangulation in which every triangle is constrained Delaunay. There is a corresponding constrained Delaunay lemma just as for unconstrained Delaunay triangulations, but we do not list it here.","category":"page"},{"location":"math/constrained/#Incremental-Insertion-Algorithm","page":"Constrained Delaunay Triangulations","title":"Incremental Insertion Algorithm","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"The algorithm for constructing constrained Delaunay triangulations is incremental and reasonably simply to describe. To compute mathcal Dmathcal T(mathcal P mathcal S), we:","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Compute mathcal Dmathcal T(mathcal P), the unconstrained Delaunay triangulation.\nInsert each segment s in mathcal S into mathcal Dmathcal T(mathcal P) one by one.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Of course, this second step is where all the complication lies. Most of the discussion in this section will be about the problem of inserting segments into a triangulation.","category":"page"},{"location":"math/constrained/#Inserting-a-Segment-into-a-Triangulation","page":"Constrained Delaunay Triangulations","title":"Inserting a Segment into a Triangulation","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Let's now discuss how we can add a segment into a triangulation. To understand the algorithm, let's first look at an example. Consider the figure below.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"To develop an algorithm, we need to notice one important thing from this figure: Since the blue segment will occlude visibility between any points on either side of the segment, the blue segment effectively divides, locally, the triangulation into two parts that no longer interact with each other. In the figure above, this means that any changes to the triangles bounded between the red curve and the blue segment will not interact those in the region bounded between the green curve and the bkue segment. This is a key observation that will allow us to develop an algorithm for inserting segments: we can handle the two sides separately.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"We need to also understand what we are showing in this figure. The highlighted triangles show all triangles intersected by the blue segment. The red boundary shows the chain of vertices intersected by the blue segment above the segment. There is a clear problem with this boundary though: there is a dangling edge, caused by the segment intersecting through two triangles that share an edge, except they are not hit right after each other. The main problem with this is that the object defined by the union of the blue segment and the red boundary is not technically a polygon. We treat it as if it were a polygon, though, by imagining an ant walking around the boundary of this object and splitting the dangling vertex into two copies of itself, so that the ant walking around the boundary essentially sees two different vertices. (It is possible for a vertex to be repeated three or more times, but this is much more rare.) The green boundary is defined similarly.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"What can we do now with this information? We have now established that the blue segment defines two polygonal cavities mathcal C_1 and mathcal C_2 that are adjacent to each other, sharing only the blue segment, and any changes to the triangulation within mathcal C_1 and mathcal C_2 will have no affect on the other cavity. We thus devise the following algorithm:","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Given a segment e_ij to be inserted, find the triangles intersected by the segment.\nDelete all triangles intersected by the segment from the triangulation and add e_ij.\nIdentify the two polygonal cavities mathcal C_1 and mathcal C_2 on each side of e_ij, taking care for any danling edges by repeating the vertices as needed.\nRetriangulate mathcal C_1 and mathcal C_2 separately.\nAdd the triangles from the triangulated polygonal cavities into the original triangulation.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Once step five is complete, the triangulation has now successfully added e_ij into the constrained triangulation. We are of course skipping over some key facts, like demonstrating why there are no other changes to the triangulation away from mathcal C_1 and mathcal C_2; for these details, see the original paper by Shewchuk and Brown (2015).","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"To actually implement this algorithm, there are some key details that need to be worked out:","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"How can we find all triangles intersected by e_ij?\nHow can we identify the polygonal cavities mathcal C_1 and mathcal C_2?\nHow can we efficiently retriangulate mathcal C_1 and mathcal C_2?","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Let's address these one at a time.","category":"page"},{"location":"math/constrained/#Finding-Triangles-Intersected-by-a-Segment","page":"Constrained Delaunay Triangulations","title":"Finding Triangles Intersected by a Segment","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"The problem is: Given a segment e_ij, find the set of all triangles intersected by the segment. This is exactly the problem that is solved by our point location algorithm - remember that our algorithm marches along all triangles from p_i to p_j until it finds the triangle containing p_j. Thus, by keeping track of all triangles visited during a point location algorithm jumping from p_i to p_j, we can find all the triangles intersected by the segment.","category":"page"},{"location":"math/constrained/#Finding-the-Polygonal-Cavities","page":"Constrained Delaunay Triangulations","title":"Finding the Polygonal Cavities","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Now we need to consider the problem of finding the two polygonal cavities mathcal C_1 and mathcal C_2. These can also be found by the point location algorithm. In addition to keeping track of all triangles visited, whenever an edge e_kell is stepped over we keep track of the vertices k and ell and put them into the list of vertices for either mathcal C_1 and mathcal C_2, depending on which side of the segment e_ij they are on. There are some important details here to consider for e.g. collinear edges, but we do not address this here.","category":"page"},{"location":"math/constrained/#Efficiency-Triangulating-the-Polygonal-Cavities","page":"Constrained Delaunay Triangulations","title":"Efficiency Triangulating the Polygonal Cavities","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Now we must address the problem of retriangulating the polygonal cavities. This issue is the same for both mathcal C_1 and mathcal C_2, so we discuss this problem in general for a given polygonal cavity mathcal C which could be either mathcal C_1 or mathcal C_2. While we could just simply triangulate mathcal C using a Bowyer-Watson algorithm, there is a better approach. It turns out that Chew's algorithm for triangulating convex polygons, as described in the convex triangulation section, also works for the polygonal cavity mathcal C. This is what we use for triangulating mathcal C. ","category":"page"},{"location":"math/constrained/#Putting-Everything-Together","page":"Constrained Delaunay Triangulations","title":"Putting Everything Together","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Now understanding all these details, the algorithm for inserting a segment into a triangulation follows the same procedure as outlined above. We first find all triangles intersected by the segment, then find the polygonal cavities mathcal C_1 and mathcal C_2, and then retriangulate these polygonal cavities using Chew's algorithm. Once this is done, we have successfully inserted the segment into the triangulation.","category":"page"},{"location":"math/constrained/#Boundaries","page":"Constrained Delaunay Triangulations","title":"Boundaries","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"One other important part of a constrained Delaunay triangulation is the enforcement of boundaries and holes in a triangulation. This part of the algorithm comes after all segments have been computed. The problem is as follows: Given a set of boundaries defined by segments, delete all triangles that fall outside of the boundaries. The approach we take for this follows the description given by Shewchuk in his Triangle paper:","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"First, we find all points that will be deleted. To do this, we go across each boundary edge (from the user-provided boundary, not necessarily of the triangulation) and identify the triangle adjacent to the edge away from the interior. The vertex of this triangle away from the boundary is used to find further points, checking all neighbours of this vertex and so on, deleting all vertices that are not in the boundary.\nUsing the set of points identified for deletion, we then identify all triangles to delete. This is done by looking all triangles that have a vertex in the set of points to delete, using the Adjacent2Vertex map to do so. We also need to assess the boundary edges once again. Safety is important here since, for example, a triangle might be comprised of vertices that all lie on the boundary but the triangle's interior is outside of the boundary. So, we check each triangle and ensure that those we've identified for deletion have a centroid that appear outside of the boundary. If this is not the case, we remove it from the set of triangles marked for deletion.\nNow having all the triangles to delete, we delete them all from the triangulation.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"With these steps complete, we will have our complete triangulation. To make these steps clear, the figure below shows an example.","category":"page"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/constrained/#Adding-Points-into-a-Constrained-Delaunay-Triangulation","page":"Constrained Delaunay Triangulations","title":"Adding Points into a Constrained Delaunay Triangulation","text":"","category":"section"},{"location":"math/constrained/","page":"Constrained Delaunay Triangulations","title":"Constrained Delaunay Triangulations","text":"Adding points into a constrained Delaunay triangulation is similar to the unconstrained case. The Bowyer-Watson algorithm is again used, except that, when we are excavating the cavity for the new point, we avoid stepping across any segments. If a point is inserted onto a segment, we dig cavities separately on each side of the segment.","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/#Constrained-Triangulations","page":"Domain with Interior Holes inside Interior Holes","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tutorials/constrained_interior_within_interiors/#Domain-with-Interior-Holes-within-Interior-Holes","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes within Interior Holes","text":"","category":"section"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"Now we consider triangulating a domain which has not only an interior boundary, but also an interior boundary inside that interior boundary. To start, let us load the packages.","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"To represent curves inside of curves, note that we have already had to do this for the outer boundary, where interior curves are clockwise - the opposite orientation of the outer boundary. So, similarly, interiors within other interior curves must be counter-clockwise. Basically, the orientation of an interior curve is the opposite orientation to the curve it's inside of. Here are the points we will be triangulating.","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"curve_1 = [\n    [(0.0, 0.0), (5.0, 0.0), (10.0, 0.0), (15.0, 0.0), (20.0, 0.0), (25.0, 0.0)],\n    [(25.0, 0.0), (25.0, 5.0), (25.0, 10.0), (25.0, 15.0), (25.0, 20.0), (25.0, 25.0)],\n    [(25.0, 25.0), (20.0, 25.0), (15.0, 25.0), (10.0, 25.0), (5.0, 25.0), (0.0, 25.0)],\n    [(0.0, 25.0), (0.0, 20.0), (0.0, 15.0), (0.0, 10.0), (0.0, 5.0), (0.0, 0.0)],\n] # outer-most boundary: counter-clockwise\ncurve_2 = [\n    [(4.0, 6.0), (4.0, 14.0), (4.0, 20.0), (18.0, 20.0), (20.0, 20.0)],\n    [(20.0, 20.0), (20.0, 16.0), (20.0, 12.0), (20.0, 8.0), (20.0, 4.0)],\n    [(20.0, 4.0), (16.0, 4.0), (12.0, 4.0), (8.0, 4.0), (4.0, 4.0), (4.0, 6.0)],\n] # inner boundary: clockwise\ncurve_3 = [\n    [\n        (12.906, 10.912), (16.0, 12.0), (16.16, 14.46), (16.29, 17.06),\n        (13.13, 16.86), (8.92, 16.4), (8.8, 10.9), (12.906, 10.912),\n    ],\n] # this is inside curve_2, so it's counter-clockwise\ncurves = [curve_1, curve_2, curve_3]\npoints = [\n    (3.0, 23.0), (9.0, 24.0), (9.2, 22.0), (14.8, 22.8), (16.0, 22.0),\n    (23.0, 23.0), (22.6, 19.0), (23.8, 17.8), (22.0, 14.0), (22.0, 11.0),\n    (24.0, 6.0), (23.0, 2.0), (19.0, 1.0), (16.0, 3.0), (10.0, 1.0), (11.0, 3.0),\n    (6.0, 2.0), (6.2, 3.0), (2.0, 3.0), (2.6, 6.2), (2.0, 8.0), (2.0, 11.0),\n    (5.0, 12.0), (2.0, 17.0), (3.0, 19.0), (6.0, 18.0), (6.5, 14.5),\n    (13.0, 19.0), (13.0, 12.0), (16.0, 8.0), (9.8, 8.0), (7.5, 6.0),\n    (12.0, 13.0), (19.0, 15.0),\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points = points)","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"To now triangulate:","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"rng = StableRNG(123) # triangulation is not unique when there are cocircular points\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/#Just-the-code","page":"Domain with Interior Holes inside Interior Holes","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\ncurve_1 = [\n    [(0.0, 0.0), (5.0, 0.0), (10.0, 0.0), (15.0, 0.0), (20.0, 0.0), (25.0, 0.0)],\n    [(25.0, 0.0), (25.0, 5.0), (25.0, 10.0), (25.0, 15.0), (25.0, 20.0), (25.0, 25.0)],\n    [(25.0, 25.0), (20.0, 25.0), (15.0, 25.0), (10.0, 25.0), (5.0, 25.0), (0.0, 25.0)],\n    [(0.0, 25.0), (0.0, 20.0), (0.0, 15.0), (0.0, 10.0), (0.0, 5.0), (0.0, 0.0)],\n] # outer-most boundary: counter-clockwise\ncurve_2 = [\n    [(4.0, 6.0), (4.0, 14.0), (4.0, 20.0), (18.0, 20.0), (20.0, 20.0)],\n    [(20.0, 20.0), (20.0, 16.0), (20.0, 12.0), (20.0, 8.0), (20.0, 4.0)],\n    [(20.0, 4.0), (16.0, 4.0), (12.0, 4.0), (8.0, 4.0), (4.0, 4.0), (4.0, 6.0)],\n] # inner boundary: clockwise\ncurve_3 = [\n    [\n        (12.906, 10.912), (16.0, 12.0), (16.16, 14.46), (16.29, 17.06),\n        (13.13, 16.86), (8.92, 16.4), (8.8, 10.9), (12.906, 10.912),\n    ],\n] # this is inside curve_2, so it's counter-clockwise\ncurves = [curve_1, curve_2, curve_3]\npoints = [\n    (3.0, 23.0), (9.0, 24.0), (9.2, 22.0), (14.8, 22.8), (16.0, 22.0),\n    (23.0, 23.0), (22.6, 19.0), (23.8, 17.8), (22.0, 14.0), (22.0, 11.0),\n    (24.0, 6.0), (23.0, 2.0), (19.0, 1.0), (16.0, 3.0), (10.0, 1.0), (11.0, 3.0),\n    (6.0, 2.0), (6.2, 3.0), (2.0, 3.0), (2.6, 6.2), (2.0, 8.0), (2.0, 11.0),\n    (5.0, 12.0), (2.0, 17.0), (3.0, 19.0), (6.0, 18.0), (6.5, 14.5),\n    (13.0, 19.0), (13.0, 12.0), (16.0, 8.0), (9.8, 8.0), (7.5, 6.0),\n    (12.0, 13.0), (19.0, 15.0),\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points = points)\n\nrng = StableRNG(123) # triangulation is not unique when there are cocircular points\ntri = triangulate(points; boundary_nodes, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"","category":"page"},{"location":"tutorials/constrained_interior_within_interiors/","page":"Domain with Interior Holes inside Interior Holes","title":"Domain with Interior Holes inside Interior Holes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/other/#Other","page":"Other","title":"Other","text":"","category":"section"},{"location":"api/other/#DelaunayTriangulation.distance_to_polygon","page":"Other","title":"DelaunayTriangulation.distance_to_polygon","text":"distance_to_polygon(q, points, boundary_nodes) -> Number\n\nGiven a query point q and a polygon defined by (points, boundary_nodes), returns the signed distance from q to the polygon. The boundary_nodes must match the specification in the documentation and in check_args.\n\nSee also dist.\n\n\n\n\n\n","category":"function"},{"location":"api/other/#DelaunayTriangulation.number_type","page":"Other","title":"DelaunayTriangulation.number_type","text":"number_type(x) -> DataType\n\nGiven a container x, returns the number type used for storing coordinates.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.number_type([1, 2, 3])\nInt64\n\njulia> DelaunayTriangulation.number_type((1, 2, 3))\nInt64\n\njulia> DelaunayTriangulation.number_type([1.0 2.0 3.0; 4.0 5.0 6.0])\nFloat64\n\njulia> DelaunayTriangulation.number_type([[[1, 2, 3, 4, 5, 1]], [[6, 8, 9], [9, 10, 11], [11, 12, 6]]])\nInt64\n\njulia> DelaunayTriangulation.number_type((1.0f0, 2.0f0))\nFloat32\n\njulia> DelaunayTriangulation.number_type(Vector{Float64})\nFloat64\n\njulia> DelaunayTriangulation.number_type(Vector{Vector{Float64}})\nFloat64\n\njulia> DelaunayTriangulation.number_type(NTuple{2, Float64})\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"api/other/#DelaunayTriangulation.pole_of_inaccessibility","page":"Other","title":"DelaunayTriangulation.pole_of_inaccessibility","text":"pole_of_inaccessibility(points, boundary_nodes; precision = one(number_type(points)))\n\nFinds the pole of inaccessibility for the polygon defined by points and boundary_nodes. The boundary_nodes  must match the specification given in the documentation. See also check_args for this specification.\n\nArguments\n\npoints: The points defining the polygon.\nboundary_nodes: The boundary nodes defining the polygon.\n\nKeyword Arguments\n\nprecision=one(number_type(points)): The precision of the returned pole. The default is one(number_type(points)).\n\nOutputs\n\nx: The x-coordinate of the pole.\ny: The y-coordinate of the pole.\n\nExtended help\n\nThe pole of inaccessibility is the point within a polygon that is furthest from an edge. For DelaunayTriangulation.jl,  this is useful as it is a representative point for ghost edges that is guaranteed to be inside the polygon, in contrast to for example a centroid which is not always inside the polygon. Some useful links are this blog post and the the original repo. Our implementation is partially based on  on the python implementation and this other Julia implementation.\n\n\n\n\n\n","category":"function"},{"location":"api/other/#DelaunayTriangulation.clip_polygon","page":"Other","title":"DelaunayTriangulation.clip_polygon","text":"clip_polygon(vertices, points, clip_vertices, clip_points; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector\n\nClip a polygon defined by (vertices, points) to a convex clip polygon defined by (clip_vertices, clip_points) with the Sutherland-Hodgman algorithm. The polygons should be defined in counter-clockwise order.\n\nArguments\n\nvertices: The vertices of the polygon to be clipped.\npoints: The underlying point set that the vertices are defined over. \nclip_vertices: The vertices of the clipping polygon.\nclip_points: The underlying point set that the clipping vertices are defined over.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nclipped_polygon: The coordinates of the clipped polygon, given in counter-clockwise order and clipped_polygon[begin] == clipped_polygon[end].\n\n\n\n\n\n","category":"function"},{"location":"api/other/#DelaunayTriangulation.construct_polygon_hierarchy","page":"Other","title":"DelaunayTriangulation.construct_polygon_hierarchy","text":"construct_polygon_hierarchy(points; IntegerType=Int) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of points. This defines a hierarchy with a single polygon.\n\n\n\n\n\nconstruct_polygon_hierarchy(points, boundary_nodes; IntegerType=Int) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of boundary_nodes that define a set of piecewise  linear curves. \n\n\n\n\n\nconstruct_polygon_hierarchy(points, boundary_nodes, boundary_curves; IntegerType=Int, n=4096) -> PolygonHierarchy{IntegerType}\n\nReturns a PolygonHierarchy defining the polygon hierarchy for a given set of boundary_nodes that define a curve-bounded domain  from the curves in boundary_curves. Uses polygonise to fill in the boundary curves.\n\nArguments\n\npoints: The point set.\nboundary_nodes: The boundary nodes. These should be the output from convert_boundary_curves!.\nboundary_curves: The boundary curves. These should be the output from convert_boundary_curves!.\n\nKeyword Arguments\n\nIntegerType=Int: The integer type to use for indexing the polygons.\nn=4096: The number of points to use for filling in the boundary curves in polygonise.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#Voronoi-Tessellations","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"","category":"section"},{"location":"api/voronoi/#DelaunayTriangulation.voronoi","page":"Voronoi Tessellations","title":"DelaunayTriangulation.voronoi","text":"voronoi(tri::Triangulation; clip=false, smooth=false, kwargs...) -> VoronoiTessellation\n\nComputes the Voronoi tessellation dual to a triangulation. If the triangulation is weighted, this computes the power diagram.\n\nArguments\n\ntri: The triangulation.\n\nKeyword Arguments\n\nclip=false: If true, then the Voronoi tessellation is clipped to the convex hull of the triangulation. Otherwise, the Voronoi tessellation is unbounded.\nclip_polygon=nothing: If clip=true, then this is the polygon to clip the Voronoi tessellation to. If nothing, the convex hull of the triangulation is used. The polygon should be defined as a Tuple of the form (points, boundary_nodes) where the boundary_nodes are vertices mapping to coordinates in points, adhering to the usual conventions for defining boundaries. \n\nwarning: Convex\nThe clipping polygon must be convex. If it is not, unexpected results may occur.\n\nsmooth=false: If true, then the Voronoi tessellation is smoothed into a centroidal tessellation. Otherwise, the Voronoi tessellation is not smoothed. Must have clip=true if smooth=true.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nkwargs...: Additional keyword arguments passed to centroidal_smooth if smooth=true.\n\nOutput\n\nvorn: The VoronoiTessellation.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.centroidal_smooth","page":"Voronoi Tessellations","title":"DelaunayTriangulation.centroidal_smooth","text":"centroidal_smooth(vorn::VoronoiTessellation; maxiters=1000, tol=default_displacement_tolerance(vorn), rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -> VoronoiTessellation\n\nSmooths vorn into a centroidal tessellation so that the new tessellation is of a set of generators whose associated Voronoi polygon is that polygon's centroid.\n\nArguments\n\nvorn: The VoronoiTessellation.\n\nKeyword Arguments\n\nmaxiters=1000: The maximum number of iterations.\nclip_polygon=nothing: If clip=true, then this is the polygon to clip the Voronoi tessellation to. If nothing, the convex hull of the triangulation is used. The polygon should be defined as a Tuple of the form (points, boundary_nodes) where the boundary_nodes are vertices mapping to coordinates in points, adhering to the usual conventions for defining boundaries. Must be a convex polygon. \ntol=default_displacement_tolerance(vorn): The displacement tolerance. See default_displacement_tolerance for the default. \nrng=Random.default_rng(): The random number generator.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nkwargs...: Extra keyword arguments passed to retriangulate.\n\nOutputs\n\nvorn: The updated VoronoiTessellation. This is not done in-place.\n\nExtended help\n\nThe algorithm is simple. We iteratively smooth the generators, moving them to the centroid of their associated Voronoi polygon for the current tessellation,  continuing until the maximum distance moved of any generator is less than tol. Boundary generators are not moved.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_triangulation","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_triangulation","text":"get_triangulation(cache::TriangulationCache) -> Triangulation\n\nReturns the Triangulation stored in cache.\n\n\n\n\n\nget_triangulation(vorn::VoronoiTessellation) -> Triangulation\n\nGets the underlying triangulation of the Voronoi tessellation vorn.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_generators","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_generators","text":"get_generators(vorn::VoronoiTessellation) -> Dict{Vertex,Point}\n\nGets the generators of the Voronoi tessellation vorn as a Dict, mapping vertices to their coordinates. These  coordinates are given as Tuples of the form (x, y).\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_polygon_points","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_polygon_points","text":"get_polygon_points(vorn::VoronoiTessellation) -> Vector{Point}\n\nGets the polygon points of the Voronoi tessellation vorn. These are the vertices of the Voronoi polygons, and are given as Tuples of the form (x, y).\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_polygons","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_polygons","text":"get_polygons(vorn::VoronoiTessellation) -> Dict{Index,Vector{Vertex}}\n\nGets the polygons of the Voronoi tessellation vorn as a Dict, mapping polygon indices to their vertices,  where the vertices refer to points in get_polygon_points(vorn). The vertices are given in counter-clockwise order  and the first and last vertices are equal. \n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_circumcenter_to_triangle","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_circumcenter_to_triangle","text":"get_circumcenter_to_triangle(vorn::VoronoiTessellation) -> Dict{Index,Triangle}\n\nGets the circumcenters of the Voronoi tessellation vorn as a Dict, mapping circumcenter indices to their corresponding triangles. The triangles are sorted so that the minimum vertex is last.\n\n\n\n\n\nget_circumcenter_to_triangle(vor::VoronoiTessellation, i) -> Triangle\n\nGets the triangle associated with the ith circumcenter. The triangle is sorted so that the minimum vertex is last.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_triangle_to_circumcenter","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_triangle_to_circumcenter","text":"get_triangle_to_circumcenter(vorn::VoronoiTessellation) -> Dict{Triangle,Index}\n\nGets the triangles of the Voronoi tessellation vorn as a Dict, mapping triangle indices to their corresponding circumcenters. The circumcenters are given as their vertices, referring to points in get_polygon_points(vorn).\n\n\n\n\n\nget_triangle_to_circumcenter(vor::VoronoiTessellation, T) -> Index\n\nGets the circumcenter index associated with the triangle T. The triangle should be sorted so that the minimum vertex is last.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_unbounded_polygons","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_unbounded_polygons","text":"get_unbounded_polygons(vorn::VoronoiTessellation) -> Set{Index}\n\nGets the unbounded polygons of the Voronoi tessellation vorn as a Set of polygon indices.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_cocircular_circumcenters","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_cocircular_circumcenters","text":"get_cocircular_circumcenters(vorn::VoronoiTessellation) -> Set\n\nGets the cocircular circumcenters of the Voronoi tessellation vorn as a Set of circumcenter indices. These are circumcenters  that come from triangles that are cocircular with another adjoining triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_boundary_polygons","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_boundary_polygons","text":"get_boundary_polygons(vorn::VoronoiTessellation) -> Set{Index}\n\nGets the boundary polygons of the Voronoi tessellation vorn as a Set of polygon indices.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_generator","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_generator","text":"get_generator(vor::VoronoiTessellation, i) -> NTuple{2, Number}\nget_generator(vor::VoronoiTessellation, i...) -> NTuple{length(i), NTuple{2, Number}}\n\nGets the coordinates for the generators i..., returned as Tuples of the form (x, y) for each generator.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_polygon_point","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_polygon_point","text":"get_polygon_point(vor::VoronoiTessellation, i) -> NTuple{2, Number}\nget_polygon_point(vor::VoronoiTessellation, i...) -> NTuple{length(i), NTuple{2, Number}}\n\nGets the coordinates corresponding to the vertices i... of the polygons, returned as Tuples of the form (x, y) for each vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_polygon","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_polygon","text":"get_polygon(vor::VoronoiTessellation, i) -> Vector{Vertex}\n\nGets the vector of vertices corresponding to the ith polygon, given in counter-clockwise order and  with the first and last vertices equal. To obtain the coordinates, see get_polygon_point.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.num_polygons","page":"Voronoi Tessellations","title":"DelaunayTriangulation.num_polygons","text":"num_polygons(vor::VoronoiTessellation) -> Integer\n\nReturns the number of polygons in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.num_polygon_vertices","page":"Voronoi Tessellations","title":"DelaunayTriangulation.num_polygon_vertices","text":"num_polygon_vertices(vor::VoronoiTessellation) -> Integer\n\nReturns the number of polygon vertices in the Voronoi tessellation vor. This might include duplicate vertices if get_polygon_points(vor) has duplicates.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.num_generators","page":"Voronoi Tessellations","title":"DelaunayTriangulation.num_generators","text":"num_generators(vor::VoronoiTessellation) -> Integer\n\nReturns the number of generators in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_centroid","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(stats::TriangulationStatistics, T)\n\nReturns the centroid field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\nget_centroid(vor::VoronoiTessellation, i) -> NTuple{2, Number}\n\nGets the centroid of the ith Voronoi polygon, given as a Tuple of the form (x, y).\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.polygon_bounds","page":"Voronoi Tessellations","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(vorn::VoronoiTessellation, unbounded_extension_factor=0.0; include_polygon_vertices=true) -> (Number, Number, Number, Number)\n\nGets the bounding box for the Voronoi tessellation vorn.\n\nArguments\n\nvorn::VoronoiTessellation: The Voronoi tessellation.\nunbounded_extension_factor=0.0: The factor by which to extend the bounding box for unbounded polygons.\n\nKeyword Arguments\n\ninclude_polygon_vertices=true: If true, then the bounding box will also include the polygon vertices. Otherwise, only the generators are included.\n\nOutput\n\nxmin: Given by xmin′ - unbounded_extension_factor * (xmin′ - xmin′), where xmin′ is the original minimum x-coordinate of the computed bounding box and similarly for xmax′.\nxmax: Given by xmax′ + unbounded_extension_factor * (xmax′ - xmax′), where xmax′ is the original maximum x-coordinate of the computed bounding box and similarly for xmin′.\nymin: Given by ymin′ - unbounded_extension_factor * (ymin′ - ymin′), where ymin′ is the original minimum y-coordinate of the computed bounding box and similarly for ymax′.\nymax: Given by ymax′ + unbounded_extension_factor * (ymax′ - ymax′), where ymax′ is the original maximum y-coordinate of the computed bounding box and similarly for ymin′.\n\n\n\n\n\npolygon_bounds(points, boundary_nodes, check_all_curves=Val(false)) -> (Number, Number, Number, Number)\n\nComputes the bounding box of the polygon defined by (points, boundary_nodes). The boundary_nodes must match the specification in the documentation and in check_args. If check_all_curves is true, then the bounding box of the union of all curves of the polygon is computed instead of just the first curve.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.get_polygon_coordinates","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_polygon_coordinates","text":"get_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nReturns the coordinates of the polygon with index i in vorn. If bounding_box is provided, then the polygon is clipped to the bounding box. If the polygon is unbounded, then bounding_box must be provided.\n\nSee also get_unbounded_polygon_coordinates and get_bounded_polygon_coordinates.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon.\nbounding_box=nothing: The bounding box to clip the polygon to. If nothing, then the polygon is not clipped. If the polygon is unbounded, then bounding_box must be provided.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ncoords: The coordinates of the polygon. This is a circular vector.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.polygon_features","page":"Voronoi Tessellations","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(vor::VoronoiTessellation, i) -> (Number, NTuple{2, Number})\n\nGets the area and centroid of the polygon with index i in vor.\n\n\n\n\n\npolygon_features(points, boundary_nodes) -> (Number, NTuple{2, Number})\n\nComputes the signed area and centroid of the polygon defined by (points, boundary_nodes). The boundary_nodes must match the specification in the documentation  and in check_args.\n\n\n\n\n\n","category":"function"},{"location":"api/voronoi/#DelaunayTriangulation.toggle_inf_warn!","page":"Voronoi Tessellations","title":"DelaunayTriangulation.toggle_inf_warn!","text":"toggle_inf_warn!()\n\nToggle the warning for infinite circumcenters in the Voronoi tessellation. By default, this warning is enabled.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/weighted/#Weighted-Triangulations","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"","category":"section"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"In this tutorial, we demonstrate how to construct a weighted Delaunay triangulation. For more information about weighted Delaunay triangulations, see the math details here. To summarise, weighted Delaunay triangulations associate with each vertex p_i a scalar weight w_i. To pass weights into triangulate, use the weights keyword argument, which by default is ZeroWeight().","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"Let's first consider a simple example. We use a triangulation with random weights and compare it to the standard unweighted Delaunay triangulation.","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"using DelaunayTriangulation, CairoMakie\nA, B, C, D, E, F, G, H,\nI, J, K, L, M, N = (-1.0, 3.0), (1.0, 3.0),\n(2.0, 2.0), (2.0, 0.0), (1.0, -1.0), (-1.0, -1.0),\n(-2.0, 0.0), (-2.0, 2.0), (-1.0, 2.0),\n(0.0, 1.5), (1.0, 2.5), (-1.0, 0.5),\n(1.0, 0.0), (1.5, 1.0)\npoints = [A, B, C, D, E, F, G, H, I, J, K, L, M, N]\nweights = randn(length(points))\ntri = triangulate(points; weights)","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"tri_unweighted = triangulate(points)","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"fig = Figure()\nax = Axis(fig[1, 1], width = 400, height = 400, title = \"Unweighted\", titlealign = :left)\ntriplot!(ax, tri_unweighted, strokecolor = :black)\nax2 = Axis(fig[1, 2], width = 400, height = 400, title = \"Weighted\", titlealign = :left)\ntriplot!(ax2, tri, strokecolor = :red)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"The triangles are of course not the same. Also, note that not all vertices appear in the weighted triangulation. To see the effect of the weights, let's reset all the weights to zero and see how the triangulation changes as we vary the weight of the point at (x y) = (0 15), starting with a weight of -10.","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"w = Observable(-10.0)\nweights = @lift (wts = zeros(length(points)); wts[10] = $w; wts)\ntri = @lift triangulate(points; weights = $weights)\nweight_itr_base = LinRange(-10, 10, 30*5)\nweight_itr = vcat(weight_itr_base, reverse(weight_itr_base))\ntitle_obs = lift(w -> L\"w_{10} = %$(round(w, sigdigits = 4))\", w)\nfig, ax, sc = triplot(tri,\naxis = (title = title_obs, titlealign = :left),\nfigure = (fontsize = 24,))\nscatter!(ax, [J], color = :red, markersize = 13)\nrecord(fig, \"varying_weight.mp4\", weight_itr; framerate = 30) do _w\n    w[] = _w\nend;\nnothing #hide","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"(Image: )","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"See that, once the weight gets so large, it essentially dominates the triangulation.","category":"page"},{"location":"tutorials/weighted/#Just-the-code","page":"Weighted Triangulations","title":"Just the code","text":"","category":"section"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"using DelaunayTriangulation, CairoMakie\nA, B, C, D, E, F, G, H,\nI, J, K, L, M, N = (-1.0, 3.0), (1.0, 3.0),\n(2.0, 2.0), (2.0, 0.0), (1.0, -1.0), (-1.0, -1.0),\n(-2.0, 0.0), (-2.0, 2.0), (-1.0, 2.0),\n(0.0, 1.5), (1.0, 2.5), (-1.0, 0.5),\n(1.0, 0.0), (1.5, 1.0)\npoints = [A, B, C, D, E, F, G, H, I, J, K, L, M, N]\nweights = randn(length(points))\ntri = triangulate(points; weights)\n\ntri_unweighted = triangulate(points)\n\nfig = Figure()\nax = Axis(fig[1, 1], width = 400, height = 400, title = \"Unweighted\", titlealign = :left)\ntriplot!(ax, tri_unweighted, strokecolor = :black)\nax2 = Axis(fig[1, 2], width = 400, height = 400, title = \"Weighted\", titlealign = :left)\ntriplot!(ax2, tri, strokecolor = :red)\nresize_to_layout!(fig)\nfig\n\nw = Observable(-10.0)\nweights = @lift (wts = zeros(length(points)); wts[10] = $w; wts)\ntri = @lift triangulate(points; weights = $weights)\nweight_itr_base = LinRange(-10, 10, 30*5)\nweight_itr = vcat(weight_itr_base, reverse(weight_itr_base))\ntitle_obs = lift(w -> L\"w_{10} = %$(round(w, sigdigits = 4))\", w)\nfig, ax, sc = triplot(tri,\naxis = (title = title_obs, titlealign = :left),\nfigure = (fontsize = 24,))\nscatter!(ax, [J], color = :red, markersize = 13)\nrecord(fig, \"varying_weight.mp4\", weight_itr; framerate = 30) do _w\n    w[] = _w\nend;","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"","category":"page"},{"location":"tutorials/weighted/","page":"Weighted Triangulations","title":"Weighted Triangulations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/predicate_kernels/#Predicate-Kernels","page":"Predicate Kernels","title":"Predicate Kernels","text":"","category":"section"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"By default, this package uses adaptive arithmetic via AdaptivePredicates.jl for computing predicates. In total, there are three different kernels offered for computing predicates:","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"FastKernel(): Predicates will be computed without any adaptive or exact arithmetic. \nAdaptiveKernel(): Predicates will be computed using adaptive arithmetic via AdaptivePredicates.jl.\nExactKernel(): Predicates will be computed using exact arithmetic via ExactPredicates.jl. ","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"There are clear strengths and weaknesses to each of these choices. To summarise them, here is when each kernel should be considered:","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"FastKernel(): This kernel can be safely used when you know that there are no collinear points or cocircular points in your data set. It may still work even in those cases, but it can not be safely relied upon. If you trust that there are no issues, this should be the kernel you use as it is the fastest. If you run into issues while using this kernel, please use try AdaptiveKernel().\nAdaptiveKernel(): This is the kernel we use by default. It has performance that is reasonably close to what is offered by FastKernel(), except it also guarantees that predicates will return the correct result even with collinear points or cocircular points, or in other degenerate cases where one typically expects predicates to be problematic. If you are using FastKernel() and run into issues, this should be the next kernel you try.\nExactKernel(): This is the slowest kernel, but it is the safest. This kernel works on a much wider range of numbers than AdaptiveKernel(), and is guaranteed to satisfy certain combinatorial properties such as orient(a, b, c) == orient(b, c, a) == orient(c, a, b). I have not seen any examples  where AdaptiveKernel() fails but ExactKernel() works, though, so you should only consider using this kernel if you do actually encounter such a case, i.e. treat this kernel as a fallback for AdaptiveKernel().","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"We give a discussion below about why robust arithmetic is actually important, to help you understand these choices. A key point is that it is highly advised that you do not use FastKernel().","category":"page"},{"location":"manual/predicate_kernels/#Why-use-robust-predicates?","page":"Predicate Kernels","title":"Why use robust predicates?","text":"","category":"section"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"Three great resources for understanding why we need robust predicates are","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"Jonathan Shewchuk's paper on adaptive precision floating-point arithmetic here.\nJonathan Shewchuk's lecture notes on geometric robustness here.\nThis paper by Kettner et al. (2008) on some examples of issues with inexact arithmetic.","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"We give a simple summary here. A big component of the algorithms used in this package are what are known as geometric predicates, some of these being:","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"orient(p, q, r): Is r left, right, or on the line through pq?\nincircle(p, q, r, s): Is s inside, outside, or on the circle through p, q, and r?","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"These predicates can be computed using determinants:","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"beginalign*\nO_pqr = textrmorient(p q r) = beginvmatrix p_x - r_x  p_y - r_y  q_x - r_x  q_y - r_y endvmatrix \nC_pqrs = textrmincircle(p q r s) = beginvmatrix p_x - s_x  p_y - s_y  (p_x - s_x)^2 + (p_y - s_y)^2  q_x - s_x  q_y - s_y  (q_x - s_x)^2 + (q_y - s_y)^2  r_x - s_x  r_y - s_y  (r_x - s_x)^2 + (r_y - s_y)^2 endvmatrix\nendalign*","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"The signs of these determinants O_pqr and C_pqrs are used to determinant the answers to the above questions. In inexact arithmetic, it is common that the sign picked is wrong when the determinants are close to zero. The consequences of this can be catastrophic:","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"The algorithms may hang or crash.\nThe final triangulation may be completely invalid. For example, if a point is being added into a triangulation right onto an existing edge, then in exact arithmetic we would know to split the edge to the left and to the right. In inexact arithmetic, the point may be to the left of the edge but detected as being to the right of it, thus adding a triangle that crosses an edge.\nYou may encounter BoundsErrors from bad Adjacent queries where a triangle is expected to exist but doesn't.","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"Another issue is due to the fact that floating point arithmetic is not associative. In exact arithmetic, we would expect for example that ","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"O_pqr = O_qrp = O_rpq","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"but this is not true in floating point arithmetic. This causes issues with consistency - a point may be found to be both left and right of an edge depending on the order of the points given to the orient predicate, inevitably leading to an invalid triangulation. With the use of robust predicates, this property is guaranteed to hold, ensuring that all the predicate results are consistent with each other. (This identity does not always hold with adaptive arithmetic, although this is less problematic due to the design of the adaptive predicates; read Shewchuk's paper for more information.) This has the following consequence: Even if you think robust predicates are not necessary for you because none of your inputs are exact (for example), you still want them to guarantee consistency with predicates regardless of the input order.","category":"page"},{"location":"manual/predicate_kernels/#Will-disabling-exact-predicates-give-me-better-performance?","page":"Predicate Kernels","title":"Will disabling exact predicates give me better performance?","text":"","category":"section"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"It is also not even the case that using inexact predicates will give you better performance than if you were to use robust predicates. AdaptiveKernel()'s performance is typically similar to FastKernel(), with the exception of queries on collinear points. This exception is irrelevant, though, as FastKernel() is not even  reliable when used on collinear points. ExactKernel() is a bit slower, but its performance is still not terrible compared to FastKernel() since ExactPredicates.jl uses clever filters that typically do as much work as FastKernel() or AdaptiveKernel() would. Thus, the only cases where performance is improved significantly using FastKernel() is exactly in the cases where you do not want to be using FastKernel().","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"You should always benchmark your problems to see if using FastKernel() over the robust kernels AdaptiveKernel() or ExactKernel(), if you choose to do, will actually give you better performance.","category":"page"},{"location":"manual/predicate_kernels/#Can-I-check-if-my-computed-triangulation-is-valid?","page":"Predicate Kernels","title":"Can I check if my computed triangulation is valid?","text":"","category":"section"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"When you are not using robust predicates, you may want to check if your computed triangulation is actually a valid Delaunay triangulation. We provide the function DelaunayTriangulation.validate_triangulation for this purpose. This functionality is quite slow to use and is not currently optimised or well-documented (contributions towards addressing these issues are welcome), but it will work. One important note is that this check does actually use predicates in certain areas, so this check is still not guaranteed to be 100% accurate without robust predicates (by default, validate_triangulation will use the ExactKernel() kernel). Here is an example of its use.","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"using DelaunayTriangulation\ntri = triangulate(rand(2, 50))\nDelaunayTriangulation.validate_triangulation(tri)","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"true","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"T = first(each_solid_triangle(tri)) \nDelaunayTriangulation.delete_triangle!(tri, T) # break the triangulation for this example\nDelaunayTriangulation.validate_triangulation(tri)","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"The edge (12, 40) does not have two incident triangles.\nThe edge (12, 40) appears as an edge in the graph but it and its reverse are not both a key of the adjacent map.\n\nfalse","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"DelaunayTriangulation.validate_triangulation(tri; print_result = false)","category":"page"},{"location":"manual/predicate_kernels/","page":"Predicate Kernels","title":"Predicate Kernels","text":"false","category":"page"},{"location":"tutorials/clipped_polygon/#Clipped-Voronoi-Tessellations","page":"Clipping to a Generic Convex Polygon","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"tutorials/clipped_polygon/#Clipping-to-a-Generic-Convex-Polygon","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"","category":"section"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"In this tutorial we show how to clip a Voronoi tessellation to more generic convex polygons (non-convex polygons are not currently supported) than just a convex hull or a rectangle. This is done by using the clip_polygon keyword argument in voronoi.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"We start by clipping the tessellation to a rectangle, showing an alternative to the previous tutorial. To start, we load in the packages we need and generate some data.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"using DelaunayTriangulation\nusing DelaunayTriangulation: EllipticalArc\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"To define the polygon, we define the points and vertices just as we would, for example, the boundary of a triangulation.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"xmin, xmax, ymin, ymax = -1/2, 1/2, -1.0, 1.0\nclip_points = ((xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax))\nclip_vertices = (1, 2, 3, 4, 1)\nclip_polygon = (clip_points, clip_vertices)","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"Now we simply pass the polygon into voronoi.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"clipped_vorn = voronoi(tri, clip = true, clip_polygon = clip_polygon)","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"Now let's look at the results.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"fig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax1, -2, 2)\nylims!(ax1, -2, 2)\nlines!(ax1, [clip_points..., clip_points[begin]], color = :black, linewidth = 4, linestyle = :dash)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax2, -2, 2)\nylims!(ax2, -2, 2)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"We can clip to any convex polygon that we want to. For example, below we clip to an elliptical boundary.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"rng = StableRNG(123333)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)\nellip = EllipticalArc((1/2, 0.0), (1/2, 0.0), (0.0, 0.0), 1/2, 1.0, 0.0)\nt = LinRange(0, 1, 50)\nclip_points = ellip.(t)\nclip_vertices = [1:(length(clip_points)-1); 1]\nclip_polygon = (clip_points, clip_vertices)\nclipped_vorn = voronoi(tri, clip = true, clip_polygon = clip_polygon)\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax1, -2, 2)\nylims!(ax1, -2, 2)\nlines!(ax1, [clip_points..., clip_points[begin]], color = :black, linewidth = 4, linestyle = :dash)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax2, -2, 2)\nylims!(ax2, -2, 2)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/clipped_polygon/#Just-the-code","page":"Clipping to a Generic Convex Polygon","title":"Just the code","text":"","category":"section"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"using DelaunayTriangulation\nusing DelaunayTriangulation: EllipticalArc\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)\n\nxmin, xmax, ymin, ymax = -1/2, 1/2, -1.0, 1.0\nclip_points = ((xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax))\nclip_vertices = (1, 2, 3, 4, 1)\nclip_polygon = (clip_points, clip_vertices)\n\nclipped_vorn = voronoi(tri, clip = true, clip_polygon = clip_polygon)\n\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax1, -2, 2)\nylims!(ax1, -2, 2)\nlines!(ax1, [clip_points..., clip_points[begin]], color = :black, linewidth = 4, linestyle = :dash)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax2, -2, 2)\nylims!(ax2, -2, 2)\nresize_to_layout!(fig)\nfig\n\nrng = StableRNG(123333)\npoints = randn(rng, 2, 50)\ntri = triangulate(points; rng)\nvorn = voronoi(tri)\nellip = EllipticalArc((1/2, 0.0), (1/2, 0.0), (0.0, 0.0), 1/2, 1.0, 0.0)\nt = LinRange(0, 1, 50)\nclip_points = ellip.(t)\nclip_vertices = [1:(length(clip_points)-1); 1]\nclip_polygon = (clip_points, clip_vertices)\nclipped_vorn = voronoi(tri, clip = true, clip_polygon = clip_polygon)\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Unclipped\", width = 600, height = 400)\nax2 = Axis(fig[1, 2], title = \"Clipped\", width = 600, height = 400)\nvoronoiplot!(ax1, vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax1, -2, 2)\nylims!(ax1, -2, 2)\nlines!(ax1, [clip_points..., clip_points[begin]], color = :black, linewidth = 4, linestyle = :dash)\nvoronoiplot!(ax2, clipped_vorn, show_generators = false, color = :white, strokewidth = 4)\nxlims!(ax2, -2, 2)\nylims!(ax2, -2, 2)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"","category":"page"},{"location":"tutorials/clipped_polygon/","page":"Clipping to a Generic Convex Polygon","title":"Clipping to a Generic Convex Polygon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"extended/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"extended/overview/","page":"Overview","title":"Overview","text":"This section shows the docstrings for all functions not in the public API; for those in the public API, see the API. We will describe the following:","category":"page"},{"location":"extended/overview/","page":"Overview","title":"Overview","text":"Data Structures: All data structures used inside the package, along with functions related to working with them. Both public and private data structures are listed here.\nAlgorithm Internals: All internal functions used for algorithms inside the package.\nUtility Functions: All internal utility or other miscellaneous functions used inside the package.","category":"page"},{"location":"extended/overview/","page":"Overview","title":"Overview","text":"Some of the functions shown here will also appear in the public API, although only very few; for example, Triangulation and its accessors are repeated here. Functions listed here are NOT necessarily in the public API (similarly, a function having a docstring does NOT guarantee that it is in the public API) - only those listed in the API have this guarantee. Here is an index of all the functions listed in the above pages.","category":"page"},{"location":"extended/overview/","page":"Overview","title":"Overview","text":"Pages = [\"data_structures.md\", \"algorithm_internals.md\", \"utils.md\"]","category":"page"},{"location":"manual/triangulation_output/#Triangulation-Output","page":"Triangulation Output","title":"Triangulation Output","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"In this section, we discuss the output given from triangulate. Let's take a curve-bounded domain and inspect its output in detail; for information about this domain in particular, see the curve-bounded domain tutorial. First, here is the triangulation.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"using DelaunayTriangulation\nusing StableRNGs \nusing DelaunayTriangulation: EllipticalArc \ncurve = [\n    [\n        [1, 2, 3], [EllipticalArc((2.0, 0.0), (-2.0, 0.0), (0.0, 0.0), 2, 1 / 2, 0.0)]\n    ],\n    [\n        [BSpline([(0.0, 0.4), (1.0, 0.2), (0.0, 0.1), (-1.0, 0.2), (0.0, 0.4)])]\n    ],\n    [\n        [4, 5, 6, 7, 4]\n    ],\n    [\n        [BezierCurve([(0.0, -2.0), (0.0, -2.5), (-1.0, -2.5), (-1.0, -3.0)])], [CatmullRomSpline([(-1.0, -3.0), (0.0, -4.0), (1.0, -3.0), (0.0, -2.0)])]\n    ],\n    [\n        [12, 11, 10, 12]\n    ],\n    [\n        [CircularArc((1.1, -3.0), (1.1, -3.0), (0.0, -3.0), positive=false)]\n    ]\n]\npoints = [(-2.0, 0.0), (0.0, 0.0), (2.0, 0.0), (-2.0, -5.0), (2.0, -5.0), (2.0, -1 / 10), (-2.0, -1 / 10), (-1.0, -3.0), (0.0, -4.0), (0.0, -2.3), (-0.5, -3.5), (0.9, -3.0)]\nrng = StableRNG(123)\ntri = triangulate(points; boundary_nodes=curve, rng)\nrefine!(tri; max_area=1e-2, rng)\ntri","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Now let's inspect tri. If we look at the fields in tri, we see that there is a lot of information stored in tri:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"propertynames(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Note that each field X has an associated accessor DelaunayTriangulation.get_X. Let's go through each field. ","category":"page"},{"location":"manual/triangulation_output/#Geometry-Fields","page":"Triangulation Output","title":"Geometry Fields","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"First, we list the fields relating to the actual geometry.","category":"page"},{"location":"manual/triangulation_output/#[get_points(tri)](@ref-get_points)","page":"Triangulation Output","title":"get_points(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores the points that were triangulated. This may be a mutated version (not a copy, though, tri.points === points above) of the points provided into tri, note.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_points(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"In some cases, the points in this vector will not all appear in tri, which is why it is recommend you work with the vertices instead, via each_vertex(tri) or, for the solid or ghost vertices use each_solid_vertex(tri) or each_ghost_vertex(tri), respectively.","category":"page"},{"location":"manual/triangulation_output/#[get_triangles(tri)](@ref-get_triangles)","page":"Triangulation Output","title":"get_triangles(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores all the triangles in the triangulation, including both solid and ghost triangles.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_triangles(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This is also the same as each_triangle(tri). If you only wanted the solid triangles, you could use each_solid_triangle(tri), and similarly for the ghost triangles with each_ghost_triangle(tri). All the triangles in these sets are defined to be counter-clockwise:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"using DelaunayTriangulation: is_positively_oriented, triangle_orientation\nall(T -> is_positively_oriented(triangle_orientation(get_point(tri, triangle_vertices(T)...)...)), each_solid_triangle(tri))","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The above check is not true for all the ghost triangles since the domain is non-convex.","category":"page"},{"location":"manual/triangulation_output/#[get_boundary_nodes(tri)](@ref-get_boundary_nodes)","page":"Triangulation Output","title":"get_boundary_nodes(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores the boundary of the triangulation.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_nodes(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Notice that these boundary nodes are not the same as those provided into triangulate above. Instead of having curve, triangulate constructs a new boundary_nodes vector and populates that with the piecewise linear approximation. You could work with these nodes using get_boundary_nodes again. For examples, the nodes associated with the first curve are given by ","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_nodes(tri, 1)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The second section of this curve is given by ","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_nodes(tri, 1, 2)","category":"page"},{"location":"manual/triangulation_output/#[get_interior_segments(tri)](@ref-get_interior_segments)","page":"Triangulation Output","title":"get_interior_segments(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores the interior segments of the triangulation. These are the segments that are not part of the boundary.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_interior_segments(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"In our case, there are no such segments, but there would be if we had used segments when calling triangulate. We could add a segment now, for example","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"r = DelaunayTriangulation.num_points(tri)\nadd_point!(tri, -3/2, -4.0, concavity_protection = true; rng)\nadd_point!(tri, -3/2, -1.0, concavity_protection = true; rng)\nadd_segment!(tri, r + 1, r + 2; rng)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Now we see that we have some segments:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_interior_segments(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Note that, for any segment (i, j), only one of (i, j) or (j, i) will appear in the list of interior segments.","category":"page"},{"location":"manual/triangulation_output/#[get_all_segments(tri)](@ref-get_all_segments)","page":"Triangulation Output","title":"get_all_segments(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"In contrast to the interior_segments field, which only stores the interior segments, this field stores both the interior and boundary segments.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_all_segments(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Just as for the interior segments, only one of (i, j) or (j, i) will appear in the list of all segments.","category":"page"},{"location":"manual/triangulation_output/#[get_weights(tri)](@ref-get_weights)","page":"Triangulation Output","title":"get_weights(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores the weights associated with each point in the triangulation. By default, you will see a ZeroWeight():","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_weights(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"If you do provide weights, this will return those.","category":"page"},{"location":"manual/triangulation_output/#Topology-Fields","page":"Triangulation Output","title":"Topology Fields","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Now we list the fields relating to the topology of the triangulation itself.","category":"page"},{"location":"manual/triangulation_output/#[get_adjacent(tri)](@ref-get_adjacent)","page":"Triangulation Output","title":"get_adjacent(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field stores the adjacent map, mapping each edge (u, v) in the triangulation to the vertex w such that (u, v, w) is a positively oriented triangle in the triangulation. In cases where there is no such triangle, the vertex 0 is returned. For this triangulation, we have:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For example, the mapping (697, 967) => 968 implies that the triangle (697, 967, 968) is in the triangulation and is positively oriented, which we can verify:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"u, v, w = 697, 967, 968\nDelaunayTriangulation.contains_triangle(tri, u, v, w)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"It is important to note that, for any triangle (u, v, w), the mappings (u, v) => w, (v, w) => u, and (w, u) => v will all appear in the adjacent map. For example:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent(tri, u, v), get_adjacent(tri, v, w), get_adjacent(tri, w, u)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"You can use get_adjacent(tri, u, v) to find this vertex w, as we demonstrated above. For cases where the edge does not exist, you will get 0:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent(tri, 1, 2)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"One last thing to notice is that some of the vertices w will be ghost vertices, and similarly some of the edges (u, v) will be ghost edges. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent(tri, 73, 36)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This vertex -6 means that (73, 36) is an edge of the boundary associated with the ghost vertex -6.","category":"page"},{"location":"manual/triangulation_output/#[get_adjacent2vertex(tri)](@ref-get_adjacent2vertex)","page":"Triangulation Output","title":"get_adjacent2vertex(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The adjacent2vertex field is similar to adjacent. The difference is that, instead of mapping edges to vertices, adjacent2vertex maps vertices w to the set of all edges (u, v) such that (u, v, w) is a positively oriented triangle in the triangulation. For this triangulation, we have:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent2vertex(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"An example of this mapping is:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent2vertex(tri, 700)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This output means that (700, 792, 1936), (700, 790, 787), (700, 789, 1693), (700, 1693, 792), (700, 1936, 790), and (700, 787, 789) are all positively oriented triangles in the triangulation, and these are the only triangles that contain the vertex 700. In contrast to get_adjacent, calling get_adjacent2vertex on a vertex not in the triangulation will throw a KeyError. For ghost vertices, you will get the set of all edges on the boundary associated with that vertex, for example","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_adjacent2vertex(tri, -1)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"gives the set of all edges on the boundary associated with the ghost vertex -1. It is important to note that the edges in this set are not returned in any particular order, and so you should not rely on the order of the edges in the set.","category":"page"},{"location":"manual/triangulation_output/#[get_graph(tri)](@ref-get_graph)","page":"Triangulation Output","title":"get_graph(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The last field relating to topology is the graph, which stores the graph information of the underlying triangulation. In particular, it stores the information about which vertices share an edge. All together, we have three different types of connectivity information being stored in a triangulation:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Adjacent: The map from edges to vertices.\nAdjacent2Vertex: The map from vertices to edges.\nGraph: The map from vertices to vertices.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For this triangulation, we have:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_graph(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This output by itself of course isn't too useful. The returned Graph does have its own fields,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"propertynames(get_graph(tri))","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"which you can expect using DelaunayTriangulation.get_vertices(tri), DelaunayTriangulation.get_edges(tri), and get_neighbours(tri). Let us go through each of these fields one at a time.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For the vertices, you should not be inspecting this field directly. Instead, we provide each_vertex(tri), each_solid_vertex(tri), and each_ghost_vertex(tri) to iterate over the vertices in the triangulation. These functions return iterators. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"each_solid_vertex(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"collect(each_solid_vertex(tri))","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Since these iterators are derived from Sets, you should not rely on the particular ordering of vertices returned.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For the edges, again we recommend you do not inspect this field directly. Instead, we provide each_edge(tri), each_solid_edge(tri), and each_ghost_edge(tri) to iterate over the edges in the triangulation. These functions return iterators. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"each_edge(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"collect(each_edge(tri))","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Since these iterators are derived from Sets, you should not rely on the particular ordering of edges returned.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The neighbours are typically the more useful part of Graph. Looking at get_neighbours by itself, you obtain a mapping:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_neighbours(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This mapping shows the neighbours for each vertex in the triangulation. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_neighbours(tri, 1)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"shows that the vertices sharing edge with 1 are -1, 18, 487, and -2. These two ghost vertices, -1 and -2, imply that 1 is on the boundary of the triangulation and is also at the corner of the two sections of the boundary associated with the ghost vertices -1 and -2. Similarly,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_neighbours(tri, -2)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"shows the set of all vertices that are on the boundary associated with the ghost vertex -2. Once again, the vertices in this set are not returned in any particular order, and so you should not rely on the order of the vertices in the set. If you did want to traverse the boundary in some order, you would need to use get_adjacent to do so, or use the boundary_nodes; see, for example, the get_triangulation_area function in this tutorial. (If you have a node on the boundary you are interested in, DelaunayTriangulation.get_left_boundary_node and DelaunayTriangulation.get_right_boundary_node are available.)","category":"page"},{"location":"manual/triangulation_output/#Boundary-Handling-Fields","page":"Triangulation Output","title":"Boundary Handling Fields","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The next set of fields relate to how the boundary is handled in the triangulation.","category":"page"},{"location":"manual/triangulation_output/#[get_boundary_curves(tri)](@ref-get_boundary_curves)","page":"Triangulation Output","title":"get_boundary_curves(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is relevant only for curve-bounded domains, like the triangulation in this example. It stores the curves that were used to define the boundary of the triangulation. For our triangulation, we have ","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_curves(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This output is not just giving the names of the curves - the actual curves themselves are stored. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_curves(tri)[3]","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"is the actual BSpline that we have provided. The curves are stored in the same order as they were provided, so that the jth curve is associated with the jth section (i.e., the ghost vertex -j) of the boundary. The parts of the boundary that are a sequence of straight lines between vertices are represented by a PiecewiseLinear curve. For a triangulation that is not curve-bounded, the output is an empty Tuple. For example:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"tri2 = triangulate(rand(2, 50))\nget_boundary_curves(tri2)","category":"page"},{"location":"manual/triangulation_output/#[get_boundary_edge_map(tri)](@ref-get_boundary_edge_map)","page":"Triangulation Output","title":"get_boundary_edge_map(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is used to give information about where boundary edges are located in the triangulation. The precise definition is a bit cumbersome to describe: For a given boundary edge (u, v), the boundary_edge_map will map (u, v) to a tuple of the form (pos, ℓ), so that pos is the position of the edge in the boundary, and ℓ is the length of the boundary up to the edge. In particular, if get_boundary_edge_map(tri, u, v) == (pos, ℓ) and bn = get_boundary_nodes(tri, pos), then get_boundary_nodes(bn, ℓ) = u and get_boundary_nodes(bn, ℓ + 1) = v. For our triangulation, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_boundary_edge_map(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Since our domain has multiple curves, the pos values are Tuples of the form (m, n), where m is the curve and n is the section of that curve. So, for example, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"pos, ℓ = get_boundary_edge_map(tri, 913, 950)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This means that (913, 950) is the 37th edge of the first section on the third boundary:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"bn = get_boundary_nodes(tri, pos) # notice that we can pass Tuples (m, n) as a single argument\nget_boundary_nodes(bn, ℓ), get_boundary_nodes(bn, ℓ + 1)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For simpler domains, pos may be either a vector of vertices (in the case of a contiguous boundary) or a single vertex (in the case of a single boundary). For the contiguous case, we have:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"tri3 = triangulate_rectangle(0, 1, 0, 1, 10, 10, single_boundary = true) \nget_boundary_edge_map(tri3)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This may seem strange, but we note that get_boundary_nodes(tri, pos), when pos is a vector of vertices, just returns pos once again so that get_boundary_nodes(get_boundary_nodes(tri, pos), ℓ) == u is always true, regardless of the boundary type. For example:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"pos, ℓ = get_boundary_edge_map(tri3, 1, 2)\nbn = get_boundary_nodes(tri3, pos)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For the sectioned case, we have:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"tri4 = triangulate_rectangle(0, 1, 0, 1, 10, 10, single_boundary = false) \nget_boundary_edge_map(tri4)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"When there is no constrained boundary, the boundary edge map will be empty:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"tri5 = triangulate(rand(2, 50))\nget_boundary_edge_map(tri5)","category":"page"},{"location":"manual/triangulation_output/#[get_ghost_vertex_map(tri)](@ref-get_ghost_vertex_map)","page":"Triangulation Output","title":"get_ghost_vertex_map(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is used to identify to what curve and to what section a ghost vertex is associated. For example, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_map(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"We see, for example, that the ghost vertex -7 comes from the first section of the fifth boundary curve. In general, the mappings are of the form g => pos, where g is the ghost vertex and pos is such that get_boundary_nodes(tri, pos) is the boundary curve associated with g. For example, using map_ghost_vertex,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"pos = map_ghost_vertex(tri, -7)\nbn = get_boundary_nodes(tri, pos)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"The forms of pos for the case of a contiguous boundary, a sectioned boundary, and no boundary are the same as for get_boundary_edge_map. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_map(tri3) # contiguous","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_map(tri4) # sectioned","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_map(tri5) # no boundary","category":"page"},{"location":"manual/triangulation_output/#[get_ghost_vertex_ranges(tri)](@ref-get_ghost_vertex_ranges)","page":"Triangulation Output","title":"get_ghost_vertex_ranges(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is used to identify all the ghost vertices associated with a curve that has a specific ghost vertex. For example, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_ranges(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This output means, for example, that the ghost vertex -5 is associated with a curve that has both ghost vertices -6 and -5 associated with it. You would use get_ghost_vertex_range to get the range of ghost vertices associated with a specific ghost vertex. For example,","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_range(tri, -5)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"Similarly, the output for the contiguous, sectioned, and no boundary cases are","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_ranges(tri3) # contiguous","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_ranges(tri4) # sectioned","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_ghost_vertex_ranges(tri5) # no boundary","category":"page"},{"location":"manual/triangulation_output/#Other-Fields","page":"Triangulation Output","title":"Other Fields","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"There are some other more general fields to inspect.","category":"page"},{"location":"manual/triangulation_output/#[get_convex_hull(tri)](@ref-get_convex_hull)","page":"Triangulation Output","title":"get_convex_hull(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"For all triangulations, the convex_hull field stores the ConvexHull of the triangulation. For our triangulation, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_convex_hull(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"To inspect the vertices of the convex hull, you use get_convex_hull_vertices:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"get_convex_hull_vertices(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"If you ever need to reconstruct the convex hull, say after some dynamic updates, you would use convex_hull!.","category":"page"},{"location":"manual/triangulation_output/#[get_representative_point_list(tri)](@ref-get_representative_point_list)","page":"Triangulation Output","title":"get_representative_point_list(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is related to the need for a representative point for each curve, as described in the ghost vertices section. For our triangulation, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"DelaunayTriangulation.get_representative_point_list(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This shows, for example, that the sixth boundary curve's representative point, i.e. its pole of inaccessibility, is the point (0, -3). You could also review this using DelaunayTriangulation.get_representative_point_coordinates:","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"DelaunayTriangulation.get_representative_point_coordinates(tri, 6)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"In the case of a triangulation with no constrained boundary, the representative point list is simply the centroid of the domain. If you ever need to recompute the representative points, you need DelaunayTriangulation.compute_representative_points!.","category":"page"},{"location":"manual/triangulation_output/#[get_polygon_hierarchy(tri)](@ref-get_polygon_hierarchy)","page":"Triangulation Output","title":"get_polygon_hierarchy(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is used to store information about which boundary curves are contained in other boundary curves. For our triangulation, we have","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"DelaunayTriangulation.get_polygon_hierarchy(tri)","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is not intended for public use. One useful method that makes direct use of the polygon hierarchy is find_polygon, but the hierarchy's main use is in boundary enrichment for curve-bounded domains, and for checking arguments via check_args.","category":"page"},{"location":"manual/triangulation_output/#[boundary_enricher(tri)](@ref-get_boundary_enricher)","page":"Triangulation Output","title":"boundary_enricher(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field, just as for the polygon_hierarchy, is not intended for public use. It is the field used for enriching the boundary for initialising the triangulation of a curve-bounded domain. ","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"DelaunayTriangulation.get_boundary_enricher(tri)","category":"page"},{"location":"manual/triangulation_output/#[get_cache(tri)](@ref-get_cache)","page":"Triangulation Output","title":"get_cache(tri)","text":"","category":"section"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"This field is not intended for public use. It is used to provide several caches for use during triangulation, such as reusing arrays for constrained triangulations.","category":"page"},{"location":"manual/triangulation_output/","page":"Triangulation Output","title":"Triangulation Output","text":"DelaunayTriangulation.get_cache(tri)","category":"page"},{"location":"tutorials/convex_hull/#Convex-Hulls","page":"Convex Hulls","title":"Convex Hulls","text":"","category":"section"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"In this tutorial, we show how we can compute convex hulls. The main method for this is to compute them directly from the triangulation, noting that for an unconstrained triangulation the boundary is the convex hull. We also provide a method for computing the convex hull from the point set directly, using the monotone chain algorithm.","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"Let us first demonstrate how we compute convex hulls from a triangulation. This is only possible from triangulations without a constrained boundary","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"We construct a triangulation of a point set.","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"rng = StableRNG(123)\npoints = randn(rng, 2, 250)\ntri = triangulate(points; rng)","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"To get the convex hull, just use get_convex_hull:","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"get_convex_hull(tri)","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"You can also obtain the vertices directly from get_convex_hull_vertices:","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"get_convex_hull_vertices(tri)","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"The vertices refer to indices of points in points, and they are given in counter-clockwise order. To obtain the convex hull directly from the points without constructing the triangulation, use convex_hull:","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"ch = convex_hull(points)\nch_points = [get_point(tri, i) for i in DelaunayTriangulation.get_vertices(ch)]\nfig, ax, sc = lines(ch_points, color = :red, linewidth = 4)\nscatter!(ax, points)\nfig","category":"page"},{"location":"tutorials/convex_hull/#Just-the-code","page":"Convex Hulls","title":"Just the code","text":"","category":"section"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\nrng = StableRNG(123)\npoints = randn(rng, 2, 250)\ntri = triangulate(points; rng)\n\nget_convex_hull(tri)\n\nget_convex_hull_vertices(tri)\n\nch = convex_hull(points)\nch_points = [get_point(tri, i) for i in DelaunayTriangulation.get_vertices(ch)]\nfig, ax, sc = lines(ch_points, color = :red, linewidth = 4)\nscatter!(ax, points)\nfig","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"","category":"page"},{"location":"tutorials/convex_hull/","page":"Convex Hulls","title":"Convex Hulls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/primitives/#Representing-Primitives","page":"Representing Primitives","title":"Representing Primitives","text":"","category":"section"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"In this package, we need methods for representing points, edges, triangles, and boundaries. By default, we provide a simple interface for defining these primitives, typically treating these primitives as:","category":"page"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"Points: Vector{NTuple{2, Float64}} or Matrix{Float64}, where in the latter case points are defined by the columns of the matrix. Where mutability is needed, typically the former is preferred as an ElasticMatrix from ElasticMatrix.jl is needed if a matrix is used instead.\nEdges: Set{NTuple{2, Int}}.\nTriangles: Set{NTuple{3, Int}}.\nBoundaries: The recommended way to represent a boundary depends on the type, as described in the Representing Boundaries section. For a contiguous boundary, Vector{Int} is preferred; for a boundary with a single sectioned curve, Vector{Vector{Int}} is preferred; for a boundary with multiple disjoint sections, Vector{Vector{Vector{Int}}} is preferred.","category":"page"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"For defining new methods, as discussed in this tutorial and this API reference, there are many methods that could be overloaded. When defining these methods, though, there are some important things to consider:","category":"page"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"Points are constantly being accessed via index, so a vector-like structure is recommended, and fixed-size tuples (like Tuple or a SVector from StaticArrays.jl) are recommended for individual points. For mutability, e.g. in the case of refinement or translating points with centroidal Voronoi tessellations, you of course want a mutable structure.\nEdges and triangles are never accessed via index, so a vector-like structure is not needed. Instead, these collections are always being used for finding specific objects and for deleting/pushing objects, so a set-like structure is highly recommended. For individual edges and triangles, fixed-size tuples of length 2 and 3, respectively, are recommended.\nInt is recommended to be used for vertices, like in an edge or a triangle, and for coordinates Float64 is highly recommended. As discussed in the Geometrical Predicates section, the use of Float64 is important for the robustness of the algorithms in this package - using Float32 is highly likely to lead to errors or infinite loops in the algorithms; as of v1.1.0, the use of AdaptiveKernel() predicate kernel makes issues from Float32 less likely.","category":"page"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"Of course, how you implement the methods for your custom types comes down to what you need. ","category":"page"},{"location":"manual/primitives/","page":"Representing Primitives","title":"Representing Primitives","text":"For using these methods inside triangulate, you need to specify all types other than the point used for points, as described in its docstring.","category":"page"},{"location":"api/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"api/convex_hull/#DelaunayTriangulation.convex_hull","page":"Convex Hull","title":"DelaunayTriangulation.convex_hull","text":"convex_hull(points; predicates::AbstractPredicateKernel=AdaptiveKernel(), IntegerType::Type{I}=Int) where {I} -> ConvexHull\n\nComputes the convex hull of points. The monotone chain algorithm is used.\n\nArguments\n\npoints: The set of points.\n\nKeyword Arguments\n\nIntegerType=Int: The integer type to use for the vertices.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nch: The ConvexHull. \n\n\n\n\n\n","category":"function"},{"location":"api/convex_hull/#DelaunayTriangulation.convex_hull!","page":"Convex Hull","title":"DelaunayTriangulation.convex_hull!","text":"convex_hull!(tri::Triangulation; reconstruct=has_boundary_nodes(tri), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nUpdates the convex_hull field of tri to match the current triangulation. \n\nArguments\n\ntri::Triangulation: The Triangulation.\n\nKeyword Arguments\n\nreconstruct=has_boundary_nodes(tri): If true, then the convex hull is reconstructed from scratch, using convex_hull on the points. Otherwise,  computes the convex hull using the ghost triangles of tri. If there are no ghost triangles but reconstruct=true, then the convex hull is reconstructed from scratch.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\n\n\n\n\nconvex_hull!(ch::ConvexHull{P,I}; predicates::AbstractPredicateKernel=AdaptiveKernel()) where {P,I}\n\nUsing the points in ch, computes the convex hull in-place. \n\nThe predicates keyword argument determines how predicates are computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nSee also convex_hull.\n\n\n\n\n\n","category":"function"},{"location":"math/curve_bounded/#Triangulating-Curve-Bounded-Domains","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In this section, we discuss the mathematical details behind the triangulation of curve-bounded domains. The algorithm we implement for this is from the PhD thesis Delaunay Refinement Mesh Generation of Curve-bounded Domains by Serge Gosselin (2009). A basic description of the algorithm is as follows:","category":"page"},{"location":"math/curve_bounded/#Boundary-Enrichment","page":"Triangulating Curve-Bounded Domains","title":"Boundary Enrichment","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The first step of the algorithm is to obtain a piecewise linear approximation to the domain so that we obtain an initial triangulation. This approximation must have no intersecting edges so that we can compute a triangulation of the approximate domain. For this approximtaion, we need to also be careful about the resolution of the approximation: Too many points will greatly increase the number of triangles in the final mesh, but too few points could result in a poor approximation and cause difficulty when triangulating with overlapping curves.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The approach we take for obtaining this approximation is based on the total variation of the curve, as defined in the last section. Recall that this total variation helps describe how much a curve varies around an interval, and so we can use the total variation to determine how many points are needed to approximate the curve by straight edges. Using the total variation as a guide so that any subcurve has total variation less than pi2, we will be able to enrich the boundary, adding points until no edges contain any other boundary points inside their diametral circles. With this requirement, all boundary edges will satisfy the constrained Delaunay property, allowing us to obtain an initial triangulation.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"One difficulty with this approach is that finding all vertices inside a given edge's diametral circle is no longer as easy a task as it is for a triangulation, since we do not have any triangulation data structure to work with during this enrichment phase. To overcome this, we instead use an R-Tree tau. This is a spatial indexing tree that will allow us to efficiently compute intersections. Once we have found such a vertex v inside an edge e's diametral circle, we need to check if it is actually visible from e. Visibility will be blocked if there is a hole between v and e, or there are other segments between v and e such that a segment from any point e to the vertex would intersect with another segment.","category":"page"},{"location":"math/curve_bounded/#Testing-Visibility","page":"Triangulating Curve-Bounded Domains","title":"Testing Visibility","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Let us consider the problem of testing visibility between a vertex v and an edge e. One approach would be to take a small subset of points on the edge and simply test whether the line segment from v to each of these points intersects with any other segment, using the tree tau to compute these intersections. This would not be efficient, though, and might still miss eom intersections. Instead, it is actually sufficient to test visibility just from the endpoints of e. To understand why, suppose that v is not visible from e's endpoints but is visible from a point in e's interior. This would imply that there are other vertices located inside e's diametral circle. Since we split all edges that contain other vertices inside their diametral circles, these subcurves would eventually be split anyway, which is the same outcome as if we had currently declared v as visible to begin with. Thus, for testing visibility we simply check the endpoints.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The actual algorithm we use for testing this visibility is as follows, assuming that we have a point p_k inside an edge e_ij's diametral circle:","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"First, we check if there is a hole between p_k and e_ij that would occlude visibility. To check this, let C be the curve associated with e_ij, and compute the certificates s_c and s_e that give the positions of p_k relative to C and e_ij, respectively. If p_k is directly on e_ij, then this means that an endpoint of a boundary edge is directly on e_ij, and so we declare that p_k is visible from e_ij; if s_c neq s_e, then e_ij intersects another boundary edge with p_k as a vertex and so we declare that p_k is visible from e_ij; if p_k is right of C, then this means that c bounds a hole and so we declare that p_k is not visible from e_ij. Otherwise, we proceed onto the next step.\nWe now need to determine if p_k is visible from either of the endpoints of e_ij. We initialise the variables int1 = false and int2 = false. To efficiently compute the intersections, we compute the intersection of the bounding box B of T_ijk with the bounding boxes in the R-Tree tau (described in the algorithm for boundary enrichment later). Then, for each edge e_uv disjoint from e_ij in the set of intersections, we set int1 = true if e_uv insteads e_ik and int2 = true if e_uv intersects e_jk. If ever int1 and int2 are both true, then we declare that p_k is not visible from e_ij. Otherwise, if after processing all intersections either int1 or int2 is false, then we declare that p_k is visible from e_ij.","category":"page"},{"location":"math/curve_bounded/#Splitting-a-Subcurve","page":"Triangulating Curve-Bounded Domains","title":"Splitting a Subcurve","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Once we have determined that an edge e_ij needs to be split, we need to determine where to place the split point. This point cannot just be, for example, (p_i + p_j)  2, since that might not lie on e_ij's parent curve C. Instead, we use the equivariation split of the subcurve between p_i and p_j, so that TV(t_1 t^*) = TV(t^* t_2) = TV(t_1 t_2)  2, where t_1 and t_2 are the parameters corresponding to p_i and p_j, respectively, and t^* is the parameter corresponding to the split point. This split point will be the new vertex that we add to the triangulation, provided there are no issues related to small angles like those we discuss below.","category":"page"},{"location":"math/curve_bounded/#Small-Angle-Complexes","page":"Triangulating Curve-Bounded Domains","title":"Small Angle Complexes","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"For discussing boundary enrichment, we also need to handle small angles between curves. We that an input angle between two curves is small if it is less than pi3. Any curves where the angle between them is small must be protected and handled appropriately during enrichment. For this, we define a small angle complex Sigma to be a set of subcurves having a common apex vertex as an endpoint and forming contiguous small angles at this apex vertex. ","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"fig # hide","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In the figure above, we show an example of a set of subcurves s_1 s_2 s_3 s_4 s_5 s_6 together with a common apex vertex. We see that the curve s_1 forms no small angle with any other curve, and so it is not a part of any small angle complex. The curves s_2 s_3 s_4 together form a small angle complex since they form a contiguous set of small angles. The curve s_5 is not included in this complex since the angle between s_4 and s_5 is not small. Lastly, the curves s_5 s_6 define a small angle complex. See that it is possible for a single apex vertex to define several separate small angle complexes.","category":"page"},{"location":"math/curve_bounded/#Locally-Small-Angles","page":"Triangulating Curve-Bounded Domains","title":"Locally Small Angles","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In addition to handling small angle complexes, we also want to handle small angles that are locally acute, meaning that the angle between two segments is small. These are local checks since the curves associated with these edges might not define actually small angle at this point. We include these checks though to ensure that the enrichment phase cannot get stuck by any missed small angles.","category":"page"},{"location":"math/curve_bounded/#Splitting-Subcurves-Near-Small-Angles","page":"Triangulating Curve-Bounded Domains","title":"Splitting Subcurves Near Small Angles","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Now let's discuss how we split subcurves near small angles. Let's first discuss the case where the subcurve is not part of a small angle complex. If there are no neighbouring acute angles to the edge e_ij associated with the subcurve s_ij, letting s_ij be the part of the parent curve C between p_i and p_j, then we just use an equivariation split. Otherwise, the split position depends on whether there are one or two neighbouring acute angles. The rule that we apply is the same as used for mesh refinement of piecewise linear bounaries as described here. The only difference is that the split position we compute is based on the intersection of the concentric circular shell with the subcurve itself instead of with e_ij.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The main difficulty to work through is the splitting of a subcurve belonging to a small angle complex. Suppose s_ij belongs to a small angle complex Sigma comprised of subcurves s_1 ldots s_m. We define the maximum split radius r_max = 2ell_min3, where ell_min is the length of the shortest boundary edge approximating a subcurve of Sigma. The biggest power of two less than r_max is then chosen to be the radius of the concentric circular shell to place the new vertex onto, meaning the radius of the shell is r_s = 2^k where k = lfloor log_2(r_max) rfloor. Then, for each subcurve s_i, we compute the intersection of this shell, centered at the apex of Sigma, with s_i closest to the apex and place the new vertex there. We show an example of this below, where we are considering splitting a subcurve in the complex Sigma defined by s_2 s_3 s_4.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"fig # hide","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"In the above figure, the subcurves of interest are the subcures defined by the curves from a to each of the first blue points on each curve. These blue points and lines shows the piecewise linear approximation to each subcurve. The shortest edge length is then used to compute r_max, giving the circle shown in red. The shell with radius 2^lfloor log_2 r_maxrfloor is shown in green. We then split each of the subcurves at their intersection with this green curve, giving the points shown in green and the updated piecewise linear approximation in the second figure. All subsequent splits of these subcurves (those between a and the new split points) will be at the next smaller power of two shell, i.e. 2^lfloor log_2 r_max rfloor - 1.","category":"page"},{"location":"math/curve_bounded/#Enriching-the-Boundary","page":"Triangulating Curve-Bounded Domains","title":"Enriching the Boundary","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Now we can finally discuss the full algorithm for enriching the boundary to prepare for triangulation. We describe these steps one at a time. We assume that all the small angle complexes have already been computed. Moreover, while our discussion thus far has not included the possibility of interior segments, simple modifications to the steps below and the details above could be made to handle them. We do not discuss interior segments here.","category":"page"},{"location":"math/curve_bounded/#Coarse-discretisation","page":"Triangulating Curve-Bounded Domains","title":"Coarse discretisation","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The first step is to obtain a coarse discretisation of the boundary. For each curve, we compute a coarse discretisation by, starting with the two endpoints, computing equivariation curves between each pair of points until the total variation across any subcurve is less than pi2. In this package this is the default, but we also provide an option to simply add a specified number of equivariation splits rather than taking care of the total variation.","category":"page"},{"location":"math/curve_bounded/#Spatial-indexing","page":"Triangulating Curve-Bounded Domains","title":"Spatial indexing","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"We then compute the R-Tree used for computing intersections. The R-Tree is initialised by inserting into it the axis-aligned bounding box of each segment's diametral circle in the coarse discretisation.","category":"page"},{"location":"math/curve_bounded/#Queueing-vertices","page":"Triangulating Curve-Bounded Domains","title":"Queueing vertices","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"To determine the order in which to process vertices in the provided vertex set mathcal P, we use a queue. This is a simple FIFO queue, i.e. just a vector, that we initialise with mathcal Q = mathcal P. We then process the vertices in the order they were added to the queue.","category":"page"},{"location":"math/curve_bounded/#Enrichment","page":"Triangulating Curve-Bounded Domains","title":"Enrichment","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"We are now ready to actually being enriching. The idea is to process each vertex in the queue, adding new vertices as needed, and then stop once the queue is empty. So, let us suppose that mathcal Q is not empty and dequeue a point p_i from mathcal Q. We then compute the intersection of p_i with the R-Tree tau, returning the set of all edges whose diametral circle's bounding box contains p_i. We then need to process each edge e_uv in this set.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"For this edge e_uv, we only need to consider processing it if p_i is in its diametral circle and is visible from p_i. If this is not the case, we can continue onto the next edge e_uv onto the next set or dequeue another point. Otherwise, we split the subcurve associated with e_uv as described previously, ensuring we take care of small angles and small angle complexes. The point p_i gets enqueued back into mathcal Q, and when we split the subcurve we (1) delete e_uv from tau and add back in the two new segments and (2) enqueue the newly added point into mathcal Q.","category":"page"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"The above iterative procedure continues until mathcal Q is empty. Once it is, we will have obtained a piecewise linear approximation to the boundary that satisfies the constrained Delaunay property. We can then proceed to compute the Delaunay triangulation of the boundary as usual.","category":"page"},{"location":"math/curve_bounded/#Mesh-Refinement","page":"Triangulating Curve-Bounded Domains","title":"Mesh Refinement","text":"","category":"section"},{"location":"math/curve_bounded/","page":"Triangulating Curve-Bounded Domains","title":"Triangulating Curve-Bounded Domains","text":"Once we have obtained the initial triangulation of the boundary, we can then refine the mesh to obtain a higher-quality mesh. The algorithm for this is reasonably straightforward. We use the existing algorithm for mesh refinement as discussed previously, but when splitting the encroached segments we use the same method for splitting a subcurve as was used during enrichment.","category":"page"},{"location":"api/primitives/#Primitive-Interfaces","page":"Primitive Interfaces","title":"Primitive Interfaces","text":"","category":"section"},{"location":"api/primitives/#Points","page":"Primitive Interfaces","title":"Points","text":"","category":"section"},{"location":"api/primitives/#DelaunayTriangulation.getx","page":"Primitive Interfaces","title":"DelaunayTriangulation.getx","text":"getx(c::RepresentativeCoordinates) -> Number\n\nReturns the x-coordinate of c.\n\n\n\n\n\ngetx(c::Cell) -> Number\n\nReturns the x-coordinate of c.\n\n\n\n\n\ngetx(p) -> Number\n\nGet the x-coordinate of p.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.3, 0.7);\n\njulia> getx(p)\n0.3\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.gety","page":"Primitive Interfaces","title":"DelaunayTriangulation.gety","text":"gety(c::RepresentativeCoordinates) -> Number\n\nReturns the y-coordinate of c.\n\n\n\n\n\ngety(c::Cell) -> Number\n\nReturns the y-coordinate of c.\n\n\n\n\n\ngety(p) -> Number\n\nGet the y-coordinate of p.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = (0.9, 1.3);\n\njulia> gety(p)\n1.3\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.getxy","page":"Primitive Interfaces","title":"DelaunayTriangulation.getxy","text":"getxy(p) -> NTuple{2, Number}\n\nGet the coordinates of p as a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> p = [0.9, 23.8];\n\njulia> getxy(p)\n(0.9, 23.8)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.is_point2","page":"Primitive Interfaces","title":"DelaunayTriangulation.is_point2","text":"is_point2(p) -> Bool\n\nTests if p represents a point in the plane. By default, this returns the result of \n\neltype(p) <: Number && length(p) == 2\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.getpoint","page":"Primitive Interfaces","title":"DelaunayTriangulation.getpoint","text":"getpoint(points, vertex) -> NTuple{2, Number}\n\nGet the point associated with vertex in points, returned as a Tuple of the coordinates.  If vertex is not an integer, then vertex is returned so that points and vertices can be easily mixed.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(0.3, 0.7), (1.3, 5.0), (5.0, 17.0)];\n\njulia> DelaunayTriangulation.getpoint(points, 2)\n(1.3, 5.0)\n\njulia> points = [0.3 1.3 5.0; 0.7 5.0 17.0];\n\njulia> DelaunayTriangulation.getpoint(points, 2)\n(1.3, 5.0)\n\njulia> DelaunayTriangulation.getpoint(points, (17.3, 33.0))\n(17.3, 33.0)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.get_point","page":"Primitive Interfaces","title":"DelaunayTriangulation.get_point","text":"get_point(points, vertices...) -> NTuple{length(vertices), NTuple{2, Number}}\n\nGet the points associated with vertices in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0)];\n\njulia> get_point(points, 1)\n(1.0, 2.0)\n\njulia> get_point(points, 1, 2, 3, 4)\n((1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0))\n\njulia> points = [1.0 3.0 1.7 -5.0; 2.0 5.5 10.3 0.0];\n\njulia> get_point(points, 1)\n(1.0, 2.0)\n\njulia> get_point(points, 1, 2, 3, 4)\n((1.0, 2.0), (3.0, 5.5), (1.7, 10.3), (-5.0, 0.0))\n\njulia> typeof(ans)\nNTuple{4, Tuple{Float64, Float64}}\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.push_point!","page":"Primitive Interfaces","title":"DelaunayTriangulation.push_point!","text":"push_point!(points, x, y)\npush_point!(points, p) = push_point!(points, getx(p), gety(p))\n\nPushes the point p = (x, y) into points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 3.0), (5.0, 1.0)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n\njulia> DelaunayTriangulation.push_point!(points, 2.3, 5.3)\n3-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n (2.3, 5.3)\n\njulia> DelaunayTriangulation.push_point!(points, (17.3, 5.0))\n4-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 1.0)\n (2.3, 5.3)\n (17.3, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.pop_point!","page":"Primitive Interfaces","title":"DelaunayTriangulation.pop_point!","text":"pop_point!(points)\n\nPops the last point from points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 2.0), (1.3, 5.3)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (1.3, 5.3)\n\njulia> DelaunayTriangulation.pop_point!(points) # returns the popped vector\n(1.3, 5.3)\n\njulia> points\n1-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.set_point!","page":"Primitive Interfaces","title":"DelaunayTriangulation.set_point!","text":"set_point!(points, i, x, y)\nset_point!(points, i, p) = set_point!(points, i, getx(p), gety(p))\n\nSets the point at index i in points to (x, y).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 3.0), (5.0, 17.0)]\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 3.0)\n (5.0, 17.0)\n\njulia> DelaunayTriangulation.set_point!(points, 1, 0.0, 0.0)\n(0.0, 0.0)\n\njulia> points\n2-element Vector{Tuple{Float64, Float64}}:\n (0.0, 0.0)\n (5.0, 17.0)\n\njulia> points = [1.0 2.0 3.0; 4.0 5.0 6.0]\n2×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n\njulia> DelaunayTriangulation.set_point!(points, 2, (17.3, 0.0))\n2-element view(::Matrix{Float64}, :, 2) with eltype Float64:\n 17.3\n  0.0\n\njulia> points\n2×3 Matrix{Float64}:\n 1.0  17.3  3.0\n 4.0   0.0  6.0\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.is_planar","page":"Primitive Interfaces","title":"DelaunayTriangulation.is_planar","text":"is_planar(points) -> Bool\n\nReturns true if all points in points are two-dimensional. The default definition is simply  all(is_point2, each_point(points)).\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#Edges","page":"Primitive Interfaces","title":"Edges","text":"","category":"section"},{"location":"api/primitives/#DelaunayTriangulation.construct_edge","page":"Primitive Interfaces","title":"DelaunayTriangulation.construct_edge","text":"construct_edge(::Type{E}, i, j) where {E} -> E\n\nConstruct an edge of type E from vertices i and j.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.construct_edge(NTuple{2,Int}, 2, 5)\n(2, 5)\n\njulia> DelaunayTriangulation.construct_edge(Vector{Int32}, 5, 15)\n2-element Vector{Int32}:\n  5\n 15\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.initial","page":"Primitive Interfaces","title":"DelaunayTriangulation.initial","text":"initial(e) -> Vertex\n\nGet the initial vertex of e.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 3);\n\njulia> DelaunayTriangulation.initial(e)\n1\n\njulia> e = [2, 5];\n\njulia> DelaunayTriangulation.initial(e)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.terminal","page":"Primitive Interfaces","title":"DelaunayTriangulation.terminal","text":"terminal(e) -> Vertex\n\nGet the terminal vertex of e.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 7);\n\njulia> DelaunayTriangulation.terminal(e)\n7\n\njulia> e = [2, 13];\n\njulia> DelaunayTriangulation.terminal(e)\n13\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.edge_vertices","page":"Primitive Interfaces","title":"DelaunayTriangulation.edge_vertices","text":"edge_vertices(e) -> NTuple{2, Vertex}\n\nGet the vertices of e\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (1, 5);\n\njulia> edge_vertices(e)\n(1, 5)\n\njulia> e = [23, 50];\n\njulia> edge_vertices(e)\n(23, 50)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.reverse_edge","page":"Primitive Interfaces","title":"DelaunayTriangulation.reverse_edge","text":"reverse_edge(e) -> Edge\n\nGet the edge with the vertices of e in reverse order.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = (17, 3);\n\njulia> DelaunayTriangulation.reverse_edge(e)\n(3, 17)\n\njulia> e = [1, 2];\n\njulia> DelaunayTriangulation.reverse_edge(e)\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.compare_unoriented_edges","page":"Primitive Interfaces","title":"DelaunayTriangulation.compare_unoriented_edges","text":"compare_unoriented_edges(u, v) -> Bool\n\nCompare the unoriented edges u and v, i.e. compare the vertices of u and v in any order.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> u = (1, 3);\n\njulia> v = (5, 3);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\nfalse\n\njulia> v = (1, 3);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\ntrue\n\njulia> v = (3, 1);\n\njulia> DelaunayTriangulation.compare_unoriented_edges(u, v)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.edge_type","page":"Primitive Interfaces","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing individual edges in tri.\n\n\n\n\n\nedge_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing individual edges in the Voronoi tessellation.\n\n\n\n\n\nedge_type(E) -> DataType\n\nGet the type of edges in E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e = Set(((1,2),(2,3),(17,5)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (17, 5)\n  (2, 3)\n\njulia> DelaunayTriangulation.edge_type(e)\nTuple{Int64, Int64}\n\njulia> e = [[1,2],[3,4],[17,3]]\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n [17, 3]\n\njulia> DelaunayTriangulation.edge_type(e)\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.contains_edge","page":"Primitive Interfaces","title":"DelaunayTriangulation.contains_edge","text":"contains_edge(i, j, E) -> Bool\ncontains_edge(e, E) -> Bool\n\nCheck if E contains the edge e = (i, j).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1,3),(17,3),(1,-1)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, -1)\n  (17, 3)\n  (1, 3)\n\njulia> DelaunayTriangulation.contains_edge((1, 2), E)\nfalse\n\njulia> DelaunayTriangulation.contains_edge((17, 3), E)\ntrue\n\njulia> DelaunayTriangulation.contains_edge(3, 17, E) # order\nfalse\n\njulia> E = [[1,2],[5,13],[-1,1]]\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [5, 13]\n [-1, 1]\n\njulia> DelaunayTriangulation.contains_edge(1, 2, E)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.contains_unoriented_edge","page":"Primitive Interfaces","title":"DelaunayTriangulation.contains_unoriented_edge","text":"contains_unoriented_edge(e, E) -> Bool\n\nCheck if E contains the unoriented edge e, i.e. check if E contains the edge e or reverse_edge(e).\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.add_to_edges!","page":"Primitive Interfaces","title":"DelaunayTriangulation.add_to_edges!","text":"add_to_edges!(E, e)\n\nAdd the edge e to E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(((1, 2),(3,5)))\nSet{Tuple{Int64, Int64}} with 2 elements:\n  (1, 2)\n  (3, 5)\n\njulia> DelaunayTriangulation.add_to_edges!(E, (1, 5))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (3, 5)\n  (1, 5)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.delete_from_edges!","page":"Primitive Interfaces","title":"DelaunayTriangulation.delete_from_edges!","text":"delete_from_edges!(E, e)\n\nDelete the edge e from E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> E = Set(([1,2],[5,15],[17,10],[5,-1]))\nSet{Vector{Int64}} with 4 elements:\n  [17, 10]\n  [5, 15]\n  [5, -1]\n  [1, 2]\n\njulia> DelaunayTriangulation.delete_from_edges!(E, [5, 15])\nSet{Vector{Int64}} with 3 elements:\n  [17, 10]\n  [5, -1]\n  [1, 2]\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.delete_unoriented_edge!","page":"Primitive Interfaces","title":"DelaunayTriangulation.delete_unoriented_edge!","text":"delete_unoriented_edge!(E, e)\n\nDelete the unoriented edge e from E, i.e. delete both the edge e and reverse_edge(e).\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.random_edge","page":"Primitive Interfaces","title":"DelaunayTriangulation.random_edge","text":"random_edge([rng], E) -> E\n\nGet a random edge from E.\n\nExamples\n\njulia> using DelaunayTriangulation, StableRNGs\n\njulia> E = Set(((1,2),(10,15),(23,20)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (23, 20)\n  (10, 15)\n\njulia> rng = StableRNG(123);\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(10, 15)\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(10, 15)\n\njulia> DelaunayTriangulation.random_edge(rng, E)\n(23, 20)\n\njulia> DelaunayTriangulation.random_edge(E)\n(1, 2)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.edges_are_disjoint","page":"Primitive Interfaces","title":"DelaunayTriangulation.edges_are_disjoint","text":"edges_are_disjoint(e, e′) -> Bool\n\nReturns true if e and e′ have any shared vertex, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#Triangles","page":"Primitive Interfaces","title":"Triangles","text":"","category":"section"},{"location":"api/primitives/#DelaunayTriangulation.construct_triangle","page":"Primitive Interfaces","title":"DelaunayTriangulation.construct_triangle","text":"construct_triangle(::Type{T}, i, j, k) where {T} -> Triangle\n\nConstruct a triangle of type T from vertices i, j, and k.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.construct_triangle(NTuple{3,Int}, 1, 2, 3)\n(1, 2, 3)\n\njulia> DelaunayTriangulation.construct_triangle(Vector{Int32}, 1, 2, 3)\n3-element Vector{Int32}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.geti","page":"Primitive Interfaces","title":"DelaunayTriangulation.geti","text":"geti(T) -> Vertex\n\nGet the first vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.geti((1, 2, 3))\n1\n\njulia> DelaunayTriangulation.geti([2, 5, 1])\n2\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.getj","page":"Primitive Interfaces","title":"DelaunayTriangulation.getj","text":"getj(T) -> Vertex\n\nGet the second vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.getj((5, 6, 13))\n6\n\njulia> DelaunayTriangulation.getj([10, 19, 21])\n19\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.getk","page":"Primitive Interfaces","title":"DelaunayTriangulation.getk","text":"getk(T) -> Vertex\n\nGet the third vertex of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.getk((1,2,3))\n3\n\njulia> DelaunayTriangulation.getk([1,2,3])\n3\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.triangle_vertices","page":"Primitive Interfaces","title":"DelaunayTriangulation.triangle_vertices","text":"triangle_vertices(T) -> NTuple{3, Vertex}\n\nReturns the vertices of T as a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> triangle_vertices((1, 5, 17))\n(1, 5, 17)\n\njulia> triangle_vertices([5, 18, 23]) # -> tuple\n(5, 18, 23)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.triangle_type","page":"Primitive Interfaces","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation) -> DataType\n\nReturns the type used for representing individual triangles in tri.\n\n\n\n\n\ntriangle_type(::InsertionEventHistory{T}) where {T} = T\n\nReturns the type of the triangles in events, T.\n\n\n\n\n\ntriangle_type(vorn::VoronoiTessellation) -> DataType\n\nType used for representing individual triangles in the Voronoi tessellation.\n\n\n\n\n\ntriangle_type(::Type{T}) -> DataType\n\nGet the triangle type of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.triangle_type(Set{NTuple{3,Int64}})\nTuple{Int64, Int64, Int64}\n\njulia> DelaunayTriangulation.triangle_type(Vector{NTuple{3,Int32}})\nTuple{Int32, Int32, Int32}\n\njulia> DelaunayTriangulation.triangle_type(Vector{Vector{Int64}})\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.triangle_edges","page":"Primitive Interfaces","title":"DelaunayTriangulation.triangle_edges","text":"triangle_edges(T) -> NTuple{3, Edge}\ntriangle_edges(i, j, k) -> NTuple{3, Edge}\n\nGet the edges of T = (i, j, k) as a Tuple, in particular \n\n((i, j), (j, k), (k, i)).\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = (1, 2, 3);\n\njulia> DelaunayTriangulation.triangle_edges(T)\n((1, 2), (2, 3), (3, 1))\n\njulia> DelaunayTriangulation.triangle_edges(1, 2, 3)\n((1, 2), (2, 3), (3, 1))\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.sort_triangle","page":"Primitive Interfaces","title":"DelaunayTriangulation.sort_triangle","text":"sort_triangle(T) -> Triangle\nsort_triangle(i, j, k) -> Triangle\n\nSort the triangle T = (i, j, k) so that its last vertex is the smallest,  respecting the orientation of T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.sort_triangle((1, 5, 3))\n(5, 3, 1)\n\njulia> DelaunayTriangulation.sort_triangle((1, -1, 2))\n(2, 1, -1)\n\njulia> DelaunayTriangulation.sort_triangle((3, 2, 1))\n(3, 2, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.compare_triangles","page":"Primitive Interfaces","title":"DelaunayTriangulation.compare_triangles","text":"compare_triangles(T, V) -> Bool\n\nCompare the triangles T and V by comparing their vertices up to rotation.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T1 = (1, 5, 10);\n\njulia> T2 = (17, 23, 20);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\nfalse\n\njulia> T2 = (5, 10, 1);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\ntrue\n\njulia> T2 = (10, 1, 5);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\ntrue\n\njulia> T2 = (10, 5, 1);\n\njulia> DelaunayTriangulation.compare_triangles(T1, T2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.add_to_triangles!","page":"Primitive Interfaces","title":"DelaunayTriangulation.add_to_triangles!","text":"add_to_triangles!(T, V)\n\nAdd the triangle V to the collection of triangles T.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> T = Set(((1, 2, 3), (17, 8, 9)));\n\njulia> DelaunayTriangulation.add_to_triangles!(T, (1, 5, 12))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (1, 5, 12)\n  (1, 2, 3)\n  (17, 8, 9)\n\njulia> DelaunayTriangulation.add_to_triangles!(T, (-1, 3, 6))\nSet{Tuple{Int64, Int64, Int64}} with 4 elements:\n  (1, 5, 12)\n  (1, 2, 3)\n  (17, 8, 9)\n  (-1, 3, 6)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.delete_from_triangles!","page":"Primitive Interfaces","title":"DelaunayTriangulation.delete_from_triangles!","text":"delete_from_triangles!(T, V)\n\nDelete the triangle V from the collection of triangles T. Only deletes V if V is in T up to rotation.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)))\nSet{Tuple{Int64, Int64, Int64}} with 3 elements:\n  (7, 8, 9)\n  (4, 5, 6)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.delete_from_triangles!(V, (4, 5, 6))\nSet{Tuple{Int64, Int64, Int64}} with 2 elements:\n  (7, 8, 9)\n  (1, 2, 3)\n\njulia> DelaunayTriangulation.delete_from_triangles!(V, (9, 7, 8))\nSet{Tuple{Int64, Int64, Int64}} with 1 element:\n  (1, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#Boundary-Nodes","page":"Primitive Interfaces","title":"Boundary Nodes","text":"","category":"section"},{"location":"api/primitives/#DelaunayTriangulation.num_boundary_edges","page":"Primitive Interfaces","title":"DelaunayTriangulation.num_boundary_edges","text":"num_boundary_edges(boundary_nodes) -> Integer\n\nGet the number of boundary edges in boundary_nodes, assuming that boundary_nodes defines a  boundary with only one curve and a single section.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#DelaunayTriangulation.each_boundary_node","page":"Primitive Interfaces","title":"DelaunayTriangulation.each_boundary_node","text":"each_boundary_node(boundary_nodes) -> Iterator\n\nReturns an iterator that goves over each node in boundary_nodes. It is assumed that boundary_nodes represents a single section or a single contiguous boundary; if you do want to loop over every boundary nodes for a boundary  with multiple sections, you should to see the result from construct_ghost_vertex_map.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.each_boundary_node([7, 8, 19, 2, 17])\n5-element Vector{Int64}:\n  7\n  8\n 19\n  2\n 17\n\njulia> DelaunayTriangulation.each_boundary_node([7, 8, 19, 2, 17, 7])\n6-element Vector{Int64}:\n  7\n  8\n 19\n  2\n 17\n  7\n\n\n\n\n\n","category":"function"},{"location":"math/voronoi/#Voronoi-Tessellations","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"","category":"section"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Now we discuss Voronoi tessellations, the dual graph to a Delaunay triangulation. To define the Voronoi tessellation, let us first define a Voronoi polygon relative to a point set mathcal P. A Voronoi polygon mathcal V_i of a generator v_i is defined by ","category":"page"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"mathcal V_i = p in mathbb R^2  forall q in mathcal P p - p_i leq q - p","category":"page"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"meaning the polygon is the set of points at least as close to the generator v_i as to any other point in mathcal P. A Voronoi tessellation, then, denoted mathcal V(mathcal P), is the union of all Voronoi polygons of each generator p in mathcal P and their boundaries.","category":"page"},{"location":"math/voronoi/#Duality","page":"Voronoi Tessellations","title":"Duality","text":"","category":"section"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Let us first prove that the Delaunay triangulation and the Voronoi tessellation are duals of each other. To do this, we need to recognise that any point that is equidistant from three generators must be in a corner of the Voronoi diagram where three Voronoi polygons meet. Mathematically, this means that a point q equidistant from generators p_i, p_j, and p_k can be written as q = mathcal V_i cap mathcal V_j cap mathcal V_k. With this fact in mind, let us consider a triangle T_ijk in mathcal Dmathcal T(mathcal P). By the Delaunay property, we know that there are no points in mathcal P inside the circumcircle of T_ijk. We can thus uniquely (assuming there are no cocircular vertices) associate each T_ijk with its circumcenter, which by definition is equidistant from the three vertices of T_ijk. This circumcenter is therefore the corner of three Voronoi polygons.","category":"page"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"To understand why this proves duality, notice that this implies that the Voronoi tessellation can be exactly reconstructed by simply connecting all the circumcenters of the Delaunay triangles. Whenever the triangle is on the boundary of the triangulation, the unbounded Voronoi edge simply comes from the perpendicular bisector of the edge of the triangle on the boundary. ","category":"page"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"An example of this duality is shown below.","category":"page"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/voronoi/#Computation","page":"Voronoi Tessellations","title":"Computation","text":"","category":"section"},{"location":"math/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The above proof of duality gives a simple algorithm for constructing the Voronoi tessellation mathcal V(mathcal P). First, we compute mathcal Dmathcal T(mathcal P). Next, compute the circumcenter of each T_ijk in mathcal Dmathcal T(mathcal P) and draw a line between any two circumcenters whose triangles share an edge. If the triangle is on the boundary of the triangulation, the unbounded Voronoi edge simply comes from the perpendicular bisector of the edge of the triangle on the boundary. Care does need to be taken for cocircular vertices since in that case there is only one circumcenter for multiple triangles, avoiding drawing duplicate lines.","category":"page"},{"location":"tutorials/constrained_edges/#Constrained-Triangulations","page":"Constrained Edges","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tutorials/constrained_edges/#Constrained-Segments","page":"Constrained Edges","title":"Constrained Segments","text":"","category":"section"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"In this tutorial, we introduce constrained triangulations, starting with the simple case of only having constrained segments, meaning edges that are forced to be in the final triangulation. To start, let us load in the packages we will need.","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"We consider triangulating the following set of points:","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"a = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"To now define the segments, we define:","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"C = Set([(2, 1), (2, 11), (2, 7), (2, 5)])","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"With this notation, each Tuple is an individual edge to include in the triangulation, with (i, j) meaning the edge connecting the points pts[i] and pts[j] together. Let us now make the triangulation, comparing it to its unconstrained counterpart.","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"tri = triangulate(pts)","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"cons_tri = triangulate(pts; segments = C)","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"fig = Figure()\nax1 = Axis(\n    fig[1, 1], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(a): Unconstrained\", titlealign = :left,\n    width = 300, height = 300,\n)\nax2 = Axis(\n    fig[1, 2], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(b): Constrained\", titlealign = :left,\n    width = 300, height = 300,\n)\ntriplot!(ax1, tri)\ntriplot!(ax2, cons_tri, show_constrained_edges = true)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"As you can see, the constrained edges in magenta have now been included in the triangulation in (b), whereas in (a) most were previously not included.","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"You can view the constrained edges by using","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"get_interior_segments(cons_tri)","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"There is also a function get_all_segments, which in this case is the same as get_interior_segments, but in the case of a triangulation with constrained boundaries, it will also include the boundary segments whereas get_interior_segments will not; this is demonstrated in the later tutorials.","category":"page"},{"location":"tutorials/constrained_edges/#Just-the-code","page":"Constrained Edges","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"using DelaunayTriangulation\nusing CairoMakie\n\na = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]\n\nC = Set([(2, 1), (2, 11), (2, 7), (2, 5)])\n\ntri = triangulate(pts)\n\ncons_tri = triangulate(pts; segments = C)\n\nfig = Figure()\nax1 = Axis(\n    fig[1, 1], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(a): Unconstrained\", titlealign = :left,\n    width = 300, height = 300,\n)\nax2 = Axis(\n    fig[1, 2], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(b): Constrained\", titlealign = :left,\n    width = 300, height = 300,\n)\ntriplot!(ax1, tri)\ntriplot!(ax2, cons_tri, show_constrained_edges = true)\nresize_to_layout!(fig)\nfig\n\nget_interior_segments(cons_tri)","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"","category":"page"},{"location":"tutorials/constrained_edges/","page":"Constrained Edges","title":"Constrained Edges","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"This section presents a series of basic tutorials. The point of these tutorials is to give a quick overview of how many applications can be performed, rather than providing a detailed introduction into how the package works and, for example, what inputs each important function takes. See the later sections in the sidebar for more detail than what we give here, and the introduction for a description of each other section. More complicated applications of how this package can be used are given in the Example Applications section.","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"In the tutorials, we make consistent use of the package StableRNGs.jl to make the random results reproducible across Julia versions. In practice, you could either","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"Just ignore worrying about the random number generation entirely,\nDo something like Random.seed!(seed) (after doing using Random).","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"The first option is fine for most applications where the points sets are in general position (meaning no four points are collinear), and the second result is fine and easier to apply more generally.","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"Lastly, in all but one of the tutorials we consider only a basic interface for defining the geometric primitives, e.g. matrices or vectors for points and sets for edges. This interface is customisable, as described in Representing Primitives and Representing Boundaries (with the API defined in Primitive Interfaces). The last tutorial will demonstrate how to use custom structs for  representing these primitives.","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"The tutorials that we consider are as follows:","category":"page"},{"location":"tutorials/overview/","page":"Overview","title":"Overview","text":"Unconstrained Triangulations: How Delaunay triangulations can be computed and accessed. We also give examples here of how we iterate over the triangulation's vertices, edges, and triangles, some warnings about having to be careful about ghost objects defined in the manual, and how to query neighbour information.\nConstrained Triangulations: How constrained Delaunay triangulations can be computed, and how different types of boundaries can be represented for triangulating. This tutorial is broken into multiple sub-tutorials, starting with considering constrained segments and ending with considering multipolygons.\nTriangulation Operations: How certain operations such as vertex insertion and deletion can be applied to an existing triangulation. This tutorial is broken into multiple sub-tutorials, demonstrating the multiple operations available for use, starting with vertex insertion and deletion.\nMesh Refinement: How triangulations can be refined to meet certain quality constraints.\nTriangulating Rectangular Regions: A simple example of how rectangular regions in the plane can be triangulated quickly.\nTriangulating Convex Polygons: How triangulations of convex polygons can be computed.\nTriangulation Curve-Bounded Domains: How triangulations of curve-bounded domains can be computed.\nWeighted Triangulations: How weighted Delaunay triangulations can be computed.\nVoronoi Tessellations: How Voronoi tessellations can be computed. We also give examples of how you can iterate over the edges and generators in the tessellation, and other features.\nClipped Voronoi Tessellations: How to compute a Voronoi tessellation of a point set such that the polygons are clipped to the point set's convex hull, or to an arbitrary rectangle. We also show how to more generally clip Voronoi tessellations to a generic convex polygon.\nCentroidal Voronoi Tessellation: How to compute centroidal Voronoi tessellations, in particular how to shift a given set of points so that each point's associated Voronoi tile is that tile's centroid.\nPower Diagrams: How to compute power diagrams, the dual of the weighted Delaunay triangulation.\nPoint Location: How to use a triangulation to perform point location.\nNearest Neighbour Queries: How to use a Voronoi tessellation to find a point's nearest neighbour.\nConvex Hulls: How to compute a convex hull of a point set, using either an existing triangulation or from scratch.\nPole of Inaccessibility: How to compute the pole of inaccessibility of a polygon, also considering cases of multipolygons (polygons composed of multiple disjoint polygons) and multiply-connected polygons.\nPoint-in-Polygon Testing: How to perform point-in-polygon testing. The method we give is obviously not going to be the fastest out of all available methods, but the algorithms in this package naturally provide a nice reasonably fast way to do this testing.\nUsing Custom Structs for Primitives and Boundaries: How to use custom structs for defining the geometric primitives.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/#Pole-of-Inaccessibility","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"","category":"section"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"In this tutorial, we demonstrate how we can compute the pole of inaccessibility of a given polygon, namely the point inside the polygon that is furthest from the boundary, using the algorithm described in this blogpost based on recursively subdividing the polygon using quadtree partitioning. The polygons should be defined the same way the boundary of a triangulation is defined; see the constrained triangulation tutorials. In particular, the algorithm we use works for polygons that may possibly have interior holes, or even nested holes, as well as for multipolygons. We give a simple example. First, let us define our polygon.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    0.0 8.0\n    2.0 5.0\n    3.0 7.0\n    1.81907 8.13422\n    3.22963 8.865\n    4.24931 7.74335\n    4.50423 5.87393\n    3.67149 4.3784\n    2.73678 2.62795\n    5.50691 1.38734\n    8.43 2.74691\n    9.7046 5.53404\n    8.56595 7.79433\n    6.71353 9.03494\n    4.13034 9.66375\n    2.75378 10.3775\n    1.0883 10.4965\n    -1.138 9.83369\n    -2.25965 8.45712\n    -2.78649 5.94191\n    -1.39292 3.64763\n    0.323538 4.97322\n    -0.900078 6.6217\n    0.98633 9.68074\n    0.153591 9.54478\n    0.272554 8.66106\n    2.90673 8.18521\n    2.12497 9.42582\n    7.27436 2.7979\n    3.0 4.0\n    5.33697 1.88019\n]'\nouter_boundary = [\n    # split into segments for demonstration purposes\n    [1, 4, 3, 2],\n    [2, 9, 10, 11, 8, 7, 12],\n    [12, 6, 13, 5, 14, 15, 16, 17, 16],\n    [16, 17, 18, 19, 20, 21, 22, 23, 1],\n]\ninner_1 = [\n    [26, 25, 24], [24, 28, 27, 26],\n]\ninner_2 = [\n    [29, 30, 31, 29],\n]\nboundary_nodes = [outer_boundary, inner_1, inner_2]\nfig = Figure()\nax = Axis(fig[1, 1])\nfor i in eachindex(boundary_nodes)\n    lines!(ax, points[:, reduce(vcat, boundary_nodes[i])], color = :red)\nend\nfig","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"To now find the pole of inaccessibility, use DelaunayTriangulation.pole_of_inaccessibility:","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"pole = DelaunayTriangulation.pole_of_inaccessibility(points, boundary_nodes)","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"scatter!(ax, pole, color = :blue, markersize = 16)\nfig","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"This shows that the point inside the red region that is furthest from the boundary is the blue point shown.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"We note that triangulations also store the poles of inaccessibility for each boundary, as these are used to define the orientation of a ghost edge. Here is an example. First, we get the triangulation.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"θ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2, Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    global cx\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\ntri = triangulate(points; boundary_nodes = boundary_nodes)","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"To see the poles, called representative points, we use","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"DelaunayTriangulation.get_representative_point_list(tri)","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"The keys of the Dict refer to the curve index, and the values contain the coordinates.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"fig, ax, sc = triplot(tri, show_ghost_edges = true)\ncolors = (:red, :blue, :darkgreen, :purple)\nfor i in eachindex(boundary_nodes)\n    lines!(ax, points[reduce(vcat, boundary_nodes[i])], color = colors[i], linewidth = 6)\n    coords = DelaunayTriangulation.get_representative_point_coordinates(tri, i)\n    scatter!(ax, coords, color = colors[i], markersize = 16)\nend\nfig","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"Note that the green and purple boundaries have the same pole of inaccessibility. The first curve, the red curve, is the only one that has the pole of inaccessibility computed with respect to all other boundaries. You can also see that indeed the ghost edges are all oriented relative to the representative points.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/#Just-the-code","page":"Pole of Inaccessibility","title":"Just the code","text":"","category":"section"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [\n    0.0 8.0\n    2.0 5.0\n    3.0 7.0\n    1.81907 8.13422\n    3.22963 8.865\n    4.24931 7.74335\n    4.50423 5.87393\n    3.67149 4.3784\n    2.73678 2.62795\n    5.50691 1.38734\n    8.43 2.74691\n    9.7046 5.53404\n    8.56595 7.79433\n    6.71353 9.03494\n    4.13034 9.66375\n    2.75378 10.3775\n    1.0883 10.4965\n    -1.138 9.83369\n    -2.25965 8.45712\n    -2.78649 5.94191\n    -1.39292 3.64763\n    0.323538 4.97322\n    -0.900078 6.6217\n    0.98633 9.68074\n    0.153591 9.54478\n    0.272554 8.66106\n    2.90673 8.18521\n    2.12497 9.42582\n    7.27436 2.7979\n    3.0 4.0\n    5.33697 1.88019\n]'\nouter_boundary = [\n    # split into segments for demonstration purposes\n    [1, 4, 3, 2],\n    [2, 9, 10, 11, 8, 7, 12],\n    [12, 6, 13, 5, 14, 15, 16, 17, 16],\n    [16, 17, 18, 19, 20, 21, 22, 23, 1],\n]\ninner_1 = [\n    [26, 25, 24], [24, 28, 27, 26],\n]\ninner_2 = [\n    [29, 30, 31, 29],\n]\nboundary_nodes = [outer_boundary, inner_1, inner_2]\nfig = Figure()\nax = Axis(fig[1, 1])\nfor i in eachindex(boundary_nodes)\n    lines!(ax, points[:, reduce(vcat, boundary_nodes[i])], color = :red)\nend\nfig\n\npole = DelaunayTriangulation.pole_of_inaccessibility(points, boundary_nodes)\n\nscatter!(ax, pole, color = :blue, markersize = 16)\nfig\n\nθ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2, Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    global cx\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\ntri = triangulate(points; boundary_nodes = boundary_nodes)\n\nDelaunayTriangulation.get_representative_point_list(tri)\n\nfig, ax, sc = triplot(tri, show_ghost_edges = true)\ncolors = (:red, :blue, :darkgreen, :purple)\nfor i in eachindex(boundary_nodes)\n    lines!(ax, points[reduce(vcat, boundary_nodes[i])], color = colors[i], linewidth = 6)\n    coords = DelaunayTriangulation.get_representative_point_coordinates(tri, i)\n    scatter!(ax, coords, color = colors[i], markersize = 16)\nend\nfig","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"","category":"page"},{"location":"tutorials/pole_of_inaccessibility/","page":"Pole of Inaccessibility","title":"Pole of Inaccessibility","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/point_location/#Point-Location","page":"Point Location","title":"Point Location","text":"","category":"section"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"In this tutorial, we demonstrate how triangulations can be used to perform point location. The problem of interest is: Given a point p and a triangulation tri, what triangle T in tri contains p? We provide a function find_triangle for this task, implementing the algorithm of Mücke, Saias, and Zhu (1999). The algorithm has been slightly modified to allow for regions with holes. Support is also provided for non-convex and disjoint domains, but the algorithm is significantly slower in these cases and requires some special case. (The approach for these cases is, basically, to just keep trying new points to start the algorithm from until it works, but you the user must specify a keyword argument concavity_protection to make an extra check to guarantee even greater safety.)","category":"page"},{"location":"tutorials/point_location/#Unconstrained-example","page":"Point Location","title":"Unconstrained example","text":"","category":"section"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"We start with a simple example, demonstrating point location on an unconstrained triangulation.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\npoints = [\n    (-3.0, 6.0), (5.0, 1.0), (-5.0, 3.0), (2.0, -3.0),\n    (5.0, 8.0), (0.0, 0.0), (2.0, 5.0), (-3.0, 1.0),\n    (-2.0, -1.0), (-1.0, 4.0),\n]\ntri = triangulate(points)\nq = (3.0, 3.0)\nfig, ax, sc = triplot(tri)\nscatter!(ax, q)\nfig","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"The aim is to, from tri, find which triangle contains the point q shown. Using the find_triangle function, this is simple.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"V = find_triangle(tri, q)","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"The result means that the triangle (2, 7, 6) contains the point, as we can easily check:","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"DelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"When we provide no keyword arguments, the default behaviour of find_triangle is to first sample some number of points (defaults to lceil sqrt3nrceil, where n is the number of points), and then start at the point that is closest to q out of those sampled, then marching along the triangulation until q is found. This number of samples can be changed using the m keyword argument. For example,","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"V = find_triangle(tri, q, m = 10)","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"means that we get a sample of size 10, and start at whichever point is the closest. (For technical reasons, this sampling is with replacement, so it is possible that the same point is sampled more than once.) You could also instead specify the point to start at using the k keyword argument, in which case no points are sampled. For example,","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"V = find_triangle(tri, q, k = 6)","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"starts the algorithm at the point 6.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Note also that the triangles found from find_triangle do not have to be given in the same order as they appear in the triangulation. For example, if a triangle (i, j, k) contains the point q, then any of (i, j, k), (j, k, i), or (k, i, j) could be returned.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"The point q does not have to be in the triangulation. For example, consider the following point.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"q = (-5.0, 8.0)\nfig, ax, sc = triplot(tri)\nscatter!(ax, q)\nfig","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"We obtain:","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"V = find_triangle(tri, q)","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"See that the result is a ghost triangle (1, 5, -1). As discussed in the manual, this can be interpreted as meaning that q is between the two lines through the points 1 and 5 that start at a central point of the triangulation. (The index -1 is just the ghost vertex.) This can be visualised.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"fig, ax, sc = triplot(tri, show_ghost_edges = true)\nscatter!(ax, q)\nfig","category":"page"},{"location":"tutorials/point_location/#Region-with-concave-boundaries-and-holes","page":"Point Location","title":"Region with concave boundaries and holes","text":"","category":"section"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Now we give an example of point location for a reason with holes. Since the case where all boundaries are convex is reasonably straight forward, here we consider concave boundaries and discuss methods for improving the speed of the algorithm in this case. First, let us give our example triangulation.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"a, b, c = (0.0, 8.0), (0.0, 6.0), (0.0, 4.0)\nd, e, f = (0.0, 2.0), (0.0, 0.0), (2.0, 0.0)\ng, h, i = (4.0, 0.0), (6.0, 0.0), (8.0, 0.0)\nj, k, ℓ = (8.0, 1.0), (7.0, 2.0), (5.0, 2.0)\nm, n, o = (3.0, 2.0), (2.0, 3.0), (2.0, 5.0)\np, q, r = (2.0, 7.0), (1.0, 8.0), (1.0, 2.2)\ns, t, u = (0.4, 1.4), (1.2, 1.8), (2.8, 0.6)\nv, w, z = (3.4, 1.2), (1.6, 1.4), (1.6, 2.2)\nouter = [[a, b, c, d, e], [e, f, g, h, i, j, k, ℓ], [ℓ, m, n, o, p, q, a]]\ninner = [[r, z, v, u, w, t, s, r]]\nboundary_nodes, points = convert_boundary_points_to_indices([outer, inner])\nrng = StableRNG(125123)\ntri = triangulate(points; rng, boundary_nodes)\nrefine!(tri; max_area = 0.01get_area(tri), rng);\nnothing #hide","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"The issue with concavity is that the ghost triangles can no longer be sensibly defined. To demonstrate this, see the following plot:","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"fig, ax, sc = triplot(tri, show_ghost_edges = true)\nfig","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"The ghost edges now intersect the boundary, which doesn't make sense, and creates difficulties. Let us now demonstrate how the function still works here. We try finding the blue points shown below.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"qs = [\n    (4.0, 5.0), (1.0, 5.6), (0.2, 5.0),\n    (0.0, -1.0), (0.5, 3.5), (2.5, 1.5),\n    (1.0, 2.0), (4.5, 1.0), (6.0, 1.5),\n    (0.5, 8.5), (1.0, 7.5), (1.2, 1.6),\n]\nfig, ax, sc = triplot(tri, show_ghost_edges = false)\nscatter!(ax, qs, color = :blue, markersize = 16)\nfig","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Now let's find the triangles.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Vs = [find_triangle(tri, q; rng) for q in qs]","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"While we do find some triangles, they may not all be correct. For example, the triangle found for (1.2, 1.6) is","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Vs[end]","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"but the point (1.2, 1.6) is actually inside the triangulation. To protect against this, you need to use concavity_protection=true, which will enable a check to be made that the point is actually outside the triangulation whenever a ghost triangle is to be returned. If the check finds this to not be the case, it restarts. With these results, we now compute:","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Vs = [find_triangle(tri, q; rng, concavity_protection = true) for q in qs]","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Here is how we can actually test that these results are now correct. We cannot directly use DelaunayTriangulation.point_position_relative_to_triangle because it does not know that the ghost triangles are invalid. Instead, we find the distance of each point to the triangulation's boundary using DelaunayTriangulation.dist so that we can classify it as being inside or outside of the triangulation, and then check the type of the found triangle.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"δs = [DelaunayTriangulation.dist(tri, q) for q in qs]\nresults = Vector{Bool}(undef, length(qs))\nfor (j, (q, δ, V)) in (enumerate ∘ zip)(qs, δs, Vs)\n    cert = DelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)\n    is_ghost = DelaunayTriangulation.is_ghost_triangle(V)\n    is_outside = DelaunayTriangulation.is_outside(cert)\n    if δ ≥ 0.0\n        results[j] = !is_outside && !is_ghost\n    else # δ < 0.0 ⟹ outside\n        results[j] = !is_outside && is_ghost\n    end\nend\nresults","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"As we see, the triangles are now all correct.","category":"page"},{"location":"tutorials/point_location/#Disjoint-domains","page":"Point Location","title":"Disjoint domains","text":"","category":"section"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Now we continue the previous example by adding in another set of domains that are disjoint to the current domain, thus allowing us to demonstrate how find_triangle applies here. The new domain is below, along with the points we will be searching for.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"m₁, n₁, o₁ = (6.0, 8.0), (8.0, 8.0), (8.0, 4.0)\np₁, q₁, r₁ = (10.0, 4.0), (6.0, 6.0), (8.0, 6.0)\ns₁, t₁, u₁ = (9.0, 7.0), (4.0, 4.0), (5.0, 4.0)\nv₁, w₁ = (5.0, 3.0), (4.0, 3.0)\nnew_domain₁ = [[m₁, q₁, o₁, p₁, r₁, s₁, n₁, m₁]]\nnew_domain₂ = [[t₁, w₁, v₁, u₁, t₁]]\nboundary_nodes, points = convert_boundary_points_to_indices(\n    [outer, inner, new_domain₁, new_domain₂],\n)\nrng = StableRNG(125123)\ntri = triangulate(points; rng, boundary_nodes)\nrefine!(tri; max_area = 0.001get_area(tri), rng)\nqs = [\n    (0.6, 6.4), (1.4, 0.8), (3.1, 2.9),\n    (6.3, 4.9), (4.6, 3.5), (7.0, 7.0),\n    (8.9, 5.1), (5.8, 0.8), (1.0, 1.5),\n    (1.5, 2.0), (8.15, 6.0),\n]\nfig, ax, sc = triplot(tri)\nscatter!(ax, qs, color = :blue, markersize = 16)\nfig","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Here are the find_triangle results.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Vs = [find_triangle(tri, q; rng, concavity_protection = true) for q in qs]","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"Again, we can verify that these are all correct as follows. Without concavity_protection=true, these would not be all correct.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"δs = [DelaunayTriangulation.dist(tri, q) for q in qs]\nresults = Vector{Bool}(undef, length(qs))\nfor (j, (q, δ, V)) in (enumerate ∘ zip)(qs, δs, Vs)\n    cert = DelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)\n    is_ghost = DelaunayTriangulation.is_ghost_triangle(V)\n    is_outside = DelaunayTriangulation.is_outside(cert)\n    if δ ≥ 0.0\n        results[j] = !is_outside && !is_ghost\n    else # δ < 0.0 ⟹ outside\n        results[j] = !is_outside && is_ghost\n    end\nend\nresults","category":"page"},{"location":"tutorials/point_location/#Just-the-code","page":"Point Location","title":"Just the code","text":"","category":"section"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\npoints = [\n    (-3.0, 6.0), (5.0, 1.0), (-5.0, 3.0), (2.0, -3.0),\n    (5.0, 8.0), (0.0, 0.0), (2.0, 5.0), (-3.0, 1.0),\n    (-2.0, -1.0), (-1.0, 4.0),\n]\ntri = triangulate(points)\nq = (3.0, 3.0)\nfig, ax, sc = triplot(tri)\nscatter!(ax, q)\nfig\n\nV = find_triangle(tri, q)\n\nDelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)\n\nV = find_triangle(tri, q, m = 10)\n\nV = find_triangle(tri, q, k = 6)\n\nq = (-5.0, 8.0)\nfig, ax, sc = triplot(tri)\nscatter!(ax, q)\nfig\n\nV = find_triangle(tri, q)\n\nfig, ax, sc = triplot(tri, show_ghost_edges = true)\nscatter!(ax, q)\nfig\n\na, b, c = (0.0, 8.0), (0.0, 6.0), (0.0, 4.0)\nd, e, f = (0.0, 2.0), (0.0, 0.0), (2.0, 0.0)\ng, h, i = (4.0, 0.0), (6.0, 0.0), (8.0, 0.0)\nj, k, ℓ = (8.0, 1.0), (7.0, 2.0), (5.0, 2.0)\nm, n, o = (3.0, 2.0), (2.0, 3.0), (2.0, 5.0)\np, q, r = (2.0, 7.0), (1.0, 8.0), (1.0, 2.2)\ns, t, u = (0.4, 1.4), (1.2, 1.8), (2.8, 0.6)\nv, w, z = (3.4, 1.2), (1.6, 1.4), (1.6, 2.2)\nouter = [[a, b, c, d, e], [e, f, g, h, i, j, k, ℓ], [ℓ, m, n, o, p, q, a]]\ninner = [[r, z, v, u, w, t, s, r]]\nboundary_nodes, points = convert_boundary_points_to_indices([outer, inner])\nrng = StableRNG(125123)\ntri = triangulate(points; rng, boundary_nodes)\nrefine!(tri; max_area = 0.01get_area(tri), rng);\n\nfig, ax, sc = triplot(tri, show_ghost_edges = true)\nfig\n\nqs = [\n    (4.0, 5.0), (1.0, 5.6), (0.2, 5.0),\n    (0.0, -1.0), (0.5, 3.5), (2.5, 1.5),\n    (1.0, 2.0), (4.5, 1.0), (6.0, 1.5),\n    (0.5, 8.5), (1.0, 7.5), (1.2, 1.6),\n]\nfig, ax, sc = triplot(tri, show_ghost_edges = false)\nscatter!(ax, qs, color = :blue, markersize = 16)\nfig\n\nVs = [find_triangle(tri, q; rng) for q in qs]\n\nVs[end]\n\nVs = [find_triangle(tri, q; rng, concavity_protection = true) for q in qs]\n\nδs = [DelaunayTriangulation.dist(tri, q) for q in qs]\nresults = Vector{Bool}(undef, length(qs))\nfor (j, (q, δ, V)) in (enumerate ∘ zip)(qs, δs, Vs)\n    cert = DelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)\n    is_ghost = DelaunayTriangulation.is_ghost_triangle(V)\n    is_outside = DelaunayTriangulation.is_outside(cert)\n    if δ ≥ 0.0\n        results[j] = !is_outside && !is_ghost\n    else # δ < 0.0 ⟹ outside\n        results[j] = !is_outside && is_ghost\n    end\nend\nresults\n\nm₁, n₁, o₁ = (6.0, 8.0), (8.0, 8.0), (8.0, 4.0)\np₁, q₁, r₁ = (10.0, 4.0), (6.0, 6.0), (8.0, 6.0)\ns₁, t₁, u₁ = (9.0, 7.0), (4.0, 4.0), (5.0, 4.0)\nv₁, w₁ = (5.0, 3.0), (4.0, 3.0)\nnew_domain₁ = [[m₁, q₁, o₁, p₁, r₁, s₁, n₁, m₁]]\nnew_domain₂ = [[t₁, w₁, v₁, u₁, t₁]]\nboundary_nodes, points = convert_boundary_points_to_indices(\n    [outer, inner, new_domain₁, new_domain₂],\n)\nrng = StableRNG(125123)\ntri = triangulate(points; rng, boundary_nodes)\nrefine!(tri; max_area = 0.001get_area(tri), rng)\nqs = [\n    (0.6, 6.4), (1.4, 0.8), (3.1, 2.9),\n    (6.3, 4.9), (4.6, 3.5), (7.0, 7.0),\n    (8.9, 5.1), (5.8, 0.8), (1.0, 1.5),\n    (1.5, 2.0), (8.15, 6.0),\n]\nfig, ax, sc = triplot(tri)\nscatter!(ax, qs, color = :blue, markersize = 16)\nfig\n\nVs = [find_triangle(tri, q; rng, concavity_protection = true) for q in qs]\n\nδs = [DelaunayTriangulation.dist(tri, q) for q in qs]\nresults = Vector{Bool}(undef, length(qs))\nfor (j, (q, δ, V)) in (enumerate ∘ zip)(qs, δs, Vs)\n    cert = DelaunayTriangulation.point_position_relative_to_triangle(tri, V, q)\n    is_ghost = DelaunayTriangulation.is_ghost_triangle(V)\n    is_outside = DelaunayTriangulation.is_outside(cert)\n    if δ ≥ 0.0\n        results[j] = !is_outside && !is_ghost\n    else # δ < 0.0 ⟹ outside\n        results[j] = !is_outside && is_ghost\n    end\nend\nresults","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"","category":"page"},{"location":"tutorials/point_location/","page":"Point Location","title":"Point Location","text":"This page was generated using Literate.jl.","category":"page"},{"location":"extended/algorithms/#Algorithm-Internals","page":"Algorithm Internals","title":"Algorithm Internals","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here we give some functions that are used for some of the algorithms in this package.","category":"page"},{"location":"extended/algorithms/#Unconstrained-Triangulations","page":"Algorithm Internals","title":"Unconstrained Triangulations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some of the internal functions used for the Bowyer-Watson algorithm, i.e. for the computation of an unconstrained triangulation.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.postprocess_triangulate!","page":"Algorithm Internals","title":"DelaunayTriangulation.postprocess_triangulate!","text":"postprocess_triangulate!(tri; delete_ghosts=false, delete_empty_features=true, recompute_representative_points=true)\n\nPostprocesses the triangulation tri after it has been constructed using triangulate. This includes:\n\nDeleting ghost triangles using delete_ghost_triangles! if delete_ghosts is true.\nClearing empty features using clear_empty_features! if delete_empty_features is true.\nRecomputing the representative points using compute_representative_points! if recompute_representative_points is true.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.add_point_bowyer_watson!-Union{Tuple{P}, Tuple{I}, Tuple{Triangulation, Any, I}, Tuple{Triangulation, Any, I, Random.AbstractRNG}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any}, Tuple{Triangulation, Any, I, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel, Any, Any, Any, P}} where {I, P}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_point_bowyer_watson!","text":"add_point_bowyer_watson!(tri::Triangulation, new_point, initial_search_point::I, rng::Random.AbstractRNG=Random.default_rng(), update_representative_point=true, store_event_history=Val(false), event_history=nothing, peek::P=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Triangle\n\nAdds new_point into tri. \n\nArguments\n\ntri: The triangulation.\nnew_point: The point to insert.\ninitial_search_point::I: The vertex to start the point location with find_triangle at. See get_initial_search_point.\nrng::Random.AbstractRNG: The random number generator to use.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nupdate_representative_point=true: If true, then the representative point is updated. See update_centroid_after_addition!.\nstore_event_history=Val(false): If true, then the event history from the insertion is stored. \nevent_history=nothing: The event history to store the event history in. Should be an InsertionEventHistory if store_event_history is true, and false otherwise.\npeek=Val(false): Whether to actually add new_point into tri, or just record into event_history all the changes that would occur from its insertion.\n\nOutput\n\nV: The triangle in tri containing new_point.\n\nExtended help\n\nThis function works as follows:\n\nFirst, the triangle containing the new point, V, is found using find_triangle.\nOnce the triangle is found, we call into add_point_bowyer_watson_and_process_after_found_triangle to properly insert the point. \nInside add_point_bowyer_watson_and_process_after_found_triangle, we first call into add_point_bowyer_watson_after_found_triangle to add the point into the cavity. We then  call into add_point_bowyer_watson_onto_segment to make any changes necessary incase the triangulation is constrained and new_point lies on a segment, since the depth-first search of the triangles containing new_point in its circumcenter must be performed on each side of the segment that new_point lies on.\n\nThe function add_point_bowyer_watson_dig_cavities! is the main workhorse of this function from add_point_bowyer_watson_after_found_triangle. See its docstring for the details. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!-Union{Tuple{F}, Tuple{N}, Tuple{Triangulation, N, Any, Any, Any}, Tuple{Triangulation, N, Vararg{Any, 4}}, Tuple{Triangulation, N, Vararg{Any, 5}}, Tuple{Triangulation, N, Vararg{Any, 6}}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, N, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where {N, F}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_point_bowyer_watson_dig_cavities!","text":"add_point_bowyer_watson_dig_cavities!(tri::Triangulation, new_point::N, V, q, flag, update_representative_point=true, store_event_history=Val(false), event_history=nothing, peek::F=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) where {N,F}\n\nDeletes all the triangles in tri whose circumcircle contains new_point. This leaves behind a polygonal cavity, whose boundary edges are then connected to new_point, restoring the Delaunay property from new_point's insertion.\n\nArguments\n\ntri: The Triangulation.\nnew_point::N: The point to insert.\nV: The triangle in tri containing new_point.\nq: The point to insert.\nflag: The position of q relative to V. See point_position_relative_to_triangle.\nupdate_representative_point=true: If true, then the representative point is updated. See update_centroid_after_addition!.\nstore_event_history=Val(false): If true, then the event history from the insertion is stored.\nevent_history=nothing: The event history to store the event history in. Should be an InsertionEventHistory if store_event_history is true, and false otherwise.\npeek=Val(false): Whether to actually add new_point into tri, or just record into event_history all the changes that would occur from its insertion.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nThere are no changes, but tri is updated in-place.\n\nExtended help\n\nThis function works as follows: \n\nTo dig the cavity, we call dig_cavity! on each edge of V, stepping towards the adjacent triangles to excavate the cavity recursively.\nOnce the cavity has been excavated, extra care is needed in case is_on(flag), meaning new_point is on one of the edges of V. In particular, extra care is needed if: is_on(flag) && (is_boundary_triangle(tri, V) || is_ghost_triangle(V) && !is_boundary_node(tri, new_point)[1]). The need for this check is in case new_point is on a boundary edge already exists, since we need to fix the associated ghost edges. For example, a boundary edge (i, k) might have been  split into the edges (i, j) and (j, k), which requires that the ghost triangle (k, i, g) be split into (j, i, g) and (k, j, g), where g is the ghost vertex. This part of the function  will fix this case. The need for is_ghost_triangle(V) && !is_boundary_node(tri, new_point)[1] is in case the ghost edges were already correctly added. Nothing happens if the edge of V that new_point  is on is not the boundary edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.dig_cavity!-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 6}}, Tuple{Triangulation, Vararg{Any, 7}}, Tuple{Triangulation, Vararg{Any, 8}}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, Any, Any, Any, F, DelaunayTriangulation.AbstractPredicateKernel}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.dig_cavity!","text":"dig_cavity!(tri::Triangulation, r, i, j, ℓ, flag, V, store_event_history=Val(false), event_history=nothing, peek::F=Val(false), predicates::AbstractPredicateKernel=AdaptiveKernel()) where {F}\n\nExcavates the cavity in tri through the edge (i, j), stepping towards the adjacent triangles to excavate the cavity recursively, eliminating all  triangles containing r in their circumcircle. \n\nArguments\n\ntri: The Triangulation.\nr: The new point being inserted. \ni: The first vertex of the edge (i, j).\nj: The second vertex of the edge (i, j).\nℓ: The vertex adjacent to (j, i), so that the triangle being stepped into is (j, i, ℓ).\nflag: The position of r relative to V. See point_position_relative_to_triangle.\nV: The triangle in tri containing r.\nstore_event_history=Val(false): If true, then the event history from the insertion is stored.\nevent_history=nothing: The event history to store the event history in. Should be an InsertionEventHistory if store_event_history is true, and false otherwise.\npeek=Val(false): Whether to actually add new_point into tri, or just record into event_history all the changes that would occur from its insertion.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nThere are no changes, but tri is updated in-place.\n\nExtended help\n\nThis function works as follows:\n\nFirst, we check if ℓ is 0, which would imply that the triangle (j, i, ℓ) doesn't exist as it has already been deleted. If this is the check, we return and stop digging. \nIf the edge (i, j) is not a segment, r is inside of the circumcenter of (j, i, ℓ), and ℓ is not a ghost vertex, then we can step forward into the next triangles. In particular,  we delete the triangle (j, i, ℓ) from tri and then call dig_cavity! again on two edges of (j, i, ℓ) other than (j, i).\nIf we did not do step 2, then this means that we are on the edge of the polygonal cavity; this also covers the case that ℓ is a ghost vertex, i.e. we are at the boundary of the triangulation. There are two cases to consider here. Firstly, if (i, j) is not a segment, we just need to add the triangle (r, i, j) into tri to connect r to this edge of the polygonal cavity. If  (i, j) is a segment, then the situation is more complicated. In particular, r being on an edge of V might imply that we are going to add a degenerate triangle (r, i, j) into tri,  and so this needs to be avoided. So, we check if is_on(flag) && contains_segment(tri, i, j) and, if the edge that r is on is (i, j), we add the triangle (r, i, j). Otherwise, we do nothing.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.enter_cavity","page":"Algorithm Internals","title":"DelaunayTriangulation.enter_cavity","text":"enter_cavity(tri::Triangulation, r, i, j, ℓ, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Bool\n\nDetermines whether to enter the cavity in tri through the edge (i, j) when inserting r into the triangulation.\n\nArguments\n\ntri: The Triangulation.\nr: The new point being inserted.\ni: The first vertex of the edge (i, j).\nj: The second vertex of the edge (i, j).\nℓ: The vertex adjacent to (j, i), so that the triangle being stepped into is (j, i, ℓ).\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\ntrue if the cavity should be entered, and false otherwise. See also dig_cavity! and point_position_relative_to_circumcircle.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_initial_search_point-Union{Tuple{F}, Tuple{Triangulation, Any, Any, Any, F, Any, Any}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.get_initial_search_point","text":"get_initial_search_point(tri::Triangulation, num_points, new_point, insertion_order, num_sample_rule::F, rng, try_last_inserted_point) where {F} -> Vertex\n\nFor a given iteration of the Bowyer-Watson algorithm, finds the point to start the point location with find_triangle at.\n\nArguments\n\ntri: The triangulation.\nnum_points: The number of points currently in the triangulation.\nnew_point: The point to insert.\ninsertion_order: The insertion order of the points. See get_insertion_order.\nnum_sample_rule::F: The rule to use to determine the number of points to sample. See default_num_samples for the default. \nrng::Random.AbstractRNG: The random number generator to use.\ntry_last_inserted_point: If true, then the last inserted point is also considered as the start point. \n\nOutput\n\ninitial_search_point: The vertex to start the point location with find_triangle at.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_initial_triangle","page":"Algorithm Internals","title":"DelaunayTriangulation.get_initial_triangle","text":"get_initial_triangle(tri::Triangulation, insertion_order, itr=0) -> Triangle\n\nGets the initial triangle for the Bowyer-Watson algorithm. \n\nArguments\n\ntri: The triangulation.\ninsertion_order: The insertion order of the points. See get_insertion_order.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nitr=0: To avoid issues with degenerate triangles and infinite loops, this counts the number of times insertion_order had to be shifted using circshift! to find an initial non-degenerate triangle.\n\nOutput\n\ninitial_triangle: The initial triangle.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_insertion_order-Union{Tuple{I}, Tuple{Any, Any, Any, Type{I}, Any}} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.get_insertion_order","text":"get_insertion_order(points, randomise, skip_points, ::Type{I}, rng) where {I} -> Vector{I}\nget_insertion_order(tri::Triangulation, randomise, skip_points, rng) -> Vector{I}\n\nGets the insertion order for points into a triangulation. \n\nArguments\n\npoints: The points to insert.\nrandomise: If true, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.\nskip_points: The points to skip.\nI::Type{I}: The type of the vertices.\nrng::Random.AbstractRNG: The random number generator to use.\n\nOutput\n\norder: The order to insert the points in.\n\nwarning: Mutation of `order`\nThis order might be mutated (by circshift!) in get_initial_triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.initialise_bowyer_watson!","page":"Algorithm Internals","title":"DelaunayTriangulation.initialise_bowyer_watson!","text":"initialise_bowyer_watson!(tri::Triangulation, insertion_order, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Triangulation\n\nInitialises the Bowyer-Watson algorithm.\n\nArguments\n\ntri: The triangulation.\ninsertion_order: The insertion order of the points. See get_insertion_order.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\ntri is updated in place to contain the initial triangle from which the Bowyer-Watson algorithm starts.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.unconstrained_triangulation!-Union{Tuple{Triangulation}, Tuple{M}} where M","page":"Algorithm Internals","title":"DelaunayTriangulation.unconstrained_triangulation!","text":"unconstrained_triangulation!(tri::Triangulation; kwargs...)\n\nComputes the unconstrained Delaunay triangulation of the points in tri.\n\nArguments\n\ntri: The triangulation.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nrandomise=true: If true, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.\nskip_points=(): The vertices to skip. \nnum_sample_rule::M=default_num_samples: The rule to use to determine the number of points to sample. See default_num_samples for the default.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\ninsertion_order=get_insertion_order(tri, randomise, skip_points, rng): The insertion order of the points. See get_insertion_order.\n\nOutputs\n\nThere is no output, but tri is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Triangulation-Rectangular-Domains","page":"Algorithm Internals","title":"Triangulation Rectangular Domains","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some of the internal functions used for triangulate_rectangle.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.get_lattice_triangles","page":"Algorithm Internals","title":"DelaunayTriangulation.get_lattice_triangles","text":"get_lattice_triangles(nx, ny, Ts, V)\n\nComputes the triangles defining a lattice with nx and ny points in the x- and y-directions, respectively.\n\nSee triangulate_rectangle.\n\nArguments\n\nnx: The number of x points in the lattice.\nny: The number of y points in the lattice.\nTs: The type to use for representing a collection of triangles.\nV: The type to use for representing an individual triangle.\n\nOutputs\n\nT: The collection of triangles.\nsub2ind: A map that takes cartesian indices (i, j) into the associated linear index along the lattice. See LinearIndices.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_lattice_points","page":"Algorithm Internals","title":"DelaunayTriangulation.get_lattice_points","text":"get_lattice_points(a, b, c, d, nx, ny, sub2ind)\n\nReturns the points on a lattice [a, b] × [c, d].\n\nSee triangulate_rectangle.\n\nArguments\n\na: The minimum x-coordinate. \nb: The maximum x-coordinate.\nc: The minimum y-coordinate.\nd: The maximum y-coordinate.\nnx: The number of points in the x-direction.\nny: The number of points in the y-direction.\nsub2ind: The map returned from get_lattice_triangles.\n\nOutputs\n\npoints: The points on the lattice, where points[sub2ind[CartesianIndex(i, j)]] is the point at the ith x point and the jth y point,\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_lattice_boundary","page":"Algorithm Internals","title":"DelaunayTriangulation.get_lattice_boundary","text":"get_lattice_boundary(nx, ny, sub2ind, single_boundary, IntegerType)\n\nReturns the boundary nodes defining a lattice. \n\nSee triangulate_rectangle.\n\nArguments\n\nnx: The number of x points in the lattice.\nny: The number of y points in the lattice.\nsub2ind: The map returned from get_lattice_triangles.\nsingle_boundary: If true, then the boundary nodes are stored as a contiguous section. Otherwise, the boundary is split into four sections, in the order   bottom, right, top, left.\nIntegerType: The type used for representing vertices. \n\nOutputs\n\nboundary_nodes: The boundary nodes, returned according to single_boundary as described above.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#Triangulating-Convex-Polygons","page":"Algorithm Internals","title":"Triangulating Convex Polygons","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions used in triangulate_convex for triangulating a convex polygon.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.add_point_convex_triangulation!","page":"Algorithm Internals","title":"DelaunayTriangulation.add_point_convex_triangulation!","text":"add_point_convex_triangulation!(tri::Triangulation, u, v, w, S, predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nAdds the point u into the triangulation tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nu: The vertex to add.\nv: The vertex next to u.\nw: The vertex previous to u.\nS: The set of vertices of the polygon.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is modified in-place.\n\nExtended help\n\nThis function forms part of Chew's algorithm for triangulating a convex polygon. There are some important points  to make.\n\nFirstly, checking that x = get_adjacent(tri, w, v) is needed to prevent the algorithm from exiting the polygon.\n\nThis is important in case this algorithm is used as part of delete_point!. When you are just triangulating   a convex polygon by itself, this checked is the same as checking edge_exists(tri, w, v).\n\nFor this method to be efficient, the set x ∈ S must be O(1) time. This is why we use a Set type for S.\nThe algorithm is recursive, recursively digging further through the polygon to find non-Delaunay edges to adjoins with u.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_vertices_in_random_order!","text":"delete_vertices_in_random_order!(list::Triangulation, tri::ShuffledPolygonLinkedList, rng, predicates::AbstractPredicateKernel)\n\nDeletes the vertices of the polygon represented by list in random order, done by switching  the pointers of the linked list. Only three vertices will survive. If these these three vertices are  collinear, then the deletion is attempted again after reshuffling the vertices.\n\nArguments\n\nlist::ShuffledPolygonLinkedList: The linked list representing the polygon to be deleted.\ntri::Triangulation: The Triangulation. \nrng::Random.AbstractRNG: The random number generator used to shuffle the vertices of S. \npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as list is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.postprocess_triangulate_convex!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.postprocess_triangulate_convex!","text":"postprocess_triangulate_convex!(tri::Triangulation, S; delete_ghosts, delete_empty_features)\n\nPostprocesses the completed triangulation tri of the convex polygon S.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nS: The vertices of the convex polygon, as in triangulate_convex.\n\nKeyword Arguments\n\ndelete_ghosts=false: If true, the ghost triangles are deleted after triangulation.\ndelete_empty_features=true: If true, the empty features are deleted after triangulation.\n\nOutput\n\nThere are no output, as tri is modified in-place. The postprocessing that is done is:\n\nThe convex hull of tri is set to S.\nThe ghost triangles are deleted if delete_ghosts=true.\nThe empty features are deleted if delete_empty_features=true.\nThe representative points are set to the centroid of S.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.triangulate_convex!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.triangulate_convex!","text":"triangulate_convex!(tri::Triangulation, S; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nTriangulates the convex polygon S in-place into tri.\n\nArguments\n\ntri::Triangulation: The triangulation to be modified.\nS: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that S[begin] ≠ S[end].\n\nKeyword Arguments\n\nrng=Random.default_rng(): The random number generator used to shuffle the vertices of S before triangulation.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place. This function does not do any post-processing, e.g. deleting any ghost triangles. This is done by  triangulate_convex or postprocess_triangulate_convex!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.triangulate_convex-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.triangulate_convex","text":"triangulate_convex(points, S; delete_ghosts=false, delete_empty_features=true, rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -> Triangulation\n\nTriangulates the convex polygon S.\n\nArguments\n\npoints: The point set corresponding to the vertices in S.\nS: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that S[begin] ≠ S[end].\n\nKeyword Arguments\n\ndelete_ghosts=false: If true, the ghost triangles are deleted after triangulation. \ndelete_empty_features=true: If true, the empty features are deleted after triangulation.\nrng=Random.default_rng(): The random number generator used to shuffle the vertices of S before triangulation.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nkwargs...: Additional keyword arguments passed to Triangulation.\n\nOutput\n\ntri::Triangulation: The triangulated polygon. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Constrained-Triangulations","page":"Algorithm Internals","title":"Constrained Triangulations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"There are many functions to list for the computation of a constrained triangulation.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.add_segment!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_segment!","text":"add_segment!(tri::Triangulation, segment; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())\nadd_segment!(tri::Triangulation, i, j; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())\n\nAdds segment = (i, j) to tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegment: The segment to add. The second method uses (i, j) to represent the segment instead.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nrng::AbstractRNG=Random.default_rng(): The RNG object.\n\nOutputs\n\nThere is no output, but tri will be updated so that it now contains segment.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_segment_to_list!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_segment_to_list!","text":"add_segment_to_list!(tri::Triangulation, e)\n\nAdds e to get_interior_segments(tri) and get_all_segments(tri) if it, or reverse_edge(e), is not already in the sets.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ne: The edge to add.\n\nOutputs\n\nThere is no output, but tri will be updated so that e is in get_interior_segments(tri) and get_all_segments(tri).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.fix_edge_order_after_rotation!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.fix_edge_order_after_rotation!","text":"fix_edge_order_after_rotation!(tri::Triangulation, segment, e)\n\nFixes the edge order in get_interior_segments(tri) after segment was rotated by optimise_edge_order.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegment: The segment that was arranged.\ne: The arranged segment from optimise_edge_order.\n\nOutputs\n\nThere is no output, but tri will be updated so that e is in get_interior_segments(tri) instead of segment.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.optimise_edge_order-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.optimise_edge_order","text":"optimise_edge_order(tri::Triangulation, segment) -> Edge\n\nOptimises the orientation of segment for inserting it into the triangulation. \n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegment: The segment to arrange. \n\nOutputs\n\ne: If segment is a boundary edge, then e = segment, Otherwise, e = sort_edge_by_degree(tri, segment) so that initial(e) has the smaller degree of the two vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_new_triangles!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_new_triangles!","text":"add_new_triangles!(tri_original::Triangulation, tris)\n\nAdds the triangles from tris to tri_original.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_point_cavity_cdt!","page":"Algorithm Internals","title":"DelaunayTriangulation.add_point_cavity_cdt!","text":"add_point_cavity_cdt!(tri::Triangulation, u, v, w, marked_vertices)\n\nAdds a point to the cavity V left behind when deleting triangles intersected in a triangulation by an edge, updating tri to do so.\n\nArguments\n\ntri::Triangulation: The Triangulation to update.\nu: The vertex to add.\nv: The vertex along the polygon that is next to u.\nw: The vertex along the polygon that is previous to u.\nmarked_vertices: Cache for marking vertices to re-triangulate during the triangulation. This gets mutated.\n\nOutputs\n\nThere is no output, but tri is updated in-place, as is marked_vertices if necessary.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E","page":"Algorithm Internals","title":"DelaunayTriangulation.connect_segments!","text":"connect_segments!(segments)\n\nConnects the ordered vector of segments so that the endpoints all connect, preserving order.\n\nExample\n\njulia> using DelaunayTriangulation\n\njulia> segments = [(7, 12), (12, 17), (17, 22), (32, 37), (37, 42), (42, 47)];\n\njulia> DelaunayTriangulation.connect_segments!(segments)\n7-element Vector{Tuple{Int64, Int64}}:\n (7, 12)\n (12, 17)\n (17, 22)\n (22, 32)\n (32, 37)\n (37, 42)\n (42, 47)\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.constrained_triangulation!-Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.constrained_triangulation!","text":"constrained_triangulation!(tri::Triangulation, segments, boundary_nodes, predicates::AbstractPredicateKernel, full_polygon_hierarchy; rng=Random.default_rng(), delete_holes=true) -> Triangulation\n\nCreates a constrained triangulation from tri by adding segments and boundary_nodes to it. This will be in-place, but a new triangulation is returned  to accommodate the changed types.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegments: The interior segments to add to the triangulation.\nboundary_nodes: The boundary nodes to add to the triangulation.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nfull_polygon_hierarchy: The PolygonHierarchy defining the boundary. This will get copied into the existing polygon hierarchy.\n\nKeyword Arguments\n\nrng=Random.default_rng(): The random number generator to use.\ndelete_holes=true: Whether to delete holes in the triangulation. See delete_holes!.\n\nOutputs\n\nnew_tri: The new triangulation, now containing segments in the interior_segments field and boundary_nodes in the boundary_nodes field, and with the updated PolygonHierarchy. See also remake_triangulation_with_constraints and replace_ghost_vertex_information.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_intersected_triangles!-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_intersected_triangles!","text":"delete_intersected_triangles!(tri, triangles)\n\nDeletes the triangles in triangles from tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_polygon_vertices_in_random_order!-Tuple{DelaunayTriangulation.ShuffledPolygonLinkedList, Triangulation, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_polygon_vertices_in_random_order!","text":"delete_polygon_vertices_in_random_order!(list::ShuffledPolygonLinkedList, tri::Triangulation, u, v, rng::Random.AbstractRNG, predicates::AbstractPredicateKernel)\n\nDeletes vertices from the polygon defined by list in a random order.\n\nArguments\n\nlist::ShuffledPolygonLinkedList: The linked list of polygon vertices.\ntri::Triangulation: The Triangulation.\nu, v: The vertices of the segment (u, v) that was inserted in order to define the polygon V = list.S.\nrng::Random.AbstractRNG: The random number generator to use.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, but list is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Algorithm Internals","title":"DelaunayTriangulation.extend_segments!","text":"extend_segments!(segments, segment)\n\nGiven an ordered vector of segments, ensures that they also represent the replacement of segment. In particular,  suppose segments represents the sequence of edges\n\n    ---(i₁, i₂)---(i₂, i₃)---(⋯, ⋯)---(iₙ₋₁, iₙ)---\n\nand segment is (i₀, iₙ₊₁). Then the extended sequence becomes \n\n    ---(i₀, i₁)---(i₁, i₂)---(i₂, i₃)---(⋯, ⋯)---(iₙ₋₁, iₙ)---(iₙ, iₙ₊₁)---\n\nExample\n\njulia> using DelaunayTriangulation\n\njulia> segments = [(2, 7), (7, 12), (12, 49)];\n\njulia> segment = (1, 68);\n\njulia> DelaunayTriangulation.extend_segments!(segments, segment)\n5-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (2, 7)\n (7, 12)\n (12, 49)\n (49, 68)\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Algorithm Internals","title":"DelaunayTriangulation.fix_segments!","text":"fix_segments!(segments, bad_indices)\n\nFixes the overlapping segments in segments, referred to via bad_indices, by connecting consecutive edges where needed.\n\nArguments\n\nsegments: The segments to fix.\nbad_indices: The indices of the segments to fix.\n\nOutputs\n\nThere are no outputs as segments is updated in-place.\n\nExample\n\njulia> using DelaunayTriangulation\n\njulia> segments = [(2, 15), (2, 28), (2, 41)]; # the edges all start with 2, so they are not actual segments in the triangulation, and so must be fixed\n\njulia> bad_indices = [1, 2, 3];\n\njulia> DelaunayTriangulation.fix_segments!(segments, bad_indices)\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 15)\n (15, 28)\n (28, 41)\n\njulia> segments = [(2, 7), (2, 12), (12, 17), (2, 22), (2, 27), (2, 32), (32, 37), (2, 42), (42, 47)];\n\njulia> bad_indices = [2, 4, 5, 6, 8]\n5-element Vector{Int64}:\n 2\n 4\n 5\n 6\n 8\n\njulia> DelaunayTriangulation.fix_segments!(segments, bad_indices)\n9-element Vector{Tuple{Int64, Int64}}:\n (2, 7)\n (7, 12)\n (12, 17)\n (17, 22)\n (22, 27)\n (27, 32)\n (32, 37)\n (37, 42)\n (42, 47)\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_vertex_closer_than_neighbours-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Vararg{Any, 5}}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_vertex_closer_than_neighbours","text":"is_vertex_closer_than_neighbours([predicates::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, jᵢ, jᵢ₋₁, jᵢ₊₁) -> Bool\nis_vertex_closer_than_neighbours([predicates::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, list::ShuffledPolygonLinkedList, u, v, j) -> Bool\n\nTests if the vertex jᵢ is closer to the line (u, v) than its neighbours jᵢ₋₁ and jᵢ₊₁, assuming all these  vertices are to the left of the line.\n\nSee also point_closest_to_line.\n\nArguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\ntri::Triangulation: The Triangulation.\nu, v: The vertices of the line. \njᵢ, jᵢ₋₁, jᵢ₊₁: The vertices to compare. \n\nThe second method extracts these latter two vertices using the doubly-linked list of vertices.\n\nOutputs\n\nflag: Whether jᵢ is closer to the line than jᵢ₋₁ and jᵢ₊₁.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.locate_intersecting_triangles","page":"Algorithm Internals","title":"DelaunayTriangulation.locate_intersecting_triangles","text":"locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true), rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Vector, Vector, Vector, Vector)\n\nFind all the triangles intersected by an edge e.\n\nSee also find_triangle.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ne: The edge going through the triangulation.\nrotate=Val(true): Whether to rotate the edge so that the minimum degree vertex of e is first.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nintersecting_triangles: The intersected triangles. \ncollinear_segments: Segments that are collinear with e.\nleft_vertices: The vertices of the intersected triangles that are left of e.\nright_vertices: The vertices of the intersected triangles that are right of e.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.merge_segments-Union{Tuple{Es}, Tuple{Any, Any, Es}} where Es","page":"Algorithm Internals","title":"DelaunayTriangulation.merge_segments","text":"merge_segments(tri::Triangulation, ghost_vertex_map) -> Edges\n\nCreates a set of edges that merge all the boundary nodes in tri as well as its interior segments into a single collection. \n\nArguments\n\ntri::Triangulation: The Triangulation.\nghost_vertex_map: The ghost vertex map to use.\n\nOutputs\n\nall_segments: The set of edges that merge all the boundary nodes in tri as well as its interior segments into a single collection, with type equal to that of get_interior_segments(tri)'s.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.prepare_vertex_linked_list-Union{Tuple{AbstractArray{I}}, Tuple{I}} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.prepare_vertex_linked_list","text":"prepare_vertex_linked_list(V) -> ShuffledPolygonLinkedList\n\nGiven a list of polygon vertices V, returns the doubly-linked list of polygon vertices.\n\nArguments\n\nV: The list of polygon vertices.\n\nOutputs\n\nlist::ShuffledPolygonLinkedList: A ShuffledPolygonLinkedList. In list, prev[begin], prev[end], next[begin], and next[end] are all 0  as are shuffled_indices[begin] and shuffled_indices[end]. Moreover, shuffled_indices will not have been shuffled yet.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.process_collinear_segments!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.process_collinear_segments!","text":"process_intersecting_triangles!(tri::Triangulation, e, collinear_segments; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng()) -> Bool\n\nGiven segments in collinear_segments that are collinear with an edge e, updates tri so that this edge e is instead  split so that it is instead represented by collinear_segments. These new segments will be placed into the triangulation using  add_segment!. Returns !isempty(collinear_segments).\n\nThe predicates::AbstractPredicateKernel argument defines the method for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nSee also connect_segments!, extend_segments!, split_segment! and split_boundary_edge_at_collinear_segments!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.remake_triangulation_with_constraints-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.remake_triangulation_with_constraints","text":"remake_triangulation_with_constraints(tri::Triangulation, segments, boundary_nodes) -> (Dict, Dict, Triangulation)\n\nRemakes the triangulation tri so that it contains segments and boundary_nodes in its fields.\n\nSee also replace_ghost_vertex_information.\n\nArguments\n\ntri::Triangulation: The triangulation to remake.\nsegments: The segments to add to the triangulation.\nboundary_nodes: The boundary nodes to add to the triangulation.\n\nOutputs\n\nnew_ghost_vertex_map: The new ghost vertex map. This will not yet be added to the triangulation.\nnew_ghost_vertex_ranges: The new ghost vertex ranges. This will not yet be added to the triangulation.\nnew_tri::Triangulation: The new triangulation, now containing boundary_nodes in the boundary_nodes field and segments in the interior_segments field.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.replace_ghost_vertex_information","page":"Algorithm Internals","title":"DelaunayTriangulation.replace_ghost_vertex_information","text":"replace_ghost_vertex_information(tri::Triangulation, ghost_vertex_map, ghost_vertex_ranges, polygon_hierarchy) -> Triangulation\n\nReplaces the ghost vertex information in tri with ghost_vertex_map and ghost_vertex_ranges, using the results from  remake_triangulation_with_constraints.\n\nArguments\n\ntri::Triangulation: The triangulation to remake.\nghost_vertex_map: The ghost vertex map to add to the triangulation.\nghost_vertex_ranges: The ghost vertex ranges to add to the triangulation.\npolygon_hierarchy: The polygon hierarchy to add to the triangulation.\n\nOutputs\n\nnew_tri::Triangulation: The new triangulation, now containing ghost_vertex_map in the ghost_vertex_map field and ghost_vertex_ranges in the ghost_vertex_ranges field.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.retriangulate_fan!-Tuple{Triangulation, Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.retriangulate_fan!","text":"retriangulate_fan!(tri::Triangulation, tri_fan::Triangulation, fan, fan_triangles; predicates::AbstractPredicateKernel=AdaptiveKernel(), rng::Random.AbstractRNG=Random.default_rng())\n\nGiven a sorted set of vertices fan in a fan of triangles associated with fan_triangles, retriangulates the fan, updating tri to do so and  using tri_fan as a temporary triangulation. (This implements Lines 17–19 and Line 28 of the algorithms in this paper.)\n\nThe predicates argument defines the method for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.select_random_vertex-Tuple{Triangulation, DelaunayTriangulation.ShuffledPolygonLinkedList, Any, Any, Any, Random.AbstractRNG, DelaunayTriangulation.AbstractPredicateKernel}","page":"Algorithm Internals","title":"DelaunayTriangulation.select_random_vertex","text":"select_random_vertex(tri::Triangulation, list::ShuffledPolygonLinkedList, u, v, range, rng) -> Vertex\n\nSelects a random vertex that is not closer to the line (u, v) than both of its neighbours.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nlist::ShuffledPolygonLinkedList: The linked list of polygon vertices.\nu, v: The vertices of the line.\nrange: The range of indices of the vertices to select from.\nrng::Random.AbstractRNG: The random number generator to use.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nj: The selected vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.setup_cavity_cdt-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.setup_cavity_cdt","text":"setup_cavity_cdt(tri::Triangulation, V; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -> ShuffledPolygonLinkedList\n\nPrepares the linked list required for triangulating a cavity excavated by segment insertion in a constrained triangulation.\n\nSee also prepare_vertex_linked_list and delete_polygon_vertices_in_random_order!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nV: The list of polygon vertices, given as a counter-clockwise list of vertices, defining the cavity. \n\nKeyword Arguments\n\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nlist::ShuffledPolygonLinkedList: The linked list of polygon vertices representing the cavity.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.sort_fan!-Tuple{Any, Any, Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.sort_fan!","text":"sort_fan!(fan, fan_triangles, tri::Triangulation)\n\nGiven a set of triangles in a fan, fan_triangles, associated with some triangulation tri, places all the triangle vertices  and sorts them counter-clockwise, placing the results into fan.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_marked_vertices!-Tuple{Any, Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_marked_vertices!","text":"split_marked_vertices!(fan_triangles, tri::Triangulation, marked_vertices)\n\nGiven a set of marked_vertices indicating a crossed triangle (like in Figure 9 of this paper), finds all triangles whose three vertices are all in marked_vertices and places them into fan_triangles. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_segment!-Tuple{Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_segment!","text":"split_segment!(tri::Triangulation, segment, collinear_segments)\nsplit_segment!(segments, segment, collinear_segments)\n\nSplits segment at the segments in collinear_segments, which are assumed to be collinear with segment.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nsegments: The underlying set of segments. This is get_interior_segments(tri) if tri is a Triangulation.\nsegment: The segment to split.\ncollinear_segments: The segments that are collinear with segment.\n\nOutputs\n\nThere is no output, as segments is updated in-place.\n\nExample\n\njulia> using DelaunayTriangulation\n\njulia> segments = Set(((2, 3), (3, 5), (10, 12)))\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (2, 3)\n  (3, 5)\n  (10, 12)\n\njulia> collinear_segments = [(2, 10), (11, 15), (2, 3)]\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 10)\n (11, 15)\n (2, 3)\n\njulia> segment = (3, 5)\n(3, 5)\n\njulia> DelaunayTriangulation.split_segment!(segments, segment, collinear_segments)\nSet{Tuple{Int64, Int64}} with 4 elements:\n  (2, 10)\n  (2, 3)\n  (11, 15)\n  (10, 12)\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.triangulate_cavity_cdt!-Tuple{Triangulation, Any, Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.triangulate_cavity_cdt!","text":"triangulate_cavity_cdt!(tri::Triangulation, V, marked_vertices; rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nTriangulates the cavity V left behind when deleting triangles intersected in a triangulation by an edge, updating tri to do so.\n\nArguments\n\ntri::Triangulation: The Triangulation to update. This should be an empty triangulation.\nV: The list of polygon vertices, given as a counter-clockwise list of vertices, defining the cavity.\ntri_fan::Triangulation: The Triangulation to use for the fan of triangles to be re-triangulated. This should be an empty triangulation.\nmarked_vertices: Cache for marking vertices to re-triangulate during the triangulation.\nfan_triangles: A cache used for sorting and identifying triangles in a fan for retriangulation.\n\nKeyword Arguments\n\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use or setup_cavity_cdt.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, but tri is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.each_boundary_edge-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.each_boundary_edge","text":"each_boundary_edge(tri::Triangulation) -> KeySet\n\nReturns an iterator over the boundary edges of tri, in no specific order.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation, ij) \nget_boundary_edge_map(tri::Triangulation, i, j)\n\nReturns the value from the key (i, j) in the boundary edge map of tri. The returned value is a Tuple  (position, index) so that boundary_nodes = get_boundary_nodes(tri, position) are the boundary nodes associated  with the section that (i, j) resides on, and i = get_boundary_nodes(boundary_nodes, index) and  j = get_boundary_nodes(boundary_nodes, index + 1).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_boundary_edge_map!-Union{Tuple{T}, Tuple{E}, Tuple{Dict{E, T}, Vararg{Any, 4}}} where {E, T}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_boundary_edge_map!","text":"split_boundary_edge_map!(boundary_edge_map, boundary_nodes, pos)\n\nAfter splitting an edge starting at pos on the boundary, updates the boundary_edge_map to reflect the new boundary edges. See split_boundary_edge!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.contains_boundary_edge-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.contains_boundary_edge","text":"contains_boundary_edge(tri::Triangulation, ij) -> Bool \ncontains_boundary_edge(tri::Triangulation, i, j) -> Bool\n\nReturns true if the boundary edge (i, j) is in tri, and false otherwise. Orientation matters here.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_boundary_node!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(tri::Triangulation, pos)\n\nDeletes the boundary node at the specified position pos in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\npos: The position to delete the node at, given as a Tuple so that delete_boundary_node!(tri, pos) is the same as deleteat!(get_boundary_nodes(tri, pos[1]), pos[2]).\n\nOutputs\n\nThere are no outputs, but the boundary nodes of tri are updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_all_boundary_nodes-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_all_boundary_nodes","text":"get_all_boundary_nodes(tri::Triangulation) -> Set{Vertex}\n\nReturns the set of all boundary vertices in tri, in no specific order.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg{Any}}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri, mnℓ...)\n\nGiven a triangulation tri, returns the specified component of the boundary nodes. There are several forms for the methods:\n\nget_boundary_nodes(tri, m): If tri has multiple curves, this returns the mth curve. If tri has multiple sections, this returns the mth section. Otherwise, this returns the mth boundary node.\nget_boundary_nodes(tri, m, n): If tri has multiple curves, this returns the nth section of the mth curve. Otherwise, if tri has multiple sections, this returns the nth boundary node of the mth section.\nget_boundary_nodes(tri, (m, n)): This is equivalent to get_boundary_nodes(tri, m, n).\nget_boundary_nodes(tri::A, ::A): This just returns boundary_nodes.  \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(tri::Triangulation, k, ghost_vertex) -> Vertex\n\nReturns the boundary node to the left of the vertex k in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex.\nghost_vertex: The ghost vertex associated with the boundary section that k is on.\n\nOutputs\n\nℓ: The vertex left of k on the boundary.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(tri::Triangulation, k, ghost_vertex) -> Vertex\n\nReturns the boundary node to the right of the vertex k in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex. \nghost_vertex: The ghost vertex associated with the boundary section that k is on. \n\nOutputs\n\nr: The vertex right of k on the boundary. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.insert_boundary_node!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(tri::Triangulation, pos, node)\n\nInserts a boundary node into tri at the specified position.\n\nArguments\n\ntri::Triangulation: The Triangulation.\npos: The position to insert the node at, given as a Tuple so that insert_boundary_node!(tri, pos, node) is the same as insert!(get_boundary_nodes(tri, pos[1]), pos[2], node).\nnode: The node to insert.\n\nOutputs\n\nThere are no outputs, but the boundary nodes of tri are updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_positively_oriented-Tuple{Triangulation, Integer}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_positively_oriented","text":"is_positively_oriented(tri::Triangulation, curve_index) -> Bool\n\nTests if the curve_indexth curve in tri is positively oriented, returning true if so and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.merge_boundary_edge!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.merge_boundary_edge!","text":"merge_boundary_edge!(tri::Triangulation, ij, node)\nmerge_boundary_edge!(tri::Triangulation, i, j, node)\n\nMerges the edges (i, node) and (node, j) into a single edge (i, j), i.e. does the inverse operation to split_boundary_edge!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_curves-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_curves","text":"num_curves(tri::Triangulation) -> Integer\n\nReturns the number of curves in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_sections-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_sections","text":"num_sections(tri::Triangulation) -> Integer\n\nAssuming tri only has one curve, returns the number of sections in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_boundary_edge!","text":"split_boundary_edge!(tri::Triangulation, ij, node)\nsplit_boundary_edge!(tri::Triangulation, i, j, node)\n\nSplits the boundary edge edge in tri at the edge (i, j).\n\nSee also merge_boundary_edge!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_boundary_edge_at_collinear_segments!","text":"split_boundary_edge_at_collinear_segments!(tri::Triangulation, collinear_segments)\n\nSplits a boundary edge into pieces defined by collinear_segments. In particular, if r = collinear_segments and\n\nu = initial(r[1])\nv = terminal(r[end]),\n\nthen the boundary edge is (u, v) and the edges are split so that all segments in collinear_segments appear instead.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_disjoint-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_disjoint","text":"is_disjoint(tri::Triangulation) -> Bool\n\nReturns true if tri has disjoint exterior boundary curves, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_exterior_curve-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_exterior_curve","text":"is_exterior_curve(tri::Triangulation, curve_index) -> Bool\n\nReturns true if the curve_indexth curve in tri is an exterior curve, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_interior_curve-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_interior_curve","text":"is_interior_curve(tri::Triangulation, curve_index) -> Bool\n\nReturns true if the curve_indexth curve in tri is an interior curve, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_exterior_curves-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_exterior_curves","text":"num_exterior_curves(tri::Triangulation) -> Integer\n\nReturns the number of exterior curves in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(tri::Triangulation, ℓ) -> Integer\n\nReturns the curve index corresponding to the ghost vertex ℓ in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_section_index-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_section_index","text":"get_section_index(tri::Triangulation, ℓ) -> Integer\n\nReturns the section index corresponding to the ghost vertex ℓ in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_exterior_ghost_vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_exterior_ghost_vertex","text":"is_exterior_ghost_vertex(tri::Triangulation, i) -> Bool\n\nReturns true if the ghost vertex i in tri is an exterior ghost vertex, and false otherwise. \n\nSee also is_ghost_vertex and is_interior_ghost_vertex.\n\nExtended help\n\nAn exterior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the exterior boundary.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_interior_ghost_vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_interior_ghost_vertex","text":"is_interior_ghost_vertex(tri::Triangulation, i) -> Bool\n\nReturns true if the ghost vertex i in tri is an interior ghost vertex, and false otherwise.\n\nSee also is_ghost_vertex and is_exterior_ghost_vertex.\n\nExtended help\n\nAn interior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the interior boundary.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.map_ghost_vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.map_ghost_vertex","text":"map_ghost_vertex(tri::Triangulation, ℓ) -> Vertex\n\nGiven a ghost vertex ℓ in tri, returns the corresponding section in the  boundary_nodes of tri. See also get_ghost_vertex_map.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.all_ghost_vertices-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.all_ghost_vertices","text":"all_ghost_vertices(tri::Triangulation) -> KeySet\n\nReturns the set of all ghost vertices in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_ghost_vertex_range-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_ghost_vertex_range","text":"get_ghost_vertex_range(tri::Triangulation, ℓ) -> UnitRange\n\nGiven a ghost vertex ℓ of tri, returns the range of all  ghost vertices corresponding to the same curve or section as ℓ does.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_boundary_nodes(tri), precision=one(number_type(tri)))\n\nComputes a new set of representative points for tri.\n\nArguments\n\ntri::Triangulation: The Triangulation for which to compute the representative points.\n\nKeyword Arguments\n\nuse_convex_hull=!has_boundary_nodes(tri): If true, then the representative points are computed using the convex hull of the triangulation. Otherwise, the representative points are computed using the boundary nodes of the triangulation.\nprecision=one(number_type(tri)): The precision to use when computing the representative points via pole_of_inaccessibility.\n\nOutput\n\nThere are no outputs as tri is updated in-place, but for each curve the representative point is computed using pole_of_inaccessibility.\n\nwarning: Exterior curves\nWhile get_exterior_curve_indices(tri) does store the curves corresponding to exterior curves, this function still treats the first  curve as the most important exterior curve, computing the representative point so that it is in no holes. In particular, other exterior curves  might have representative points that are in a hole of one of their interior holes. This isn't much of a problem, indeed it wouldn't be a significant  problem even if we had the representative point in a hole of the first curve, but it is something to be aware of.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.empty_representative_points!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.empty_representative_points!","text":"empty_representative_points!(tri::Triangulation)\n\nEmpties the Dict of representative points of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_representative_point_coordinates-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_representative_point_coordinates","text":"get_representative_point_coordinates(tri::Triangulation, curve_index) -> NTuple{2, Number}\n\nReturns the coordinates of the representative point of the curve_indexth curve in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.new_representative_point!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.new_representative_point!","text":"new_representative_point!(tri::Triangulation, curve_index)\n\nCreates a new representative point for the curve_indexth curve in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.reset_representative_points!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.reset_representative_points!","text":"reset_representative_points!(tri::Triangulation)\n\nResets each representative point of tri to the origin.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.update_centroid_after_addition!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.update_centroid_after_addition!","text":"update_centroid_after_addition!(tri::Triangulation, curve_index, p)\n\nUpdates the centroid of the curve_indexth curve in tri after the addition of the point p.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.update_centroid_after_deletion!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.update_centroid_after_deletion!","text":"update_centroid_after_deletion!(tri::Triangulation, curve_index, p)\n\nUpdates the centroid of the curve_indexth curve in tri after the deletion of the point p.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.contains_segment-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.contains_segment","text":"contains_segment(tri::Triangulation, ij) -> Bool \ncontains_segment(tri::Triangulation, i, j) -> Bool\n\nReturns true if (i, j) is a segment in tri, and false otherwise. Both (i, j) and (j, i) are checked.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.each_segment-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.each_segment","text":"each_segment(tri::Triangulation) -> Edges\n\nReturns an iterator over all segments in tri. This includes both interior and boundary segments. If you only want  interior segments, then see get_interior_segments,\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Weighted-Triangulations","page":"Algorithm Internals","title":"Weighted Triangulations","text":"","category":"section"},{"location":"extended/algorithms/#DelaunayTriangulation.add_weight!-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_weight!","text":"add_weight!(weights, w)\n\nPushes the weight w into weights. The default definition for this is push!(weights, w).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_weight!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_weight!","text":"add_weight!(tri::Triangulation, w)\n\nPushes the weight w into the weights of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_distance_to_witness_plane-Tuple{DelaunayTriangulation.AbstractPredicateKernel, Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_distance_to_witness_plane","text":"\"     getdistancetowitnessplane([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i, V; cache = nothing) -> Number\n\nComputes the distance between the lifted companion of the vertex i and the witness plane to the triangle V. If V is a ghost triangle  and i is not on its solid edge, then the distance is -Inf if it is below the ghost triangle's witness plane and Inf if it is above. If V is a ghost triangle and i  is on its solid edge, then the distance returned is the distance associated with the solid triangle adjoining V.\n\nIn general, the distance is positive if the lifted vertex is above the witness plane, negative if it is below,  and zero if it is on the plane.\n\nThe kernel argument determines how this result is computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is passed to [point_position_relative_to_circumcircle]. Please see the documentation for that function for more information.\n\nSee also point_position_relative_to_witness_plane and get_distance_to_plane.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_lifted_point-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_lifted_point","text":"get_lifted_point(p, w) -> NTuple{3, Number}\n\nReturns the lifted companion of the point p, in particular (x, y, x^2 + y^2 - w), where (x, y) is p.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_lifted_point-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_lifted_point","text":"get_lifted_point(tri::Triangulation, i) -> NTuple{3, Number}\n\nReturns the lifted companion of the ith vertex of tri, in particular (x, y, x^2 + y^2 - w), where w is the ith weight of tri and (x, y) is the ith point of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_power_distance-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_power_distance","text":"get_power_distance(tri::Triangulation, i, j) -> Number\n\nReturns the power distance between vertices i and j, defined by  ||pᵢ - pⱼ||^2 - wᵢ - wⱼ, where wᵢ and wⱼ are the respective weights.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_weight-Tuple{Any, Integer}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_weight","text":"get_weight(weights, i) -> Number\n\nGets the ith weight from weights. The default definition for this is weights[i], but this can be extended - e.g., ZeroWeight uses get_weight(weights, i) = 0.0.\n\nIf i is not an integer, then the default definition is is_point3(i) ? i[3] : zero(number_type(weights)).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_weight-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_weight","text":"get_weight(tri::Triangulation, i) -> Number\n\nGets the ith weight from tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_weighted_nearest_neighbour","page":"Algorithm Internals","title":"DelaunayTriangulation.get_weighted_nearest_neighbour","text":"get_weighted_nearest_neighbour(tri::Triangulation, i, j = rand(each_solid_vertex(tri))) -> Vertex\n\nUsing a greedy search, finds the closest vertex in tri to the vertex i (which might not already be in tri),  measuring distance in lifted space (i.e., using the power distance - see get_power_distance).  The search starts from the vertex j which should be in tri. \n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_submerged","page":"Algorithm Internals","title":"DelaunayTriangulation.is_submerged","text":"is_submerged([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i; cache = nothing) -> Bool \nis_submerged([kernel::AbstractPredicateKernel = AdaptiveKernel(), ] tri::Triangulation, i, V; cache = nothing) -> Bool\n\nReturns true if the vertex i is submerged in tri and false otherwise. In the  second method, V is a triangle containing tri.\n\nThe kernel argument determines how this result is computed, and should be one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\nThe cache keyword argument is passed to [point_position_relative_to_circumcircle]. Please see the documentation for that function for more information.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_weighted-Tuple{DelaunayTriangulation.ZeroWeight}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_weighted","text":"is_weighted(weights) -> Bool\n\nReturns true if weights represents a set of weights that are not all zero, and false otherwise. Note that even for vectors like zeros(n), this will return true; by default, false is returned only for  weights = ZeroWeight().\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Mesh-Refinement","page":"Algorithm Internals","title":"Mesh Refinement","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions involved with mesh refinement.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation._split_subsegment_curve_bounded!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation._split_subsegment_curve_bounded!","text":"_split_subsegment_curve_bounded!(tri::Triangulation, args::RefinementArguments, e)\n\nSplits a subsegment e of tri at a position determined by split_subcurve! for curve-bounded domains. See  split_subsegment!. See also _split_subsegment_curve_bounded_standard! and _split_subsegment_curve_bounded_small_angle!, as well as the original functions _split_subsegment_curve_standard! and _split_subcurve_complex!, respectively, used during boundary enrichment.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation._split_subsegment_piecewise_linear!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation._split_subsegment_piecewise_linear!","text":"_split_subsegment_piecewise_linear!(tri::Triangulation, args::RefinementArguments, e)\n\nSplits a subsegment e of tri at a position determined by compute_split_position for piecewise linear domains. See split_subsegment!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.assess_added_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.assess_added_triangles!","text":"assess_added_triangles!(args::RefinementArguments, tri::Triangulation)\n\nAssesses the quality of all triangles in args.events.added_triangles according to assess_triangle_quality, and enqueues any bad quality triangles into args.queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.assess_triangle_quality-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.assess_triangle_quality","text":"assess_triangle_quality(tri::Triangulation, args::RefinementArguments, T) -> Float64, Bool\n\nAssesses the quality of a triangle T of tri according to the RefinementArguments.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nargs::RefinementArguments: The RefinementArguments.\nT: The triangle.\n\nOutput\n\nρ: The radius-edge ratio of the triangle.\nflag: Whether the triangle is bad quality.\n\nA triangle is bad quality if it does not meet the area constraints, violates the custom constraint, or if it is skinny but neither seditious or nestled.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.balanced_power_of_two_quarternary_split-Tuple{Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.balanced_power_of_two_quarternary_split","text":"balanced_power_of_two_quarternary_split(ℓ) -> Float\n\nReturns the value of s ∈ [0, ℓ] that gives the most balanced quarternary split of the segment pq, so s is a power-of-two and s ∈ [ℓ / 4, ℓ / 2].\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.balanced_power_of_two_ternary_split-Tuple{Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.balanced_power_of_two_ternary_split","text":"balanced_power_of_two_ternary_split(ℓ) -> Float64\n\nReturns the value of s ∈ [0, ℓ] that gives the most balanced ternary split of the segment pq, so s is a power-of-two  and s ∈ [ℓ / 3, 2ℓ / 3].\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_for_invisible_steiner_point-Tuple{Triangulation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_for_invisible_steiner_point","text":"check_for_invisible_steiner_point(tri::Triangulation, V, T, flag, c) -> Point, Triangle\n\nDetermines if the Steiner point c's insertion will not affect the quality of T, and if so instead changes c to be T's centroid.\n\nArguments\n\ntri::Triangulation: The Triangulation to split a triangle of.\nV: The triangle that the Steiner point is in.\nT: The triangle that the Steiner point is from.\nflag: A Certificate which is Cert.On if the Steiner point is on the boundary of V, Cert.Outside if the Steiner point is outside of V, and Cert.Inside if the Steiner point is inside of V.\nc: The Steiner point.\n\nOutput\n\nc′: The Steiner point to use instead of c, which is T's centroid if c is not suitable.\nV′: The triangle that the Steiner point is in, which is T if c is not suitable.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_for_steiner_point_on_segment-Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_for_steiner_point_on_segment","text":"check_for_steiner_point_on_segment(tri::Triangulation, V, V′, new_point, flag, predicates::AbstractPredicateKernel) -> Bool\n\nChecks if the Steiner point with vertex new_point is on a segment. If so, then its vertex is pushed into the offcenter-split list from args, indicating that it should no longer be regarded as a free vertex (see is_free).\n\nArguments\n\ntri::Triangulation: The Triangulation.\nV: The triangle that the Steiner point was originally in prior to check_for_invisible_steiner_point.\nV′: The triangle that the Steiner point is in.\nnew_point: The vertex associated with the Steiner point.\nflag: A Certificate which is Cert.On if the Steiner point is on the boundary of V, Cert.Outside if the Steiner point is outside of V, and Cert.Inside if the Steiner point is inside of V.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nonflag: Whether the Steiner point is on a segment or not.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_seditious_precision-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_seditious_precision","text":"check_seditious_precision(ℓrp, ℓrq) -> Bool\n\nChecks if there are precision issues related to the seditiousness of a triangle, returning true if so and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_split_subsegment_precision-NTuple{4, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_split_subsegment_precision","text":"check_split_subsegment_precision(mx, my, p, q) -> Bool\n\nChecks if there are precision issues related to the computed split position (mx, my) of a segment (p, q),  returning true if so and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_steiner_point_precision-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_steiner_point_precision","text":"check_steiner_point_precision(tri::Triangulation, T, c) -> Bool\n\nChecks if the Steiner point c of a triangle T of tri can be computed without precision issues, returning true if there are precision issues and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compute_concentric_shell_quarternary_split_position-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.compute_concentric_shell_quarternary_split_position","text":"compute_concentric_shell_quarternary_split_position(p, q) -> Float64\n\nReturns the value of t ∈ [0, 1] that gives the most balanced quarternary split of the segment pq, so that one of the segments has a power-of-two length between 1/4 and 1/2 of the length of pq.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compute_concentric_shell_ternary_split_position-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.compute_concentric_shell_ternary_split_position","text":"compute_concentric_shell_ternary_split_position(p, q) -> Float64\n\nReturns the value of t ∈ [0, 1] that gives the most balanced ternary split of the segment pq, so that one of the  segments has a power-of-two length and both segments have lengths between 1/3 and 2/3 of the length of pq.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compute_split_position-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.compute_split_position","text":"compute_split_position(tri::Triangulation, args::RefinementArguments, e) -> NTuple{2, Float}\n\nComputes the position to split a segment e of tri at in split_subsegment!. \n\nArguments\n\ntri::Triangulation: The Triangulation to split a segment of.\nargs::RefinementArguments: The RefinementArguments for the refinement.\ne: The segment to split.\n\nOutput\n\nmx, my: The position to split the segment at.\n\nThis point is computed according to a set of rules:\n\nIf e is not a subsegment, meaning it is an input segment, then its midpoint is returned.\nIf e is a subsegment and the segment adjoins two other distinct segments (one for each vertex) at an acute angle, as determined by  segment_vertices_adjoin_other_segments_at_acute_angle, then the point is returned so that e can be split such that one of the new subsegments has a power-of-two  length between 1/4 and 1/2 of the length of e, computed using compute_concentric_shell_quarternary_split_position.\nIf e is a subsegment and the segment adjoins one other segment at an acute angle, as determined by  segment_vertices_adjoin_other_segments_at_acute_angle, then the point is returned so that e can be split such that one of the new subsegments has a power-of-two  length between 1/3 and 2/3 of the length of e, computed using compute_concentric_shell_ternary_split_position.\nOtherwise, the midpoint is returned.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_free_vertices_around_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_free_vertices_around_subsegment!","text":"delete_free_vertices_around_subsegment!(tri::Triangulation, args::RefinementArguments, e)\n\nDeletes all free vertices (i.e., Steiner points) contained in the diametral circle of e.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nargs::RefinementArguments: The RefinementArguments.\ne: The segment.\n\nOutput\n\nThe free vertices are deleted from tri in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.encroaches_upon-Tuple{Any, Any, Any, DelaunayTriangulation.RefinementArguments}","page":"Algorithm Internals","title":"DelaunayTriangulation.encroaches_upon","text":"encroaches_upon(p, q, r, args::RefinementArguments) -> Bool\n\nDetermines if a point r encroaches upon a segment pq according to the RefinementArguments.\n\nSee also point_position_relative_to_diametral_circle and point_position_relative_to_diametral_lens.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.enqueue_all_bad_triangles!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.enqueue_all_bad_triangles!","text":"enqueue_all_bad_triangles!(args::RefinementArguments, tri::Triangulation)\n\nEnqueues all bad triangles in the triangulation into args.queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.enqueue_all_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.enqueue_all_encroached_segments!","text":"enqueue_all_encroached_segments!(args::RefinementArguments, tri::Triangulation)\n\nEnqueues all encroached segments in the triangulation into args.queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.enqueue_newly_encroached_segments!-Tuple{DelaunayTriangulation.RefinementArguments, Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.enqueue_newly_encroached_segments!","text":"enqueue_newly_encroached_segments!(args::RefinementArguments, tri::Triangulation) -> Bool\n\nEnqueues all segments that are newly encroached upon after a point insertion into the triangulation into args.queue.\n\nArguments\n\nargs::RefinementArguments: The RefinementArguments for the refinement.\ntri::Triangulation: The Triangulation to enqueue newly encroached segments of.\n\nOutput\n\nany_encroached: Whether any segments were newly encroached upon.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.finalise!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}","page":"Algorithm Internals","title":"DelaunayTriangulation.finalise!","text":"finalise!(tri::Triangulation, args::RefinementArguments)\n\nFinalises the triangulation after refinement, e.g. by deleting ghost triangles and unlocking the convex hull if needed.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_init_for_steiner_point-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_init_for_steiner_point","text":"get_init_for_steiner_point(tri::Triangulation, T) -> Vertex\n\nGets the initial vertex to start the search for the Steiner point of a triangle T of tri in get_steiner_point. The  initial vertex is chosen so that it is opposite the longest edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_steiner_point","text":"get_steiner_point(tri::Triangulation, args::RefinementArguments, T) -> Certificate, Point\n\nComputes the Steiner point for a triangle T of tri to improve its quality in split_triangle!.\n\nArguments\n\ntri::Triangulation: The Triangulation to split a triangle of.\nargs::RefinementArguments: The RefinementArguments for the refinement.\nT: The triangle to split.\n\nOutput\n\nprecision_flag: A Certificate which is Cert.PrecisionFailure if the Steiner point could not be computed due to precision issues, and Cert.None otherwise.\nc: The Steiner point. If is_precision_failure(precision_flag), then this is just an arbitrary point of T to ensure type stability.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_encroached-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_encroached","text":"is_encroached(tri::Triangulation, args::RefinementArguments, edge) -> Bool\n\nDetermines if a segment edge of tri is encroached upon.\n\nSee also encroaches_upon.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_triangle_nestled-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_triangle_nestled","text":"is_triangle_nestled(tri::Triangulation, T, idx) -> Bool\n\nDetermines if a triangle T of tri is nestled in the corner of a small input angle.\n\nSee also is_triangle_seditious.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nT: The triangle.\nidx: The index of the smallest edge of the triangle, so that 1 means uv is the smallest edge, 2 means vw is the smallest edge, and 3 means wu is the smallest edge.\n\nOutput\n\nflag: Whether the triangle is nestled in the corner of a small input angle.\n\nA triangle is nestled in the corner of a small input angle if it is nestled in the corner of a small input angle and the shortest edge is seditious. The size of the angle is not checked by this function, and is instead determined by assess_triangle_quality.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_triangle_seditious","text":"is_triangle_seditious(tri::Triangulation, args, u, v, w, smallest_idx) -> Bool\n\nDetermines if a triangle uvw of tri is seditious according to the RefinementArguments.\n\nSee also is_triangle_nestled.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nargs: The RefinementArguments.\nu, v, w: The vertices of the triangle.\nsmallest_idx: The index of the smallest edge of the triangle, so that 1 means uv is the smallest edge, 2 means vw is the smallest edge, and 3 means wu is the smallest edge.\n\nOutput\n\nflag: Whether the triangle is seditious.\n\nA triangle is seditious if it is nestled in the corner of a small input angle, or if it is nestled in the corner of a small input angle and the shortest edge is seditious. Here, 'small' is defined by  args.constraints.seditious_angle.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.locate_steiner_point-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.locate_steiner_point","text":"locate_steiner_point(tri::Triangulation, args::RefinementArguments, T, c) -> Triangle, Cert\n\nLocates the Steiner point c of a triangle T of tri in get_steiner_point. The Steiner point is located by walking from the initial vertex init to c using find_triangle.\n\nArguments\n\ntri::Triangulation: The Triangulation to split a triangle of.\nargs::RefinementArguments: The RefinementArguments for the refinement.\nT: The triangle that the Steiner point is from.\nc: The Steiner point.\n\nOutput\n\nV: The triangle that the Steiner point is in.\nflag: A Certificate which is Cert.On if the Steiner point is on the boundary of V, Cert.Outside if the Steiner point is outside of V, and Cert.Inside if the Steiner point is inside of V.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.refine!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.refine!","text":"refine!(tri::Triangulation; kwargs...)\n\nRefines the given Triangulation tri to meet the given quality constraints.\n\nSee the documentation for more information about mesh refinement, e.g. convergence issues and issues with small input-angles.\n\nArguments\n\ntri::Triangulation: The Triangulation to refine.\n\nKeyword Arguments\n\nmin_angle=30.0: The minimum angle constraint, in degrees.\nmax_angle=180.0: The maximum angle constraint, in degrees. \n\ndanger: Maximum angle constraints\nMaximum angle constraints are not currently implemented.\n\nmin_area=get_area(tri) / 1e9: The minimum area constraint.\nmax_area=typemax(number_type(tri)): The maximum area constraint.\nmax_points=max(1_000, num_solid_vertices(tri))^2: The maximum number of vertices allowed in the triangulation. Note that this refers to num_solid_vertices, not the amount returned by num_points.\nseditious_angle=20.0: The angle at which a triangle is considered seditious, in degrees. See is_triangle_seditious.\ncustom_constraint=(tri, T) -> false: A custom constraint function that takes a Triangulation and a triangle, and returns true if the triangle should be refined and false otherwise.\nuse_circumcenter=true: Whether to insert circumcenters for refining a triangle or generalised Steiner points.\n\ndanger: Generalised Steiner points\nGeneralised Steiner points are not yet implemented. Thus, this argument must be true (and the steiner_scale keyword below is ignored).\n\nuse_lens=true: Whether to use the diametral lens or the diametral circle for checking encroachment.\nsteiner_scale=0.999: The perturbation factor to use for generalised Steiner points if use_circumcenter=false. (Not currently used - see above.)\nrng=Random.default_rng(): The random number generator to use in case it is needed during point location.\nconcavity_protection=false: Whether to use concavity protection or not for find_triangle. Most likely not needed, but may help in pathological cases.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nThe triangulation is refined in-place.\n\nwarning: Duplicate points and unused points\nDuring refinement, points are often deleted, which may often lead to points in get_points(tri) that do not  appear anywhere in the triangulation. (This is why we recommend e.g. each_solid_vertex over each_point.) Similarly, since points are deleted, when two triangles have a common circumcenter it might happen (if they are near an input segment) that a point is duplicated inside get_points(tri), in case one circumcenter was deleted previously.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.refine_itr!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}","page":"Algorithm Internals","title":"DelaunayTriangulation.refine_itr!","text":"refine_itr!(tri::Triangulation, args::RefinementArguments)\n\nPerforms a single iteration of the refinement algorithm.\n\nArguments\n\ntri::Triangulation: The Triangulation to refine.\nargs::RefinementArguments: The RefinementArguments for the refinement.\n\nOutput\n\nThe triangulation is refined in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle","page":"Algorithm Internals","title":"DelaunayTriangulation.segment_vertices_adjoin_other_segments_at_acute_angle","text":"segment_vertices_adjoin_other_segments_at_acute_angle(tri::Triangulation, e) -> Int, Vertex\n\nDetermines if the vertices of a segment e of tri adjoin other segments at an acute angle.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ne: The segment.\n\nOutput\n\nnum_adjoin: The number of vertices of e that adjoin other segments at an acute angle.\nadjoin_vert: The vertex of e that adjoins another segment at an acute angle if num_adjoin == 1, and ∅ otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.split_all_encroached_segments!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_all_encroached_segments!","text":"split_all_encroached_segments!(tri::Triangulation, args::RefinementArguments)\n\nSplits all encroached segments of tri according to split_subsegment! until no more encroached segments exist in args.queue.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_subsegment!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_subsegment!","text":"split_subsegment!(tri::Triangulation, args::RefinementArguments, e)\n\nSplits a subsegment e of tri at a position determined by compute_split_position; for curve-bounded domains,  the position is determined by split_subcurve!. After the split, assess_triangle_quality is used to  find any new bad quality triangles. Before splitting, all free vertices in the segment's diametral circle  are deleted using delete_free_vertices_around_subsegment!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_triangle!-Tuple{Triangulation, DelaunayTriangulation.RefinementArguments, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_triangle!","text":"split_triangle!(tri::Triangulation, args::RefinementArguments, T) -> Certificate\n\nSplits a bad triangle T of tri to improve its quality.\n\nArguments\n\ntri::Triangulation: The Triangulation to split a triangle of.\nargs::RefinementArguments: The RefinementArguments for the refinement.\nT: The triangle to split.\n\nOutput\n\ncert: A Certificate indicating whether the split was successful or not. In particular, returns one of:\nCert.SuccessfulInsertion: The triangle was split successfully.\nCert.EncroachmentFailure: The triangle was not split successfully as the newly inserted point encroached upon a segment.\nCert.PrecisionFailure: The triangle was not split successfully due to precision issues.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_encroachmentfailure","page":"Algorithm Internals","title":"DelaunayTriangulation.is_encroachmentfailure","text":"is_encroachmentfailure(cert::Certificate) -> Bool\n\nReturns true if cert is EncroachmentFailure, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_successfulinsertion","page":"Algorithm Internals","title":"DelaunayTriangulation.is_successfulinsertion","text":"is_successfulinsertion(cert::Certificate) -> Bool\n\nReturns true if cert is SuccessfulInsertion, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_failedinsertion","page":"Algorithm Internals","title":"DelaunayTriangulation.is_failedinsertion","text":"is_failedinsertion(cert::Certificate) -> Bool\n\nReturns true if cert is FailedInsertion, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_precisionfailure","page":"Algorithm Internals","title":"DelaunayTriangulation.is_precisionfailure","text":"is_precisionfailure(cert::Certificate) -> Bool\n\nReturns true if cert is PrecisionFailure, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#RTree","page":"Algorithm Internals","title":"RTree","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"The RTrees we work with during boundary enrichment have several functions associated with them.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.EnlargementValues","page":"Algorithm Internals","title":"DelaunayTriangulation.EnlargementValues","text":"EnlargementValues\n\nType for representing the values used in the minimisation of enlargement.\n\nFields\n\nenlargement::Float64: The enlargement of the bounding box of the child being compared with.\nidx::Int: The index of the child being compared with.\narea::Float64: The area of the child being compared with.\nbounding_box::BoundingBox: The bounding box being compared with for enlargement.\n\nConstructor\n\nEnlargementValues(enlargement, idx, area, bounding_box)\nEnlargementValues(bounding_box)\n\n\n\n\n\n","category":"type"},{"location":"extended/algorithms/#Base.append!-Union{Tuple{C}, Tuple{DelaunayTriangulation.AbstractNode, C}} where C","page":"Algorithm Internals","title":"Base.append!","text":"append!(node::AbstractNode, child)\n\nAppends child to node's children. Also updates node's bounding box.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Base.delete!-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}","page":"Algorithm Internals","title":"Base.delete!","text":"delete!(tree::RTree, id_bounding_box::DiametralBoundingBox)\n\nDeletes id_bounding_box from tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Base.insert!-Tuple{DelaunayTriangulation.AbstractNode, Any, DelaunayTriangulation.RTree}","page":"Algorithm Internals","title":"Base.insert!","text":"insert!(node::AbstractNode, child, tree::RTree) -> Bool\n\nInserts child into node in tree. Returns true if the tree's bounding boxes had to be adjusted and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Base.insert!-Tuple{DelaunayTriangulation.RTree, Any}","page":"Algorithm Internals","title":"Base.insert!","text":"insert!(tree::RTree, bounding_box[, level = 1]) -> Bool\n\nInserts bounding_box into tree. Returns true if the tree's bounding boxes had to be adjusted and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Base.iterate-Tuple{DelaunayTriangulation.RTreeIntersectionIterator}","page":"Algorithm Internals","title":"Base.iterate","text":"iterate(itr::RTreeIntersectionIterator, state...)\n\nIterate over the next state of itr to find more intersections with the bounding box in RTreeIntersectionIterator.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.collapse_after_deletion!-Tuple{DelaunayTriangulation.AbstractNode, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.collapse_after_deletion!","text":"collapse_after_deletion!(node::AbstractNode, tree::RTree, detached)\n\nCondenses tree after a deletion of one of node's children. The detached argument will contain the nodes that were detached from tree during the condensing process.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.detach!-Tuple{DelaunayTriangulation.AbstractNode, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.detach!","text":"detach!(node::AbstractNode, idx) -> Bool\n\nDetaches the idxth child of node. Returns true if the node's bounding box had to be adjusted and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_bounding_box-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.DiametralBoundingBox}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_bounding_box","text":"find_bounding_box(tree::RTree, id_bounding_box::DiametralBoundingBox) -> Tuple{Leaf{Branch}, Int}\n\nReturns the leaf node and the index in the leaf node's children that id_bounding_box is associated with.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_subtree-Tuple{Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_subtree","text":"find_subtree(tree, bounding_box, level) -> Union{Branch,Leaf{Branch}}\n\nReturns the subtree of tree at level that bounding_box should be inserted into.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, DelaunayTriangulation.BoundingBox}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::RTree, bounding_box::BoundingBox; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with bounding_box. cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_intersections-Tuple{DelaunayTriangulation.RTree, Tuple{var\"#s102\", var\"#s102\"} where var\"#s102\"<:Number}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_intersections","text":"get_intersections(tree::RTree, point::NTuple{2,<:Number}; cache_id=1) -> RTreeIntersectionIterator\n\nReturns an RTreeIntersectionIterator over the elements in tree that intersect with point, representing point  as a BoundingBox with zero width and height centered at point. cache_id must be 1 or 2, and determines what cache to use for the intersection query.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_next_child-Tuple{DelaunayTriangulation.AbstractNode, Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_next_child","text":"get_next_child(node::AbstractNode, start_idx, need_tests, itr::RTreeIntersectionIterator) -> Int, QueryResult\n\nReturns the index of the next child of node that intersects with the bounding box in itr and the QueryResult of the intersection.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.insert_detached!-Tuple{DelaunayTriangulation.RTree, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.insert_detached!","text":"insert_detached!(tree::RTree, detached)\n\nGiven the detached nodes from collapse_after_deletion!, inserts them back into tree.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.minimise_enlargement-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.minimise_enlargement","text":"minimise_enlargement(node, bounding_box) -> EnlargementValues\n\nReturns the EnlargementValues associated with the child of node that minimises the enlargement, where enlargement  is defined as the difference between the area of bounding_box and the area of the child's bounding box.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.overflow_insert!-Tuple{Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.overflow_insert!","text":"overflow_insert!(node, child, tree) -> Bool\n\nInserts child into node in tree when node is full. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.replace!-NTuple{5, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.replace!","text":"replace!(node::AbstractNode, left, right, original_bounding_box, tree::RTree)\n\nReplaces the node in tree with left and right. Returns true if the tree's bounding boxes had to be adjusted and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split!-Union{Tuple{N}, Tuple{N, Any}} where N","page":"Algorithm Internals","title":"DelaunayTriangulation.split!","text":"split!(node::AbstractNode, tree::RTree) -> Branch, Branch\n\nSplits node into two other nodes using a linear splitting rule. Returns the two new nodes.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_seeds-Tuple{Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_seeds","text":"split_seeds(node::AbstractNode) -> NTuple{2, Int}\n\nReturns the indices of two children in node used to initiate the split in split!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.test_intersection-Tuple{DelaunayTriangulation.AbstractNode, DelaunayTriangulation.RTreeIntersectionIterator}","page":"Algorithm Internals","title":"DelaunayTriangulation.test_intersection","text":"test_intersection(node::AbstractNode, itr::RTreeIntersectionIterator) -> QueryResult\n\nTests whether node intersects with the bounding box in itr, returning a QueryResult.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.update_bounding_box!-NTuple{4, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.update_bounding_box!","text":"update_bounding_box!(node, idx, original_bounding_box, tree)\n\nUpdates the bounding box of node to be the union of its children's bounding boxes. If node has a parent, updates the bounding box of the parent as well if needed.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.update_bounding_box!-Tuple{Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.update_bounding_box!","text":"update_bounding_box!(node)\n\nUpdates the bounding box of node to be the union of its children's bounding boxes.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.update_enlargement-Tuple{Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.update_enlargement","text":"update_enlargement(values::EnlargementValues, child, idx) -> EnlargementValues\n\nCompare the enlargement state in values with child and return the updated values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Point-Location","page":"Algorithm Internals","title":"Point Location","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions related to point location.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q; itr = each_triangle(tri), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nSearches for the triangle containing the point q by brute force. An exception will be  raised if no triangle contains the point.\n\nSee also find_triangle.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The point to be located.\n\nKeyword Arguments\n\nitr = each_triangle(tri): The iterator over the triangles of the triangulation.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nV: The triangle containing the point q.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.brute_force_search_enclosing_circumcircle","page":"Algorithm Internals","title":"DelaunayTriangulation.brute_force_search_enclosing_circumcircle","text":"brute_force_search_enclosing_circumcircle(tri::Triangulation, i, predicates::AbstractPredicateKernel=AdaptiveKernel(); cache = nothing) -> Triangle\n\nSearches for a triangle in tri containing the vertex i in its circumcircle using brute force. If  tri is a weighted Delaunay triangulation, the triangle returned instead has the lifted vertex i  below its witness plane. If no such triangle exists, (0, 0, 0) is returned. You can control  the method used for computing predicates via the predicates argument.\n\nThe cache argument is passed to [point_position_relative_to_circumcircle] and should be one of \n\nnothing: No cache is used.\nget_incircle_cache(tri): The cache stored inside tri.\nAdaptivePredicates.incircleadapt_cache(number_type(tri)): Compute a new cache.\n\nThe cache is only needed if an AdaptiveKernel() is used.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges-Union{Tuple{I}, Tuple{W}, Tuple{BN}, Tuple{T}, Tuple{P}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any}, Tuple{Triangulation{P, T, BN, W, I}, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}} where {P, T, BN, W, I}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","text":"check_for_intersections_with_adjacent_boundary_edges(tri::Triangulation, k, q, ghost_vertex=𝒢, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Certificate, Certificate, Vertex, Certificate, Certificate)\n\nGiven a boundary vertex k, find a triangle adjacent to k to locate a triangle or edge containing q.\n\nSee also search_down_adjacent_boundary_edges, which uses this function to determine an initial direction to search along a  straight boundary in case q is collinear with it.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex to start from.\nq: The query point.\nghost_vertex=𝒢: The ghost vertex corresponding to the boundary that k resides on.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ndirection_cert: The direction of q relative to the vertex k along the boundary, given as a Certificate Left, Right, or Outside. If is_outside(direction_cert), then q is not collinear with either of the adjacent boundary edges.\nq_pos_cert: The position of q relative to the vertex k along the boundary, given as a Certificate Left, Right, On, Outside, or Degenerate. This is similar to direction_cert in that it will be Outside whenever direction_cert is, but this certificate can also be On to indicate that not only is q in the direction given by direction_cert, but it is directly on the edge in that direction. If is_degnerate(q_pos_cert), then q = get_point(tri, next_vertex).\nnext_vertex: The next vertex along the boundary in the direction of q, or k if q is not collinear with either of the adjacent boundary edges.\nright_cert: The Certificate for the position of q relative to the boundary edge right of k.\nleft_cert: The Certificate for the position of q relative to the boundary edge left of k.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 4}}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex","text":"check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex(tri::Triangulation, k, q, right_cert, left_cert, predicates::AbstractPredicateKernel=AdaptiveKernel(), store_history=Val(false), history=nothing, ghost_vertex=𝒢) -> (Bool, Vertex, Vertex, Certificate, Certificate)\n\nChecks for intersections between the line pq, where p = get_point(tri, k), and the edges neighbouring p, assuming k is a boundary node. This function should only be used  after using check_for_intersections_with_adjacent_boundary_edges.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex to start from.\nq: The query point.\nright_cert: The Certificate for the position of q relative to the boundary edge right of k, coming from check_for_intersections_with_adjacent_boundary_edges.\nleft_cert: The Certificate for the position of q relative to the boundary edge left of k, coming from check_for_intersections_with_adjacent_boundary_edges.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history=Val(false): Whether to store the history of the algorithm.\nhistory=nothing: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nghost_vertex=𝒢: The ghost vertex corresponding to the boundary that k resides on.\n\nOutputs\n\nThe output takes the form (i, j, edge_cert, triangle_cert). Rather than defining each output individually, here are the possible froms of the output:\n\n(i, j, Single, Outside): The line pq intersects the edge pᵢpⱼ and (j, i, k) is a positively oriented triangle so that pᵢ is left of pq and pⱼ is right of pq.\n(i, j, None, Inside): The point q is inside the positively oriented triangle (i, j, k).\n(0, 0, None, Outside): The point q is outside of the triangulation.\n(i, j, On, Inside): The point q is on the edge pᵢpⱼ, and thus inside the positively oriented triangle (i, j, k).\n(i, j, Right, Outside):The pointqis collinear with the edgepᵢpⱼ`, but is off of it and further into the triangulation. \n\nwarning: Non-convex geometries\nThis function assumes that the geometry is convex.\n\nExtended help\n\nThis function works in two stages. Firstly, using check_for_intersections_with_single_interior_edge_adjacent_to_boundary_vertex, we check for the intersection of pq with the edges neighbouring  the vertex k, rotating counter-clockwise until we find an intersection or reach the other side of the boundary, starting from the first edge counter-clockwise away from the boundary edge right of  the vertex k. By keeping track of the positions of pq relative to the current vertex and the previous, we can identify when an intersection is found. If no intersection is found before  reaching the boundary edge left of k, then check_for_intersections_with_triangle_left_to_boundary_vertex is used to check the remaining triangle.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compare_distance-Union{Tuple{I}, Tuple{Any, I, Vararg{Any, 4}}} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.compare_distance","text":"compare_distance(current_dist, current_idx, pts, i, qx, qy) -> (Number, Vertex)\n\nComputes the minimum of the distance between the ith point of pts and (qx, qy) and current_dist.\n\nArguments\n\ncurrent_dist: The current value for the distance to the point (qx, qy).\ncurrent_idx: The point of pts corresponding to the distance current_dist.\npts: The point set. \ni: The vertex to compare with current_idx.\nqx: The x-coordinate of the query point.\nqy: The y-coordinate of the query point.\n\nOutputs\n\ncurrent_dist: The minimum of the distance between the ith point of pts and (qx, qy) and current_dist.\ncurrent_idx: The point of pts corresponding to the distance current_dist, which will be either i or current_idx.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.concavity_protection_check","page":"Algorithm Internals","title":"DelaunayTriangulation.concavity_protection_check","text":"concavity_protection_check(tri::Triangulation, concavity_protection, V, q, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Bool\n\nCheck whether the find_triangle algorithm needs to restart. This is only needed if tri is not convex.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nconcavity_protection: Whether this check is needed.\nV: The triangle that the algorithm has found.\nq: The query point.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nneed_to_restart: Whether the algorithm needs to restart. Will also be false if concavity_protection.\n\nExtended help\n\nThis function uses dist to determine whether the query point q is inside or outside of the polygon defined by the triangulation, and also checks the position of q relative to V via point_position_relative_to_triangle. If q is outside of this triangle,  then need_to_restart = true. If q is inside this triangle, then issues can still arise due to overlapping ghost triangles from the non-convexity. Thus,  depending on the result from dist and whether V is a ghost triangle, need_to_restart will be set accordingly.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.default_num_samples-Tuple{I} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.default_num_samples","text":"default_num_samples(n) -> Integer\n\nGiven a number of points n, returns ∛n rounded up to the nearest integer. This is the default number of samples used in the jump-and-march algorithm.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.exterior_find_triangle","page":"Algorithm Internals","title":"DelaunayTriangulation.exterior_find_triangle","text":"exterior_find_triangle(tri::Triangulation, k, q, ghost_vertex=𝒢, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Vertex, Vertex)\n\nGiven a query point q outside of the triangulation, find the ghost triangle containing q.\n\nArguments\n\ntri: The Triangulation.\nk: The exterior ghost vertex to start from.\nq: The query point. \nghost_vertex=𝒢: The ghost vertex corresponding to the boundary that k resides on.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ni: The first vertex of the edge on the boundary adjoining the positively oriented ghost triangle. \nj: The second vertex of the edge on the boundary adjoining the positively oriented ghost triangle.\n\nwarning: Non-convex geometries and internal query points\nThis function assumes that the geometry is convex. If the geometry is not convex, the returned value may not be correct and should be   checked separately. Additionally, if q is actually inside the triangulation, then the result is meaningless.\n\nExtended help\n\nThis function works by first finding the position of q relative to pₘp, where pₘ is the representative point for  the ghost_vertex and p = get_point(tri, k). Depending on this position, we rotate counter-clockwise if q is  left of the line using exterior_find_triangle_rotate_left and clockwise otherwise using exterior_find_triangle_rotate_right. By keeping track of the current position of q and its position relative to the next ghost edge, we can identify when q  resides inside a ghost triangle.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.find_triangle-Union{Tuple{U}, Tuple{F}, Tuple{Triangulation, Any}} where {F, U}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_triangle","text":"find_triangle(tri, q; kwargs...) -> Triangle[, Bool]\n\nFind the triangle in the triangulation tri containing the query point q using the jump-and-march algorithm.\n\ndanger: Ghost triangles\nFor this function to work best, the triangulation should have ghost triangles, which you can add using add_ghost_triangles! in case tri does not already have them.  Without ghost triangles, the function may not be able to find the correct triangle containing q.\n\nFor the variables defined below, you may want to refer to the extended help which also gives  some warnings and notes.\n\nArguments\n\ntri: The Triangulation.\nq: The query point.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=ExactKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\npoint_indices=each_solid_vertex(tri): The indices of the vertices to consider as possible starting points for the algorithm.\nm=default_num_samples(num_vertices(point_indices)): The number of samples to use when selecting the initial point.\ntry_points=(): A list of points to try as the initial point in addition to the m sampled.\nrng=Random.default_rng(): The random number generator to use.\nk=select_initial_point(tri, q; point_indices, m, try_points, rng): The initial point to start the algorithm from. See select_initial_point.\nstore_history=Val(false): Whether to store the history of the algorithm.\nhistory=nothing: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nmaxiters=2 + num_exterior_curves(tri) - num_solid_vertices(tri) + num_solid_edges(tri): The maximum number of iterations to perform before restarting the algorithm with restart_find_triangle.\nconcavity_protection=false: Whether to use concavity protection. See concavity_protection_check. This is only needed if your triangulation is not convex. \nuse_barriers::Val{U}=Val(false): Whether to stop searching beyond any segments in the triangulation. \n\nOutput\n\nV: The triangle containing q, with type given by triangle_type(tri).\n\nIf you have use_barriers == Val(true), then we also return \n\ninvisible_flag: false if the triangle was found without hitting a barrier, and true otherwise.\n\nExtended help\n\nThe algorithm underlying this function is complicated and broken into many parts. Here, we describe a brief overview of the algorithm, but note that the      documentation contains a much more detailed description.\n\nFirstly, the algorithm is initialised depending on whether k is a boundary or an interior vertex, using    initialise_find_triangle_boundary_vertex or initialise_find_triangle_interior_vertex respectively.\nFrom the initial triangle (i, j, k) chosen, we then check if q is one of pᵢ, pⱼ, and p = pₖ and then return according to find_triangle_return_on_vertex if needed.\nIf we do not return above, we need to step from the initial triangle towards q. Since we put pᵢ and pⱼ   to the left and right of the line pq, respectively, this means that we step until the triangle pᵢpⱼq is no longer    positively oriented. So, while the triangle is positively oriented, we step according to find_triangle_across_triangle.\nIf we have not yet returned and the triangle is no longer positively oriented, we check if the triangle is degenerate using find_triangle_degenerate_arrangement   and reinitialise the algorithm if needed. Otherwise, we have found the triangle containing q and return the triangle.\n\nHere are some additional warnings and notes for the variables defined in this function.\n\nnote: Restarting the algorithm\nIf the algorithm restarts, then the initial point k is selected again using select_initial_point, and the algorithm is restarted from there.  This is done if the algorithm gets stuck in a loop, or if the algorithm is not able to find the correct triangle containing q after maxiters iterations. For a convex  geometry, maxiters can be safely ignored, as the sequence of triangles visited is acyclic [see H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251-260.)].\n\nwarning: Found triangles with barriers\nIf you are using barriers, it will be your responsibility to verify that any found triangle from this function actually  contains the triangle. This can be verified using the returned flag (see below), although the point might still be on the triangle's  boundary.\n\nwarning: Walking past vertices of barriers\nIf you are using barriers, it is possible that the algorithm can walk past vertices of barriers. One way this can happen is if  the initial search line intersects a vertex, in which case the segment might not be considered. Another way this can happen is if you  start the algorithm directly on a segment vertex, in which case the algorithm can go past it (e.g. this means that it is possible that a  ghost triangle might still be returned if you start the algorithm on a boundary node).\n\nSome notes about the output:\n\ndanger: Hitting barriers\nIf a barrier is hit before any initial triangle is properly identified, the returned triangle is  (0, 0, 0); this is only possible if use_barriers == Val(true). Moreover, if use_barriers == Val(true),  the final triangle may not even be valid if invisible_flag == true (defined below).\n\nwarning: Non-convex geometries\nWhile this function does still work for non-convex geometries, it may be significantly slower than for convex geometries, as most of the details  of the algorithm assume that the geometry is convex, and so the algorithm may have to restart many times at new initial vertices k.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_triangle_across_triangle-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 12}}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.find_triangle_across_triangle","text":"find_triangle_across_triangle(tri::Triangulation, q, k, predicates, store_history, history, maxiters, cur_iter, concavity_protection, arrangement, original_k, last_changed, p, i, j, pᵢ, pⱼ) -> (Bool, Bool, Bool, Triangle, Integer, Certificate, Vertex, Vertex, Vertex, Point, Point, Integer, Integer)\n\nWalks across the current triangle past the edge (i, j). progressing the find_triangle algorithm.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nk: The vertex that the algorithm started from.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history: Whether to store the history of the algorithm.\nhistory: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nmaxiters: The maximum number of iterations to perform before restarting the algorithm with restart_find_triangle.\ncur_iter: The current iteration of the algorithm.\nconcavity_protection: Whether to use concavity protection. See concavity_protection_check. This is only needed if your triangulation is not convex.\narrangement: A Certificate defining the orientation of the triangle pᵢpⱼq.\noriginal_k: The original vertex that the algorithm started from.\nlast_changed: The last vertex that was changed in the algorithm.\np: The point corresponding to the vertex original_k.\ni: The first vertex of the triangle adjoining k to step from.\nj: The second vertex of the triangle adjoining k to step from.\npᵢ: The point corresponding to the vertex i.\npⱼ: The point corresponding to the vertex j.\n\nOutputs\n\nrestart_flag: Whether the algorithm needs to be restarted.\nreturn_flag: Whether the algorithm can return immediately, returning V.\nreinitialise_flag: Whether the algorithm needs to be reinitialised at a new vertex k. (This would only be needed if !has_ghost_triangles(tri).)\nV: The triangle stepped into. \ncur_iter: The new number of iterations of the algorithm.\narrangement: A Certificate defining the orientation of the triangle pᵢpⱼq with the updated values of i and j.\nk: The new vertex that the algorithm is at.\nlast_changed: The last vertex that was changed in the algorithm.\noriginal_k: The original vertex that the algorithm started from.\npᵢ: The point corresponding to the vertex i.\npⱼ: The point corresponding to the vertex j.\ni: The first vertex of the triangle adjoining k to step from.\nj: The second vertex of the triangle adjoining k to step from.\n\nExtended help\n\nThis part of the algorithm is relatively complicated because there are many cases that need to be accounted for. Here we give a brief description of how this step works,  and note that the documentation contains a much more detailed description.\n\nFirstly, we need to check whether k is an exterior ghost vertex or not. If k is an exterior ghost vertex, then this means that we are stepping outside of the  triangulation. Thus, we use exterior_find_triangle to find where q is, starting from the last_changed vertex. If concavity_protection = true, then  concavity_protection_check is used to determine if a restart is needed, or if we can return safely. If we reach this step but !has_ghost_triangles(tri), then the algorithm should need to be reinitialised since q should not be outside of the triangulation, and so we return with reinitialise_flag = true.\nNow we consider the case where k is not an exterior ghost vertex. We move forward by updating the value of k so that k = get_adjacent(tri, i, j), and then consider where pₖ is relative  to the line pq.\n\n2a. If pₖ is to the right of pq, then we should update j by j = k, ensuring that j is always to the right of pq.\n\n2b. If pₖ is to the left of pq, then we should update i by i = k, ensuring that i is always to the left of pq.\n\n2c. The alternative to 2a and 2b is that pₖ is collinear with the edge of pq, which could mean that q is in the current triangle or it is in a triangle further away. We compute a      Certificate that determines where q is relative to the triangle pᵢpⱼpₖ. If q is inside or on this triangle, then we return, restarting if necessary according to      concavity_protection and concavity_protection_check. If we do not yet need to return, then we need to make a decision as to which of i and j to update, noting that      we want i to be left of pq and j to be right of pq, but this is no longer unambiguous since pₖ is collinear with pq. We make this decision according to last_changed:     If last_changed = i, then moving left is what caused us to find this collinear edge, and so we send k left by letting i = k. Otherwise, we send k right by letting j = k.\n\nNow having stepped forward, we recompute the Certificate for arrangement and return, setting restart_flag = true if cur_iters ≥ maxiters.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_triangle_degenerate_arrangement-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Vararg{Any, 5}}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.find_triangle_degenerate_arrangement","text":"find_triangle_degenerate_arrangement(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history::F, history, pᵢ, pⱼ, i, j) -> Bool\n\nGiven a degenerate arrangement pᵢpⱼq, reinitialise the jump and march algorithm.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nk: The vertex that the algorithm started from.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history: Whether to store the history of the algorithm.\nhistory: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\npᵢ: The point corresponding to the vertex i.\npⱼ: The point corresponding to the vertex j.\ni: The first vertex of the triangle adjoining k to step from.\nj: The second vertex of the triangle adjoining k to step from.\n\nOutputs\n\nBool: Whether the algorithm needs to be restarted.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_triangle_return_on_vertex-Tuple{Triangulation, Vararg{Any, 8}}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_triangle_return_on_vertex","text":"find_triangle_return_on_vertex(tri::Triangulation, q, k, p, pᵢ, pⱼ, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Bool, Bool, Triangle)\n\nCheck if q is one of the vertices of the triangle (i, j, k) and return if needed.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nk: The vertex k that the algorithm started from. \np: The point corresponding to the vertex k.\npᵢ: The point corresponding to the vertex i.\npⱼ: The point corresponding to the vertex j.\ni: The first vertex of the triangle adjoining k to start from.\nj: The second vertex of the triangle adjoining k to start from.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nrestart_flag: Whether the algorithm needs to be restarted.\nreturn_flag: Whether the algorithm can return immediately, returning V.\nV: The triangle (i, j, k).\n\nExtended help\n\nAn extra check is made in this algorithm for the case that the point that q is equal to is one of the points corresponding to a ghost vertex,  so it may be for example that q == pᵢ but is_ghost_vertex(i), in which case the algorithm would need to restart.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.initialise_find_triangle_boundary_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any, Any}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.initialise_find_triangle_boundary_vertex","text":"initialise_find_triangle_boundary_vertex(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history, history, ghost_vertex, concavity_protection) -> (Bool, Bool, Triangle, Point, Vertex, Vertex, Point, Point)\n\nInitialise the jump-and-march algorithm for a boundary vertex k.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nk: The boundary vertex to start from.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history: Whether to store the history of the algorithm.\nhistory: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nghost_vertex: The ghost vertex corresponding to the boundary that k resides on.\nconcavity_protection: Whether to use concavity protection. See concavity_protection_check. This is only needed if your triangulation is not convex.\n\nOutputs\n\nrestart_flag: Whether the algorithm needs to be restarted.\nreturn_flag: Whether the algorithm can return immediately, returning V.\nV: Either a triangle that can returned if return_flag = true, or some triangle that is used for type stability for this return value.\np: The point corresponding to the vertex k, or it may be q if the algorithm is going to be restarted or return_flag = true.\ni: The first vertex of the triangle adjoining k to start from, or k if the algorithm is going to be restarted or return_flag = true.\nj: The second vertex of the triangle adjoining k to start from, or k if the algorithm is going to be restarted or return_flag = true.\npᵢ: The point corresponding to the vertex i, or it may be q if the algorithm is going to be restarted or return_flag = true.\npⱼ: The point corresponding to the vertex j, or it may be q if the algorithm is going to be restarted or return_flag = true.\n\nExtended help\n\nThere are multiple stages to this initialisation, starting from check_for_intersections_with_adjacent_boundary_edges. \n\nIf it is found that q is not outside of the triangulation, so that q is collinear with one of the boundary edges, then we use search_down_adjacent_boundary_edges to find where to start, noting   that we can return immediately if q is found to be on an adjacent boundary edge. Otherwise, exterior_find_triangle can then be used to find the ghost triangle containing   q; if concavity_protection = true, then concavity_protection_check is used to determine if a restart is needed.\nIf is is not found that q is outside of the triangulation yet based on information from the adjacent boundary edges, then we need to check the neighbouring   interior edges using check_for_intersections_with_interior_edges_adjacent_to_boundary_vertex, returning early if q is found to be inside one of   the neighbouring triangles. If the line pq, where p = get_point(tri, k), does not intersect any of the neighbouring edges and it is not inside any of   the neighbouring triangles, then it must be outside of the triangulation and so we use exterior_find_triangle to find the triangle; as before, concavity_protection_check  is used on the found ghost triangle if needed. If there is an intersection, then we return the triangle containing the intersection point that we can start the algorithm from,   and its associated vertices and points. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.initialise_find_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.initialise_find_triangle_interior_vertex","text":"initialise_find_triangle_interior_vertex(tri::Triangulation, q, k, predicates::AbstractPredicateKernel, store_history::F, history, rng) -> (Bool, Point, Vertex, Vertex, Point, Point)\n\nInitialise the jump-and-march algorithm for an interior vertex k.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nk: The interior vertex to start from.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history: Whether to store the history of the algorithm.\nhistory: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nrng: The random number generator to use.\n\nOutputs\n\nrestart_flag: Whether the algorithm needs to be restarted.\np: The point corresponding to the vertex k.\ni: The first vertex of the triangle adjoining k to start from.\nj: The second vertex of the triangle adjoining k to start from.\npᵢ: The point corresponding to the vertex i.\npⱼ: The point corresponding to the vertex j.\n\nExtended help\n\nThis function works by simply using select_initial_triangle_interior_vertex to find the initial triangle to start from. A check is made  to see if the edge (i, j) refers to a non-existent edge (0, 0), in which case the algorithm needs to be restarted.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.prepare_initial_edge","page":"Algorithm Internals","title":"DelaunayTriangulation.prepare_initial_edge","text":"prepare_initial_edge(tri::Triangulation, edges, p, q, rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Vertex, Vertex, Point, Point, Certificate, Certificate)\n\nSelects a random edge from the set of edges edges and computes the certificates for the points corresponding to the initial and terminal vertices of the edge.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nedges: The set of edges to sample from.\np: The initial point.\nq: The query point.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ni: The initial vertex of the edge.\nj: The terminal vertex of the edge.\npᵢ: The point corresponding to i.\npⱼ: The point corresponding to j.\nline_cert_i: The Certificate for pᵢ's position relative to the oriented line pq.\nline_cert_j: The Certificate for pⱼ's position relative to the oriented line pq.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.restart_find_triangle-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}","page":"Algorithm Internals","title":"DelaunayTriangulation.restart_find_triangle","text":"restart_find_triangle(tri::Triangulation, q, store_history, history, rng, maxiters, cur_iter, concavity_protection, num_restarts, use_barriers, predicates::AbstractPredicateKernel) -> Triangle[, Bool]\n\nRestart the find_triangle algorithm, or use brute_force_search to find q if num_restarts ≥ 25.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point.\nstore_history: Whether to store the history of the algorithm.\nhistory: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nrng: The random number generator to use.\nmaxiters: The maximum number of iterations to perform before restarting the algorithm with restart_find_triangle.\ncur_iter: The current iteration of the algorithm.\nconcavity_protection: Whether to use concavity protection. See concavity_protection_check. This is only needed if your triangulation is not convex.\nnum_restarts: The number of times the algorithm has been restarted. \nuse_barriers: Whether to use barriers, stopping the algorithm at any segment.\npredicates::AbstractPredicateKernel: Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nV: The triangle containing q.\n\nIn addition, if use_barriers = Val(true), then a second output is returned, which is a boolean indicating whether the algorithm reached a barrier (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.search_down_adjacent_boundary_edges-Union{Tuple{F}, Tuple{Triangulation, Vararg{Any, 5}}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, Any, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Any}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.search_down_adjacent_boundary_edges","text":"search_down_adjacent_boundary_edges(tri::Triangulation, k, q, direction_cert, q_pos_cert, next_vertex, predicates::AbstractPredicateKernel=AdaptiveKernel(), store_history=Val(false), history=nothing, ghost_vertex=𝒢) -> (Bool, Certificate, Vertex, Vertex, Vertex)\n\nStarting at the boundary vertex k, walks down the boundary in the direction of q until finding q or finding that it is outside of the triangulation.\n\nSee also check_for_intersections_with_adjacent_boundary_edges, which uses this function to determine an initial direction to search along.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex to start from.\nq: The query point.\ndirection_cert: The direction of q relative to the vertex k along the boundary, defined from check_for_intersections_with_adjacent_boundary_edges.\nq_pos_cert: The position of q relative to the vertex k along the boundary, defined from check_for_intersections_with_adjacent_boundary_edges.\nnext_vertex: The next vertex along the boundary in the direction of q, defined from check_for_intersections_with_adjacent_boundary_edges.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history=Val(false): Whether to store the history of the algorithm.\nhistory=nothing: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nghost_vertex=𝒢: The ghost vertex corresponding to the boundary that k resides on.\n\nOutputs\n\nreturn_flag: Whether to return, or throw an exception.\nq_pos_cert: A Certificate that is On if q is on the edge (u, v), and Outside if q is outside of the triangulation.\nu: If is_on(q_pos_cert), this is the first vertex of a positively oriented triangle that q is on, so that q is on the edge (u, v). Otherwise, (u, v, w) is a ghost triangle close to q.\nv: If is_on(q_pos_cert), this is the second vertex of a positively oriented triangle that q is on, so that q is on the edge (u, v). Otherwise, (u, v, w) is a ghost triangle close to q.\nw: If is_on(q_pos_cert), this is the third vertex of a positively oriented triangle that q is on, so that q is on the edge (u, v) and w = get_adjacent(tri, u, v). Otherwise, (u, v, w) is a ghost triangle close to q.\n\nwarning: Non-convex geometries\nThis function assumes that the geometry is convex. The function will still be able to return, but is_outside(q_pos_cert) may not necessarily mean q  is outside of the triangulation. The main function find_triangle will have to restart the algorithm if it is found that is_outside(q_pos_cert)  was incorrect.\n\nExtended help\n\nThis function works by stepping along vertices on the boundaries in the direction specified by direction_cert, using search_right_down_adjacent_boundary_edges if is_right(direction_cert) and search_left_down_adjacent_boundary_edges otherwise. In these functions, a while loop is used to keep stepping until q_pos_cert, which is updated at each iteration, changes value.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.select_initial_point","page":"Algorithm Internals","title":"DelaunayTriangulation.select_initial_point","text":"select_initial_point(tri::Triangulation, q; kwargs...) -> Vertex\n\nSelects the initial point for find_triangle to start from.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nq: The query point. Can be either a point or a vertex - if it is a vertex, the corresponding point get_point(tri, q) will be used.\n\nKeyword Arguments\n\npoint_indices=each_solid_vertex(tri): The indices to sample from. \nm=default_num_samples(num_vertices(point_indices)): The number of samples to take. Replacement is not used, so there may be duplicates.\ntry_points=(): A list of points to try in addition to those randomly sampled.\nallow_boundary_points=!is_disjoint(tri): Whether to allow boundary points to be selected.\nrng=Random.default_rng(): The random number generator to use.\n\nOutputs\n\ni: The index of the point closest to q out of those queried.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.select_initial_triangle_interior_vertex-Union{Tuple{F}, Tuple{Triangulation, Any, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any}, Tuple{Triangulation, Any, Any, DelaunayTriangulation.AbstractPredicateKernel, F, Any, Random.AbstractRNG}} where F","page":"Algorithm Internals","title":"DelaunayTriangulation.select_initial_triangle_interior_vertex","text":"select_initial_triangle_interior_vertex(tri::Triangulation, \n    k, \n    q, \n    predicates::AbstractPredicateKernel=AdaptiveKernel(),\n    store_history=Val(false), \n    history=nothing, \n    rng::Random.AbstractRNG=Random.default_rng()) -> (Point, Vertex, Vertex, Point, Point)\n\nSelects the initial triangle for find_triangle to start from, for the case where k is an interior vertex.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The vertex to start from.\nq: The query point.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_history=Val(false): Whether to store the history of the algorithm.\nhistory=nothing: The history of the algorithm. If store_history, then this should be a PointLocationHistory object.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\np: The point corresponding to k.\ni: The initial vertex of the triangle. \nj: The terminal vertex of the triangle.\npᵢ: The point corresponding to i.\npⱼ: The point corresponding to j.\n\nwarning: Non-convex geometries\nThis function assumes that the geometry is convex. To deal with this, when an infinite loop is detected  we return ∅ for both i and j, and then let find_triangle handle how to  correct the algorithm from there.    \n\nExtended help\n\nThis part of the algorithm works by rotating around the vertex k, looking for a triangle whose edges adjoining k  are to the left and to the right of k. By choosing the initial edge at random via prepare_initial_edge,  and computing the position of q relative to this initial edge, the rotation will be either clockwise or counter-clockwise,  and the triangle is then found using either select_initial_triangle_clockwise or select_initial_triangle_counterclockwise, respectively. \n\nIn case the initial edge is collinear with the line pq, where p = get_point(tri, q), then fix_initial_collinear_edge_for_interior_vertex to find a  non-collinear edge resample more edges from prepare_initial_edge if necessary.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.select_random_edge","page":"Algorithm Internals","title":"DelaunayTriangulation.select_random_edge","text":"select_random_edge(tri::Triangulation, edges, rng::Random.AbstractRNG=Random.default_rng()) -> (Vertex, Vertex, Point, Point)\n\nSelects a random edge from the set of edges edges.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nedges: The set of edges to sample from.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use.\n\nOutputs\n\ni: The initial vertex of the edge.\nj: The terminal vertex of the edge.\npᵢ: The point corresponding to i.\npⱼ: The point corresponding to j.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#Triangulation-Operations","page":"Algorithm Internals","title":"Triangulation Operations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Some of the triangulation operations have internal functions associated with them.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_all_exterior_triangles!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_all_exterior_triangles!","text":"delete_all_exterior_triangles!(tri::Triangulation, triangles)\n\nDeletes all the triangles in the set triangles from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_holes!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_holes!","text":"delete_holes!(tri::Triangulation)\n\nDeletes all the exterior faces to the boundary nodes specified in the triangulation tri.\n\nExtended help\n\nThis function works in several stages:\n\nFirst, find_all_points_to_delete is used to identify all points in the exterior faces.\nOnce all the points to delete have been found, all the associated triangles are found using find_all_triangles_to_delete, taking care for any incorrectly identified triangles and points. \nOnce the correct set of triangles to delete has been found, they are deleted using delete_all_exterior_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_points_to_delete!-Tuple{Any, Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_points_to_delete!","text":"find_all_points_to_delete!(points_to_process, tri::Triangulation, seed, all_bn)\n\nStarting at seed, finds more points to spread to and mark for deletion. \n\nArguments\n\npoints_to_process: The current list of points marked for deletion. \ntri::Triangulation: The Triangulation.\nseed: The seed vertex to start spreading from.\nall_bn: All the boundary nodes in the triangulation, obtained from get_all_boundary_nodes.\n\nOutputs\n\nThere are no outputs, as points_to_process is updated in-place.\n\nExtended help\n\nThis function works by considering the neighbours around the vertex seed. For each neighbouring vertex, we designate that as a new seed,  and consider if it needs to be added into points_to_process according to its distance from the triangulation computed from distance_to_polygon. We then call find_all_points_to_delete! recursively again on the new seed.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_points_to_delete-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_points_to_delete","text":"find_all_points_to_delete(tri::Triangulation) -> Set{Int}\n\nReturns a set of all the points that are in the exterior faces of the triangulation tri.\n\nExtended help\n\nThis function works by 'spreading' from some initial vertex. In particular, starting at each boundary node, we spread outwards towards adjacent vertices, recursively spreading so that all exterior points are identified with the help of find_all_points_to_delete!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_triangles_to_delete-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_triangles_to_delete","text":"find_all_triangles_to_delete(tri::Triangulation, points_to_process) -> Set{Triangle}\n\nReturns a set of all the triangles that are in the exterior faces of the triangulation tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\npoints_to_process: The set of points that are in the exterior faces of the triangulation tri, obtained from find_all_points_to_delete.\n\nOutputs\n\ntriangles_to_delete: The set of triangles that are in the exterior faces of the triangulation tri.\n\nExtended help\n\nThis function works in two stages. \n\nFirstly, all the non-boundary vertices, i.e. those from points_to_process, are processed. For each vertex v, the triangles adjoining it, given by get_adjacent2vertex(tri, v), aremarked for deletion. \nNext, all the boundary vertices need to be processed and carefully analysed to determine if any other triangles need to be deleted since, for example, a triangle may be adjoining three vertices that are all  boundary vertices, and it might not be obvious if it is inside or outside of the triangulation. By applying dist to compute the distance between the triangle's centroid and the triangulation,  the triangle can be accurately marked for deletion if it is outside of the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.check_delete_point_args-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.check_delete_point_args","text":"check_delete_point_args(tri::Triangulation, vertex, S) -> Bool\n\nChecks that the vertex vertex can be deleted from the triangulation tri. Returns true if so,  and throws an InvalidVertexDeletionError otherwise. This will occur if:\n\nvertex is a boundary node of tri.\nvertex is a ghost vertex of tri.\nvertex adjoins a segment of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_point!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_point!","text":"delete_point!(tri::Triangulation, vertex; kwargs...)\n\nDeletes the vertex of tri, retriangulating the cavity formed by the surrounding polygon of vertex using  triangulate_convex.\n\nIt is not possible to delete vertices that are on the boundary, are ghost vertices, or adjoin a segment of tri.  See also check_delete_point_args.\n\nwarn: Point deletion\nThis function will not actually delete the corresponding coordinates from get_points(tri), nor will it remove  the associated weight from get_weights(tri).\n\nArguments\n\ntri::Triangulation: Triangulation.\nvertex: The vertex to delete.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nstore_event_history=Val(false): Whether to store the event history of the triangulation from deleting the point. \nevent_history=nothing: The event history of the triangulation from deleting the point. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator to use for the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.fix_edges_after_deletion!-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.fix_edges_after_deletion!","text":"fix_edges_after_deletion!(tri::Triangulation, S)\n\nEnsures that the edges in S surrounding a deleted vertex of tri are correctly updated.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_surrounding_polygon-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(tri::Triangulation, u; skip_ghost_vertices=false) -> Vector\n\nReturns the counter-clockwise sequence of neighbours of u in tri.\n\nArguments\n\ntri::Triangulation: Triangulation.\nu: The vertex.\n\nKeyword Arguments\n\nskip_ghost_vertices=false: Whether to skip ghost vertices in the returned polygon. \n\nOutputs\n\nS: The surrounding polygon. This will not be circular, meaning S[begin] ≠ S[end].  In case u is an exterior ghost vertex, the returned polygon is a clockwise list of vertices for   the associated boundary curve. If you do not have ghost triangles and you try to get the surrounding polygon  of a ghost vertex, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.complete_split_edge_and_legalise!","page":"Algorithm Internals","title":"DelaunayTriangulation.complete_split_edge_and_legalise!","text":"complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nGiven a triangulation tri, an edge (i, j), and a point r, splits both (i, j) and (j, i) at r using split_edge! and then subsequently legalises the new edges with legalise_split_edge!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the edge to split.\nj: The second vertex of the edge to split.\nr: The vertex to split the edge at.\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_edges_for_split_edge-Tuple{Triangulation, Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_edges_for_split_edge","text":"get_edges_for_split_edge(tri::Triangulation, i, j, r)\n\nReturns the edges (i, j), (j, i), (i, r), (r, i), (r, j), and (j, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.legalise_split_edge!","page":"Algorithm Internals","title":"DelaunayTriangulation.legalise_split_edge!","text":"legalise_split_edge!(tri::Triangulation, i, j, k, r, store_event_history=Val(false), event_history=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nLegalises the newly added edges in tri after the edge (i, j) was split using split_edge!.\n\nSee also complete_split_edge_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the edge that was split.\nj: The second vertex of the edge that was split.\nk: The vertex that was originally adjacent to (i, j).\nr: The vertex that (i, j) was split at.\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.split_edge!","page":"Algorithm Internals","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nSplits the edge (i, j) in tri at the vertex r. For the triangulation to be valid after this splitting, it is assumed that r is collinear with,  or at least very close to collinear with, the edge (i, j).\n\nSee also legalise_split_edge! and complete_split_edge_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.    \ni: The first vertex of the edge to split.\nj: The second vertex of the edge to split.\nr: The vertex to split the edge at.\nstore_event_history=Val(false): Whether to store the event history of the flip.\nevent_history=nothing: The event history. Only updated if store_event_history is true, in which case it needs to be an InsertionEventHistory object.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\nwarning: Handling unoriented edges\nThe triangulation will only be updated as if (i, j) has been split rather than also (j, i). You will need to call split_edge! again with (j, i) if you want to split that edge as well.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.complete_split_triangle_and_legalise!-Tuple{Triangulation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.complete_split_triangle_and_legalise!","text":"complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)\n\nSplits the triangle (i, j, k) at the vertex r, assumed to be inside the triangle, and legalises the newly added edges in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the triangle.\nj: The second vertex of the triangle.\nk: The third vertex of the triangle.\nr: The vertex to split the triangle at.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.legalise_split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.legalise_split_triangle!","text":"legalise_split_triangle!(tri::Triangulation, i, j, k, r; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nLegalises the newly added edges in tri after the triangle (i, j, k) was split using split_triangle!.\n\nSee also complete_split_triangle_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the triangle.\nj: The second vertex of the triangle.\nk: The third vertex of the triangle.\nr: The vertex to split the triangle at.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere is no output, as tri is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_triangle!-Tuple{Triangulation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.split_triangle!","text":"split_triangle!(tri::Triangulation, i, j, k, r)\n\nSplits the triangle (i, j, k) at the vertex r, assumed to be inside the triangle. \n\nSee also legalise_split_triangle! and complete_split_triangle_and_legalise!.\n\nArguments\n\ntri::Triangulation: The Triangulation.\ni: The first vertex of the triangle.\nj: The second vertex of the triangle.\nk: The third vertex of the triangle.\nr: The vertex to split the triangle at.\n\nOutputs\n\nThere is no output, but tri will be updated so that it now contains the triangles (i, j, r), (j, k, r), and (k, i, r).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation._safe_get_adjacent-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation._safe_get_adjacent","text":"_safe_get_adjacent(tri::Triangulation, uv) -> Vertex\n\nThis is the safe version of get_adjacent, which is used when the triangulation has multiple sections, ensuring that the correct ghost vertex is returned in case uv is a ghost edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(tri::Triangulation, uv, w)\nadd_adjacent!(tri::Triangulation, u, v, w)\n\nAdds the key-value pair (u, v) ⟹ w to the adjacency map of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(tri::Triangulation, uv)\ndelete_adjacent!(tri::Triangulation, u, v)\n\nDeletes the key (u, v) from the adjacency map of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation, uv) -> Vertex\nget_adjacent(tri::Triangulation, u, v) -> Vertex\n\nReturns the vertex w such that (u, v, w) is a positively oriented triangle in the underlying triangulation, or ∅ if no such triangle exists.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(tri::Triangulation, w, uv)\nadd_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nAdds the edge (u, v) into the set of edges returned by get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w, uv)\ndelete_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nDeletes the edge (u, v) from the set of edges returned by get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w)\n\nDeletes the key w from the Adjacent2Vertex map of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation, w) -> Edges\n\nReturns the set of all edges (u, v) in tri such that (u, v, w) is a positively oriented triangle in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(tri::Triangulation, u, v...)\n\nAdds the neighbours v... to u in the graph of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(tri::Triangulation, u...)\n\nAdds the vertices u... into the graph of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_ghost_vertices_from_graph!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_ghost_vertices_from_graph!","text":"delete_ghost_vertices_from_graph!(tri::Triangulation)\n\nDeletes all ghost vertices from the graph of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(tri::Triangulation, u, v...)\n\nDeletes the neighbours v... from u in the graph of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Algorithm Internals","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(tri::Triangulation, u...)\n\nDeletes the vertices u... from the graph of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation, u) -> Set{Vertex}\n\nReturns the set of neighbours of u in tri. Note that, if has_ghost_triangles(tri), then some of the neighbours and vertices will be ghost vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation) -> Dict{Vertex, Set{Vertex}}\n\nReturns the neighbours map of tri. Note that, if has_ghost_triangles(tri), then some of the neighbours and vertices will be ghost vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.has_ghost_vertices-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.has_ghost_vertices","text":"has_ghost_vertices(tri::Triangulation) -> Bool\n\nReturns true if tri has ghost vertices, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.has_vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.has_vertex","text":"has_vertex(tri::Triangulation, u) -> Bool\n\nReturns true if u is a vertex in tri, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_edges-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_edges","text":"num_edges(tri::Triangulation) -> Integer\n\nReturns the number of edges in tri. Note that, if has_ghost_triangles(tri), then some of these edges will be ghost edges.\n\nSee also num_solid_edges and num_ghost_edges.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_ghost_edges-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(tri::Triangulation) -> Integer\n\nReturns the number of ghost edges in tri.\n\nSee also num_solid_edges and num_edges.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_ghost_vertices-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(tri::Triangulation) -> Integer\n\nReturns the number of ghost vertices in tri. \n\nSee also num_solid_vertices and num_vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_neighbours-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(tri::Triangulation, u) -> Integer\n\nReturns the number of neighbours of u in tri. Note that, if has_ghost_triangles(tri), then some of the neighbours counted might be ghost vertices if u is a boundary vertex.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_solid_edges-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(tri::Triangulation) -> Integer\n\nReturns the number of solid edges in tri.\n\nSee also num_ghost_edges and num_edges.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_solid_vertices-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(tri::Triangulation) -> Integer\n\nReturns the number of solid vertices in tri.\n\nSee also num_ghost_vertices and num_vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_vertices-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(tri::Triangulation) -> Integer\n\nReturns the number of vertices in tri. Note that, if has_ghost_triangles(tri), then some of these vertices will be ghost vertices.\n\nSee also num_solid_vertices and num_ghost_vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.sort_edge_by_degree-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.sort_edge_by_degree","text":"sort_edge_by_degree(tri::Triangulation, e) -> Edge\n\nReturns the edge e sorted so that initial(e) has the smaller degree of the two vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_point","text":"get_point(tri::Triangulation, i) -> NTuple{2, Number}\nget_point(tri::Triangulation, i...) -> NTuple{length(i), NTuple{2, Number}}\n\nReturns the coordinates corresponding to the vertices i... of tri, given as a Tuple of the form (x, y) for each point. If i is a ghost vertex, then the coordinates of the representative point of the curve associated with i are returned instead.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_points-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_points","text":"num_points(tri::Triangulation) -> Integer\n\nReturns the number of points in tri.\n\ndanger: Danger\nIf tri has vertices that are not yet present in the triangulation, e.g. if you have deleted vertices or have  some submerged vertices in a weighted triangulation, then the corresponding points will still be counted in this  function. It is recommended that you instead consider num_vertices, num_solid_vertices, or  num_ghost_vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.pop_point!-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.pop_point!","text":"pop_point!(tri::Triangulation)\n\nPops the last point from the points of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.push_point!-Tuple{Triangulation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.push_point!","text":"push_point!(tri::Triangulation, x, y)\npush_point!(tri::Triangulation, p)\n\nPushes the point p = (x, y) into the points of tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.set_point!-Tuple{Triangulation, Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.set_point!","text":"set_point!(tri::Triangulation, i, x, y)\nset_point!(tri::Triangulation, i, p)\n\nSets the ith point of tri to p = (x, y).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.construct_positively_oriented_triangle","page":"Algorithm Internals","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_triangle(tri::Triangulation, i, j, k, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Triangle\n\nReturns a triangle in tri from the vertices i, j, and k such that the triangle is positively oriented.\n\nYou can use the predicates argument to determine how the orientation predicate is computed. Can be one of  FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for more discussion on these  choices.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(tri::Triangulation, T) -> (Triangle, Bool)\ncontains_triangle(tri::Triangulation, i, j, k) -> (Triangle, Bool)\n\nTests whether tri contains T = (i, j, k) up to rotation, returning \n\nV: The rotated form of T that is in tri, or simply T if T is not in tri.\nflag: true if T is in tri, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_ghost_triangles-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(tri::Triangulation) -> Integer\n\nReturns the number of ghost triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_solid_triangles-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(tri::Triangulation) -> Integer\n\nReturns the number of solid triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.num_triangles-Tuple{Triangulation}","page":"Algorithm Internals","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(tri::Triangulation) -> Integer\n\nReturns the number of triangles in tri. Note that, if has_ghost_triangles(tri), then some of these triangles will be ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Voronoi-Tessellations","page":"Algorithm Internals","title":"Voronoi Tessellations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions related to the computation of unbounded Voronoi tessellations.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.add_edge_to_voronoi_polygon!-Tuple{Any, VoronoiTessellation, Vararg{Any, 5}}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_edge_to_voronoi_polygon!","text":"add_edge_to_voronoi_polygon!(B, vorn::VoronoiTessellation, i, k, S, m, encountered_duplicate_circumcenter) -> (Vertex, Bool, Vertex)\n\nAdd the next edge to the Voronoi polygon for the point i in the VoronoiTessellation vorn.\n\nArguments\n\nB: The vector of circumcenters defining the polygon. \nvorn: The VoronoiTessellation.\ni: The polygon index.\nk: The vertex to add.\nS: The surrounding polygon of i. See get_surrounding_polygon.\nm: The index of the next vertex in S.\nencountered_duplicate_circumcenter: Whether or not a duplicate circumcenter has been encountered.\n\nOutputs\n\nci: The index for the circumcenter of the triangle considered.\nencountered_duplicate_circumcenter: Whether or not a duplicate circumcenter has been encountered.\nk: The next vertex in S after the input k.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_voronoi_polygon!-Tuple{VoronoiTessellation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_voronoi_polygon!","text":"add_voronoi_polygon!(vorn::VoronoiTessellation, i) -> Vector\n\nAdd the Voronoi polygon for the point i to the VoronoiTessellation vorn.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The polygon index.\n\nOutputs\n\nB: The vector of circumcenters defining the polygon. This is a circular vector, i.e. B[begin] == B[end].\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.close_voronoi_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.close_voronoi_polygon!","text":"close_voronoi_polygon!(vorn::VoronoiTessellation, B, i, encountered_duplicate_circumcenter, prev_ci)\n\nClose the Voronoi polygon for the point i in the VoronoiTessellation vorn.\n\nArguments\n\nvorn: The VoronoiTessellation.\nB: The vector of circumcenters defining the polygon.\ni: The polygon index.\nencountered_duplicate_circumcenter: Whether or not a duplicate circumcenter has been encountered.\nprev_ci: The previous circumcenter index.\n\nOutputs\n\nThere are no outputs, as vorn and B are modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.connect_circumcenters!-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.connect_circumcenters!","text":"connect_circumcenters!(B, ci)\n\nAdd the circumcenter index ci to the array B.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_next_triangle_for_voronoi_polygon-Tuple{VoronoiTessellation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_next_triangle_for_voronoi_polygon","text":"get_next_triangle_for_voronoi_polygon(vorn::VoronoiTessellation, i, k, S, m) -> (Vertex, Vertex)\n\nGet the next triangle for the Voronoi polygon for the point i in the VoronoiTessellation. \n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The polygon index.\nk: The vertex to add.\nS: The surrounding polygon of i. See get_surrounding_polygon.\nm: The index of the next vertex in S.\n\nOutputs\n\nci: The index for the circumcenter of the next triangle.\nk: The next vertex in S after the input k.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.initialise_voronoi_tessellation-Tuple{Tr} where Tr<:Triangulation","page":"Algorithm Internals","title":"DelaunayTriangulation.initialise_voronoi_tessellation","text":"initialise_voronoi_tessellation(tri::Triangulation) -> VoronoiTessellation\n\nInitialise a VoronoiTessellation from the triangulation tri.\n\nArguments\n\ntri: The Triangulation.\n\nOutput\n\nvorn: The VoronoiTessellation. This tessellation is not yet filled in, as all the polygons and other fields need to be properly defined. This simply defines all the initial objects that will be pushed into.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.prepare_add_voronoi_polygon-Tuple{VoronoiTessellation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.prepare_add_voronoi_polygon","text":"prepare_add_voronoi_polygon(vorn::VoronoiTessellation, i) -> (Vector, Vector)\n\nPrepare to add a Voronoi polygon for the vertex i to the Voronoi tessellation vorn.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The vertex. \n\nOutputs\n\nS: The surrounding polygon of i. See get_surrounding_polygon.\nB: The buffer for the circumcenters. This is an empty Vector{I}, where I = integer_type(tri).\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Clipped-Voronoi-Tessellations","page":"Algorithm Internals","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions related to the computation of clipped Voronoi tessellations.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.add_all_boundary_polygons!-Tuple{VoronoiTessellation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_all_boundary_polygons!","text":"add_all_boundary_polygons!(vorn::VoronoiTessellation, boundary_sites)\n\nAdd all of the boundary polygons to the Voronoi tessellation.\n\nArguments\n\nvorn: The VoronoiTessellation.\nboundary_sites: A dictionary of boundary sites.\n\nOutputs\n\nThere are no outputs, but the boundary polygons are added in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_intersection_points!-Tuple{VoronoiTessellation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_intersection_points!","text":"add_intersection_points!(vorn::VoronoiTessellation, segment_intersections) -> Integer\n\nAdds all of the segment_intersections into the polygon vertices of vorn.\n\nArguments\n\nvorn: The VoronoiTessellation.\nsegment_intersections: The intersection points from find_all_intersections.\n\nOutputs\n\nn: The number of polygon vertices before the intersections were added.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_segment_intersection!-Union{Tuple{I}, Tuple{Any, Any, Any, I}} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.add_segment_intersection!","text":"add_segment_intersection!(segment_intersections, boundary_sites, intersection_point, incident_polygon::I) where {I} -> Integer\n\nAdds the intersection_point into the list of segment_intersections.\n\nArguments\n\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nintersection_point: The intersection point to add.\nincident_polygon: The index of the polygon that is incident to the intersection point.\n\nOutputs\n\nidx: The index of the intersection point in the list of segment intersections. If the intersection point already exists in the list, then the index of the existing point is returned and used instead.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.add_to_intersected_edge_cache!-Union{Tuple{V}, Tuple{E}, Tuple{AbstractVector{V}, Vararg{Any, 4}}} where {E, V<:Pair{E, E}}","page":"Algorithm Internals","title":"DelaunayTriangulation.add_to_intersected_edge_cache!","text":"add_to_intersected_edge_cache!(intersected_edge_cache, u, v, a, b)\n\nAdd the edge uv to the list of intersected edges.\n\nArguments\n\nintersected_edge_cache: The list of intersected edges.\nu: The first vertex of the edge of the Voronoi polygon intersecting the edge ab of the boundary. \nv: The second vertex of the edge of the Voronoi polygon intersecting the edge ab of the boundary.\na: The first vertex of the edge of the boundary.\nb: The second vertex of the edge of the boundary.\n\nOutputs\n\nThere are no outputs, as intersected_edge_cache is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.classify_intersections!-NTuple{7, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.classify_intersections!","text":"classify_intersections!(intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge)\n\nClassify the intersections in intersected_edge_cache into left_edge_intersectors, right_edge_intersectors, and current_edge_intersectors based on whether they intersect left_edge, right_edge, or current_edge, respectively.\n\nArguments\n\nintersected_edge_cache: The list of intersected edges currently being considered.\nleft_edge_intersectors: The set of sites that intersect the edge to the left of an edge currently being considered.\nright_edge_intersectors: The set of sites that intersect the edge to the right of an edge currently being considered.\ncurrent_edge_intersectors: The set of sites that intersect the current edge being considered.\nleft_edge: The edge to the left of e on the boundary.\nright_edge: The edge to the right of e on the boundary.\ncurrent_edge: The edge on the boundary being considered.\n\nOutputs\n\nThere are no outputs, but left_edge_intersectors, right_edge_intersectors, or current_edge_intersectors are updated all in-place depending on the type of intersection for each  edge in intersected_edge_cache.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.cleanup_unbounded_polygons!-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.cleanup_unbounded_polygons!","text":"cleanup_unbounded_polygons!(vorn::VoronoiTessellation)\n\nRemoves any remaining unbounded polygons from vorn after clipping. This is needed only for power diagrams. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_all_polygons!-Tuple{VoronoiTessellation, Vararg{Any, 4}}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_all_polygons!","text":"clip_all_polygons!(vorn::VoronoiTessellation, n, boundary_sites, exterior_circumcenters, equal_circumcenter_mapping)\n\nClip all of the polygons in the Voronoi tessellation.\n\nArguments\n\nvorn: The VoronoiTessellation.\nn: The number of vertices in the tessellation before clipping.\nboundary_sites: A dictionary of boundary sites.\nexterior_circumcenters: Any exterior circumcenters to be filtered out.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\nOutputs\n\nThere are no outputs, but the polygons are clipped in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_polygon!-Tuple{VoronoiTessellation, Vararg{Any, 6}}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_polygon!","text":"clip_polygon!(vorn::VoronoiTessellation, n, points, polygon, new_verts, exterior_circumcenters, equal_circumcenter_mapping)\n\nClip the polygon polygon by removing the vertices that are outside of the domain and adding the new vertices new_verts to the polygon.\n\nArguments\n\nvorn: The VoronoiTessellation.\nn: The number of vertices in the tessellation before clipping.\npoints: The polygon points of the tessellation.\npolygon: The index of the polygon to be clipped.\nnew_verts: The indices of the new vertices that are added to the polygon.\nexterior_circumcenters: Any exterior circumcenters to be filtered out.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\nOutputs\n\nThere are no outputs, but the polygon is clipped in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_voronoi_tessellation!-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_voronoi_tessellation!","text":"clip_voronoi_tessellation!(vorn::VoronoiTessellation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nClip the Voronoi tessellation vorn to the convex hull of the generators in vorn. \n\nArguments\n\nvorn: The VoronoiTessellation.\n\nKeyword Arguments\n\nclip_polygon=nothing: If clip=true, then this is the polygon to clip the Voronoi tessellation to. If nothing, the convex hull of the triangulation is used. The polygon should be defined as a Tuple of the form (points, boundary_nodes) where the boundary_nodes are vertices mapping to coordinates in points, adhering to the usual conventions for defining boundaries. Must be a convex polygon.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere are no outputs, but the Voronoi tessellation is clipped in-place.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.convert_to_edge_adjoining_ghost_vertex","text":"convert_to_edge_adjoining_ghost_vertex(tri::Triangulation, e) -> Edge\n\nReturns the edge e if it is not a boundary edge, and the edge reverse(e) if it is a boundary edge. \n\nSee also is_boundary_edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.dequeue_and_process!","page":"Algorithm Internals","title":"DelaunayTriangulation.dequeue_and_process!","text":"dequeue_and_process!(vorn, polygon_edge_queue, edges_to_process,\n    intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors,\n    processed_pairs, boundary_sites, segment_intersections, exterior_circumcenters, equal_circumcenter_mapping,\n    rng::Random.AbstractRNG=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nDequeue an edge from polygon_edge_queue and process it. If polygon_edge_queue is empty, then we process the first edge in edges_to_process.\n\nArguments\n\nvorn: The VoronoiTessellation.\npolygon_edge_queue: The queue of edges that need to be processed.\nedges_to_process: The edges that need to be processed.\nintersected_edge_cache: A cache of intersected edges.\nleft_edge_intersectors: The intersection points of left_edge with other edges.\nright_edge_intersectors: The intersection points of right_edge with other edges.\ncurrent_edge_intersectors: The intersection points of current_edge with other edges.\nprocessed_pairs: A set of pairs of edges and polygons that have already been processed.\nboundary_sites: A dictionary of boundary sites.\nsegment_intersections: A dictionary of segment intersections.\nexterior_circumcenters: A dictionary of exterior circumcenters.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator. \npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere are no outputs. Instead, the caches and queues are updated in-place.\n\nExtended help\n\nThis function works as follows:\n\nFirstly, if there are no edges queued in polygon_edge_queue, then we enqueue the first in edge in edges_to_process using enqueue_new_edge!.\nWe then dequeue the next edge to be processed. If the edge has already been processed, then we return early.\nIf we're still here, then we process the (edge, polygon) pair enqueued from polygon_edge_queue using process_polygon!. This function checks for intersections of the edge with the polygon.\nOnce the polygon has been processed, we then needed to classify all of the intersections using classify_intersections!, which determines, for each intersection, if the intersection is with edge,  or with the edge left of edge, or to the edge right of edge.\nThen, process_intersection_points! is used to process the intersection points, enqueueing new edges when needed.\nWe then delete the edge from edges_to_process if it is in there and return.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.enqueue_new_edge!","page":"Algorithm Internals","title":"DelaunayTriangulation.enqueue_new_edge!","text":"enqueue_new_edge!(polygon_edge_queue, vorn::VoronoiTessellation, e)\n\nEnqueue the edge e of the boundary to be processed.\n\nArguments\n\npolygon_edge_queue: The queue of edges that are to be processed.\nvorn: The VoronoiTessellation.\ne: The edge to be processed.\nrng::AbstractRNG=Random.default_rng(): Random number generator. Needed for get_nearest_neighbour.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods. Needed for get_nearest_neighbour.\n\nOutputs\n\nThere are no outputs, as polygon_edge_queue is modified in-place.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_exterior_circumcenters-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_exterior_circumcenters","text":"find_all_exterior_circumcenters(vorn::VoronoiTessellation, clip_points, clip_vertices) -> Set{I}\n\nFinds all the polygon vertices in vorn that are outside of the polygon defined by (clip_points, clip_vertices). The  return is the set of all exterior vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_intersecting_polygons-Tuple{VoronoiTessellation, Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_intersecting_polygons","text":"find_all_intersecting_polygons(vorn::VoronoiTessellation, clip_points, clip_vertices, exterior_circumcenters) -> (Set{I}, Set{I})\n\nClassifies all polygons in vorn into three sets depending on how they intersect the polygon  defined by (clip_points, clip_vertices), returning (interior, intersecting, exterior), where\n\ninterior are the polygons that are entirely inside the polygon defined by (clip_points, clip_vertices),\npossibly_intersecting are the polygons that might intersect the polygon defined by (clip_points, clip_vertices).\n\nThe exterior_circumcenters are the circumcenters that are outside of the domain, see find_all_exterior_circumcenters.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.find_all_intersections-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.find_all_intersections","text":"find_all_intersections(vorn::VoronoiTessellation; rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Dict, Vector, Set, Dict)\n\nFind all intersections between the edges of the Voronoi tessellation and the boundary of the polygon.\n\nArguments\n\nvorn: The VoronoiTessellation.\n\nKeyword Arguments\n\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nboundary_sites: A dictionary of boundary sites.\nsegment_intersections: The intersection points.\nexterior_circumcenters: The circumcenters that are outside of the domain.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\nExtended help\n\nThis algorithm works as follows:\n\nFirst, using initialise_clipping_arrays, we initialise the arrays that we will use to store the intersections, and queue up all boundary edges for processing.\nThen, starting with the first edge in edges_to_process, we dequeue an edge from polygon_edge_queue and process it via dequeue_and_process!.\nWe repeat step 2 until polygon_edge_queue and edges_to_process are both empty.\nWe then return.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.fix_no_intersections!-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.fix_no_intersections!","text":"fix_no_intersections!(vorn::VoronoiTessellation; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nIn the case that the Voronoi tiles have no intersections at all with the convex hull, this function adds in the missing intersections. clip_polygon is used for this.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_neighbouring_boundary_edges-Tuple{Triangulation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_neighbouring_boundary_edges","text":"get_neighbouring_boundary_edges(tri::Triangulation, e) -> (Edge, Edge)\n\nReturns the two boundary edges adjacent to the boundary edge e in the triangulation tri.\n\nArguments\n\ntri::Triangulation: a triangulation\ne: The boundary edge.\n\nOutputs\n\nleft_e: The left edge.\nright_e: The right edge.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_shared_vertex-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_shared_vertex","text":"get_shared_vertex(e, f) -> Vertex\n\nReturns the vertex shared by the edges e and f, or ∅ if they do not share a vertex.\n\nArguments\n\ne: The first edge.\nf: The second edge.\n\nOutputs\n\nu: The shared vertex.\n\nExample\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_shared_vertex((1, 3), (5, 7))\n0\n\njulia> DelaunayTriangulation.get_shared_vertex((1, 3), (3, 7))\n3\n\njulia> DelaunayTriangulation.get_shared_vertex((10, 3), (10, 5))\n10\n\njulia> DelaunayTriangulation.get_shared_vertex((9, 4), (9, 5))\n9\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.initialise_clipping_arrays-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.initialise_clipping_arrays","text":"initialise_clipping_arrays(vorn::VoronoiTessellation) -> (Set{E}, Queue{Tuple{E,I}}, Dict{I,Set{I}}, NTuple{2,F}[], Set{Tuple{E,I}}, Pair{E,E}[], Set{I}, Set{E}, Set{E}, Set{E}, Dict{I,I})\n\nInitialise the arrays used in the clipping algorithm for the VoronoiTessellation vorn.\n\nArguments\n\nvorn: The VoronoiTessellation.\n\nOutputs\n\nedges_to_process: The set of edges that are to be processed.\npolygon_edge_queue: The queue of edges that are to be processed.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nsegment_intersections: The list of segment intersections.\nprocessed_pairs: The set of pairs of edges and polygons that have been processed.\nintersected_edge_cache: The list of intersected edges currently being considered.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nleft_edge_intersectors: The set of sites that intersect the edge to the left of an edge currently being considered.\nright_edge_intersectors: The set of sites that intersect the edge to the right of an edge currently being considered.\ncurrent_edge_intersectors: The set of sites that intersect the current edge being considered.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_finite_segment-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_finite_segment","text":"is_finite_segment(u, v) -> Bool\n\nReturns true if the segment (u, v) is finite, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_ray_going_in-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_ray_going_in","text":"is_ray_going_in(u, v) -> Bool\n\nReturns true if the ray (u, v) is coming in from infinity, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_ray_going_out-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_ray_going_out","text":"is_ray_going_out(u, v) -> Bool\n\nReturns true if the ray (u, v) is going out to infinity, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_segment_between_two_ghosts-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_segment_between_two_ghosts","text":"is_segment_between_two_ghosts(u, v) -> Bool\n\nReturns true if the segment (u, v) is between two ghost vertices, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.process_intersection_points!-NTuple{12, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.process_intersection_points!","text":"process_intersection_points!(polygon_edge_queue, vorn, current_incident_polygon,\n    left_edge_intersectors, right_edge_intersectors, current_edge_intersectors,\n    left_edge, right_edge, current_edge, processed_pairs, segment_intersections, boundary_sites)\n\nProcess the intersection points in left_edge_intersectors, right_edge_intersectors, and current_edge_intersectors and add the new edges to polygon_edge_queue if necessary. Special care is taken to not miss any corner points.\n\nArguments\n\npolygon_edge_queue: The queue of edges that need to be processed.\nvorn: The VoronoiTessellation.\ncurrent_incident_polygon: The index of the current polygon being processed.\nleft_edge_intersectors: The intersection points of left_edge with other edges.\nright_edge_intersectors: The intersection points of right_edge with other edges.\ncurrent_edge_intersectors: The intersection points of current_edge with other edges.\nleft_edge: The left edge of the current polygon.\nright_edge: The right edge of the current polygon.\ncurrent_edge: The current edge of the current polygon.\nprocessed_pairs: A set of pairs of edges and polygons that have already been processed.\nsegment_intersections: A dictionary of segment intersections.\nboundary_sites: A dictionary of boundary sites.\n\nOutputs\n\nThere are no outputs, but the caches and queues are updated in-place.\n\nExtended help\n\nThe rules are based on the paper \"Efficient Computation of Clipped Voronoi Diagram for Mesh Generation\" by Yan, Wang, Levy, and Liu. Namely,  an edge that intersects a boundary edge and one adjacent to it has its shared vertex added to the queue together with the current polygon (current_incident_polygon) being  considered, and any intersections have the adjacent polygon added to the queue together with the intersecting edge. (These are not strictly  the rules in the paper.)\n\nThis function works as follows:\n\nFirst, assuming that there is more than one triangle in the underlying triangulation of vorn, we need to consider left_edge and right_edge individually. \nThe procedure for each edge is the same, so here we just describe the left_edge. If there are any intersectors with the left_edge, and neither of  (left_edge, current_incident_polygon) or (reverse_edge(left_edge), current_incident_polygon) have already been processed (i.e., in processed_pairs), then we enqueue  (left_edge, i) and (left_edge, j) into polygon_edge_queue, where i and j are the vertices of left_edge which correspond to polygons. This will ensure that we can find intersections next to this polygon. \nAfter enqueueing these pairs, we also need to protect against corner points, which we check for by considering current_incident_polygon ∈ all_indices, where all_indices are the vertices of left_edge,  right_edge, and current_edge. If this is true, and if the shared vertex of current_edge and left_edge is equal to current_incident_polygon, then we need to add the point generator of current_incident_polygon as an intersection. This need comes from having to worry about corners, i.e. points where the two unbounded polygons meet and go directly left and right of a vertex so that that vertex is not considered an intersection; this point needs to be included.\nOnce the left_edge and right_edge have been processed as above, we need to then consider all of left_edge, right_edge, and current_edge, and each of the intersections through the respective edge. This step is done  regardless of whether there is a single triangle in the underlying triangulation. The procedure for each edge is the same, so let us just describe the current_edge. For each edge uv in the current_edge_intersectors, we need to get the polygon adjacent to that edge. Then, if (current_edge, adjacent_incident_polygon) or (reverse_edge(current_edge), adjacent_incident_polygon) have not been processed, we enqueue (current_edge, adjacent_incident_polygon).\nOnce the edges have all been processed as above, we return.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.process_polygon!","page":"Algorithm Internals","title":"DelaunayTriangulation.process_polygon!","text":"process_polygon!(vorn::VoronoiTessellation, e, incident_polygon, boundary_sites, segment_intersections, intersected_edge_cache, exterior_circumcenters, equal_circumcenter_mapping, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Edge, Edge, Edge)\n\nProcesses the polygon incident_polygon for all of its intersections based on the boundary edge e.\n\nArguments\n\nvorn::VoronoiTessellation: The VoronoiTessellation.\ne: The edge on the boundary being considered.\nincident_polygon: The index of the polygon being considered.\nboundary_sites: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.\nsegment_intersections: The list of segment intersections.\nintersected_edge_cache: A cache of the edges that have been intersected by the ray from u to v.\nexterior_circumcenters: A list of the circumcenters of the sites that are outside the convex hull of the sites on the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nleft_edge: The edge to the left of e on the boundary.\nright_edge: The edge to the right of e on the boundary.\ne: The edge on the boundary being considered.\n\nIn addition to these outputs, the caches are also updated in-place.\n\nExtended help\n\nThis function works as follows: \n\nFirst, for the current edge e, we get the edges left_edge and right_edge that neighbour it via get_neighbouring_boundary_edges.\nFor each edge of the incident_polygon, we need to process it depending on whether the edge (u, v) is finite, between two ghosts, going out to infinity, or coming in from infinity.  If the edge is between two ghosts, we skip the edge. For rays that go out or in to infinity, we use process_ray_intersection! and process_ray_intersection_with_other_edges!  to process the intersection of the ray with the boundary edges. The function process_ray_intersection_with_other_edges! is needed since rays going out to infinity may have to go  through other boundary edges in order to do so, e.g. at a corner it may be that it crosses two boundary edges. For finite segments, process_segment_intersection! is used to process the intersection. We apply this function with each of e, left_edge, and right_edge to check for all intersections.\nThe function is done once each of the polygon edges has been considered.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.process_ray_intersection!","page":"Algorithm Internals","title":"DelaunayTriangulation.process_ray_intersection!","text":"process_ray_intersection!(\n    vorn::VoronoiTessellation,\n    u,\n    v,\n    incident_polygon,\n    intersected_edge_cache,\n    segment_intersections,\n    boundary_sites,\n    exterior_circumcenters,\n    equal_circumcenter_mapping,\n    predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Point\n\nProcess the intersection of the Voronoi polygon of the site u with the ray emanating from the circumcenter of the site v.\n\nArguments\n\nvorn: The VoronoiTessellation.\nu: The index of the site u, given as a ghost vertex for the associated ghost triangle.\nv: The index of the site v.\nincident_polygon: The index of the Voronoi polygon of the site u that is incident to the ray emanating from the circumcenter of the site v.\nintersected_edge_cache: The list of intersected edges currently being considered.\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\np: The coordinates of the intersection. \n\nIn addition to the point p, add_segment_intersection! is also updated to incorporate the new intersection point, as is add_to_intersected_edge_cache!.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.process_ray_intersection_with_other_edges!","page":"Algorithm Internals","title":"DelaunayTriangulation.process_ray_intersection_with_other_edges!","text":"process_ray_intersection_with_other_edges!(vorn::VoronoiTessellation,\n    u,\n    v,\n    e,\n    left_edge,\n    right_edge,\n    r,\n    segment_intersections,\n    boundary_sites,\n    incident_polygon,\n    equal_circumcenter_mapping,\n    intersected_edge_cache,\n    predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nProcess the intersection of the ray from the ghost site u to the site v with the edges e, left_edge and right_edge.\n\nArguments\n\nvorn::VoronoiTessellation: The VoronoiTessellation.\nu: The index of the ghost site.\nv: The index of the site u is going to.\ne: The edge on the boundary being considered.\nleft_edge: The edge to the left of e on the boundary.\nright_edge: The edge to the right of e on the boundary.\nr: The coordinates of the intersection of the ray from u to v with some edge. If any(isnan, r), then the ray does not intersect any edge and we skip.\nsegment_intersections: The list of segment intersections.\nboundary_sites: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.\nincident_polygon: The index of the polygon that contains the intersection of the ray from u to v with the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\nintersected_edge_cache: A cache of the edges that have been intersected by the ray from u to v.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nThere are no outputs, but add_segment_intersection! and add_to_intersected_edge_cache! are used to update the intersection objects.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.process_segment_intersection!","page":"Algorithm Internals","title":"DelaunayTriangulation.process_segment_intersection!","text":"process_segment_intersection!(\n    vorn::VoronoiTessellation,\n    u,\n    v,\n    e,\n    incident_polygon,\n    intersected_edge_cache,\n    segment_intersections,\n    boundary_sites,\n    exterior_circumcenters,\n    equal_circumcenter_mapping,\n    predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Point\n\nProcess the intersection of the Voronoi polygon's edge (u, v) with the edge e of the boundary, returning the coordinates of the intersection and updating via add_segment_intersection!.\n\nArguments\n\nvorn: The VoronoiTessellation.\nu: The index of the site u.\nv: The index of the site v.\ne: The edge e of the boundary.\nincident_polygon: The index of the Voronoi polygon currently being considered.\nintersected_edge_cache: The list of intersected edges currently being considered.\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\np: The coordinates of the intersection. If there is no intersection, this is (NaN, NaN).\n\nIn addition to the point p, add_segment_intersection! is also updated to incorporate the new intersection point, as is add_to_intersected_edge_cache!.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.single_triangle_clip!-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.single_triangle_clip!","text":"single_triangle_clip!(vorn::VoronoiTessellation; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nIn the case that vorn is dual to a triangulation with only a single triangle, this function clips the tessellation more efficiently  than the general case with find_all_intersections.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation._get_ray","page":"Algorithm Internals","title":"DelaunayTriangulation._get_ray","text":"_get_ray(vorn, i, ghost_vertex, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Point, Point)\n\nExtracts the ray from the ith polygon of vorn corresponding to the ghost_vertex, where ghost_vertex here means that get_polygon(vorn, i)[ghost_vertex] is a ghost vertex.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon.\nghost_vertex: The index of the ghost vertex in the polygon.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\np: The first point of the ray.\nq: A second point of the ray, so that pq gives the direction of the ray (which extends to infinity).\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_bounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_bounded_polygon_to_bounding_box","text":"clip_bounded_polygon_to_bounding_box(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nClips the ith polygon of vorn to bounding_box.\n\nSee also clip_polygon.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon.\nbounding_box: The bounding box to clip the polygon to.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ncoords: The coordinates of the clipped polygon. This is a circular vector.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_unbounded_polygon_to_bounding_box-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_unbounded_polygon_to_bounding_box","text":"clip_unbounded_polygon_to_bounding_box(vorn::VoronoiTessellation, i, bounding_box; predicates::AbsractPredicateType=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nClips the ith polygon of vorn to bounding_box. The polygon is assumed to be unbounded. See also clip_polygon.\n\nUse the keyword arguments predicates to determine how predicates are computed. Should be one of ExactKernel, AdaptiveKernel, and FastKernel. See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_bounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_bounded_polygon_coordinates","text":"get_bounded_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nReturns the coordinates of the ith polygon of vorn, clipped to bounding_box.\n\nUse the keyword arguments predicates to determine how predicates are computed. Should be one of ExactKernel, AdaptiveKernel, and FastKernel. See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_clipping_poly_structs-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_clipping_poly_structs","text":"get_clipping_poly_structs(vorn::VoronoiTessellation, i, bounding_box) -> (Polygon, Polygon)\n\nReturns the polygons used for clipping the ith polygon of vorn to bounding_box.\n\nSee also clip_polygon.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon.\nbounding_box: The bounding box to clip the polygon to.\n\nOutputs\n\npoly: The polygon to clip.\nclip_poly: The polygon to clip to.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_new_polygon_indices-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_new_polygon_indices","text":"get_new_polygon_indices(vorn, vertices) -> (Vector{Int}, Vector{NTuple{2,Float64}}, Tuple{Int, Int})\n\nReturns the new vertices and points of the polygon, as well as the indices of the ghost vertices in the polygon.\n\nArguments\n\nvorn: The VoronoiTessellation.\nvertices: The vertices of the polygon.\n\nOutputs\n\nnew_vertices: The new vertices of the polygon. This is not a circular vector. The vertices corresponding to a ghost vertex will be given by the ghost vertex itself.\nnew_points: The new points of the polygon. This is not a circular vector. The points corresponding to a ghost vertex will be given by by (NaN, NaN).\nghost_vertices: The indices of the ghost vertices in new_vertices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.get_polygon_coordinates","page":"Algorithm Internals","title":"DelaunayTriangulation.get_polygon_coordinates","text":"get_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box=nothing; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nReturns the coordinates of the polygon with index i in vorn. If bounding_box is provided, then the polygon is clipped to the bounding box. If the polygon is unbounded, then bounding_box must be provided.\n\nSee also get_unbounded_polygon_coordinates and get_bounded_polygon_coordinates.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon.\nbounding_box=nothing: The bounding box to clip the polygon to. If nothing, then the polygon is not clipped. If the polygon is unbounded, then bounding_box must be provided.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ncoords: The coordinates of the polygon. This is a circular vector.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.get_unbounded_polygon_coordinates-Tuple{VoronoiTessellation, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.get_unbounded_polygon_coordinates","text":"get_unbounded_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector{NTuple{2,Number}}\n\nReturns the coordinates of the ith polygon of vorn, clipped to bounding_box. The polygon is assumed to be unbounded.\n\nUse the keyword arguments predicates to determine how predicates are computed. Should be one of ExactKernel, AdaptiveKernel, and FastKernel. See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.grow_polygon_outside_of_box","page":"Algorithm Internals","title":"DelaunayTriangulation.grow_polygon_outside_of_box","text":"grow_polygon_outside_of_box(vorn::VoronoiTessellation, i, bounding_box, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Vector{Int}, Vector{NTuple{2,Number}})\n\nTruncates the unbounded edges of the ith polygon of vorn so that the line connecting the truncated unbounded edges is entirely outside of bounding_box.\n\nArguments\n\nvorn: The VoronoiTessellation.\ni: The index of the polygon. The polygon must be unbounded.\nbounding_box: The bounding box to clip the polygon to. See also polygon_bounds.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nnew_vertices: The new vertices of the polygon. This is not a circular vector.\nnew_points: The new points of the polygon. This is not a circular vector.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_first_ghost_vertex-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_first_ghost_vertex","text":"is_first_ghost_vertex(cell, i) -> Bool\n\nAssuming that the circular vector cell is such that ghost vertices only appear next to eachother in cell and there are only two, tests if i is the first ghost vertex in cell.\n\nSee also is_last_ghost_vertex.\n\nArguments\n\ncell: The circular vector.\ni: The index of the vertex in cell.\n\nOutputs\n\nflag: true if i is the first ghost vertex in cell, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_last_ghost_vertex-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.is_last_ghost_vertex","text":"is_last_ghost_vertex(cell, i) -> Bool\n\nAssuming that the circular vector cell is such that ghost vertices only appear next to eachother in cell, tests if i is the last ghost vertex in cell.\n\nSee also is_first_ghost_vertex.\n\nArguments\n\ncell: The circular vector.\ni: The index of the vertex in cell.\n\nOutputs\n\nflag: true if i is the last ghost vertex in cell, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.maximum_distance_to_box-NTuple{5, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.maximum_distance_to_box","text":"maximum_distance_to_box(a, b, c, d, p) -> Number\n\nComputes the maximum squared distance from the point p to the box with corners (a, c), (b, c), (b, d), (a, d).\n\nArguments\n\na: The minimum x-coordinate of the box. \nb: The maximum x-coordinate of the box.\nc: The minimum y-coordinate of the box.\nd: The maximum y-coordinate of the box.\np: The point.\n\nOutputs\n\ndist: The maximum squared distance from p to the box.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.liang_barsky-NTuple{6, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.liang_barsky","text":"liang_barsky(a, b, c, d, p, q) -> (Point, Point)\n\nApplies the Liang-Barsky algorithm to find the intersection of the line segment pq with the rectangle  [a, b] × [c, d].\n\nArguments\n\np: The first point of the line segment.\nq: The second point of the line segment.\na: The minimum x-coordinate of the rectangle.\nb: The maximum x-coordinate of the rectangle.\nc: The minimum y-coordinate of the rectangle.\nd: The maximum y-coordinate of the rectangle.\n\nOutput\n\nu: The first coordinate of the intersection, or (NaN, NaN) if there is no intersection. \nv: The second coordinate of the intersection, or (NaN, NaN) if there is no intersection.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.clip_polygon-NTuple{4, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.clip_polygon","text":"clip_polygon(vertices, points, clip_vertices, clip_points; predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Vector\n\nClip a polygon defined by (vertices, points) to a convex clip polygon defined by (clip_vertices, clip_points) with the Sutherland-Hodgman algorithm. The polygons should be defined in counter-clockwise order.\n\nArguments\n\nvertices: The vertices of the polygon to be clipped.\npoints: The underlying point set that the vertices are defined over. \nclip_vertices: The vertices of the clipping polygon.\nclip_points: The underlying point set that the clipping vertices are defined over.\n\nKeyword Arguments\n\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nclipped_polygon: The coordinates of the clipped polygon, given in counter-clockwise order and clipped_polygon[begin] == clipped_polygon[end].\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Centroidal-Voronoi-Tessellations","page":"Algorithm Internals","title":"Centroidal Voronoi Tessellations","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"Here are some functions related to the computation of centroidal Voronoi tessellations.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation._centroidal_smooth_itr","page":"Algorithm Internals","title":"DelaunayTriangulation._centroidal_smooth_itr","text":"_centroidal_smooth_itr(vorn::VoronoiTessellation, points, rng, predicates::AbstractPredicateKernel=AdaptiveKernel(); kwargs...) -> (VoronoiTessellation, Number)\n\nPerforms a single iteration of the centroidal smoothing algorithm. \n\nArguments\n\nvorn: The VoronoiTessellation.\npoints: The underlying point set. This is a deepcopy of the points of the underlying triangulation.\nrng: The random number generator.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nKeyword Arguments\n\nclip_polygon=nothing: If clip=true, then this is the polygon to clip the Voronoi tessellation to. If nothing, the convex hull of the triangulation is used. The polygon should be defined as a Tuple of the form (points, boundary_nodes) where the boundary_nodes are vertices mapping to coordinates in points, adhering to the usual conventions for defining boundaries.\nkwargs...: Extra keyword arguments passed to retriangulate.\n\nOutputs\n\nvorn: The updated VoronoiTessellation.\nmax_dist: The maximum distance moved by any generator.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.centroidal_smooth-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.centroidal_smooth","text":"centroidal_smooth(vorn::VoronoiTessellation; maxiters=1000, tol=default_displacement_tolerance(vorn), rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -> VoronoiTessellation\n\nSmooths vorn into a centroidal tessellation so that the new tessellation is of a set of generators whose associated Voronoi polygon is that polygon's centroid.\n\nArguments\n\nvorn: The VoronoiTessellation.\n\nKeyword Arguments\n\nmaxiters=1000: The maximum number of iterations.\nclip_polygon=nothing: If clip=true, then this is the polygon to clip the Voronoi tessellation to. If nothing, the convex hull of the triangulation is used. The polygon should be defined as a Tuple of the form (points, boundary_nodes) where the boundary_nodes are vertices mapping to coordinates in points, adhering to the usual conventions for defining boundaries. Must be a convex polygon. \ntol=default_displacement_tolerance(vorn): The displacement tolerance. See default_displacement_tolerance for the default. \nrng=Random.default_rng(): The random number generator.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nkwargs...: Extra keyword arguments passed to retriangulate.\n\nOutputs\n\nvorn: The updated VoronoiTessellation. This is not done in-place.\n\nExtended help\n\nThe algorithm is simple. We iteratively smooth the generators, moving them to the centroid of their associated Voronoi polygon for the current tessellation,  continuing until the maximum distance moved of any generator is less than tol. Boundary generators are not moved.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.default_displacement_tolerance-Tuple{VoronoiTessellation}","page":"Algorithm Internals","title":"DelaunayTriangulation.default_displacement_tolerance","text":"default_displacement_tolerance(vorn::VoronoiTessellation) -> Number\n\nReturns the default displacement tolerance for the centroidal smoothing algorithm. The default is given by  max_extent / 1e4, where max_extent = max(width, height), where width and height are the width and height  of the bounding box of the underlying point set.\n\nArguments\n\nvorn: The VoronoiTessellation.\n\nOutputs\n\ntol: The default displacement tolerance.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.move_generator_to_centroid!-Tuple{Any, VoronoiTessellation, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.move_generator_to_centroid!","text":"move_generator_to_centroid!(points, vorn::VoronoiTessellation, generator) -> Number\n\nMoves the generator generator to the centroid of its Voronoi cell. Returns the distance moved.\n\nArguments\n\npoints: The underlying point set. This is a deepcopy of the points of the underlying triangulation. \nvorn: The VoronoiTessellation.\ngenerator: The generator to move.\n\nOutputs\n\ndist: The distance moved.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#Triangulating-Curve-Bounded-Domains","page":"Algorithm Internals","title":"Triangulating Curve-Bounded Domains","text":"","category":"section"},{"location":"extended/algorithms/","page":"Algorithm Internals","title":"Algorithm Internals","text":"We have several functions related to the triangulation of curve-bounded domains.","category":"page"},{"location":"extended/algorithms/#DelaunayTriangulation.coarse_discretisation!-Union{Tuple{I}, Tuple{Any, Any, Any}} where I","page":"Algorithm Internals","title":"DelaunayTriangulation.coarse_discretisation!","text":"coarse_discretisation!(points, boundary_nodes, boundary_curve; n=0)\n\nConstructs an initial coarse discretisation of a curve-bounded domain with bonudary defines by  (points, boundary_nodes, boundary_curves), where boundary_nodes and boundary_curves should  come from convert_boundary_curves!. The argument n is the amount of times to split an edge. If non-zero, this should be a power of two (otherwise it will be rounded up to the next power of two). If it is  zero, then the splitting will continue until the maximum total variation over any subcurve is less than π/2.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.compute_split_position","page":"Algorithm Internals","title":"DelaunayTriangulation.compute_split_position","text":"compute_split_position(enricher::BoundaryEnricher, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> (Float64, Float64, NTuple{2,Float64})\n\nGets the point to split the edge (i, j) at.\n\nArguments\n\nenricher::BoundaryEnricher: The enricher.\ni: The first point of the edge.\nj: The second point of the edge.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\nt: The parameter value of the split point.\nΔθ: The total variation of the subcurve (i, t). If a split was created due to a small angle, this will be set to zero.\nct: The point to split the edge at.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}","page":"Algorithm Internals","title":"DelaunayTriangulation.enrich_boundary!","text":"enrich_boundary!(enricher::BoundaryEnricher; predicates::AbstractPredicateKernel=AdaptiveKernel())\n\nEnriches the initial boundary defined inside enricher, implementing the algorithm of Gosselin and Ollivier-Gooch (2007). At the termination of the algorithm, all edges will contain no other points inside their  diametral circles.\n\nThe predicates argument determines how predicates are computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.has_acute_neighbouring_angles-Union{Tuple{I}, Tuple{C}, Tuple{B}, Tuple{P}, Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher{P, B, C, I}, Any, Any}} where {P, B, C, I}","page":"Algorithm Internals","title":"DelaunayTriangulation.has_acute_neighbouring_angles","text":"has_acute_neighbouring_angles(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j) -> Int, Vertex\n\nGiven a boundary edge (i, j), tests if the neighbouring angles are acute. The first returned value  is the number of angles adjoining (i, j) that are acute (0, 1, or 2). The second returned value is the vertex that adjoins the edge (i, j) that is acute. If there are no such angles, or if there are two, then this  returned vertex is 0.\n\n(The purpose of this function is similar to segment_vertices_adjoin_other_segments_at_acute_angle.)\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.split_subcurve!","page":"Algorithm Internals","title":"DelaunayTriangulation.split_subcurve!","text":"split_subcurve!(enricher::BoundaryEnricher, i, j, predicates::AbstractPredicateKernel=AdaptiveKernel()) -> Bool\n\nSplits the curve associated with the edge (i, j) into two subcurves by inserting a point r between (i, j) such that the  total variation of the subcurve is equal on (i, r) and (r, j). The returned value is a flag that is true  if there was a precision issue, and false otherwise.\n\nThe predicate argument determines how predicates are computed, and should be  one of ExactKernel, FastKernel, and AdaptiveKernel (the default). See the documentation for more information about these choices.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.test_visibility-Tuple{DelaunayTriangulation.AbstractPredicateKernel, DelaunayTriangulation.BoundaryEnricher, Any, Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.test_visibility","text":"test_visibility(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j, k) -> Certificate\n\nTests if the vertex k is visible from the edge (i, j). Returns a Certificate which is\n\nInvisible: If k is not visible from (i, j).\nVisible: If k is visible from (i, j).  \n\nFor this function, k should be inside the diametral circle of (i, j).\n\nWe say that k is invisibile from (i, j) if the edges (i, k) or (j, k) intersect any other  boundary edges, or there is a hole between (i, j) and k.\n\ndanger: Definition incompatibility\nThis is not the same definition used in defining constrained Delaunay triangulations,  where visibility means visible from ANY point on the edge instead of only from the endpoints.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.triangulate_curve_bounded-Union{Tuple{Es}, Tuple{E}, Tuple{I}, Tuple{P}} where {P, I, E, Es}","page":"Algorithm Internals","title":"DelaunayTriangulation.triangulate_curve_bounded","text":"triangulate_curve_bounded(points::P;\nsegments=nothing,\nboundary_nodes=nothing,\npredicates::AbstractPredicateKernel=AdaptiveKernel(),\nIntegerType::Type{I}=Int,\npolygonise_n=4096,\ncoarse_n=0,\ncheck_arguments=true,\ndelete_ghosts=false,\ndelete_empty_features=true,\nrecompute_representative_points=true,\nrng::Random.AbstractRNG=Random.default_rng(),\ninsertion_order=nothing, \nkwargs...) where {P,I} -> Triangulation\n\nTriangulates a curve-bounded domain defined by (points, segments, boundary_nodes). Please see triangulate for a description of the arguments. The only differences are:\n\ninsertion_order=nothing: This argument is ignored for curve-bounded domains.\npolygonise_n=4096: For generating a high-resolution discretisation of a boundary initially for   the construction of a PolygonHierarchy, many points are needed. This number of points is defined   by polygonise_n, and must be a power of 2 (otherwise, the next highest power of 2 is used). See polygonise.\ncoarse_n=0: This is the number of points to use for initialising a curve-bounded domain via coarse_discretisation!.  The default coarse_n=0 means the discretisation is performed until the maximum variation over any subcurve is   less than π/2.\nskip_points: This is still used, but it is ignored during the enrichment phase (see enrich_boundary!).\n\nSee also BoundaryEnricher and enrich_boundary!.\n\nnote: Refinement\nTo refine the mesh further beyond its initial coarse discretisation, as produced from this function,  please see refine!.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.convert_boundary_curves!-Union{Tuple{I}, Tuple{Any, Any, Type{I}}} where I<:Integer","page":"Algorithm Internals","title":"DelaunayTriangulation.convert_boundary_curves!","text":"convert_boundary_curves!(points, boundary_nodes, IntegerType) -> (NTuple{N, AbstractParametricCurve} where N, Vector)\n\nConverts the provided points and boundary_nodes into a set of boundary curves and modified boundary nodes suitable for  triangulation. In particular:\n\nThe function gets boundary_curves from to_boundary_curves.\nboundary_nodes is replaced with a set of initial boundary nodes (from get_skeleton). These nodes come from evaluating each boundary curve at t = 0 and t = 1. In the case of a piecewise linear boundary, the vertices are copied directly. Note that not all control points of a CatmullRomSpline (which is_interpolating) will be added - only those at t = 0 and t = 1.\nThe points are modified to include the new boundary nodes. If a point is already in points, it is not added again.  \n\nArguments\n\npoints: The point set. This is modified in place with the new boundary points.\nboundary_nodes: The boundary nodes to be converted. This is not modified in place.\nIntegerType: The type of integer to use for the boundary nodes.\n\nOutput\n\nboundary_curves: The boundary curves associated with boundary_nodes.\nboundary_nodes: The modified boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_curve_bounded","page":"Algorithm Internals","title":"DelaunayTriangulation.is_curve_bounded","text":"is_curve_bounded(tri::Triangulation) -> Bool \nis_curve_bounded(boundary_nodes) -> Bool\n\nReturns true if tri is curve bounded, and false otherwise; similarly for the  boundary_nodes method.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.to_boundary_curves-Tuple{Any, Any}","page":"Algorithm Internals","title":"DelaunayTriangulation.to_boundary_curves","text":"to_boundary_curves(points, boundary_nodes) -> NTuple{N, AbstractParametricCurve} where N\n\nReturns the set of boundary curves associated with boundary_nodes and points. \n\n\n\n\n\n","category":"method"},{"location":"extended/algorithms/#DelaunayTriangulation.is_visible","page":"Algorithm Internals","title":"DelaunayTriangulation.is_visible","text":"is_visible(cert::Certificate) -> Bool\n\nReturns true if cert is Visible, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.is_invisible","page":"Algorithm Internals","title":"DelaunayTriangulation.is_invisible","text":"is_invisible(cert::Certificate) -> Bool\n\nReturns true if cert is Invisible, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"extended/algorithms/#DelaunayTriangulation.test_visibility","page":"Algorithm Internals","title":"DelaunayTriangulation.test_visibility","text":"test_visibility([kernel::AbstractPredicateKernel = AdaptiveKernel(),] tri::Triangulation, q, i) -> Certificate\n\nTests if the vertex i and the point q can see each other. Here, visibility means that the line segment joining  the two does not intersect any segments.\n\nArguments\n\nkernel::AbstractPredicateKernel = AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel (the default), and AdaptiveKernel. See the documentation for a further discussion of these methods.\ntri: The Triangulation.\nq: The point from which we are testing visibility.\ni: The vertex we are testing visibility of.\n\nOutputs\n\ncert: A Certificate. This will be Visible if i is visible from q, and Invisible otherwise.\n\n\n\n\n\ntest_visibility([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, i; shift=0.0, attractor=get_point(tri,i)) -> Certificate\n\nTests if the edge (u, v) and the point i can see each other. Here, visibility means that any point in the interior  of (u, v) can see i. To test this, we only check 10 points equally spaced between u and v, excluding u and v.\n\nArguments\n\nkernel::AbstractPredicateKernel=AdaptiveKernel(): How predicates are computed. See the documentation for information on the choices between FastKernel, ExactKernel, and AdaptiveKernel.\ntri: The Triangulation.\nu: The first vertex of the edge.\nv: The second vertex of the edge.\ni: The vertex we are testing visibility of.\n\nKeyword Arguments\n\nshift=0.0: The amount by which to shift each point on the edge towards attractor, i.e. if p is a point on the edge, then p .+ shift .* (attractor - p) is the point used to test visibility rather than p itself.\nattractor=get_point(tri,i): Related to shift; see above. \npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ncert: A Certificate. This will be Visible if i is visible from (u, v), and Invisible otherwise.\n\n\n\n\n\ntest_visibility(predicates::AbstractPredicateKernel, enricher::BoundaryEnricher, i, j, k) -> Certificate\n\nTests if the vertex k is visible from the edge (i, j). Returns a Certificate which is\n\nInvisible: If k is not visible from (i, j).\nVisible: If k is visible from (i, j).  \n\nFor this function, k should be inside the diametral circle of (i, j).\n\nWe say that k is invisibile from (i, j) if the edges (i, k) or (j, k) intersect any other  boundary edges, or there is a hole between (i, j) and k.\n\ndanger: Definition incompatibility\nThis is not the same definition used in defining constrained Delaunay triangulations,  where visibility means visible from ANY point on the edge instead of only from the endpoints.\n\n\n\n\n\n","category":"function"},{"location":"manual/curve_bounded/#Defining-Curve-Bounded-Domains","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"","category":"section"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"This section discusses how curve-bounded domains, and curves, are defined in this package. A good demonstration of how these domains are worked with is in the curve-bounded tutorial.","category":"page"},{"location":"manual/curve_bounded/#Curves","page":"Defining Curve-Bounded Domains","title":"Curves","text":"","category":"section"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"To start, let us discuss curves. All functions that work with curves in this package treat them as being subtypes of the AbstractParametricCurve type. These curves must:","category":"page"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"Be defined as parametric curves, parametrised over 0 leq t leq 1.\nNot be self-intersecting, with the exception of allowing for closed curves.\nImplement differentiate, twice_differentiate, and thrice_differentiate.\nBe defined as a callable struct.\nEither implement point_position_relative_to_curve or get_closest_point. Alternatively, the struct should have a lookup_table field so that lookup_table[i] is the value of the curve at t = (i - 1) / (length(lookup_table) - 1).","category":"page"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"With these specifications, a curve can be fully compatible with the functions in this package, as other functions such as arc_length, curvature, and total_variation are automatically defined for such a curve. The curves that are defined in this package can be found using subtypes:","category":"page"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"using DelaunayTriangulation, InteractiveUtils\nsubtypes(DelaunayTriangulation.AbstractParametricCurve)","category":"page"},{"location":"manual/curve_bounded/#Curve-Bounded-Domains","page":"Defining Curve-Bounded Domains","title":"Curve-Bounded Domains","text":"","category":"section"},{"location":"manual/curve_bounded/","page":"Defining Curve-Bounded Domains","title":"Defining Curve-Bounded Domains","text":"For defining curve-bounded domains, defining them is similar to defining piecewise linear boundaries as described here. You still need to be careful about orientation, and you of course need to make sure that curves belonging to the same boundary connect appropriately. For defining curve-bounded domains that also have a piecewise linear section, the piecewise linear section should be defined as a vector of vertices just like here.","category":"page"},{"location":"manual/predicates/#Geometrical-Predicates","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"","category":"section"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"This section discusses how geometrical predicates are defined in this package. The predicates in this package are primarily derived from those implemented in ExactPredicates.jl and AdaptivePredicates.jl. The choice of robust predicates is important for the robustness of the algorithms in this package. Without using robust predicates, you may quickly find issues such as infinite loops or errors in the algorithms, as discussed for example at the start of p.3 of these notes by Shewchuk. A discussion of the three predicate kernels available in this package, namely FastKernel(), AdaptiveKernel(), and ExactKernel(), are discussed in detail here.","category":"page"},{"location":"manual/predicates/#Certificates","page":"Geometrical Predicates","title":"Certificates","text":"","category":"section"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"All predicates defined in this package return a Certificate which simply specifies the result of the predicate. This is easier than working with Bools only as (1) not all predicates have only two outcomes and (2) it is easier to see the certificate than to remember exactly what outcome is represented by a Bool. For example:","category":"page"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"using DelaunayTriangulation\np, q, r = (0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\nflag = DelaunayTriangulation.triangle_orientation(p, q, r)","category":"page"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"We could then inspect the result using e.g.","category":"page"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"DelaunayTriangulation.is_positively_oriented(flag)","category":"page"},{"location":"manual/predicates/#Predicates","page":"Geometrical Predicates","title":"Predicates","text":"","category":"section"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"The predicates we define are implemented in a function with a _predicate suffix that then dispatches based on the provided kernel. The base predicates we define are:","category":"page"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"orient\nincircle\nparallelorder\nsameside\nmeet","category":"page"},{"location":"manual/predicates/","page":"Geometrical Predicates","title":"Geometrical Predicates","text":"These last three predicates are taken from ExactPredicates.jl. Almost all other geometric predicates are derived from these five, e.g. triangle_orientation and point_position_relative_to_line. Predicates for working with the boundary and ghost vertices are also implemented, for example, is_ghost_edge and is_boundary_node.","category":"page"},{"location":"tutorials/constrained_outer_boundary/#Constrained-Triangulations","page":"Outer Boundary","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary/#Outer-Boundary","page":"Outer Boundary","title":"Outer Boundary","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"This tutorial now considers the case where, rather than only having constrained segments, we have a constrained outer boundary. This is especially useful as it allows us to, for example, have a non-convex boundary. To start, let us load in the packages we will need.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"Now, we define some of the points we will be triangulating.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"pts = [\n    (-7.36, 12.55), (-9.32, 8.59), (-9.0, 3.0), (-6.32, -0.27),\n    (-4.78, -1.53), (2.78, -1.41), (-5.42, 1.45), (7.86, 0.67),\n    (10.92, 0.23), (9.9, 7.39), (8.14, 4.77), (13.4, 8.61),\n    (7.4, 12.27), (2.2, 13.85), (-3.48, 10.21), (-4.56, 7.35),\n    (3.44, 8.99), (3.74, 5.87), (-2.0, 8.0), (-2.52, 4.81),\n    (1.34, 6.77), (1.24, 4.15),\n]","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"To define a boundary, we need to provide a counter-clockwise sequence of indices corresponding to the boundary points, and the first index must match the last index so the boundary is closed. While we could include in pts the boundary points that we want to include, and then write down the indices of the points within pts, this is cumbersome and often tedious to get correct. So, we instead provide the function convert_boundary_points_to_indices which takes in a vector of coordinates, and then returns the correct set of indices. Here is how we use it:","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"boundary_points = [\n    (0.0, 0.0), (2.0, 1.0), (3.98, 2.85), (6.0, 5.0),\n    (7.0, 7.0), (7.0, 9.0), (6.0, 11.0), (4.0, 12.0),\n    (2.0, 12.0), (1.0, 11.0), (0.0, 9.13), (-1.0, 11.0),\n    (-2.0, 12.0), (-4.0, 12.0), (-6.0, 11.0), (-7.0, 9.0),\n    (-6.94, 7.13), (-6.0, 5.0), (-4.0, 3.0), (-2.0, 1.0), (0.0, 0.0),\n]\nboundary_nodes, pts = convert_boundary_points_to_indices(boundary_points; existing_points = pts);\nnothing #hide","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"The keyword argument existing_points is so that the points in boundary_points get appended (in-place) to pts, as we see:","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"pts","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"The boundary_nodes is then these indices:","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"boundary_nodes","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"To now triangulate, we use the boundary_nodes keyword argument. Like in the last tutorial, we also give a comparison to the unconstrained version.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"tri = triangulate(pts)\ncons_tri = triangulate(pts; boundary_nodes)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"fig = Figure()\nax1 = Axis(\n    fig[1, 1], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(a): Unconstrained\", titlealign = :left,\n    width = 300, height = 300,\n)\nax2 = Axis(\n    fig[1, 2], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(b): Constrained\", titlealign = :left,\n    width = 300, height = 300,\n)\ntriplot!(ax1, tri)\ntriplot!(ax2, cons_tri, show_constrained_edges = true, show_convex_hull = true)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"Notice now that the boundary in (b) is not convex, as is clear from the convex hull shown in red. You can access the convex hull using get_convex_hull(cons_tri). We also note that the triangulation no longer contains every point in pts, as by default all triangles away from the boundary are deleted, so that we do actually have a boundary. If for some reason you do not want this behaviour, use delete_holes = false:","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"full_tri = triangulate(pts; boundary_nodes, delete_holes = false)\nfig, ax, sc = triplot(full_tri, show_constrained_edges = true, show_convex_hull = true)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"This default behaviour does mean you need to be careful if you use DelaunayTriangulation.each_point or DelaunayTriangulation.each_point_index, as these iterators will contain all points, possibly iterating over points that aren't in the triangulation. For this reason, it is recommended that you use each_solid_vertex as a default.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"There are multiple methods available for working directly with the boundary nodes. You can get the boundary nodes using get_boundary_nodes(tri):","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"get_boundary_nodes(cons_tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"Later tutorials also consider other methods for working with the boundary where care needs to be taken with the boundary, or part of the boundary, being considered. For now, here is an example where we use get_right_boundary_node to iterate over the boundary in a counter-clockwise order, getting the area of the triangulation using","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"A = dfrac12sum_i=1^n left(y_i + y_i+1right)left(x_i - x_i+1right)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"Here is one implementation.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"function shoelace_area(tri)\n    bn = get_boundary_nodes(tri)\n    n = num_boundary_edges(bn) # length(bn) - 1 in this case since bn[1] = bn[end]\n    A = 0.0\n    for i in 1:n\n        vᵢ = get_boundary_nodes(bn, i)\n        vᵢ₊₁ = get_boundary_nodes(bn, i + 1)\n        pᵢ, pᵢ₊₁ = get_point(tri, vᵢ, vᵢ₊₁)\n        xᵢ, yᵢ = getxy(pᵢ)\n        xᵢ₊₁, yᵢ₊₁ = getxy(pᵢ₊₁)\n        A += (yᵢ + yᵢ₊₁) * (xᵢ - xᵢ₊₁)\n    end\n    return A / 2\nend\nshoelace_area(cons_tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"We also provide a map that contains the edges as the keys (not in order), and the values are Tuples (I, J) such that get_boundary_nodes(get_boundary_nodes(cons_tri, I), J) gives the corresponding edge. The first call, bn = get_boundary_nodes(cons_tri, I) is for obtaining the chain of boundary edges containing the boundary edge, and then get_boundary_nodes(bn, j) gets the actual edge.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"get_boundary_edge_map(cons_tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"In our case, the I is just boundary_nodes since we only have one contiguous boundary. To give an example, take","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"bem = get_boundary_edge_map(cons_tri)\ne, (I, J) = first(bem)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"bn = get_boundary_nodes(cons_tri, I) # same as boundary_nodes for this problem; see the later tutorials\nbn_j = get_boundary_nodes(bn, J)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"This returns 23, which is the start of the edge e. The full edge is given by","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"get_boundary_nodes.(Ref(bn), (J, J + 1)) # Ref to not broadcast over bn","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"To give an example, here's how we compute the perimeter of the triangulation. This only needs the edges, so we only consider the keys of the map.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"function get_perimeter(tri)\n    bem = get_boundary_edge_map(tri)\n    ℓ = 0.0\n    for e in keys(bem)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ += sqrt((getx(p) - getx(q))^2 + (gety(p) - gety(q))^2)\n    end\n    return ℓ\nend\nget_perimeter(cons_tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary/#Just-the-code","page":"Outer Boundary","title":"Just the code","text":"","category":"section"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"using DelaunayTriangulation\nusing CairoMakie\n\npts = [\n    (-7.36, 12.55), (-9.32, 8.59), (-9.0, 3.0), (-6.32, -0.27),\n    (-4.78, -1.53), (2.78, -1.41), (-5.42, 1.45), (7.86, 0.67),\n    (10.92, 0.23), (9.9, 7.39), (8.14, 4.77), (13.4, 8.61),\n    (7.4, 12.27), (2.2, 13.85), (-3.48, 10.21), (-4.56, 7.35),\n    (3.44, 8.99), (3.74, 5.87), (-2.0, 8.0), (-2.52, 4.81),\n    (1.34, 6.77), (1.24, 4.15),\n]\n\nboundary_points = [\n    (0.0, 0.0), (2.0, 1.0), (3.98, 2.85), (6.0, 5.0),\n    (7.0, 7.0), (7.0, 9.0), (6.0, 11.0), (4.0, 12.0),\n    (2.0, 12.0), (1.0, 11.0), (0.0, 9.13), (-1.0, 11.0),\n    (-2.0, 12.0), (-4.0, 12.0), (-6.0, 11.0), (-7.0, 9.0),\n    (-6.94, 7.13), (-6.0, 5.0), (-4.0, 3.0), (-2.0, 1.0), (0.0, 0.0),\n]\nboundary_nodes, pts = convert_boundary_points_to_indices(boundary_points; existing_points = pts);\n\npts\n\nboundary_nodes\n\ntri = triangulate(pts)\ncons_tri = triangulate(pts; boundary_nodes)\n\nfig = Figure()\nax1 = Axis(\n    fig[1, 1], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(a): Unconstrained\", titlealign = :left,\n    width = 300, height = 300,\n)\nax2 = Axis(\n    fig[1, 2], xlabel = \"x\", ylabel = L\"y\",\n    title = \"(b): Constrained\", titlealign = :left,\n    width = 300, height = 300,\n)\ntriplot!(ax1, tri)\ntriplot!(ax2, cons_tri, show_constrained_edges = true, show_convex_hull = true)\nresize_to_layout!(fig)\nfig\n\nfull_tri = triangulate(pts; boundary_nodes, delete_holes = false)\nfig, ax, sc = triplot(full_tri, show_constrained_edges = true, show_convex_hull = true)\n\nget_boundary_nodes(cons_tri)\n\nfunction shoelace_area(tri)\n    bn = get_boundary_nodes(tri)\n    n = num_boundary_edges(bn) # length(bn) - 1 in this case since bn[1] = bn[end]\n    A = 0.0\n    for i in 1:n\n        vᵢ = get_boundary_nodes(bn, i)\n        vᵢ₊₁ = get_boundary_nodes(bn, i + 1)\n        pᵢ, pᵢ₊₁ = get_point(tri, vᵢ, vᵢ₊₁)\n        xᵢ, yᵢ = getxy(pᵢ)\n        xᵢ₊₁, yᵢ₊₁ = getxy(pᵢ₊₁)\n        A += (yᵢ + yᵢ₊₁) * (xᵢ - xᵢ₊₁)\n    end\n    return A / 2\nend\nshoelace_area(cons_tri)\n\nget_boundary_edge_map(cons_tri)\n\nbem = get_boundary_edge_map(cons_tri)\ne, (I, J) = first(bem)\n\nbn = get_boundary_nodes(cons_tri, I) # same as boundary_nodes for this problem; see the later tutorials\nbn_j = get_boundary_nodes(bn, J)\n\nget_boundary_nodes.(Ref(bn), (J, J + 1)) # Ref to not broadcast over bn\n\nfunction get_perimeter(tri)\n    bem = get_boundary_edge_map(tri)\n    ℓ = 0.0\n    for e in keys(bem)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ += sqrt((getx(p) - getx(q))^2 + (gety(p) - gety(q))^2)\n    end\n    return ℓ\nend\nget_perimeter(cons_tri)","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"","category":"page"},{"location":"tutorials/constrained_outer_boundary/","page":"Outer Boundary","title":"Outer Boundary","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/data_structures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"api/data_structures/#DelaunayTriangulation.Adjacent","page":"Data Structures","title":"DelaunayTriangulation.Adjacent","text":"Adjacent{IntegerType, EdgeType}\n\nStruct for storing adjacency relationships for a triangulation.\n\nFields\n\nadjacent::Dict{EdgeType, IntegerType}\n\nThe map taking edges (u, v) to w such that (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\nConstructors\n\nAdjacent{IntegerType, EdgeType}()\nAdjacent(adjacent::Dict{EdgeType, IntegerType})\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.Adjacent2Vertex","page":"Data Structures","title":"DelaunayTriangulation.Adjacent2Vertex","text":"Adjacent2Vertex{IntegerType, EdgesType}\n\nStruct for connectivity information about edges relative to vertices for a triangulation.\n\nFields\n\nadjacent2vertex::Dict{IntegerType, EdgesType}\n\nThe map taking w to the set of all (u, v) such that (u, v, w) is a positively oriented triangle in the underlying triangle.\n\nConstructors\n\nAdjacent2Vertex{IntegerType, EdgesType}()\nAdjacent2Vertex(adj2v::Dict{IntegerType, EdgesType})\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.Graph","page":"Data Structures","title":"DelaunayTriangulation.Graph","text":"Graph{IntegerType}\n\nStruct for storing neighbourhood relationships between vertices in a triangulation. This is an undirected graph.\n\nFields\n\nvertices::Set{IntegerType}\n\nThe set of vertices in the underlying triangulation.\n\nedges::Set{NTuple{2, IntegerType}}\n\nThe set of edges in the underlying triangulation.\n\nneighbours::Dict{IntegerType, Set{IntegerType}}\n\nThe map taking vertices u to the set of all v such that (u, v) is an edge in the underlying triangulation.\n\nConstructors\n\nGraph{IntegerType}()\nGraph(vertices::Set{IntegerType}, edges::Set{NTuple{2, IntegerType}}, neighbours::Dict{IntegerType, Set{IntegerType}})\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.Triangulation","page":"Data Structures","title":"DelaunayTriangulation.Triangulation","text":"Triangulation{P,T,BN,W,I,E,Es,BC,BCT,BEM,GVM,GVR,BPL,C,BE}\n\nStruct representing a triangulation, as constructed by triangulate.\n\nnote: Field access\nAccessing the fields themselves using e.g. tri.field is not recommended and is not intended  to be in the public API. You should be using the  accessor functions, e.g. instead of tri.points do get_points(tri). Similarly, for the iterators, e.g. tri.triangles, each_triangle(tri) is recommended instead.\n\nFields\n\npoints::P\n\nThe point set of the triangulation. Please note that this may not necessarily correspond to each point  in the triangulation, e.g. some points may have been deleted - see each_solid_vertex for an iterator over  each vertex in the triangulation. \n\ntriangles::T\n\nThe triangles in the triangulation. Each triangle is oriented counter-clockwise. If your triangulation has ghost triangles, some of these triangles will contain ghost vertices (i.e., vertices with negative indices). Solid triangles can be iterated over using  each_solid_triangle.\n\nboundary_nodes::BN\n\nThe boundary nodes of the triangulation, if the triangulation is constrained; the assumed form of these boundary nodes is outlined  in the docs. If your triangulation is unconstrained, then boundary_nodes will be empty and the boundary should instead be inspected using the convex hull field, or alternatively you can see lock_convex_hull!.\n\ninterior_segments::Es\n\nConstrained segments appearing in the triangulation. These will only be those segments appearing off of the boundary. If your triangulation is unconstrained, then segments will be empty.\n\nall_segments::Es\n\nThis is similar to segments, except this includes both the interior segments and the boundary segments. If your triangulation is unconstrained, then all_segments will be empty.\n\nweights::W\n\nThe weights of the triangulation. If you are not using a weighted triangulation, this will be given by ZeroWeight(). Otherwise,  the weights must be such that get_weight(weights, i) is the weight for the ith vertex. The weights should have the same type as the  coordinates in points.\n\nadjacent::Adjacent{I,E}\n\nThe Adjacent map of the triangulation. This maps edges (u, v) to vertices w such that (u, v, w) is a positively  oriented triangle in triangles (up to rotation).\n\nadjacent2vertex::Adjacent2Vertex{I,Es}\n\nThe Adjacent2Vertex map of the triangulation. This maps vertices w to sets S such that (u, v, w) is a positively  oriented triangle in triangles (up to rotation) for all (u, v) ∈ S.\n\ngraph::Graph{I}\n\nThe Graph of the triangulation, represented as an undirected graph that defines all the neighbourhood information for the triangulation.\n\nboundary_curves::BC\n\nFunctions defining the boundary curves of the triangulation, incase you are triangulating a curve-bounded domain. By default, this will be an empty Tuple, indicating that the boundary is as specified in boundary_nodes - a piecewise linear curve. If you are triangulating a curve-bounded domain, then these will  be the parametric curves (see AbstractParametricCurve) you provided as a Tuple, where the ith element of the Tuple is associated with the ghost vertex -i, i.e. the ith section as indicated by  ghost_vertex_map. If the ith boundary was left was a sequence of edges, then the function will be a PiecewiseLinear().\n\nboundary_edge_map::BEM\n\nThis is a Dict from construct_boundary_edge_map that maps boundary edges (u, v) to their corresponding position in boundary_nodes.\n\nghost_vertex_map::GVM\n\nThis is a Dict that maps ghost vertices to their corresponding section in boundary_nodes, constructed by construct_ghost_vertex_map.\n\nghost_vertex_ranges::GVR\n\nThis is a Dict that maps ghost vertices to a range of all other ghost vertices that appear on the curve corresponding to the given ghost vertex,  constructed by construct_ghost_vertex_ranges.\n\nconvex_hull::ConvexHull{P,I}\n\nThe ConvexHull of the triangulation, which is the convex hull of the point set points.\n\nrepresentative_point_list::BPL\n\nThe Dict of points giving RepresentativeCoordinates for each boundary curve, or for the  convex hull if boundary_nodes is empty. These representative points are used for interpreting  ghost vertices.\n\npolygon_hierarchy::PolygonHierarchy{I}\n\nThe PolygonHierarchy of the boundary, defining the hierarchy of the boundary curves, giving information about which curves are contained in which other curves.\n\nboundary_enricher::BE\n\nThe BoundaryEnricher used for triangulating a curve-bounded domain. If the domain is not curve-bounded, this is nothing.\n\ncache::C\n\nA TriangulationCache used as a cache for add_segment! which requires a separate Triangulation structure for use. This will not contain any segments or boundary nodes. Also stores segments useful for lock_convex_hull! and unlock_convex_hull!.\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.VoronoiTessellation","page":"Data Structures","title":"DelaunayTriangulation.VoronoiTessellation","text":"VoronoiTessellation{Tr<:Triangulation,P,I,T,S,E}\n\nStruct for representing a Voronoi tessellation.\n\nSee also voronoi.\n\nnote: Field access\nAccessing the fields themselves using e.g. vorn.field is not recommended and is not intended  to be in the public API. You should be using the  accessor functions, e.g. instead of vorn.adjacent do get_adjacent(vorn). Similarly, for the iterators, e.g. vorn.generators, each_generators(vorn) is recommended instead.\n\nnote: Power diagram\nIn the case that the underlying triangulation is weighted, then this struct represents the power diagram,  and instead of circumcenters the points are orthocenters computed with triangle_orthocenter.\n\nFields\n\ntriangulation::Tr: The underlying triangulation. The tessellation is dual to this triangulation,   although if the underlying triangulation is constrained then this is no longer the case (but it is   still used).\ngenerators::Dict{I,P}: A Dict that maps vertices of generators to coordinates. These are simply the   points present in the triangulation. A Dict is needed in case the triangulation is missing some points.\npolygon_points::Vector{P}: The points defining the coordinates of the polygons. The points are not guaranteed  to be unique if a circumcenter appears on the boundary or you are considering a clipped tessellation. (See also get_polygon_coordinates.)\npolygons::Dict{I,Vector{I}}: A Dict mapping polygon indices (which is the same as a generator vertex) to the vertices of a polygon. The polygons are given in   counter-clockwise order and the first and last vertices are equal.\ncircumcenter_to_triangle::Dict{I,T}: A Dict mapping a circumcenter index to the triangle that contains it. The triangles are sorted such that the   minimum vertex is last. \ntriangle_to_circumcenter::Dict{T,I}: A Dict mapping a triangle to its circumcenter index. The triangles are sorted such that the minimum vertex is last. \nunbounded_polygons::Set{I}: A Set of indices of the unbounded polygons. \ncocircular_circumcenters::S: A Set of indices of circumcenters that come from triangles that are cocircular with another triangle's vertices, and adjoin said triangles. \nadjacent::Adjacent{I,E}: The adjacent map. This maps an oriented edge to the polygon that it belongs to.\nboundary_polygons::Set{I}: A Set of indices of the polygons that are on the boundary of the tessellation. Only relevant for clipped   tessellations, otherwise see unbounded_polygons.\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.ConvexHull","page":"Data Structures","title":"DelaunayTriangulation.ConvexHull","text":"ConvexHull{PointsType, IntegerType}\n\nStruct for representing a convex hull. See also convex_hull.\n\nFields\n\npoints::PointsType: The underlying point set.\nvertices::Vector{IntegerType}: The vertices of the convex hull, in counter-clockwise order. Defined so that vertices[begin] == vertices[end].\n\nConstructors\n\nConvexHull(points, vertices)\nconvex_hull(points; predicates=AdaptiveKernel(), IntegerType=Int)\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.InsertionEventHistory","page":"Data Structures","title":"DelaunayTriangulation.InsertionEventHistory","text":"InsertionEventHistory{T,E}\n\nA data structure for storing the changes to the triangulation during the insertion of a point.\n\nFields\n\nadded_triangles::Set{T}: The triangles that were added.\ndeleted_triangles::Set{T}: The triangles that were deleted.\nadded_segments::Set{E}: The interior segments that were added.\ndeleted_segments::Set{E}: The interior segments that were deleted.\nadded_boundary_segments::Set{E}: The boundary segments that were added.\ndeleted_boundary_segments::Set{E}: The boundary segments that were deleted.\n\nConstructor\n\nThe default constructor is available, but we also provide \n\nInsertionEventHistory(tri::Triangulation)\n\nwhich will initialise this struct with empty, appropriately sizehint!ed, sets.\n\n\n\n\n\n","category":"type"},{"location":"api/data_structures/#DelaunayTriangulation.PointLocationHistory","page":"Data Structures","title":"DelaunayTriangulation.PointLocationHistory","text":"PointLocationHistory{T,E,I}\n\nHistory from using find_triangle.\n\nFields\n\ntriangles::Vector{T}: The visited triangles. \ncollinear_segments::Vector{E}: Segments collinear with the original line pq using to jump.\ncollinear_point_indices::Vector{I}: This field contains indices to segments in collinear_segments that refer to points that were on the original segment, but there is no valid segment for them. We use manually fix this after the fact. For example, we could add an edge (1, 14), when really we mean something like (7, 14) which isn't a valid edge.\nleft_vertices::Vector{I}: Vertices from the visited triangles to the left of pq.\nright_verices::Vector{I}: Vertices from the visited triangles to the right of pq.\n\n\n\n\n\n","category":"type"},{"location":"math/clipped/#Clipped-Voronoi-Tessellations","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Now we consider a variant of the Voronoi tessellation called the clipped Voronoi tessellation. In the clipped Voronoi tessellation, the Voronoi polygons are clipped to the convex hull of the point set. This is useful when we want to ensure that the Voronoi polygons are bounded and do not extend to infinity. The computation of this tessellation is much more involved than the standard Voronoi tessellation. To be exact, we are interested in computing tildemathcal V(mathcal P) equiv mathcal V(mathcal P) cap mathcal Cmathcal H(mathcal P). An example of a clipped Voronoi tessellation is shown below. We will revisit this example throughout the discussion of the algorithm.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"At the end of this section, we also discuss the intersection of mathcal V(mathcal P) with a rectangle, and then discuss clipping mathcal V(mathcal P) more generically to a given convex polygon.","category":"page"},{"location":"math/clipped/#Computing-intersections-of-the-Voronoi-polygons-and-the-convex-hull","page":"Clipped Voronoi Tessellations","title":"Computing intersections of the Voronoi polygons and the convex hull","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The main complication with clipping the Voronoi polygons to the convex hull is in computing all the intersections of the polygons with the convex hull. For this step, we use an iterative approach. The steps are described below. We will start by describing the algorithm in words, and then provide a clearer example.","category":"page"},{"location":"math/clipped/#Initialising-the-queue","page":"Clipped Voronoi Tessellations","title":"Initialising the queue","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"We maintain a queue of edges to determine where we need to process the intersections. First, we initialise a set mathcal E containing all boundary edges. We take a random edge e in mathcal E and use it to initialise a queue mathcal Q of polygon edges. To be specific, into mathcal Q we enqueue (e mathcal V), where mathcal V_i is the polygon incident to the boundary edge e; we find this incident polygon by finding the nearest neighbour to the edge's midpoint.","category":"page"},{"location":"math/clipped/#Processing-an-edge","page":"Clipped Voronoi Tessellations","title":"Processing an edge","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"If either of mathcal Q or mathcal E are not empty, we can consider processing an edge for intersections. If mathcal Q = emptyset, we take the next edge in mathcal E and enqueue it and its incident polygon into mathcal Q. Now, dequeue a pair (e mathcal V) from mathcal Q. If the pair (e mathcal V) has already been processed, we skip this step and dequeue the next pair from mathcal Q.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"For the first step of this processing, we need to find any intersections of e with the polygon mathcal V. To do this, we first find the edges e_ell and e_r left and right of e, respectively. We then need to consider each edge of mathcal V. Let s be an edge of mathcal V. How s intersects the edges depends on whether (1) it is an unbounded ray oriented so that it is going out to infinity, (2) it is an unbounded ray oriented so that it is coming in from infinity, or (3) it is a bounded edge. The first two cases are reasonably straightforward - just compute the intersection of the edge with the unbounded rays. For the third case, we compute all the intersections of e, e_ell, and e_r with s. The reason for needing to check all of e, e_ell, and e_r rather than e alone is that there may be issues finding intersections when considering Voronoi polygons near corners of the convex hull.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Once we have processed all of the edges of mathcal V, we store the intersections of the edges with e, e_ell, and e_r into the sets mathcal E(mathcal V), mathcal L(mathcal V), and mathcal R(mathcal V), respectively. We use these intersections to determine what edges need to be enqueued into mathcal Q, taking care that we do not miss any corner points. Consider some intersection point p in mathcal L(mathcal V); the cases for the other sets are similar. If (e_ell mathcal V) has not been processed, then we enqueue (e_ell mathcal V_i) and (e_ell mathcal V_j) into mathcal Q, where v_i and v_j are the vertices of e_ell. This ensures that we will find the intersections next to this polygon. After enqueueing these pairs, we still need to protect against corner points. To do this, we note that a corner point only needs to be checked if the incident polygon mathcal V belongs to the boundary of the convex hull. If it is, then let v_u be the shared vertex between e_i and e_ell. If v_u is exactly the generator of mathcal V, then we have a corner point, and so we need to add this corner point into the set of intersections since it will necessarily be included in the clipped Voronoi tessellation. Once we have processed all the intersections for e, e_ell, and e_r as above, we need to then also enqueue all of the edges and their adjacent incident poygons into mathcal Q, provided that these pairs have not already been processed.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Let us give an example that illustrates this part of the procedure clearly.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In the first figure above, we are considering the processing of an edge e. The Voronoi polygon mathcal V we consider incident to e is shown, obtained by finding that the midpoint of e is contained in mathcal V. By just processing the intersections of mathcal V, we find the intersections with mathcal Cmathcal H(mathcal P) (shown in magenta) shown in orange. This alone is not enough, though, as we can see that we don't identify that the black dot between e_ell and e should be included in this intersection. This dot is an example of a corner point we were discussing previously, showing the need for this extra processing step. Note also from the above figure that  unbounded polygons mathcal V alone are not sufficient for checking all intersections, as we can see that some of the bounded polygons also intersect with the convex hull. Eventually, after processing all edges in this way, we obtain the set of orange points shown in the second figure.","category":"page"},{"location":"math/clipped/#Clipping-the-polygons","page":"Clipped Voronoi Tessellations","title":"Clipping the polygons","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Once all the intersections have been computed, clipping the polygons is straightforward. For each mathcal V for which intersections were found, we store with it all intersections found between it and the convex hull. We then remove all vertices from mathcal V that are outside of the domain and then add in these intersection points, sorting mathcal V as needed so that it remains a convex polygon. Doing this for all mathcal V completes the clipping, giving the tessellation shown at the start of this section.","category":"page"},{"location":"math/clipped/#Clipping-a-Voronoi-polygon-to-a-rectangle","page":"Clipped Voronoi Tessellations","title":"Clipping a Voronoi polygon to a rectangle","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Now let us describe clipping to some rectangle mathcal R = a b times c d rather than to the convex hull. The procedure here is very different, and rather than processing the entire tessellation at once we apply the procedure to individual polygons. Before we discuss this procedure in general, we need to discuss two algorithms: The Sutherland-Hodgman algorithm and the Liang-Barsky algorithm.","category":"page"},{"location":"math/clipped/#The-Sutherland-Hodgman-algorithm","page":"Clipped Voronoi Tessellations","title":"The Sutherland-Hodgman algorithm","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The Sutherland-Hodgman algorithm is an algorithm for clipping a polygon (called the subject polygon) to a convex polygon (called the clip polygon). The algorithm works by essentially extending each edge of the clip polygon to infinity and then iteratively clipping the subject polygon to each edge of the clip polygon. Let us give an example of this.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In the figure above, the black polygon shows the subject polygon and the red polygon is the clip polygon. Our aim is to clip the subject polygon to the clip polygon to obtain the blue polygon shown. Letting mathcal P_S = p_1 ldots p_n and mathcal P_C = q_1 ldots q_m be the subject and clip polygons listed in counter-clockwise order with p_1 neq p_n and q_1 neq q_m, respectively, the procedure for this clipping as follows:","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Define mathcal O = mathcal P_S and let q = q_n. For each p in mathcal P_C, we first let mathcal I = mathcal O and then reset mathcal O = emptyset.\nWith this p, let s = mathcal I_r, where mathcal I = r and mathcal I_j denotes the jth element of mathcal I. For i=12ldotsr, we consider the edge e = (s mathcal I_i). If mathcal I_i is left of overrightarrowqp, then it is outside of mathcal P_S, and so we need to check if there is any intersection, i.e. if e intersects overrightarrowqp, which can be easily checked by considering the position of s relative to overrightarrowqp. If  mathcal I_i is not left of overrightarrowqp but s is left, then there must be an intersection of e with overrightarrowqp since s and mathcal I_i are on opposite sides of overrightarrowqp. In either of these cases, the intersection that we find gets pushed into mathcal O, and we then set s = mathcal I_i and continue onto the next i.\nOnce we have processed each mathcal I_i, we set q = p and then continue onto the next p in mathcal P_C.\nFinally, once each vertex in mathcal P_C has been processed, the final polygon is defined by the points in mathcal O.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Let's visualise this procedure.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In the figure above, we show the individual steps of this algorithm. In the second panel, the blue line shows the extended edge of the clip polygon that we use to slice the subject polygon, clipping it onto the edge. For the next four panels, the blue line never touches the subject polygon, and so nothing happens. The last two panels show the last two clips needed to obtain the final polygon.","category":"page"},{"location":"math/clipped/#The-Liang-Barsky-algorithm","page":"Clipped Voronoi Tessellations","title":"The Liang-Barsky algorithm","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Now we describe the Liang-Barsky algorithm, an algorithm for clipping a line segment to a rectangle. Let us take a line vb p(t) = vb p_0 + tvb d, where vb p_0 = (x_0 y_0), vb d = (Delta x Delta y), and 0 leq t leq 1. A point (x y) = vb p(t) is in the rectangle if (1) a leq x_0 + t Delta x leq b and (2) c leq y_0 = t Delta y leq d, or equivalently tp_i leq q_i for i=1234, where:","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Left edge: p_1 = -Delta x, q_1 = x_0 - a.\nRight edge: p_2 = Delta x, q_2 = b - x_0.\nBottom edge: p_3 = -Delta y, q_3 = y_0 - c.\nTop edge: p_4 = Delta y, q_4 = d - y_0.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Using these inequalities, we can efficiently compute the intersections by processing each side of the rectangle at a time. Starting with t_1 = 0 and t_2 = 1 defining the current interval for the intersections, for each edge we do the following: Compute the p_i and q_i associated with the edge, and then r_i = q_i  p_i. This r_i gives the parameter value for the intersection point of the line and the current edge (possibly extended outside of 0 leq t leq 1). There are three cases to consider:","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"If p_i = 0 and q_i  0, then the line is parallel with the edge but outside of the rectangle, and so there are no intersections of the line with the rectangle.\nIf p_i  0 and r  t_1, then the the line enters the rectangle earlier than what is proposed by the current interval t_1 t_2, and so the line is outside of the rectangle and we have no intersections to consider. If r  t_2, then we update the intersection interval and let t_2 = r.\nIf p_i  0 and r  t_2, then just like above we see that the line is outside of the rectangle and so we return no intersections. If r  t_1, set t_1 = r.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Applying these cases to each edge one at a time, updating t_1 and t_2 as required, gives the intersection parameters t_1 and t_2 defining the intersection of the line with the rectangle. If we ever did exit early, then we do not return any intersections.","category":"page"},{"location":"math/clipped/#Clipping-a-bounded-Voronoi-polygon","page":"Clipped Voronoi Tessellations","title":"Clipping a bounded Voronoi polygon","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Now that we have two important algorithms for clipping, let us begin our discussion on clipping the Voronoi polygons in particular, starting with bounded Voronoi polygons. This case is simple - simply apply the Sutherland-Hodgman algorithm to the polygon, using the clip polygon as the rectangle.","category":"page"},{"location":"math/clipped/#Clipping-an-unbounded-Voronoi-polygon","page":"Clipped Voronoi Tessellations","title":"Clipping an unbounded Voronoi polygon","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The case of clipping an unbounded Voronoi polygon is more complicated. Rather than trying to come up with an effective way to clip the unbounded rays of the polygon to a rectangle and taking care of all the possible edge cases, we use a more direct approach. Our aim is to convert the unbounded polygon into a finite polygon such that its intersection with the rectangle is the same as the intersection of the unbounded polygon with the rectangle. We do this in steps.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"First, for the two unbounded edges, we let u_m and v_m be the two midpoints of the edges of the convex hull that the unbounded edges go through.\nNext, we compute the maximum distance of the box to u_m and v_m, letting m = maxoperatornamedist(u_m mathcal R) operatornamedist(v_m mathcal R).\nNow, starting with inside = true and t = 1, we do the following until inside = false.\nReplace t by 2t, and compute p = u_m + td_1, where d_1 is a unit vector in the direction of the unbounded edge associated with u_m, and similarly q = v_m + td_2. \nApply the Liang-Barsky algorithm to mathcal R and the line segment through p and q, and check if the line segment is completely outside of mathcal R. If it is, then set outside = true.\nWe then need to be careful about the case where the generator associated with the polygon is outside of mathcal R. In this case, the unbounded edge might start outside of the rectangle and eventually find its way inside. To avoid this, we be conservative and check that the length of each ray is greater than the maximum distance from u_m and v_m to the clip rectangle. In particular, compute delta_1 = p - u_m and delta_2 = q - v_m. If mindelta_1 delta_2  m, then the edge might possibly be inside mathcal R. If this is the case, we let inside = true and continue, and otherwise we let inside = false.\nOnce we stop iterating, the final values of p and q are the points that the unbounded edges will now stop at, thus defining a bounded polygon.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The reason we start with t = 1 instead of, say, t = 1 is so that we start at t = 2 in the loop and avoid any possibility of duplicated vertices for polygons completely outside of the box. Note also that an important reason that we need to apply the Liang-Barsky algorithm to the line segment through p and q is so that we can join the two unbounded edges together and be confident that this line is completely outside of this rectangle.  Let's make this polygon growing procedure clearer with an example, where we also pick a complicated example that demonstrates the need for the conservative check in the fifth step.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In the figure above, the polygon we are interested is the one corresponding to the black dot, and we want to clip this polygon to the red rectangle. The following figures show how we grow the polygon's unbounded edges to begin.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In these figures, the blue polygon shows the Voronoi polygon, and the green edges show the approximations to the unbounded rays; the top-most ray starts away from the polygon since the midpoint is further behind the associated circumcenter in this case. The magenta line shows the line segment joining the two approximations - the aim is to grow the green edges long enough such that the magenta line is completely outside of the red rectangle. Let's analyse each figure.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"At t = 1, the line segment is outside of the rectangle, but there is still room to grow the green edges such that they go through the clip rectangle (in particular, the right-most edge). Since the maximum distance of the green edges is not larger than the maximum distance from the green edge's origins to the clip rectangle, our procedure will continue to grow the edges.\nAt t = 2, we have the same problem as at t=1 in that the magenta edge is still outside of the clip rectangle but the green edges can still grow into the clip rectangle.\nAt t = 4, the magenta edge is finally inside of the clip rectangle, but since it intersects it we need to keep growing the green edges until the magenta edge leaves again.\nThe situation at t=8 is the same as at t=4.\nFinally, at t=18, the magenta edge is completely outside of the clip rectangle, and the length of the two green edges is now greater than the maximum distance from the green edge's origins to the clip rectangle. Thus, we can stop growing the unbounded edges here.\nThe final figure shows the bounded polygon obtained by growing the unbounded edges (with the left side of it out of frame).","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Once a bounded polygon representing the unbounded polygon has been obtained, we apply the Sutherland-Hodgman algorithm as before to clip it to the rectangle. For the example above, the polygon we obtain is shown below.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"fig # hide","category":"page"},{"location":"math/clipped/#Computing-the-intersection-of-the-Voronoi-tessellation-with-a-convex-polygon","page":"Clipped Voronoi Tessellations","title":"Computing the intersection of the Voronoi tessellation with a convex polygon","text":"","category":"section"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"We also provide support for clipping Voronoi tessellations to convex polygons. The mathematical details are not too complex in this case. To summarise, we simply, letting mathcal C denote the convex polygon,","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Find a bounding box for mathcal C, say a b times c d.\nUsing the approach in the previous section, clip all Voronoi polygons to a b times c d.\nThen, using the Sutherland-Hodgman algorithm (this is why the polygon must be convex), clip all these newly clipped Voronoi polygons to mathcal C.","category":"page"},{"location":"math/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The second approach is used because we need to ensure that we grow the unbounded polygons appropriately to guarantee that the third step is correct.","category":"page"},{"location":"math/refinement/#Mesh-Refinement","page":"Mesh Refinement","title":"Mesh Refinement","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Now we describe how we refine meshes. We do not discuss curve-bounded domains here, leaving this discussion to the curve-bounded section. The mesh refinement algorithm we implement is Ruppert's Delaunay refinement algorithm with some modifications from Shewchuk, following the presentation in Chapter 6 of the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013). ","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"To introduce the mesh refinement algorithm, we need to discuss a few preliminaries. We let mathcal M denote a mesh mathcal Dmathcal T(mathcal P mathcal S mathcal B), where mathcal P is the point set, mathcal S is the segment set, and mathcal B is the boundary.","category":"page"},{"location":"math/refinement/#Triangle-Quality","page":"Mesh Refinement","title":"Triangle Quality","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We need a way to measure the \"quality\" of a triangle in order to know what triangles need refinement. The quality of a triangle is typically measured using the radius-edge ratio, which is the ratio of the radius of the triangle's circumference to its minimmu edge length. Symbolically, rho = Rell_min, where R is the triangle's circumradius, ell_min its minimum edge length, and rho is the radius-edge ratio. The lower the radius-edge ratio, the better we say the triangle's quality is. We can also view reducing rho as increasing the minimum angle, theta_min, since rho is related to theta_min by ","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"rho = fracRell_min = frac12sintheta_min","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We say that a triangle is of bad quality if rho  barrho for some barrho  0 or, equivalently, theta_min  bartheta. Typically, bartheta approx 339^circ is about the limit of convergence for the algorithm. In addition to controlling rho, we can also control the area A of the triangle, saying a triangle is too large if A  A_max and too small if A  A_min. ","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Thus, given a triangle T and constants barrho, A_min, and A_max, we say that T is of bad quality if any of the following are true: (1) rho  bar rho or (2) A  A_max. For A_min, we of course can't split T in order to increase its area. Instead, the A_min threshold will be used to stop the splitting of any bad quality triangle if its area would be reduced to below A_min, and any triangle whose area is already below A_min will never be refined further.","category":"page"},{"location":"math/refinement/#Edge-Encroachment","page":"Mesh Refinement","title":"Edge Encroachment","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Mesh refinement algorithms typically refine bad quality triangles by inserting their circumcenter into the triangulation (there are other variants, but we will not discuss them here). There is one problem with this approach: the circumcenter of a triangle might lie outside of mathcal M, and so we would never be able to insert it. To get around this, we introduce the concept of edge encroachment. We say that a vertex v encroaches upon a segment e if it is inside the closed diametral circle of e but is not a vertex of e, and v is visible from e.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Checking for encroachment is relatively straightforward: The only vertices that might encroach upon a segment e are those adjacent to it. In particular, let the segment be e = e_uv and find the triangles T_uvw and T_uvx adjacent to e. If either p_w or p_x are in the diametral circle of e_uv, then e is encroached. Checking whether a point is inside a diametral circle is also simple: By Thales' theorem, the angle angle p_upp_v is a right angle when p is on the diametral circle, so p is inside the diametral circle if and only if angle p_upp_v leq 90^circ. To efficiently check if theta = angle p_upp_v leq 90^circ, we can use a dot product. Since ","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"cos theta = fraclangle p - p_u p - p_v ranglep - p_up - p_v","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"and cos 90^circ = 0, we can check if theta leq 90^circ by checking if langle p - p_u p - p_v rangle geq 0. Thus:","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"If langle p - p_u p - p_vrangle  0, then theta  90^circ.\nIf langle p - p_u p - p_vrangle = 0, then theta = 90^circ.\nIf langle p - p_u p - p_vrangle  0, then theta  90^circ.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The first two cases would imply that p encroaches upon e_uv.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Once we have identifed an edge as being encroached, we need to split it. We do this by simply inserting the midpoint p_m = (p_u + p_v)  2 into the triangulation, and replacing the segment e_uv by the two new subsegments, legalising any new edges as needed to restore the Delaunay property.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"One issue with this definition of encroachment is that there may be a large number of vertices that have to be inserted to deal with all encroached edges as the diametral circle is quite large. To avoid this, we generalise the definition of a diametral circle to that of a diametral lens defined by some lens angle theta_ell. Firstly, let p be a point on the perpendicular bisector L_uv of e_uv, and left of e_uv, such that angle p_upp_v = theta_ell, and similarly for a point q right of L. Now draw two circles through p_u p_v p and p_u p_v q, respectively, and compute their intersection. The diametral lens is this intersection. We show an example of a diametral lens below.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig # hide","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In this figure, the blue circle shows the diametral circle, and the red shape shows the diametral lens, the grey line is the perpendicular bisector of e_uv, and the magenta circles show the two circles whose intersection defines the diametral lens. Checking if a point p is inside the diametral lens can be done using an extended version of Thales' theorem (see, for example, Theorem 9 in Lisboa's thesis). We define the quantity ","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Delta(p_u p_v p) = langle p_u - p p_v - p rangle^2 - p_u - p^2 p_v - p^2 cos^2(theta_ell)","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Then:","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"If Delta(p_u p_v p)  0, then p is inside the diametral lens.\nIf Delta(p_u p_v p) = 0, then p is on the boundary of the diametral lens.\nIf Delta(p_u p_v p)  0, then p is outside the diametral lens.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"One issue with diametral lens is that the final mesh is not guaranteed to be Delaunay, but many more subsegment splits will be avoided than if we had used diametral circles so that the final mesh has fewer triangles. It is possible that circumcenters are outside of the boundary when using diametral lens. In this case, we insert the triangle's centroid rather than its circumcenter.","category":"page"},{"location":"math/refinement/#Deleting-Free-Vertices","page":"Mesh Refinement","title":"Deleting Free Vertices","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In addition to splitting a subsegment whenever it is encroached, we can also use an idea from Chew's algorithm for mesh refinement to improve our refinement. When we split a subsegment, points inside the original segment's diametral circle might cause unduly short edges to be created, leading to bad quality triangles that will just have to be split once again. To overcome this, we delete all free vertices inside the diametral circle, except those that are not visible to the segment (i.e., a segment in mathcal S occludes the visibility between the segment and the vertex), before splitting the segment. A free vertex is any vertex not belonging to a segment that was inserted into the triangulation through refinement, i.e. a vertex that was not originally in mathcal P and is not on the boundary or on an interior segment.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"To delete these free vertices, we apply the following routine to each of e_uv and e_vu. We write these details for e_uv only.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Get the vertex w adjacent to e_uv using the adjacent map.\nIf w is a free vertex and is either inside or on the diametral circle of e_uv, delete w from the triangulation and return to step 1. Otherwise, stop the routine here.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Using this idea, we can reduce the number of triangles present in the final refined mesh while still retaining a high quality output. Moreover, since we use diametral lens instead of diametral circles, we avoid introducing as many vertices that would just be deleted by this procedure anyway.","category":"page"},{"location":"math/refinement/#Splitting-a-Triangle","page":"Mesh Refinement","title":"Splitting a Triangle","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Now let's discuss how we actually insert a circumcenter into the triangulation to improve the quality of a triangle T_uvw. The procedure is simple:","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Let c be the circumcenter of a bad quality T_uvw.\nIf c encroaches upon some subsegment e in mathcal S, split e. Otherwise, insert c into mathcal M.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Inserting c into mathcal M is simple using the Bowyer-Watson algorithm. Note that, for the point location step, we already know that the triangle T_uvw is a triangle containg c in its circumcircle, so we can skip the point location step.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Checking if c encroaches upon a subsegment e can be expensive. The cheapest way to do this is to actually just insert c into mathcal M, and simply check if any of the edges of triangles containing c are encroahced. If they are, we undo the insertion of c and return to the original mathcal M prior to the insertion of c, and split the marked encroached edges. To undo this insertion efficiently, we store a list of all changes to the triangulation made during the insertion of c.","category":"page"},{"location":"math/refinement/#Small-Angles","page":"Mesh Refinement","title":"Small Angles","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A very crucial issue to notice with our refinement algorithm thus far is that it may fail to handle small angles. The first problem is called ping-pong encroachment, encountered when segments share a vertex and meet at an angle less than 45^circ. Consider the example below; we illustrate this using diametral circles, but the same problem can be encountered when using diametral lenses.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig # hide","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In the first figure, the bottom segment e_1 encroaches upon the vertex of the other adjoining segment e_2, so we split e_1 at its midpoint. Once we insert this new midpoint, the segment e_2 is encroached upon, and so we need to split e_2. The third figure then shows how the new segment of e_1 is encroached upon by the vertex adding onto e_2, and so yet again we must split this subsegment. We can continue this process again to obtain the fourth figure. This will repeat indefinitely, leading to many points added as shown in the last figure. This is the ping-pong encroachment problem.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"To overcome this problem, we use concentric circular shells. The basic idea is to imagine that each input vertex is surrounded by concentric circles whose radii are all the powers of two. We will still always split a segment initially at its midpoint, but for any future subsegments we need to make use of the concentric circles. When an encroached subsegment adjoins another segment at an acute angle, we split it at one of the circular shells centred at the shared vertex, so that one of the new subsegments has a power of two length. The shell we choose to split at is the one that guarantees that the two new subsegments produced by the split are between 13 and 23 the length of the split subsegment. With this approach, we can avoid the ping-pong encroachment. Notice that the choice of having the shells be powers of two implies that, for any future splits, the most balanced split for the power-of-two length subsegment will always be at the midpoint. If both vertices of a segment adjoin other segments, then the segment could be split twice at each end. To deal with this, just chosoe one vertex arbitrarily and split it so that the subsegment adjoining that vertex has a power-of-two length between 14 and 12 the length of the split subsegment. The other subsegment could still undergo another off-center split, but eventually all subsegment splits are bisections. This solves our ping-pong encroachment problem since adjoining subsegments of equal length cannot encroach upon each other. An example of this adaptation is shown below.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig # hide","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In the second and third figures we have two midpoint splits since the segments are the input segments. For the subsegment in the fourth figure, we see that the new point is being put onto the concentric circles surrounding the input vertex, and similarly for the last figure. In the last figure, we finally see that the newly inserted vertx is no longer encroaching upon the other subsegment, and so the ping-pong encroachment stops.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"One other improvement made by Ruppert is to avoid splitting triangles that are nestled in the corner of a small input angle. For a triangle T_uvw, suppose that e_uv is its shortest edge so that the smallest angle of T_uvw is opposite e_uv. Then, if e_wu and e_wv are both segments and the triangle is skinny, it is considered to be a nestled triangle and so the triangle will never be split.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The last improvement we consider involves seditious triangles. If two adjoining subsegments meet at a very small angle, then splitting them may lead to a new edge that is shorter than the previously shortest edge in the mesh, leading to a bad quality mesh. Moreover, this short edge will cause more triangles to be refined as the adjoining triangles will necessarily be skinny, leading to more short edges, thus leading to an infinite loop. To avoid this, we need to prevent these short edges from causing more refinement. We say that an edge is seditious if its two vertices lie on two distinct segments that meet each other at an angle less than 60^circ (in this package, the default definition for a seditious edge actually uses an angle of 20^circ), they lie on the same concentric shell (we don't check this requirement in this package), and the two vertices are true midpoints (not off-center splits). With this definition, we say that a triangle is seditious if its shortest edge is seditious, and refuse to split any skinny triangle that is seditious, thus preventing seditious edges from infesting the rest of the mesh.","category":"page"},{"location":"math/refinement/#The-Complete-Algorithm","page":"Mesh Refinement","title":"The Complete Algorithm","text":"","category":"section"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Now that we have an understanding of all the pieces involved in the refinement algorithm, we can list the complete algorithm.","category":"page"},{"location":"math/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Start by identifying all encroached segments and placing them into a priority queue, prioritising the longer segments first.\nFor each encroached subsegment e: Delete all free vertices in the diametral circle (or lens) of e and then split e at a position depending on whether e is an input segment or meets another subsegment at a small angle.\nNext, identify all triangles that need to be refined, i.e. any triangle T_uvw with rho  barrho or A  A_max, ignoring any of those which are nestled or seditious or A  A_min. Store these triangles in a priority queue, prioriting the triangles with the largest radius-edge ratio first.\nNext, while there are any bad quality triangles: Attempt to split the bad quality triangle T by inserting its circumcenter c into mathcal M (or centroid, if c is outside of the domain in case diametral lenses are used). If c encroaches on any new edges, undo the insertion and then split all those encroached segments as in step 2. If the insertion was successful, check all the newly added triangles for bad quality and add them to the priority queue if needed.\nOnce there are no more bad quality triangles to split, the algorithm is complete.","category":"page"},{"location":"tutorials/unconstrained/#Unconstrained-Triangulations","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"Our first example considers constructing unconstrained Delaunay triangulations. To start, let us load in the packages we will need.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"using DelaunayTriangulation\nusing CairoMakie # for plotting\nusing StableRNGs # for reproducibility\nusing LinearAlgebra # used for computing norms later","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We consider just triangulating a random set of points. First, generating the points:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"rng = StableRNG(123)\npoints = rand(rng, 2, 500) # just do rand(2, 500) if you are not concerned about the RNG","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We now triangulate these points by using triangulate. We pass the rng as a keyword argument, but again if you are not concerned about the RNG (or set the seed using Random.seed!) then you can ignore this.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri = triangulate(points; rng = rng)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"fig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This tri object is our Triangulation, and we can interact with it in many ways.","category":"page"},{"location":"tutorials/unconstrained/#Iterating-over-vertices","page":"Unconstrained Triangulations","title":"Iterating over vertices","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"For example, we can iterate over the points in the triangulation using each_solid_vertex. Here we compute the centroid of the point cloud:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"function compute_centroid(tri)\n    s = [0.0, 0.0]\n    for i in each_solid_vertex(tri)\n        p = get_point(tri, i)\n        s .+= p\n    end\n    s ./= num_solid_vertices(tri)\n    return s\nend\ns = compute_centroid(tri)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We need to use the solid identifier because triangulations are made up of both solid and ghost vertices/edges/triangles, for reasons described in the manual. If we just use each_vertex(tri), then we also find a vertex -1 that corresponds to the boundary. For example, the points on the boundary can be obtained using:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_neighbours(tri, -1)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"One reason to be careful with this especially is that get_point(tri, -1) does actually correspond to a coordinate,","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_point(tri, -1)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"(This is the pole of inaccessibility for the domain; see here for more details.) You can use each_vertex or each_ghost_vertex to consider all types of vertices or only the ghost vertices. If you just want the vertices, use each_vertex(tri), which will also include the ghost vertex.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"each_vertex(tri)","category":"page"},{"location":"tutorials/unconstrained/#Iterating-over-edges","page":"Unconstrained Triangulations","title":"Iterating over edges","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We can also iterate over the edges of the triangulation using each_solid_edge, or each_edge for both solid and ghost edges and each_ghost_edge for only the ghost edges. To give an example, here we compute the average length of an edge.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"function compute_mean_edge_length(tri)\n    ℓ = 0.0\n    for e in each_solid_edge(tri)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ += norm(p .- q)\n    end\n    ℓ /= num_solid_edges(tri)\n    return ℓ\nend\nℓ = compute_mean_edge_length(tri)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"By default, the triangulation has ghost edges, so each_edge and each_solid_edge are not the same.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"each_edge(tri)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"Note also that the edges are all given as unordered, so the set of edges only includes one of (i, j) and (j, i) for each edge (i, j).","category":"page"},{"location":"tutorials/unconstrained/#Iterating-over-triangles","page":"Unconstrained Triangulations","title":"Iterating over triangles","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"Similarly, we can iterate over the triangles using each_solid_triangle, each_ghost_triangle, or each_triangle. By default, ghost triangles are included in the output. Here we compute the area of the domain by getting the area of each triangle.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"area(p, q, r) = 0.5 * ((getx(q) - getx(p)) * (gety(r) - gety(p)) - (gety(q) - gety(p)) * (getx(r) - getx(p)))\nfunction compute_triangulation_area(tri)\n    A = 0.0\n    for T in each_solid_triangle(tri)\n        i, j, k = triangle_vertices(T)\n        p, q, r = get_point(tri, i, j, k)\n        A += area(p, q, r)\n    end\n    return A\nend\nA = compute_triangulation_area(tri)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"(You can compute areas like this using get_area(tri).) You can access the set of triangles using get_triangles(tri):","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_triangles(tri)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"The triangles are all positively oriented, meaning the triangles are given such that the corresponding points are traversed in counter-clockwise order.","category":"page"},{"location":"tutorials/unconstrained/#Querying-neighbour-information","page":"Unconstrained Triangulations","title":"Querying neighbour information","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We can query neighbour information at several levels.","category":"page"},{"location":"tutorials/unconstrained/#Points","page":"Unconstrained Triangulations","title":"Points","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"For a given point, there are two type of neighbours: The neighbouring vertices, and the neighbouring triangles. The neighbours can be obtained using get_neighbours. For example, the set of vertices that share an edge with the fifth vertex is:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_neighbours(tri, 5)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"The set of triangles that share an edge with the fifth vertex is obtained using get_adjacent2vertex. This returns a set of edges (v, w) such that, for a given vertex u, (u, v, w) is a positively oriented triangle in the triangulation. For example,","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_adjacent2vertex(tri, 5)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"means that the triangles that contain 5 as a vertex are (5, 93, 117), (5, 117, 301), (5, 301, 214), and (5, 214, 93). We can verify this:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"filter(T -> 5 ∈ triangle_vertices(T), get_triangles(tri))","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"These queries can also be applied to the ghost vertices, in which information about the boundary is provided.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_neighbours(tri, -1)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_adjacent2vertex(tri, -1)","category":"page"},{"location":"tutorials/unconstrained/#Edges","page":"Unconstrained Triangulations","title":"Edges","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"For a given edge (u, v), the relevant neighbours are the vertices that are next to it so that a triangle is formed. We can find the vertex w such that (u, v, w) is a positively oriented triangle in the triangulation using get_adjacent(tri, u, v). For example,","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_adjacent(tri, 163, 365)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"means that (163, 365, 295) is a positively oriented triangle, as we can verify:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"DelaunayTriangulation.triangle_orientation(tri, 163, 365, 295)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"(The representation of this predicate using a DelaunayTriangulation.Certificate is described in more detail in the manual.) The other triangle adjoining the unordered edge (u, v), meaning the oriented edge (v, u), is obtained similarly:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_adjacent(tri, 365, 163)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"If an edge (u, v) is on the boundary, oriented so that there is no solid vertex w such that (u, v, w) is a triangle in the triangulation, then get_adjacent(tri, u, v) returns the ghost vertex. For example,","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"get_adjacent(tri, 398, 258)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"means that (398, 258) is a boundary edge and (398, 258, -1) is a ghost triangle. You can test for this case using DelaunayTriangulation.is_boundary_edge:","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"DelaunayTriangulation.is_boundary_edge(tri, 258, 398)","category":"page"},{"location":"tutorials/unconstrained/#Just-the-code","page":"Unconstrained Triangulations","title":"Just the code","text":"","category":"section"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"using DelaunayTriangulation\nusing CairoMakie # for plotting\nusing StableRNGs # for reproducibility\nusing LinearAlgebra # used for computing norms later\n\nrng = StableRNG(123)\npoints = rand(rng, 2, 500) # just do rand(2, 500) if you are not concerned about the RNG\n\ntri = triangulate(points; rng = rng)\n\nfig, ax, sc = triplot(tri)\nfig\n\nfunction compute_centroid(tri)\n    s = [0.0, 0.0]\n    for i in each_solid_vertex(tri)\n        p = get_point(tri, i)\n        s .+= p\n    end\n    s ./= num_solid_vertices(tri)\n    return s\nend\ns = compute_centroid(tri)\n\nget_neighbours(tri, -1)\n\nget_point(tri, -1)\n\neach_vertex(tri)\n\nfunction compute_mean_edge_length(tri)\n    ℓ = 0.0\n    for e in each_solid_edge(tri)\n        u, v = edge_vertices(e)\n        p, q = get_point(tri, u, v)\n        ℓ += norm(p .- q)\n    end\n    ℓ /= num_solid_edges(tri)\n    return ℓ\nend\nℓ = compute_mean_edge_length(tri)\n\neach_edge(tri)\n\narea(p, q, r) = 0.5 * ((getx(q) - getx(p)) * (gety(r) - gety(p)) - (gety(q) - gety(p)) * (getx(r) - getx(p)))\nfunction compute_triangulation_area(tri)\n    A = 0.0\n    for T in each_solid_triangle(tri)\n        i, j, k = triangle_vertices(T)\n        p, q, r = get_point(tri, i, j, k)\n        A += area(p, q, r)\n    end\n    return A\nend\nA = compute_triangulation_area(tri)\n\nget_triangles(tri)\n\nget_neighbours(tri, 5)\n\nget_adjacent2vertex(tri, 5)\n\nfilter(T -> 5 ∈ triangle_vertices(T), get_triangles(tri))\n\nget_neighbours(tri, -1)\n\nget_adjacent2vertex(tri, -1)\n\nget_adjacent(tri, 163, 365)\n\nDelaunayTriangulation.triangle_orientation(tri, 163, 365, 295)\n\nget_adjacent(tri, 365, 163)\n\nget_adjacent(tri, 398, 258)\n\nDelaunayTriangulation.is_boundary_edge(tri, 258, 398)","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"","category":"page"},{"location":"tutorials/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/triangulation/#Triangulations","page":"Triangulations","title":"Triangulations","text":"","category":"section"},{"location":"api/triangulation/#DelaunayTriangulation.triangulate","page":"Triangulations","title":"DelaunayTriangulation.triangulate","text":"triangulate(points; segments=nothing, boundary_nodes=nothing, kwargs...) -> Triangulation\n\nComputes the Delaunay triangulation of points, and then the constrained Delaunay triangulation if any of segments and boundary_nodes are not nothing.\n\nArguments\n\npoints: The points to triangulate. (This might get mutated for curve-bounded domains.)\n\nKeyword Arguments\n\nFor the keyword arguments below, you may like to review the extended help as some of the arguments carry certain warnings.\n\nsegments=nothing: The segments to include in the triangulation. If nothing, then no segments are included.\nboundary_nodes=nothing: The boundary nodes to include in the triangulation. If nothing, then no boundary nodes are included, and the convex hull of points remains as the triangulation. These boundary nodes   should match the specification given in check_args if a boundary is provided as a set of vertices, meaning the boundary is a piecewise linear curve. To specify a curve-bounded domain, you should   follow the same specification, but use AbstractParametricCurves to fill out the vector, and any piecewise linear section should still be provided as a sequence of vertices. \npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nweights=ZeroWeight{number_type(points)}(): The weights to use for the triangulation. By default, the triangulation is unweighted. The weights can also be provided as a vector, with the ith weight referring to the ith vertex, or more generally any object that defines get_weight. \nIntegerType=Int: The integer type to use for the triangulation. This is used for representing vertices.\nEdgeType=isnothing(segments) ? NTuple{2,IntegerType} : (edge_type ∘ typeof)(segments): The edge type to use for the triangulation. \nTriangleType=NTuple{3,IntegerType}: The triangle type to use for the triangulation.\nEdgesType=isnothing(segments) ? Set{EdgeType} : typeof(segments): The type to use for storing the edges of the triangulation.\nTrianglesType=Set{TriangleType}: The type to use for storing the triangles of the triangulation.\nrandomise=true: Whether to randomise the order in which the points are inserted into the triangulation. This is done using get_insertion_order.\ndelete_ghosts=false: Whether to delete the ghost triangles after the triangulation is computed. This is done using delete_ghost_triangles!.\ndelete_empty_features=true: Whether to delete empty features after the triangulation is computed. This is done using clear_empty_features!.\ntry_last_inserted_point=true: Whether to try the last inserted point first when inserting points into the triangulation. \nskip_points=(): The points to skip when inserting points into the triangulation.   Note that, for curve-bounded domains, skip_points is ignored when using enrich_boundary!.\nnum_sample_rule=default_num_samples: A function mapping a number of points n to a number of samples m to use for sampling the initial points during the point location step of the algorithm within find_triangle.\nrng::Random.AbstractRNG=Random.default_rng(): The random number generator.\ninsertion_order::Vector=get_insertion_order(points, randomise, skip_points, IntegerType, rng): The insertion order to use for inserting points into the triangulation. This is ignored if you are defining a curve-bounded domain.\nrecompute_representative_points=true: Whether to recompute the representative points after the triangulation is computed. This is done using compute_representative_points!. \ndelete_holes=true: Whether to delete holes after the triangulation is computed. This is done using delete_holes!.\ncheck_arguments=true: Whether to check the arguments points and boundary_nodes are valid. This is done using check_args.\npolygonise_n=4096: Number of points to use for polygonising the boundary when considering the polygon hierarchy for a curve-bounded domain using polygonise. See triangulate_curve_bounded.\ncoarse_n=0: Number of points to use for initialising a curve-bounded domain. See triangulate_curve_bounded. (A value of 0 means the number of points is chosen automatically until the diametral circles of all edges are empty.)\n\nOutputs\n\ntri::Triangulation: The triangulation.\n\nnote: Type stability\nThe output from this function is currently not type stable. In particular, the inferred type is only Triangulation without any other information. If you are depending on the output from triangulate inside some other function, you should consider putting the output behind a function barrier; information about using function barriers is given here.\n\nExtended help\n\nHere are some warnings to consider for some of the arguments.\n\npoints\n\nwarning: Mutation\nFor curve-bounded domains, points may get mutated to include the endpoints of the provided curves, and when inserting  Steiner points to split segments or refine boundaries.\n\ndanger: Floating point precision\nIf your points are defined using non-Float64 coordinates, you may run into precision issues that  lead to problems with robustness. The consequences of this could be potentially catastrophic, leading to  infinite loops for example. If you do encounter such issues, consider converting your coordinates to Float64.\n\nsegments\n\nwarning: Segments outside of the domain\nWhen segments are outside of the domain, are if they are not entirely contained with the domain, you may run into issues - especially for curve-bounded domains. It is your responsibility to ensure that the segments are contained within the domain.\n\nwarning: Mutation\nThe segments may get mutated in two ways: (1) Segments may get rotated so that (i, j) becomes (j, i). (2) If there are segments that are collinear with other segments, then they may get split into chain of non-overlapping connecting segments (also see below). For  curve-bounded domains, segments are also split so that no subsegment's diametral circle contains any other point.\n\nwarning: Intersecting segments\nCurrently, segments that intersect in their interiors (this excludes segments that only intersect by sharing a vertex) cause problems for triangulating. While there  is some support for collinear segments that lie on top of each other (they get split automatically), this is not the case for segments that intersect in their interiors. Moreover, this automatic splitting should not be heavily relied upon, and for curve-bounded domains you should not rely on it at all as it causes problems during the enrichment phase from enrich_boundary!.\n\nboundary_nodes\n\nwarning: Points outside of boundary curves\nWhile for standard domains with piecewise linear boundaries (or no boundaries) it is fine for points to be  outside of the domain (they just get automatically deleted if needed), they may cause problems for curve-bounded domains. Please ensure that all your points are inside the curve-bounded domain if you are providing curves in boundary_nodes.\n\nwarning: Aliasing\nFor curve-bounded domains, the boundary_nodes in the resulting Triangulation will not be aliased with the input boundary nodes.\n\nnote: Refinement\nFor curve-bounded domains, note that the triangulation produced from this function is really just an initial coarse discretisation of the true curved boundaries. You will need to  refine further, via refine!, to improve the discretisation, or increase coarse_n below. See also polygonise for a more direct approach to discretising a boundary (which  might not give as high-quality meshes as you can obtain from refine! though, note).\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.triangulate_convex","page":"Triangulations","title":"DelaunayTriangulation.triangulate_convex","text":"triangulate_convex(points, S; delete_ghosts=false, delete_empty_features=true, rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -> Triangulation\n\nTriangulates the convex polygon S.\n\nArguments\n\npoints: The point set corresponding to the vertices in S.\nS: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that S[begin] ≠ S[end].\n\nKeyword Arguments\n\ndelete_ghosts=false: If true, the ghost triangles are deleted after triangulation. \ndelete_empty_features=true: If true, the empty features are deleted after triangulation.\nrng=Random.default_rng(): The random number generator used to shuffle the vertices of S before triangulation.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\nkwargs...: Additional keyword arguments passed to Triangulation.\n\nOutput\n\ntri::Triangulation: The triangulated polygon. \n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.triangulate_rectangle","page":"Triangulations","title":"DelaunayTriangulation.triangulate_rectangle","text":"triangulate_rectangle(a, b, c, d, nx, ny; kwargs...) -> Triangulation\n\nTriangulates the rectangle [a, b] × [c, d].\n\nArguments\n\na: The minimum x-coordinate. \nb: The maximum x-coordinate.\nc: The minimum y-coordinate.\nd: The maximum y-coordinate.\nnx: The number of points in the x-direction.\nny: The number of points in the y-direction.\n\nKeyword Arguments\n\nsingle_boundary=false: If true, then the boundary nodes are stored as a contiguous section. Otherwise, the boundary is split into four sections, in the order   bottom, right, top, left.\ndelete_ghosts=false: If true, then the ghost triangles are deleted. Otherwise, they are kept.\nIntegerType::Type{I}=Int: The type of the vertices. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type of the edges.\nTriangleType::Type{V}=NTuple{3,IntegerType}: The type of the triangles.\nEdgesType::Type{Es}=Set{EdgeType}: The type of the edges container.\nTrianglesType::Type{Ts}=Set{TriangleType}: The type of the triangles container.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutputs\n\ntri: The triangulation of the rectangle.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.refine!","page":"Triangulations","title":"DelaunayTriangulation.refine!","text":"refine!(tri::Triangulation; kwargs...)\n\nRefines the given Triangulation tri to meet the given quality constraints.\n\nSee the documentation for more information about mesh refinement, e.g. convergence issues and issues with small input-angles.\n\nArguments\n\ntri::Triangulation: The Triangulation to refine.\n\nKeyword Arguments\n\nmin_angle=30.0: The minimum angle constraint, in degrees.\nmax_angle=180.0: The maximum angle constraint, in degrees. \n\ndanger: Maximum angle constraints\nMaximum angle constraints are not currently implemented.\n\nmin_area=get_area(tri) / 1e9: The minimum area constraint.\nmax_area=typemax(number_type(tri)): The maximum area constraint.\nmax_points=max(1_000, num_solid_vertices(tri))^2: The maximum number of vertices allowed in the triangulation. Note that this refers to num_solid_vertices, not the amount returned by num_points.\nseditious_angle=20.0: The angle at which a triangle is considered seditious, in degrees. See is_triangle_seditious.\ncustom_constraint=(tri, T) -> false: A custom constraint function that takes a Triangulation and a triangle, and returns true if the triangle should be refined and false otherwise.\nuse_circumcenter=true: Whether to insert circumcenters for refining a triangle or generalised Steiner points.\n\ndanger: Generalised Steiner points\nGeneralised Steiner points are not yet implemented. Thus, this argument must be true (and the steiner_scale keyword below is ignored).\n\nuse_lens=true: Whether to use the diametral lens or the diametral circle for checking encroachment.\nsteiner_scale=0.999: The perturbation factor to use for generalised Steiner points if use_circumcenter=false. (Not currently used - see above.)\nrng=Random.default_rng(): The random number generator to use in case it is needed during point location.\nconcavity_protection=false: Whether to use concavity protection or not for find_triangle. Most likely not needed, but may help in pathological cases.\npredicates::AbstractPredicateKernel=AdaptiveKernel(): Method to use for computing predicates. Can be one of FastKernel, ExactKernel, and AdaptiveKernel. See the documentation for a further discussion of these methods.\n\nOutput\n\nThe triangulation is refined in-place.\n\nwarning: Duplicate points and unused points\nDuring refinement, points are often deleted, which may often lead to points in get_points(tri) that do not  appear anywhere in the triangulation. (This is why we recommend e.g. each_solid_vertex over each_point.) Similarly, since points are deleted, when two triangles have a common circumcenter it might happen (if they are near an input segment) that a point is duplicated inside get_points(tri), in case one circumcenter was deleted previously.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.retriangulate","page":"Triangulations","title":"DelaunayTriangulation.retriangulate","text":"retriangulate(tri::Triangulation, points=get_points(tri); kwargs...)\n\nRetriangulates the triangulation tri using the points points, returning a new Triangulation. \n\nArguments\n\ntri::Triangulation: The triangulation to retriangulate.\npoints=get_points(tri): The points to use for retriangulating the triangulation. By default, this is simply get_points(tri).\n\nKeyword Arguments\n\nskip_points=Set(filter(i -> !has_vertex(tri, i), each_point_index(tri))): The points to skip when inserting points into the triangulation.\nkwargs...: Extra keyword arguments passed to triangulate. Other keyword arguments, like segments and boundary_nodes,   are automatically passed from the fields of tri, but may be overridden by passing the corresponding keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.convert_boundary_points_to_indices","page":"Triangulations","title":"DelaunayTriangulation.convert_boundary_points_to_indices","text":"convert_boundary_points_to_indices(x, y; existing_points = NTuple{2, Float64}[], check_args=true) -> (Vector, Vector)\nconvert_boundary_points_to_indices(xy; existing_points = NTuple{2, Float64}[], check_args=true) -> (Vector, Vector)\n\nConverts a boundary represented by (x, y) or xy, where the points are combined rather than as separate sets of coordinates,  into a set of boundary nodes for use in triangulate.\n\nArguments\n\nx, y: The x and y-coordinates for the boundary points. The individual vectors must match the specification required for boundaries outlined in the documentation.\nxy: As above, except the coordinates are combined rather than given as separate vectors. \n\nKeyword Arguments\n\nexisting_points: The existing points to append the boundary points to. This is useful if you have a pre-existing set of points.\ncheck_args: Whether to check that the arguments match the specification in the documentation. \n\nOutputs\n\nboundary_nodes: The boundary nodes. \npoints: The point set, which is the same as existing_points but with the boundary points appended to it. \n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.check_args","page":"Triangulations","title":"DelaunayTriangulation.check_args","text":"check_args(points, boundary_nodes, hierarchy::PolygonHierarchy, boundary_curves = (); skip_points = Set{Int}()) -> Bool\n\nCheck that the arguments points and boundary_nodes to triangulate, and a constructed  PolygonHierarchy given by hierarchy, are valid. In particular, the function checks:\n\nThe dimension of the points. If the points are not 2D, a warning is thrown.\nThe points are all unique. If they are not, a warning is thrown and the indices of the duplicates are merged into skip_points.\nThere are at least three points. If there are not, an InsufficientPointsError is thrown.\n\nIf any duplicate points are found, the indices of the duplicates are merged into skip_points in-place.\n\nIf boundary_nodes are provided, meaning has_boundary_nodes, then the function also checks:\n\nIf the boundary curves all connect consistently. Here, this means that each section of a boundary curve ends at the start of the next boundary section;  for contiguous boundary curves, this means that the start and end boundary nodes are the same.\nIf the orientation of the boundary curves are all consistent. This means that the curves are all positively oriented relative to the domain,  so that e.g. the exterior boundary curves are all counter-clockwise (relative to just themselves), the next exterior-most curves inside those   exteriors are all clockwise (again, relative to just themselves), and so on.\n\ndanger: Intersecting boundaries\nAnother requirement for triangulate is that none of the boundaries intersect in their interior, which also prohibits  interior self-intersections. This is NOT checked. Similarly, segments should not intersect in their interior, which is not checked.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.toggle_warn_on_dupes!","page":"Triangulations","title":"DelaunayTriangulation.toggle_warn_on_dupes!","text":"toggle_warn_on_dupes!()\n\nToggle the warning for duplicate points in the input data. By default, this warning is enabled.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_points","page":"Triangulations","title":"DelaunayTriangulation.get_points","text":"get_points(convex_hull::ConvexHull) -> Points\n\nReturns the underlying point set of convex_hull.\n\n\n\n\n\nget_points(tri::Triangulation) -> Points\n\nReturn the points of the triangulation. Note that this may include points not yet in tri.\n\n\n\n\n\nget_points(boundary_enricher::BoundaryEnricher{P}) -> P\n\nReturns the point set associated with boundary_enricher.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_triangles","page":"Triangulations","title":"DelaunayTriangulation.get_triangles","text":"get_triangles(tri::Triangulation) -> Triangles\n\nReturn the triangles of the triangulation. These triangles are all given in counter-clockwise order,  and may include ghost triangles.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_boundary_nodes","page":"Triangulations","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(boundary_nodes, mnℓ...)\n\nGiven a collection of boundary_nodes, returns the specified component of the collection. There are several forms for the methods:\n\nget_boundary_nodes(boundary_nodes, m): If boundary_nodes has multiple curves, this returns the mth curve. If boundary_nodes has multiple sections, this returns the mth section. Otherwise, this returns the mth boundary node.\nget_boundary_nodes(boundary_nodes, m, n): If boundary_nodes has multiple curves, this returns the nth section of the mth curve. Otherwise, if boundary_nodes has multiple sections, this returns the nth boundary node of the mth section.\nget_boundary_nodes(boundary_nodes, (m, n)): This is equivalent to get_boundary_nodes(boundary_nodes, m, n).\nget_boundary_nodes(boundary_nodes::A, ::A): This just returns boundary_nodes.  \n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 2)\n2-element Vector{Vector{Int64}}:\n [6, 7, 8, 9]\n [9, 10, 6]\n\njulia> get_boundary_nodes([[1, 2, 3, 4], [4, 5, 1]], 1)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> get_boundary_nodes([1, 2, 3, 4, 5, 6, 1], 4)\n4\n\njulia> get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 1, 2)\n3-element Vector{Int64}:\n 4\n 5\n 1\n\njulia> get_boundary_nodes([[1, 2, 3, 4], [4, 5, 6, 1]], 2, 3)\n6\n\njulia> get_boundary_nodes([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 5, 1])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_interior_segments","page":"Triangulations","title":"DelaunayTriangulation.get_interior_segments","text":"get_interior_segments(tri::Triangulation) -> Edges\n\nReturn the interior segments of the triangulation. These are segments that are forced to be in the triangulation -  they are not the same as edges.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_all_segments","page":"Triangulations","title":"DelaunayTriangulation.get_all_segments","text":"get_all_segments(tri::Triangulation) -> Edges\n\nReturn all segments of the triangulation. This includes interior segments and boundary segments. Segments are  edges that are forced to be in the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_weights","page":"Triangulations","title":"DelaunayTriangulation.get_weights","text":"get_weights(tri::Triangulation) -> Weights\n\nReturn the weights of the triangulation. These are the weights of the vertices of the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_adjacent","page":"Triangulations","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent) -> Dict\n\nReturns the adjacent map of adj.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> d = Dict((1, 2) => 3, (2, 3) => 1, (3, 1) => 2);\n\njulia> adj = DelaunayTriangulation.Adjacent(d)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj)\nDict{Tuple{Int64, Int64}, Int64} with 3 entries:\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj) == d\ntrue\n\n\n\n\n\nget_adjacent(adj::Adjacent{I, E}, uv::E) -> Vertex\nget_adjacent(adj::Adjacent{I, E}, u, v) -> Vertex\n\nReturns the vertex w such that (u, v, w) is a positively oriented triangle in the underlying triangulation, or ∅ if no such triangle exists.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj = DelaunayTriangulation.Adjacent(Dict((1, 2) => 3, (2, 3) => 1, (3, 1) => 2, (4, 5) => -1))\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (4, 5) => -1\n  (1, 2) => 3\n  (3, 1) => 2\n  (2, 3) => 1\n\njulia> get_adjacent(adj, 4, 5)\n-1\n\njulia> get_adjacent(adj, (3, 1))\n2\n\njulia> get_adjacent(adj, (1, 2))\n3\n\njulia> get_adjacent(adj, 17, 5)\n0\n\njulia> get_adjacent(adj, (1, 6))\n0\n\n\n\n\n\nget_adjacent(tri::Triangulation) -> Adjacent\n\nReturns the adjacency map of the triangulation. This is a map from each edge (u, v) to a vertex w such that (u, v, w)  is a positively oriented triangle in tri. \n\nSee also Adjacent.\n\n\n\n\n\nget_adjacent(tri::Triangulation, uv) -> Vertex\nget_adjacent(tri::Triangulation, u, v) -> Vertex\n\nReturns the vertex w such that (u, v, w) is a positively oriented triangle in the underlying triangulation, or ∅ if no such triangle exists.\n\n\n\n\n\nget_adjacent(vorn::VoronoiTessellation) -> Adjacent{Index,Edge}\n\nGets the adjacency information of the Voronoi tessellation vorn as an Adjacent object. This object maps oriented edges  to the polygons that they belong to.\n\n\n\n\n\nget_adjacent(vor::VoronoiTessellation, ij) -> Index \nget_adjacent(vor::VoronoiTessellation, i, j) -> Index\n\nGets the polygon index associated with the oriented edge ij in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_adjacent2vertex","page":"Triangulations","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex) -> Dict\n\nReturns the adjacent2vertex map of adj2v.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> e1 = Set(((1, 2), (5, 3), (7, 8)));\n\njulia> e2 = Set(((2, 3), (13, 5), (-1, 7)));\n\njulia> d = Dict(9 => e1, 6 => e2);\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(d)\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  6 => Set([(13, 5), (-1, 7), (2, 3)])\n  9 => Set([(1, 2), (7, 8), (5, 3)])\n\njulia> get_adjacent2vertex(adj2v)\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  6 => Set([(13, 5), (-1, 7), (2, 3)])\n  9 => Set([(1, 2), (7, 8), (5, 3)])\n\njulia> get_adjacent2vertex(adj2v) == d\ntrue\n\n\n\n\n\nget_adjacent2vertex(adj2v::Adjacent2Vertex, w) -> Edges\n\nReturns the set of edges E such that (u, v, w) is a positively oriented triangle in the underlying triangulation for each (u, v) ∈ E.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> adj2v = DelaunayTriangulation.Adjacent2Vertex(Dict(1 => Set(((2, 3), (5, 7), (8, 9))), 5 => Set(((1, 2), (7, 9), (8, 3)))))\nAdjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:\n  5 => Set([(1, 2), (8, 3), (7, 9)])\n  1 => Set([(8, 9), (5, 7), (2, 3)])\n\njulia> get_adjacent2vertex(adj2v, 1)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (8, 9)\n  (5, 7)\n  (2, 3)\n\njulia> get_adjacent2vertex(adj2v, 5)\nSet{Tuple{Int64, Int64}} with 3 elements:\n  (1, 2)\n  (8, 3)\n  (7, 9)\n\n\n\n\n\nget_adjacent2vertex(tri::Triangulation) -> Adjacent2Vertex\n\nReturns the Adjacent2Vertex map of the triangulation tri. This is a map from a vertex w to a set of  all edges (u, v) such that (u, v, w) is a positively oriented triangle in tri.\n\n\n\n\n\nget_adjacent2vertex(tri::Triangulation, w) -> Edges\n\nReturns the set of all edges (u, v) in tri such that (u, v, w) is a positively oriented triangle in tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_graph","page":"Triangulations","title":"DelaunayTriangulation.get_graph","text":"get_graph(tri::Triangulation) -> Graph\n\nReturns the Graph of the triangulation tri. This is an undirected graph.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_neighbours","page":"Triangulations","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(graph::Graph) -> Dict{Vertex, Set{Vertex}}\n\nReturns the neighbours map of graph.\n\n\n\n\n\nget_neighbours(G::Graph, u) -> Set{Vertex}\n\nReturns the set of neighbours of u in G.\n\n\n\n\n\nget_neighbours(tri::Triangulation) -> Dict{Vertex, Set{Vertex}}\n\nReturns the neighbours map of tri. Note that, if has_ghost_triangles(tri), then some of the neighbours and vertices will be ghost vertices.\n\n\n\n\n\nget_neighbours(tri::Triangulation, u) -> Set{Vertex}\n\nReturns the set of neighbours of u in tri. Note that, if has_ghost_triangles(tri), then some of the neighbours and vertices will be ghost vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_boundary_curves","page":"Triangulations","title":"DelaunayTriangulation.get_boundary_curves","text":"get_boundary_curves(tri::Triangulation) -> NTuple{N, Function}\n\nReturns the functions defining the boundaries of tri. If !is_curve_bounded(tri),  then this returns an empty Tuple. Otherwise, this returns a Tuple of functions, one for each section of the boundary,  where the ith element of the Tuple corresponds to the ith section of the boundary, which corresponds to the ghost vertex -i. For curves that are defined by boundary nodes rather than by a function, the function is PiecewiseLinear. For the other functions, these  are all defined by t -> NTuple{2, Number}, where t ∈ [0, 1] and the NTuple{2, Number} is the coordinate on the curve at that t.\n\n\n\n\n\nget_boundary_curves(boundary_enricher::BoundaryEnricher{P,B,C}) -> C\n\nReturns the boundary curves associated with boundary_enricher.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_boundary_edge_map","page":"Triangulations","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation) -> Dict\n\nReturns the boundary edge map of the triangulation tri. This is a Dict that maps  a boundary edge (u, v) to its position in get_boundary_nodes(tri). In particular,  the returned value is a Tuple (position, index) so that boundary_nodes = get_boundary_nodes(tri, position) are the boundary nodes associated  with the section that (u, v) resides on, and u = get_boundary_nodes(boundary_nodes, index) and  v = get_boundary_nodes(boundary_nodes, index + 1).\n\nSee also construct_boundary_edge_map.\n\n\n\n\n\nget_boundary_edge_map(boundary_enricher::BoundaryEnricher{P,B,C,I,BM}) -> BM\n\nReturns the boundary edge map associated with boundary_enricher.\n\n\n\n\n\nget_boundary_edge_map(boundary_enricher::BoundaryEnricher, i, j)\n\nReturns the value from the key (i, j) in the boundary edge map of boundary_enricher. The returned value is a Tuple  (position, index) so that boundary_nodes = get_boundary_nodes(get_boundary_nodes(boundary_enricher), position) are the boundary nodes associated  with the section that (i, j) resides on, and i = get_boundary_nodes(boundary_nodes, index) and  j = get_boundary_nodes(boundary_nodes, index + 1).\n\n\n\n\n\nget_boundary_edge_map(tri::Triangulation, ij) \nget_boundary_edge_map(tri::Triangulation, i, j)\n\nReturns the value from the key (i, j) in the boundary edge map of tri. The returned value is a Tuple  (position, index) so that boundary_nodes = get_boundary_nodes(tri, position) are the boundary nodes associated  with the section that (i, j) resides on, and i = get_boundary_nodes(boundary_nodes, index) and  j = get_boundary_nodes(boundary_nodes, index + 1).\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_ghost_vertex_map","page":"Triangulations","title":"DelaunayTriangulation.get_ghost_vertex_map","text":"get_ghost_vertex_map(tri::Triangulation) -> Dict\n\nReturns the ghost vertex map of the triangulation tri. This is a Dict that maps ghost vertices  to their associated section in boundary_nodes. There are three cases; below, I is integer_type(tri):\n\nhas_multiple_curves(tri)\n\nReturns dict::Dict{I, NTuple{2, I}}, mapping ghost vertices i to Tuples (m, n) so that get_boundary_nodes(tri, m, n) are the boundary nodes associated with i,  i.e. the nth section of the mth curve is associated with the ghost vertex i.\n\nhas_multiple_sections(tri)\n\nReturns dict::Dict{I, I}, mapping ghost vertices i to n so that get_boundary_nodes(tri, n) are the boundary nodes associated with i, i.e. the nth section of the boundary is associated with the ghost vertex i.\n\notherwise\n\nReturns dict::Dict{I, A}, mapping the ghost vertex i to get_boundary_nodes(tri), where A = typeof(get_boundary_nodes(tri)).\n\nSee also construct_ghost_vertex_map.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_ghost_vertex_ranges","page":"Triangulations","title":"DelaunayTriangulation.get_ghost_vertex_ranges","text":"get_ghost_vertex_ranges(tri::Triangulation) -> Dict\n\nReturns the ghost vertex ranges map of the triangulation tri. This is a Dict that maps ghost vertices i  to the range of all other ghost vertices associated with the curve that i is associated with. \n\nSee also construct_ghost_vertex_ranges.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_convex_hull","page":"Triangulations","title":"DelaunayTriangulation.get_convex_hull","text":"get_convex_hull(tri::Triangulation) -> ConvexHull\n\nReturns the convex hull of the points in tri. This is given as a ConvexHull object, where the vertices  are sorted counter-clockwise and defined so that the first and last vertices are equal.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_representative_point_list","page":"Triangulations","title":"DelaunayTriangulation.get_representative_point_list","text":"get_representative_point_list(tri::Triangulation) -> Dict\n\nReturns the Dict of RepresentativeCoordinates of tri, mapping curve indices i to the representative point for that  curve. These representative points are how we interpret ghost triangles relative to that curve.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.num_curves","page":"Triangulations","title":"DelaunayTriangulation.num_curves","text":"num_curves(tri::Triangulation) -> Integer\n\nReturns the number of curves in tri.\n\n\n\n\n\nnum_curves(boundary_nodes) -> Integer\n\nGet the number of curves in boundary_nodes.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.num_curves([1, 2, 3, 1])\n1\n\njulia> DelaunayTriangulation.num_curves([[1, 2, 3], [3, 4, 1]])\n1\n\njulia> DelaunayTriangulation.num_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])\n2\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.num_sections","page":"Triangulations","title":"DelaunayTriangulation.num_sections","text":"num_sections(tri::Triangulation) -> Integer\n\nAssuming tri only has one curve, returns the number of sections in tri.\n\n\n\n\n\nnum_sections(boundary_nodes) -> Integer\n\nAssuming boundary_nodes has only one curve, get the number of sections in boundary_nodes.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.num_sections([1, 2, 3, 4, 5, 1])\n1\n\njulia> DelaunayTriangulation.num_sections([[1, 2, 3, 4], [4, 5, 1]])\n2\n\njulia> DelaunayTriangulation.num_sections([[1, 2, 3], [3, 4, 5, 6, 7, 8], [8, 9], [9, 1]])\n4\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_right_boundary_node","page":"Triangulations","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(tri::Triangulation, k, ghost_vertex) -> Vertex\n\nReturns the boundary node to the right of the vertex k in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex. \nghost_vertex: The ghost vertex associated with the boundary section that k is on. \n\nOutputs\n\nr: The vertex right of k on the boundary. \n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_left_boundary_node","page":"Triangulations","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(tri::Triangulation, k, ghost_vertex) -> Vertex\n\nReturns the boundary node to the left of the vertex k in tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nk: The boundary vertex.\nghost_vertex: The ghost vertex associated with the boundary section that k is on.\n\nOutputs\n\nℓ: The vertex left of k on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_all_boundary_nodes","page":"Triangulations","title":"DelaunayTriangulation.get_all_boundary_nodes","text":"get_all_boundary_nodes(tri::Triangulation) -> Set{Vertex}\n\nReturns the set of all boundary vertices in tri, in no specific order.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.contains_boundary_edge","page":"Triangulations","title":"DelaunayTriangulation.contains_boundary_edge","text":"contains_boundary_edge(tri::Triangulation, ij) -> Bool \ncontains_boundary_edge(tri::Triangulation, i, j) -> Bool\n\nReturns true if the boundary edge (i, j) is in tri, and false otherwise. Orientation matters here.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.has_vertex","page":"Triangulations","title":"DelaunayTriangulation.has_vertex","text":"has_vertex(G::Graph, u) -> Bool\n\nReturns true if u is a vertex in G, and false otherwise.\n\n\n\n\n\nhas_vertex(tri::Triangulation, u) -> Bool\n\nReturns true if u is a vertex in tri, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.delete_ghost_vertices_from_graph!","page":"Triangulations","title":"DelaunayTriangulation.delete_ghost_vertices_from_graph!","text":"delete_ghost_vertices!(G::Graph)\n\nDeletes all ghost vertices from G.\n\n\n\n\n\ndelete_ghost_vertices_from_graph!(tri::Triangulation)\n\nDeletes all ghost vertices from the graph of tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.has_ghost_vertices","page":"Triangulations","title":"DelaunayTriangulation.has_ghost_vertices","text":"has_ghost_vertices(G::Graph) -> Bool\n\nReturns true if G has ghost vertices, and false otherwise.\n\n\n\n\n\nhas_ghost_vertices(tri::Triangulation) -> Bool\n\nReturns true if tri has ghost vertices, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_convex_hull_vertices","page":"Triangulations","title":"DelaunayTriangulation.get_convex_hull_vertices","text":"get_convex_hull_vertices(tri::Triangulation) -> Vector{Vertex}\n\nReturns the vertices on the convex hull of tri, in counter-clockwise order. \n\nSee also ConvexHull.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.is_exterior_ghost_vertex","page":"Triangulations","title":"DelaunayTriangulation.is_exterior_ghost_vertex","text":"is_exterior_ghost_vertex(tri::Triangulation, i) -> Bool\n\nReturns true if the ghost vertex i in tri is an exterior ghost vertex, and false otherwise. \n\nSee also is_ghost_vertex and is_interior_ghost_vertex.\n\nExtended help\n\nAn exterior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the exterior boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.is_interior_ghost_vertex","page":"Triangulations","title":"DelaunayTriangulation.is_interior_ghost_vertex","text":"is_interior_ghost_vertex(tri::Triangulation, i) -> Bool\n\nReturns true if the ghost vertex i in tri is an interior ghost vertex, and false otherwise.\n\nSee also is_ghost_vertex and is_exterior_ghost_vertex.\n\nExtended help\n\nAn interior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the interior boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_curve_index","page":"Triangulations","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(dict, ghost_vertex) -> Int\nget_curve_index(ghost_vertex) -> Int\n\nGiven a Dict from construct_ghost_vertex_map and a ghost_vertex, returns the index of the curve corresponding to that ghost vertex. The second method  maps ghost_vertex to 1 if it is an Integer or a Vector, and ghost_vertex[1] if it is a Tuple.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_curve_index(-1)\n1\n\njulia> DelaunayTriangulation.get_curve_index((5, 3))\n5\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])\nDict{Int64, Tuple{Int64, Int64}} with 4 entries:\n  -1 => (1, 1)\n  -3 => (2, 2)\n  -2 => (2, 1)\n  -4 => (2, 3)\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -1)\n1\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -2)\n2\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -3)\n2\n\njulia> DelaunayTriangulation.get_curve_index(gv_map, -4)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_section_index","page":"Triangulations","title":"DelaunayTriangulation.get_section_index","text":"get_section_index(dict, ghost_vertex) -> Int\nget_section_index(ghost_vertex) -> Int\n\nGiven a Dict from construct_ghost_vertex_map and a ghost_vertex, returns the index of the section corresponding to that ghost vertex. The second method maps ghost_vertex to itself if it is an Integer, 1 if it is a Vector, and  ghost_vertex[2] if it is a Tuple. \n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> DelaunayTriangulation.get_section_index((2, 3)) # 3rd section of the 2nd curve\n3\n\njulia> DelaunayTriangulation.get_section_index(4)\n4\n\njulia> DelaunayTriangulation.get_section_index([1, 2, 3, 4, 5, 1])\n1\n\njulia> gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])     \nDict{Int64, Tuple{Int64, Int64}} with 4 entries:\n  -1 => (1, 1)\n  -3 => (2, 2)\n  -2 => (2, 1)\n  -4 => (2, 3)\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -1)\n1\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -2)\n1\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -3)\n2\n\njulia> DelaunayTriangulation.get_section_index(gv_map, -4)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.map_ghost_vertex","page":"Triangulations","title":"DelaunayTriangulation.map_ghost_vertex","text":"map_ghost_vertex(tri::Triangulation, ℓ) -> Vertex\n\nGiven a ghost vertex ℓ in tri, returns the corresponding section in the  boundary_nodes of tri. See also get_ghost_vertex_map.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_ghost_vertex_range","page":"Triangulations","title":"DelaunayTriangulation.get_ghost_vertex_range","text":"get_ghost_vertex_range(tri::Triangulation, ℓ) -> UnitRange\n\nGiven a ghost vertex ℓ of tri, returns the range of all  ghost vertices corresponding to the same curve or section as ℓ does.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.all_ghost_vertices","page":"Triangulations","title":"DelaunayTriangulation.all_ghost_vertices","text":"all_ghost_vertices(tri::Triangulation) -> KeySet\n\nReturns the set of all ghost vertices in tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.num_points","page":"Triangulations","title":"DelaunayTriangulation.num_points","text":"num_points(points) -> Integer\n\nReturns the number of points in points.\n\nExamples\n\njulia> using DelaunayTriangulation\n\njulia> points = [(1.0, 1.0), (2.3, 1.5), (0.0, -5.0)];\n\njulia> DelaunayTriangulation.num_points(points)\n3\n\njulia> points = [1.0 5.5 10.0 -5.0; 5.0 2.0 0.0 0.0];\n\njulia> DelaunayTriangulation.num_points(points)\n4\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_representative_point_coordinates","page":"Triangulations","title":"DelaunayTriangulation.get_representative_point_coordinates","text":"get_representative_point_coordinates(tri::Triangulation, curve_index) -> NTuple{2, Number}\n\nReturns the coordinates of the representative point of the curve_indexth curve in tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.compute_representative_points!","page":"Triangulations","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_boundary_nodes(tri), precision=one(number_type(tri)))\n\nComputes a new set of representative points for tri.\n\nArguments\n\ntri::Triangulation: The Triangulation for which to compute the representative points.\n\nKeyword Arguments\n\nuse_convex_hull=!has_boundary_nodes(tri): If true, then the representative points are computed using the convex hull of the triangulation. Otherwise, the representative points are computed using the boundary nodes of the triangulation.\nprecision=one(number_type(tri)): The precision to use when computing the representative points via pole_of_inaccessibility.\n\nOutput\n\nThere are no outputs as tri is updated in-place, but for each curve the representative point is computed using pole_of_inaccessibility.\n\nwarning: Exterior curves\nWhile get_exterior_curve_indices(tri) does store the curves corresponding to exterior curves, this function still treats the first  curve as the most important exterior curve, computing the representative point so that it is in no holes. In particular, other exterior curves  might have representative points that are in a hole of one of their interior holes. This isn't much of a problem, indeed it wouldn't be a significant  problem even if we had the representative point in a hole of the first curve, but it is something to be aware of.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.add_weight!","page":"Triangulations","title":"DelaunayTriangulation.add_weight!","text":"add_weight!(weights, w)\n\nPushes the weight w into weights. The default definition for this is push!(weights, w).\n\n\n\n\n\nadd_weight!(tri::Triangulation, w)\n\nPushes the weight w into the weights of tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_weight","page":"Triangulations","title":"DelaunayTriangulation.get_weight","text":"get_weight(weights, i) -> Number\n\nGets the ith weight from weights. The default definition for this is weights[i], but this can be extended - e.g., ZeroWeight uses get_weight(weights, i) = 0.0.\n\nIf i is not an integer, then the default definition is is_point3(i) ? i[3] : zero(number_type(weights)).\n\n\n\n\n\nget_weight(tri::Triangulation, i) -> Number\n\nGets the ith weight from tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.ZeroWeight","page":"Triangulations","title":"DelaunayTriangulation.ZeroWeight","text":"ZeroWeight{T}()\n\nStruct used for indicating that a triangulation has zero weights. The weights have type T, which is Float64 by default.\n\n\n\n\n\n","category":"type"},{"location":"api/triangulation/#DelaunayTriangulation.get_area","page":"Triangulations","title":"DelaunayTriangulation.get_area","text":"get_area(r::BoundingBox) -> Float64\n\nReturns the area of r, i.e. hspan(r) * vspan(r).\n\n\n\n\n\nget_area(stats::TriangulationStatistics)\n\nReturns the area field from the TriangulationStatistics stats.\n\n\n\n\n\nget_area(stats::TriangulationStatistics, T)\n\nReturns the area field from the individual triangle statistics for the triangle T in the TriangulationStatistics stats.\n\n\n\n\n\nget_area(vor::VoronoiTessellation, i) -> Number\n\nGets the area of the ith Voronoi polygon.\n\n\n\n\n\nget_area(tri::Triangulation) -> Number\n\nReturns the area of tri.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.iterated_neighbourhood","page":"Triangulations","title":"DelaunayTriangulation.iterated_neighbourhood","text":"iterated_neighbourhood(tri::Triangulation, i, d) -> Set{Vertex}\n\nReturns the set of vertices of tri in the iterated neighbourhood of the vertex i of depth d. \n\nExtended help\n\nThe d-times iterated neighbourhood is defined by \n\nN_i^d = bigcup_j in N_i^d-1 N_j setminus i\n\nwhere N_i^1 = N_i is the set of neighbours of i.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.dist","page":"Triangulations","title":"DelaunayTriangulation.dist","text":"dist(p, q) -> Number\n\nAssuming p and q are two-dimensional, computes the Euclidean distance between p and q.\n\n\n\n\n\ndist(tri::Triangulation, p) -> Number\n\nGiven a point p, returns the distance from p to the triangulation, using the  conventions from distance_to_polygon:\n\nδ > 0: If the returned distance is positive, then p is inside the triangulation.\nδ < 0: If the returned distance is negative, then p is outside the triangulation.\nδ = 0: If the returned distance is zero, then p is on the boundary of the triangulation.\n\nWhere we say distance, we are referring to the distance from p to the boundary of the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_insertion_order","page":"Triangulations","title":"DelaunayTriangulation.get_insertion_order","text":"get_insertion_order(points, randomise, skip_points, ::Type{I}, rng) where {I} -> Vector{I}\nget_insertion_order(tri::Triangulation, randomise, skip_points, rng) -> Vector{I}\n\nGets the insertion order for points into a triangulation. \n\nArguments\n\npoints: The points to insert.\nrandomise: If true, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.\nskip_points: The points to skip.\nI::Type{I}: The type of the vertices.\nrng::Random.AbstractRNG: The random number generator to use.\n\nOutput\n\norder: The order to insert the points in.\n\nwarning: Mutation of `order`\nThis order might be mutated (by circshift!) in get_initial_triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.get_vertices-Tuple{Triangulation}","page":"Triangulations","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(tri::Triangulation) -> Set{Vertex}\n\nReturns the set of all vertices in tri. Note that, if has_ghost_triangles(tri), then some of these vertices will be ghost vertices.\n\nSee also each_vertex, each_solid_vertex, and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"api/triangulation/#DelaunayTriangulation.get_edges-Tuple{Triangulation}","page":"Triangulations","title":"DelaunayTriangulation.get_edges","text":"get_edges(tri::Triangulation) -> Set{NTuple{2,Vertex}}\n\nReturns the set of all edges in tri. Orientation is ignored, so that  only one of (i, j) and (j, i) will appear in the result. Note that,  if has_ghost_triangles(tri), then some of these edges will be ghost edges.\n\nSee also each_edge, each_solid_edge, and each_ghost_edge.\n\n\n\n\n\n","category":"method"},{"location":"api/triangulation/#DelaunayTriangulation.num_neighbours","page":"Triangulations","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(G::Graph, u) -> Integer\n\nReturns the number of neighbours of u in G.\n\n\n\n\n\nnum_neighbours(tri::Triangulation, u) -> Integer\n\nReturns the number of neighbours of u in tri. Note that, if has_ghost_triangles(tri), then some of the neighbours counted might be ghost vertices if u is a boundary vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/triangulation/#DelaunayTriangulation.validate_triangulation","page":"Triangulations","title":"DelaunayTriangulation.validate_triangulation","text":"validate_triangulation(tri::Triangulation; print_result=true, predicates::AbstractPredicateKernel=ExactKernel()) -> Bool\n\nTests if tri is a valid Triangulation. Returns true if so,  and false otherwise. If print_result=true and tri is not a  valid triangulation, all the issues with tri will be printed.\n\nUse the predicates keyword argument to control the method used for computing predicates.  Can be one of FastKernel, ExactKernel, and AdaptiveKernel.  See the documentation for a further discussion of these methods.\n\n\n\n\n\n","category":"function"},{"location":"manual/boundaries/#Representing-Boundaries","page":"Representing Boundaries","title":"Representing Boundaries","text":"","category":"section"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"Here we will give a description of how we represent boundaries when considering constrained triangulations. There are three possible types of boundaries that can be considered:","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"A contiguous boundary with no holes. For example, a circle.\nA single boundary with no holes, but the boundary is split into multiple sections that can be identified separately via ghost vertices (ghost vertices are described in the next section). For example, a square with a different ghost vertex for each side.\nA boundary comprising multiple disjoint curves and possibly disjoint domains. For example, a square with a circular hole inside and a separate circular domain.","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"The way to represent boundaries can be customised as needed, but any such interface for the boundaries must conform to the following specifications; these specifications are what we use in the convert_boundary_points_to_indices function.","category":"page"},{"location":"manual/boundaries/#Contiguous-boundary","page":"Representing Boundaries","title":"Contiguous boundary","text":"","category":"section"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"In the case of a contiguous boundary, the boundary should be defined in a counter-clockwise orientation (meaning that, if you were to walk along the boundary, the interior of the domain would be on your left). Moreover, the first and last points of the boundary must be the same. For example, if ","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"points = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"Then the boundary nodes should be defined as ","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"boundary_nodes = [1, 2, 3, 4, 1]","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"The vector [1, 2, 3, 4] would not be correct as the first and last points are  not correct, and [1, 4, 3, 2, 1] would not be correct as the orientation is clockwise.","category":"page"},{"location":"manual/boundaries/#Sectioned-boundary","page":"Representing Boundaries","title":"Sectioned boundary","text":"","category":"section"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"In the case of a single boundary that is split into sections, the boundary should be defined in a counter-clockwise orientation, and the first and last points of each section must be the same. For example, suppose we have ","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"points = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"and we want to define each side of the square to be its own section of the boundary. We should then define the boundary nodes as ","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"boundary_nodes = [[1, 2], [2, 3], [3, 4], [4, 1]]","category":"page"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"The vector [[1, 2], [2, 3], [3, 4]] would not be correct as the first and last points of the boundary are not the same, and [[1, 4], [4, 3], [3, 2], [2, 1]] would not be correct as the orientation is clockwise.","category":"page"},{"location":"manual/boundaries/#Multiply-connected-domain","page":"Representing Boundaries","title":"Multiply-connected domain","text":"","category":"section"},{"location":"manual/boundaries/","page":"Representing Boundaries","title":"Representing Boundaries","text":"The specification of a multiply-connected domain is a bit more cumbersome. For each individual boundary, the specification is the same as that of a sectioned boundary, but more care is needed for the orientations. The orientation of the entire domain's boundary must be positive, but individual boundaries may need to be defined in a clockwise orientation so that the domain's interior remains on the left when it is traversed. For example, if a circle is to be defined inside of a square boundary, then the circle would have to be defined clockwise.","category":"page"},{"location":"math/weighted/#Weighted-Triangulations","page":"Weighted Delaunay Triangulations","title":"Weighted Triangulations","text":"","category":"section"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"Here we give a brief overview of the details behind weighted Delaunay triangulations. For a more  detailed description, see Chapters 2 and 3 of the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013).","category":"page"},{"location":"math/weighted/#Parabolic-Lifting-Map","page":"Weighted Delaunay Triangulations","title":"Parabolic Lifting Map","text":"","category":"section"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"The definition of a weighted triangulation is derived from the idea of a parabolic lifting map. The parabolic lifting map takes a triangulation mathcal Dmathcal T(mathcal P) of a finite point set mathcal p and projects it to a parabolid in mathbb R^3 via the map mathcal L colon mathbb R^2 to mathbb R^3 defined by mathcal L(p) = (p_x p_y p_x^2 + p_y^2). The point mathcal L(p) is the lifted compansion of p, denoted p^+. An example of this mapping applied to a triangulation is shown below.","category":"page"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"fig # hide","category":"page"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"Let mathcal P^+ denote the set of lifted points. It can be shown that the projection of the underside of the convex hull of mathcal P^+, meaning the projection of all faces of the convex hull with a downward-facing normal (where the positive z-axis points upward), is equal to mathcal Dmathcal T(mathcal P); see Proposition 2.2 in the reference above. This is the basis for the definition of a weighted Delaunay triangulation.","category":"page"},{"location":"math/weighted/#Weighted-Delaunay-Triangulations","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"","category":"section"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"Weighted Delaunay triangulations allow the lifted points p^+ to live away from the paraboloid x^2 + y^2. In particular, augment each point p_i in mathcal P with a weight w_i such that the lifted point is p_i^+ = (x_i y_i x_i^2 + y_i^2 - w_i). The point w_i gives the deviation of p_i^+ from the paraboloid. In particular, w_i  0 means the point is below the paraboloid, and w_i  0 means it is below; the sign convention here is defined so that increasing w_i increases its affect on the underside of the convex hull of mathcal P^+, the set of lifted points. The weighted Delaunay triangulation is then defined to be the projection of the underside of the convex hull of mathcal P^+.","category":"page"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"Given this definition, it is possible that not all points will appear in the weighted triangulation, since not all faces will be projected in this case. Such points are said to be submerged or redundant. ","category":"page"},{"location":"math/weighted/#Constructing-Weighted-Triangulations","page":"Weighted Delaunay Triangulations","title":"Constructing Weighted Triangulations","text":"","category":"section"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"The algorithm for constructing weighted triangulations is a simple modification of the standard Bowyer-Watson algorithm. The only difference is the test of whether a point is inside a triangle's circumcircle. Instead of circumcircles, we use witness planes. ","category":"page"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"From the definition of the weighted triangulation, a point will only be included in the triangulation if it is part of a downward-facing face of the convex hull of mathcal P^+. The definition of the convex hull thus means that, instead of checking if a triangle's circumcircle contains a point, we should instead be checking if that point is below the plane through that triangle, i.e. the witness plane. A point that is below this witness plane is submerged.","category":"page"},{"location":"math/weighted/","page":"Weighted Delaunay Triangulations","title":"Weighted Delaunay Triangulations","text":"Thus, the Bowyer-Watson algorithm can be extended to weighted triangulations by simply replacing calls to point_position_relative_to_circumcircle with calls to a predicate that checks if a point is below a witness plane. This has been implemented in the point_position_relative_to_witness_plane predicate. Care is needed for ghost triangles - if a point is being inserted onto the solid edge of a ghost triangle, we say it is below the ghost triangle's witness plane if it is not submerged relative to the solid triangle opposite the ghost triangle. The only other modification to the algorithm needed is to be careful that it is not guaranteed that there exists any triangle whose witness plane is above a new point, in which case that point's insertion should be completely rejected.","category":"page"},{"location":"math/convex/#Triangulating-Convex-Polygons","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"","category":"section"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Here we describe an algorithm used for triangulating convex polygons, called Chew's algorithm after Chew's 1990 paper Building Voronoi diagrams for convex polygons in linear expected time. ","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Suppose we have a counter-clockwise sequence of vertices mathcal S defining a convex polygon, and generate a random permutation of mathcal S denoted pi(mathcal S) that defines the insertion order. The idea of the algorithm is to, starting from a triangle constructed by the first three vertices of pi(mathcal S), add the remaining points in one at a time using the Bowyer-Watson algorithm, but leveraging the convexity of mathcal S to greatly simplify the point location step.","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"We can determine how to avoid the point location step by considering an example. Using the Bowyer-Watson algorithm, let's look at how a convex polygon gets triangulated.","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"fig # hide","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"See that at each stage the vertex v_u to be added, shown in red, it lies outside of the triangulation, and only a single edge e_vw separates v_u from the triangulation. Thus, we can identify that the point location step amounts to finding this edge e_vw so that we inserting v_u into the triangulation can be done by retriangulating the cavity formed by the union of the triangles T_uvw and the triangles containing u in their circumcircles.","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"We now need to find an efficient way to find this edge e_vw. Imagine running the Bowyer-Watson algorithm in reverse, meaning removing vertices one at a time in the reverse order of pi(mathcal S). When we remove v_u, this is the same as connecting its neighbours v_v and v_w with an edge e_vw, which is exactly the edge needed for our point location problem. Thus, if we keep track of the polygon vertices and their neighbours, we can easily find the edge e_vw in constant time. ","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Using this insight, we can now present Chew's algorithm:","category":"page"},{"location":"math/convex/","page":"Triangulating Convex Polygons","title":"Triangulating Convex Polygons","text":"Write mathcal S = v_1 ldots v_n and obtain some random permutation pi(mathcal S) of mathcal S, representing the permutation pi(mathcal S) as a permutation of 1 2 ldots n chosen uniformly at random.\nConstruct a circularly- and doubly-linked list of the vertices in mathcal S by defining mathcal S_textnext = 2 3 ldots n 1 and mathcal S_textprev = n 1 2 ldots n-1.\nFor i = nn-1ldots4: Delete v_pi(mathcal S)i from the list by setting mathcal S_textnextmathcal S_textprevpii = mathcal S_textnextpii and mathcal S_textprevmathcal S_textnextpii = mathcal S_textprevpii, where pii equiv mathcal pi(mathcal S)i.\nInitialise the triangulation by adding T_v_pi1v_pi2v_pi3 to the triangulation.\nFor i = 4 ldots k: Add v_pii into the triangulation using the Bowyer-Watson algorithm, noting that the polygonal cavity can be evacuated starting from the edge e_mathcal S_textnextpiimathcal S_textprevpii.","category":"page"},{"location":"manual/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This section gives a manual for certain parts of the package. Little code will be provided here, instead descriptions will be given for parts of the package; if you do want to see code and, for example, docstrings, you should see the API section or the extended manual section. We will describe the following:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Representing Primitives: How geometric primitives are represented in this package, and how you can customise this representation.\nRepresenting Boundaries: How boundaries are represented in this package.\nDefining Curve-Bounded Domains: How curve-bounded domains can be defined in this package.\nGhost (Negative) Vertices: How ghost triangles and ghost vertices are used in this package to represent boundary information.\nGeometrical Predicates: How geometric predicates are defined in this package.\nTriangulation Output: How the output of a triangulation is defined.\nVoronoi Tessellation Output: How the output of a Voronoi tessellation is defined.\nPredicate Kernels: The methods available for computing geometric predicates.","category":"page"},{"location":"tutorials/power/#Power-Diagrams","page":"Power Diagrams","title":"Power Diagrams","text":"","category":"section"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"In this tutorial, we demonstrate how we can construct power diagrams (also called weighted Voronoi tessellations). These are dual to the weighted Delaunay triangulation and, instead of being based on the Euclidean metric like Voronoi tessellations, the power distance is used to define the Voronoi tiles. The power distance is defined by pi(p q) = d(p q)^2 - w_p - w_q, where d(p q) is the Euclidean distance between points p and q, and w_p and w_q are weights associated with p and q. See this page for more details. To start with the tutorial, we load in the packages we'll need.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"To build a power diagram, you need to start from a weighted Delaunay triangulation as described in this tutorial.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"points = [\n    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),\n    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),\n    (-4.0, -3.0), (3.0, 8.0),\n]\nweights = [0.2, 0.0, -3.0, 2.0, 7.5, 2.3, 0.0, -0.5]\nrng = StableRNG(123)\ntri = triangulate(points; weights, rng)\npvorn = voronoi(tri; rng)","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Let's compare the power diagram to its unweighted counterpart.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"vorn = voronoi(triangulate(points; rng); rng)\nfig = Figure()\nax1 = Axis(fig[1, 1], title=\"Unweighted\", width=300, height=400)\nax2 = Axis(fig[1, 2], title=\"Weighted\", width=300, height=400)\nvoronoiplot!(ax1, vorn, show_generators=true, colormap=:matter, strokewidth=4, clip=(-5, 5, -5, 10))\nvoronoiplot!(ax2, pvorn, show_generators=true, colormap=:matter, strokewidth=4, clip=(-5, 5, -5, 10))\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"Notice that, unlike the unweighted tessellation, the generators in the power diagram don't actually have to live in their own tile, and more than one generator may inhibit a tile. This is because the power diagram is based on the power distance, not the Euclidean distance.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"We can easily look at the affect of the weights on the power diagram.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"A, B, C, D, E, F, G, H,\nI, J, K, L, M, N = (-1.0, 3.0), (1.0, 3.0),\n(2.0, 2.0), (2.0, 0.0), (1.0, -1.0), (-1.0, -1.0),\n(-2.0, 0.0), (-2.0, 2.0), (-1.0, 2.0),\n(0.0, 1.5), (1.0, 2.5), (-1.0, 0.5),\n(1.0, 0.0), (1.5, 1.0)\npoints = [A, B, C, D, E, F, G, H, I, J, K, L, M, N]\nw = Observable(-10.0)\nweights = @lift (wts = zeros(length(points)); wts[10] = $w; wts)\ntri = @lift tri = triangulate(points; weights=$weights)\nvorn = @lift voronoi($tri)\nweight_itr_base = LinRange(-10, 10, 30 * 5)\nweight_itr = vcat(weight_itr_base, reverse(weight_itr_base))\ntitle_obs = lift(w -> L\"w_{10} = %$(round(w, sigdigits = 4))\", w)\nfig, ax, sc = voronoiplot(vorn,\n    axis=(title=title_obs, titlealign=:left),\n    figure=(fontsize=24,),\n    clip = (-4, 4, -4, 4),\n    color = [:red, :blue, :green, :purple, :orange, :yellow, :cyan, :white, :black, :magenta, :gray, :brown, :pink, :lightblue]\n)\nscatter!(ax, [J], color=:red, markersize=13)\nrecord(fig, \"varying_weight_power.mp4\", weight_itr; framerate=30) do _w\n    w[] = _w\nend;\nnothing #hide","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"(Image: )","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"See that, for small weights, the Voronoi tile of the 10th point isn't even present. As the weight increases, the tile grows and eventually dominates the tessellation.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"We also note that, just like standard Voronoi tessellations, we can also apply clipping and smoothing to power diagrams. These can be done in exactly the same manner.","category":"page"},{"location":"tutorials/power/#Just-the-code","page":"Power Diagrams","title":"Just the code","text":"","category":"section"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StableRNGs\n\npoints = [\n    (-3.0, 7.0), (1.0, 6.0), (-1.0, 3.0),\n    (-2.0, 4.0), (3.0, -2.0), (5.0, 5.0),\n    (-4.0, -3.0), (3.0, 8.0),\n]\nweights = [0.2, 0.0, -3.0, 2.0, 7.5, 2.3, 0.0, -0.5]\nrng = StableRNG(123)\ntri = triangulate(points; weights, rng)\npvorn = voronoi(tri; rng)\n\nvorn = voronoi(triangulate(points; rng); rng)\nfig = Figure()\nax1 = Axis(fig[1, 1], title=\"Unweighted\", width=300, height=400)\nax2 = Axis(fig[1, 2], title=\"Weighted\", width=300, height=400)\nvoronoiplot!(ax1, vorn, show_generators=true, colormap=:matter, strokewidth=4, clip=(-5, 5, -5, 10))\nvoronoiplot!(ax2, pvorn, show_generators=true, colormap=:matter, strokewidth=4, clip=(-5, 5, -5, 10))\nresize_to_layout!(fig)\nfig\n\nA, B, C, D, E, F, G, H,\nI, J, K, L, M, N = (-1.0, 3.0), (1.0, 3.0),\n(2.0, 2.0), (2.0, 0.0), (1.0, -1.0), (-1.0, -1.0),\n(-2.0, 0.0), (-2.0, 2.0), (-1.0, 2.0),\n(0.0, 1.5), (1.0, 2.5), (-1.0, 0.5),\n(1.0, 0.0), (1.5, 1.0)\npoints = [A, B, C, D, E, F, G, H, I, J, K, L, M, N]\nw = Observable(-10.0)\nweights = @lift (wts = zeros(length(points)); wts[10] = $w; wts)\ntri = @lift tri = triangulate(points; weights=$weights)\nvorn = @lift voronoi($tri)\nweight_itr_base = LinRange(-10, 10, 30 * 5)\nweight_itr = vcat(weight_itr_base, reverse(weight_itr_base))\ntitle_obs = lift(w -> L\"w_{10} = %$(round(w, sigdigits = 4))\", w)\nfig, ax, sc = voronoiplot(vorn,\n    axis=(title=title_obs, titlealign=:left),\n    figure=(fontsize=24,),\n    clip = (-4, 4, -4, 4),\n    color = [:red, :blue, :green, :purple, :orange, :yellow, :cyan, :white, :black, :magenta, :gray, :brown, :pink, :lightblue]\n)\nscatter!(ax, [J], color=:red, markersize=13)\nrecord(fig, \"varying_weight_power.mp4\", weight_itr; framerate=30) do _w\n    w[] = _w\nend;","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"","category":"page"},{"location":"tutorials/power/","page":"Power Diagrams","title":"Power Diagrams","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/custom_primitive/#Using-Custom-Structs-for-Primitives-and-Boundaries","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"","category":"section"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"In this package, we allow for custom structs to be used for defining points, edges, triangles, and boundaries (and parametric curves, as done for example in the final example of this tutorial). This tutorial demonstrates how this can be done, showing what methods need to be defined to use certain parts of the package. We note that there are some good defaults already defined for most methods that can be overloaded for these primitives, but for completely new structs you are required to define many new methods. The packages we will be using are loaded below.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"using DelaunayTriangulation\nusing CairoMakie\nusing Random\nusing StableRNGs\nconst DT = DelaunayTriangulation;\nnothing #hide","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Let us now define our custom structs.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"struct CustomPoint\n    x::Float64\n    y::Float64\nend\nstruct CustomPoints\n    points::Vector{CustomPoint}\nend\nstruct CustomSegment\n    i::Int32\n    j::Int32\nend\nstruct CustomSegments\n    segments::Set{CustomSegment}\nend\nstruct CustomTriangle\n    i::Int32\n    j::Int32\n    k::Int32\nend\nstruct CustomTriangles\n    triangles::Vector{CustomTriangle}\nend\nstruct CustomPolygonSegment\n    segments::Vector{CustomSegment}\nend\nstruct CustomPolygon\n    segments::Vector{CustomPolygonSegment}\nend\nstruct CustomPolygons{N}\n    polygons::NTuple{N, CustomPolygon}\nend","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Now, depending on your application you might not need to define all possible methods. For example, if you just want an unconstrained triangulation, all you need are CustomPoint and CustomPoints. So, let's define our methods for increasing complexity. First, for unconstrained triangulations, all we need to define are:","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"DT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\nDT.number_type(::Type{CustomPoint}) = Float64\n\nBase.eachindex(points::CustomPoints) = Base.eachindex(points.points)\nBase.iterate(points::CustomPoints, state...) = Base.iterate(points.points, state...)\nBase.length(points::CustomPoints) = length(points.points)\nBase.getindex(points::CustomPoints, i) = points.points[i]\nDT.number_type(::Type{CustomPoints}) = Float64\nDT.is_planar(::CustomPoints) = true\n\nDT.geti(T::CustomTriangle) = T.i\nDT.getj(T::CustomTriangle) = T.j\nDT.getk(T::CustomTriangle) = T.k\nDT.number_type(::Type{CustomTriangle}) = Int32\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\n\nBase.iterate(triangles::CustomTriangles, state...) = Base.iterate(triangles.triangles, state...)\nBase.sizehint!(triangles::CustomTriangles, n) = sizehint!(triangles.triangles, n)\nBase.eltype(::Type{CustomTriangles}) = CustomTriangle\nBase.push!(triangles::CustomTriangles, T::CustomTriangle) = push!(triangles.triangles, T)\nBase.delete!(triangles::CustomTriangles, T::CustomTriangle) = deleteat!(triangles.triangles, findfirst(==(T), triangles.triangles))\nBase.length(triangles::CustomTriangles) = length(triangles.triangles)\nCustomTriangles() = CustomTriangles(Vector{CustomTriangle}())","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Now let's suppose we want to add in some segments. For this, we also need the following methods.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"DT.construct_edge(::Type{CustomSegment}, i, j) = CustomSegment(i, j)\nDT.initial(e::CustomSegment) = e.i\nDT.terminal(e::CustomSegment) = e.j\n\nBase.iterate(segments::CustomSegments, state...) = Base.iterate(segments.segments, state...)\nBase.eltype(::Type{CustomSegments}) = CustomSegment\nBase.push!(segments::CustomSegments, e::CustomSegment) = push!(segments.segments, e)\nBase.delete!(segments::CustomSegments, e::CustomSegment) = delete!(segments.segments, e)\nBase.rand(rng::AbstractRNG, segments::CustomSegments) = rand(rng, segments.segments)\nBase.length(segments::CustomSegments) = length(segments.segments)\nCustomSegments() = CustomSegments(Set{CustomSegment}())","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Next, we want to allow for defining a boundary. For this, we need the following methods.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"DT.has_multiple_curves(::CustomPolygons{N}) where {N} = N > 1\nDT.has_multiple_curves(::CustomPolygon) = false\nDT.has_multiple_curves(::CustomPolygonSegment) = false\nDT.has_multiple_sections(::CustomPolygons) = true\nDT.has_multiple_sections(::CustomPolygon) = true\nDT.has_multiple_sections(::CustomPolygonSegment) = false\nDT.num_curves(::CustomPolygons{N}) where {N} = N\nDT.num_sections(poly::CustomPolygon) = length(poly.segments)\nDT.num_boundary_edges(seg::CustomPolygonSegment) = length(seg.segments)\nDT.get_boundary_nodes(poly::CustomPolygons, m::Integer) = poly.polygons[m] # go down to the mth polygon\nDT.get_boundary_nodes(poly::CustomPolygon, m::Integer) = poly.segments[m] # go down to the mth segment\nDT.get_boundary_nodes(seg::CustomPolygonSegment, m::Integer) = m > length(seg.segments) ? DT.terminal(seg.segments[m - 1]) : DT.initial(seg.segments[m]) # go down to the mth edge and extract the left node\nDT.get_boundary_nodes(poly::CustomPolygons, (m, n)::NTuple{2, Int32}) = DT.get_boundary_nodes(DT.get_boundary_nodes(poly, m), n)","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"We now have all that we need for defining our custom primitives for constrained triangulations. We can go further and define methods for working with Voronoi tessellations and centroidal Voronoi tessellations. For these methods, note that these only apply to unconstrained triangulations, so you of course would not have to define the methods we have just defined for segments and boundaries. For Voronoi tessellations, no extra methods are needed, except for","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Base.empty!(segments::CustomSegments) = empty!(segments.segments)","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"if we specify EdgesType inside triangulate together with clip=true (and not otherwise). For centroidal Voronoi tessellations, we need","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"DT.set_point!(points::CustomPoints, i, x, y) = points.points[i] = CustomPoint(x, y)","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"We also need to consider methods needed for mesh refinement. We could also consider how we can define a method for a new parametric curve, but an example of this is already given in the curve bounded tutorial, so we will only consider methods with piecewise linear boundaries. For refinement, we need the following methods:","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Base.pop!(points::CustomPoints) = pop!(points.points)\nDT.push_point!(points::CustomPoints, x, y) = push!(points.points, CustomPoint(x, y))\n\nDT.contains_edge(e::CustomSegment, Es::CustomSegments) = e ∈ Es.segments\n\nBase.empty!(triangles::CustomTriangles) = empty!(triangles.triangles)\n\nfunction Base.insert!(seg::CustomPolygonSegment, index, node)\n    cur_segment = seg.segments[index - 1]\n    u, v = edge_vertices(cur_segment)\n    seg.segments[index - 1] = CustomSegment(u, node)\n    insert!(seg.segments, index, CustomSegment(node, v))\n    return seg\nend","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Now we have all that we need. Let's now demonstrate that this works. First, let's define the points, segments, and the boundary.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"p1 = CustomPoint(0.0, 0.0)\np2 = CustomPoint(1.0, 0.0)\np3 = CustomPoint(1.0, 1.0)\np4 = CustomPoint(0.0, 1.0)\np5 = CustomPoint(0.5, 0.5)\np6 = CustomPoint(0.25, 0.25)\np7 = CustomPoint(0.75, 0.25)\np8 = CustomPoint(0.75, 0.75)\np9 = CustomPoint(0.25, 0.75)\npoints = CustomPoints([p1, p2, p3, p4, p5, p6, p7, p8, p9])\nsegments = CustomSegments(Set{CustomSegment}((CustomSegment(2, 7), CustomSegment(8, 3))))\nouter_polygon = CustomPolygon(\n    [\n        CustomPolygonSegment([CustomSegment(1, 2), CustomSegment(2, 3)]),\n        CustomPolygonSegment([CustomSegment(3, 4), CustomSegment(4, 1)]),\n    ],\n)\ninner_polygon = CustomPolygon(\n    [\n        CustomPolygonSegment([CustomSegment(6, 9), CustomSegment(9, 8), CustomSegment(8, 7), CustomSegment(7, 6)]),\n    ],\n)\npolygons = CustomPolygons((outer_polygon, inner_polygon));\nnothing #hide","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Now we triangulate and refine.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"rng = StableRNG(123)\ntri = triangulate(\n    points; boundary_nodes = polygons, segments,\n    IntegerType = Int32,\n    EdgeType = CustomSegment,\n    TriangleType = CustomTriangle,\n    EdgesType = CustomSegments,\n    TrianglesType = CustomTriangles,\n    rng,\n)\nrefine!(tri; max_area = 1.0e-3, rng)\nfig, ax, sc = triplot(tri)\nfig","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"Now let's give an example of a centroidal Voronoi tessellation to show that this all works.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"rng = StableRNG(123)\npoints = CustomPoints([p1, p2, p3, p4, p5, p6, p7, p8, p9])\ntri = triangulate(\n    points;\n    IntegerType = Int32,\n    EdgeType = CustomSegment,\n    TriangleType = CustomTriangle,\n    EdgesType = CustomSegments,\n    TrianglesType = CustomTriangles,\n    rng,\n)\nvorn = voronoi(tri; clip = true, smooth = true, rng)\nfig, ax, sc = voronoiplot(vorn)\nfig","category":"page"},{"location":"tutorials/custom_primitive/#Just-the-code","page":"Using Custom Structs for Primitives and Boundaries","title":"Just the code","text":"","category":"section"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"using DelaunayTriangulation\nusing CairoMakie\nusing Random\nusing StableRNGs\nconst DT = DelaunayTriangulation;\n\nstruct CustomPoint\n    x::Float64\n    y::Float64\nend\nstruct CustomPoints\n    points::Vector{CustomPoint}\nend\nstruct CustomSegment\n    i::Int32\n    j::Int32\nend\nstruct CustomSegments\n    segments::Set{CustomSegment}\nend\nstruct CustomTriangle\n    i::Int32\n    j::Int32\n    k::Int32\nend\nstruct CustomTriangles\n    triangles::Vector{CustomTriangle}\nend\nstruct CustomPolygonSegment\n    segments::Vector{CustomSegment}\nend\nstruct CustomPolygon\n    segments::Vector{CustomPolygonSegment}\nend\nstruct CustomPolygons{N}\n    polygons::NTuple{N, CustomPolygon}\nend\n\nDT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\nDT.number_type(::Type{CustomPoint}) = Float64\n\nBase.eachindex(points::CustomPoints) = Base.eachindex(points.points)\nBase.iterate(points::CustomPoints, state...) = Base.iterate(points.points, state...)\nBase.length(points::CustomPoints) = length(points.points)\nBase.getindex(points::CustomPoints, i) = points.points[i]\nDT.number_type(::Type{CustomPoints}) = Float64\nDT.is_planar(::CustomPoints) = true\n\nDT.geti(T::CustomTriangle) = T.i\nDT.getj(T::CustomTriangle) = T.j\nDT.getk(T::CustomTriangle) = T.k\nDT.number_type(::Type{CustomTriangle}) = Int32\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\n\nBase.iterate(triangles::CustomTriangles, state...) = Base.iterate(triangles.triangles, state...)\nBase.sizehint!(triangles::CustomTriangles, n) = sizehint!(triangles.triangles, n)\nBase.eltype(::Type{CustomTriangles}) = CustomTriangle\nBase.push!(triangles::CustomTriangles, T::CustomTriangle) = push!(triangles.triangles, T)\nBase.delete!(triangles::CustomTriangles, T::CustomTriangle) = deleteat!(triangles.triangles, findfirst(==(T), triangles.triangles))\nBase.length(triangles::CustomTriangles) = length(triangles.triangles)\nCustomTriangles() = CustomTriangles(Vector{CustomTriangle}())\n\nDT.construct_edge(::Type{CustomSegment}, i, j) = CustomSegment(i, j)\nDT.initial(e::CustomSegment) = e.i\nDT.terminal(e::CustomSegment) = e.j\n\nBase.iterate(segments::CustomSegments, state...) = Base.iterate(segments.segments, state...)\nBase.eltype(::Type{CustomSegments}) = CustomSegment\nBase.push!(segments::CustomSegments, e::CustomSegment) = push!(segments.segments, e)\nBase.delete!(segments::CustomSegments, e::CustomSegment) = delete!(segments.segments, e)\nBase.rand(rng::AbstractRNG, segments::CustomSegments) = rand(rng, segments.segments)\nBase.length(segments::CustomSegments) = length(segments.segments)\nCustomSegments() = CustomSegments(Set{CustomSegment}())\n\nDT.has_multiple_curves(::CustomPolygons{N}) where {N} = N > 1\nDT.has_multiple_curves(::CustomPolygon) = false\nDT.has_multiple_curves(::CustomPolygonSegment) = false\nDT.has_multiple_sections(::CustomPolygons) = true\nDT.has_multiple_sections(::CustomPolygon) = true\nDT.has_multiple_sections(::CustomPolygonSegment) = false\nDT.num_curves(::CustomPolygons{N}) where {N} = N\nDT.num_sections(poly::CustomPolygon) = length(poly.segments)\nDT.num_boundary_edges(seg::CustomPolygonSegment) = length(seg.segments)\nDT.get_boundary_nodes(poly::CustomPolygons, m::Integer) = poly.polygons[m] # go down to the mth polygon\nDT.get_boundary_nodes(poly::CustomPolygon, m::Integer) = poly.segments[m] # go down to the mth segment\nDT.get_boundary_nodes(seg::CustomPolygonSegment, m::Integer) = m > length(seg.segments) ? DT.terminal(seg.segments[m - 1]) : DT.initial(seg.segments[m]) # go down to the mth edge and extract the left node\nDT.get_boundary_nodes(poly::CustomPolygons, (m, n)::NTuple{2, Int32}) = DT.get_boundary_nodes(DT.get_boundary_nodes(poly, m), n)\n\nBase.empty!(segments::CustomSegments) = empty!(segments.segments)\n\nDT.set_point!(points::CustomPoints, i, x, y) = points.points[i] = CustomPoint(x, y)\n\nBase.pop!(points::CustomPoints) = pop!(points.points)\nDT.push_point!(points::CustomPoints, x, y) = push!(points.points, CustomPoint(x, y))\n\nDT.contains_edge(e::CustomSegment, Es::CustomSegments) = e ∈ Es.segments\n\nBase.empty!(triangles::CustomTriangles) = empty!(triangles.triangles)\n\nfunction Base.insert!(seg::CustomPolygonSegment, index, node)\n    cur_segment = seg.segments[index - 1]\n    u, v = edge_vertices(cur_segment)\n    seg.segments[index - 1] = CustomSegment(u, node)\n    insert!(seg.segments, index, CustomSegment(node, v))\n    return seg\nend\n\np1 = CustomPoint(0.0, 0.0)\np2 = CustomPoint(1.0, 0.0)\np3 = CustomPoint(1.0, 1.0)\np4 = CustomPoint(0.0, 1.0)\np5 = CustomPoint(0.5, 0.5)\np6 = CustomPoint(0.25, 0.25)\np7 = CustomPoint(0.75, 0.25)\np8 = CustomPoint(0.75, 0.75)\np9 = CustomPoint(0.25, 0.75)\npoints = CustomPoints([p1, p2, p3, p4, p5, p6, p7, p8, p9])\nsegments = CustomSegments(Set{CustomSegment}((CustomSegment(2, 7), CustomSegment(8, 3))))\nouter_polygon = CustomPolygon(\n    [\n        CustomPolygonSegment([CustomSegment(1, 2), CustomSegment(2, 3)]),\n        CustomPolygonSegment([CustomSegment(3, 4), CustomSegment(4, 1)]),\n    ],\n)\ninner_polygon = CustomPolygon(\n    [\n        CustomPolygonSegment([CustomSegment(6, 9), CustomSegment(9, 8), CustomSegment(8, 7), CustomSegment(7, 6)]),\n    ],\n)\npolygons = CustomPolygons((outer_polygon, inner_polygon));\n\nrng = StableRNG(123)\ntri = triangulate(\n    points; boundary_nodes = polygons, segments,\n    IntegerType = Int32,\n    EdgeType = CustomSegment,\n    TriangleType = CustomTriangle,\n    EdgesType = CustomSegments,\n    TrianglesType = CustomTriangles,\n    rng,\n)\nrefine!(tri; max_area = 1.0e-3, rng)\nfig, ax, sc = triplot(tri)\nfig\n\nrng = StableRNG(123)\npoints = CustomPoints([p1, p2, p3, p4, p5, p6, p7, p8, p9])\ntri = triangulate(\n    points;\n    IntegerType = Int32,\n    EdgeType = CustomSegment,\n    TriangleType = CustomTriangle,\n    EdgesType = CustomSegments,\n    TrianglesType = CustomTriangles,\n    rng,\n)\nvorn = voronoi(tri; clip = true, smooth = true, rng)\nfig, ax, sc = voronoiplot(vorn)\nfig","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"","category":"page"},{"location":"tutorials/custom_primitive/","page":"Using Custom Structs for Primitives and Boundaries","title":"Using Custom Structs for Primitives and Boundaries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"In this section we discuss the mathematics behind the curves we provide in this package, and the operations that we perform on curves.","category":"page"},{"location":"math/curves/#AbstractParametricCurve","page":"Curves","title":"AbstractParametricCurve","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Before we get into the curves themselves, let us first discuss what we need from a parametric curve, i.e. for a curve subtyping AbstractParametricCurve. We let vb r colon 0 1 to mathbb R^2 denote a parametric curve, and we always assume the curve to be non-intersecting (except at the endpoints) and three times continuously differentiable. For the discussion below, there may be some curves which take a simpler approach than the general approach described, and this will be indicated later when we discuss these specific curves. ","category":"page"},{"location":"math/curves/#Arc-length","page":"Curves","title":"Arc length","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"One important quantity to compute is the arc length over some interval t_1 leq t leq t_2 along the curve. In general, this is given by the integral","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"s(t_1 t_2) = int_t_1^t_2 vb r(t)  mathrm dt","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"which is typically computed using numerical integration. In this package, we use Gauss-Legendre quadrature so that","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"s(t_1 t_2) approx fract_2 - t_12 sum_i=1^n w_i leftvb rleft(fract_2 - t_12xi_i + fract_1 + t_22right)right","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where xi_i are the nodes and w_i are the weights of the Gauss-Legendre quadrature rule, and n are the number of nodes in use. We use n = 250 for all integrals in this package.","category":"page"},{"location":"math/curves/#Curvature","page":"Curves","title":"Curvature","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The curvature of a curve describes how much the curve deviates from a straight line at a given point. It is defined as ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"kappa(t) = fracvb r(t) times vb r(t)vb r(t)^3","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where times denotes the cross product; in mathbb R^2, we are defining vb u times vb v = u_1v_2 - u_2v_1. Writing vb r(t) = (x(t) y(t)), this can be written as ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"kappa(t) = fracx(t)y(t) - y(t)x(t)(x(t)^2 + y(t)^2)^32","category":"page"},{"location":"math/curves/#Total-variation","page":"Curves","title":"Total variation","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The total variation of vb r(t) over t_1 leq t leq t_2 is defined as the total absolute change in the tangent angle, which we can write as","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"TV(t_1 t_2) = int_C(t_1 t_2) mathrm dtheta","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where theta is the tangent angle of the curve, and C(t_1 t_2) is the curve segment from t_1 to t_2. This is also called the total absolute curvature, since mathrm dtheta = kappa(s)mathrm ds (treating s as the arc length parameter). Thus,","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"TV(t_1 t_2) = int_t_1^t_2 kappa(t)vb r(t) mathrm dt","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where we have used mathrm ds = vb r(t) mathrm dt. We evaluate this using numerical integration just as we did for arc length, writing","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"TV(t_1 t_2) approx fract_2 - t_12 sum_i=1^n w_i leftkappaleft(fract_2 - t_12xi_i + fract_1 + t_22right)rightleftvb rleft(fract_2 - t_12xi_i + fract_1 + t_22right)right","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The reason that total variation is important is that it gives a measure of how much the curve is bending over the interval t_1 leq t leq t_2, meaning we can use the total variation to assess how many edges are needed to give a reasonable piecewise linear approximation to the curve.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"There is a way to evaluate TV(t_1 t_2) without computing the integral. By default, any new AbstractParametricCurve will do so, but for the curves we have implemented in this package we apply the following idea. First, note that the total variation TV(t_1 t_2) over some curve where the curve's orientation is monotone is simply the angle between the tangent vectors at the endpoints. To see this, note that since the orientation is monotone the angle theta is monotone, and so the total change in the angle is simply the difference in the angles at the endpoints. With this idea, we take C(t_1 t_2) and write C(t_1 t_2) = cup_i=1^m C_i where C_i cap C_j = emptyset for i neq j and C_i is a curve segment where the orientation is monotone. Thus, the integral can be evaluated by simply summing the angles between the tangent vectors at the endpoints of each C_i.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"One complication with the above approach is that actually finding the C_i can be difficult. To do so, we need to understand where the curve's orientation changes. There are five cases where this can occur that we list below, letting t^* be a point where the orientation changes and vb r(t) = (x(t) y(t)):","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Horizontal turning point: x(t^*) = 0.\nVertical turning point: y(t^*) = 0.\nHorizontal inflection point: x(t^*) = 0 and x(t^*) neq 0.\nVertical inflection point: y(t^*) = 0 and y(t^*) neq 0.\nInflection point: kappa(t^*) = 0.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"These cases do not have to occur simultaneously - any of them is sufficient to potentially cause a change in orientation; in our implementation, for cases 3 and 4 we do not check whether x(t^*) or y(t^*) is zero. Note that the first four conditions together are not necessarily needed for finding these monotone pieces, but they guarantee that the change in orientation is at most pi2, making it easier to compute the total change in orientation (since a change in orientation of beta could also be 2pi - beta if beta  pi2). To find these points t^*, we use Newton's method on all of the respective functions. So, when initialising a curve that uses this approach, we first find all t^* in 0 1 where any of these changes occur, and order them so that 0 leq t_1^* leq cdots leq t_m^* leq 1. These values define the monotone pieces that the curve is split into. An example of these orientation markers t^* is shown below, where we show the markers on the curve using red dots.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"fig # hide","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"There are many orientation markers on this curve. Only two of these come from kappa(t) = 0, with all the others coming from x y x, and y, as we can see from the graphs shown.","category":"page"},{"location":"math/curves/#Point-on-a-curve-closest-to-a-point","page":"Curves","title":"Point on a curve closest to a point","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"An important problem is finding the point on a curve vb r(t) that is closest to a given point p. Our generic approach to this relies on there being a lookup table for vb r(t) which stores the values vb r(t_i) for i=12ldotsn, where t_i = (i-1)(n-1) to allow for binary search to be used. ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The approach starts by computing (i delta^2), where i is the index so that the point q = vb r(t_i) in the lookup table is closest to p, and delta = p - q. We can then apply binary search in the following way to find an approximation to the closest point on vb r(t) closest to p up to some tolerance varepsilon (varepsilon = 10^-12 in this package); in what follows, we assume 1  i  n, but these boundary cases can be handled in a similar way:","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"First, let t_ell = t_i-1, t_c = t_i, and t_r = t_i+1, and compute w = t_r - t_ell. If w  varepsilon, then we are done, otherwise we go to step 2.\nCompute t_ell c = (t_ell + t_c)  2, t_cr = (t_c + t_r)  2, delta_ell c = p - vb r(t_ell c), and delta_cr = p - vb r(t_cr). If delta_ell c  delta_c r, then we choose the left-middle to be the new center point, replacing t_r with t_c and t_c with t_ell c. Otherwise, we choose the right-middle to be the new center point, replacing t_ell with t_c and t_c with t_cr. We then go back to step 1 with w = t_r - t_ell.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Once the above procedure converges, the final value of t_c gives the point on vb r(t) that is closest to p, i.e. vb r(t_c) is the approximation to the closest point on vb r(t) to p. ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"An example of this procedure is shown below: The point of interest is shown in red, and the lookup points are shown in blue. The lookup point closest to the point of interest is shown via the green line, which defines t_ell leq t_c leq t_r, and the magenta line shows the section of the curve corresponding to this interval t_ell t_r. The black dot shows the closest point on the curve to the point of interest. The binary search for this problem would start by shrinking into the interval t_c t_r, replacing t_c by (t_c + t_r)2, since p is closer to that side of t_c than to t_ell t_c.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"fig # hide","category":"page"},{"location":"math/curves/#Position-of-a-point-relative-to-a-curve","page":"Curves","title":"Position of a point relative to a curve","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"It is important that we know how to find the position of a point p relative to some curve vb r(t), meaning whether p is left or right of vb r(t). The approach we take for this is relatively simple:","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"First, find t^* so that q = vb r(t^*) is the closest point on vb r(t) to p.\nCompute T = vb r(t^*) and construct the line segment L that connects q and T.\nThe position of p is then determined by the position of p relative to L.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"In the example below, p would be right of the curve as it is to the right of the tangent vector T.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"fig # hide","category":"page"},{"location":"math/curves/#Computing-equidistant-splits","page":"Curves","title":"Computing equidistant splits","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"We may want to split a curve between two points t_1 leq t leq t_2 at a point t^* such that s(t_1 t^*) = s(t^* t_2). This is done using a simple bisection method:","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Compute s_12 = s(a b), let s = s_12  2, and set t = (a + t_2)  2, where a = t_1.\nFor 100 iterations, do: Compute s = s(a t). If s - s  varepsilon_1 or b - a  varepsilon_2, then break and return t = t^*. Otherwise, replace t_1 with t if s  s, and replace t_2 with t otherwise. Finally, let t = (t_1 + t_2)  2 and continue iterating.\nReturn t as the equidistant split point.","category":"page"},{"location":"math/curves/#Computing-equivariation-splits","page":"Curves","title":"Computing equivariation splits","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Another important operation is the computation of a point t that splits a given curve vb r(t) between two points t_1 leq t leq t_2 at a point t^* such that TV(t_1 t^*) = TV(t^* t_2). This is called an equivariation split, and is useful as it gives a way to divide a curve into two halves in a more natural way than using, say, an equidistant split which might not be as appropriate a split for certain curves. The computation of t^* is done using a simple bisection method that follows the exact same approach as for equidistant splits, except that instead of computing arc length we compute the total variation, and we initialise t as the equidistant split rather than the midpoint of the interval.","category":"page"},{"location":"math/curves/#Computing-the-inverse-of-a-curve","page":"Curves","title":"Computing the inverse of a curve","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"We often need to find the point t that corresponds to a point q on a curve vb r(t). This is done by simply finding the closest point on the curve to q and returning the parameter value of that point.","category":"page"},{"location":"math/curves/#Computing-the-angle-between-two-curves","page":"Curves","title":"Computing the angle between two curves","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Given two curves vb r_1 and vb r_2, a problem of interest is to consider the angle between them at some point t. This is done by computing the tangent vectors at the point t for both curves, and then computing the angle between these two tangent vectors. Computing these angles is needed during mesh refinement, since we need to protect against small angles.","category":"page"},{"location":"math/curves/#Computing-the-intersection-of-a-curve-with-a-circle","page":"Curves","title":"Computing the intersection of a curve with a circle","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"For mesh refinement we need to use concentric circular shells to protect against small angles. For curves, this means that we need to know how to compute the intersection of a circle with a given curve. In particular, given a circle of radius r centered at vb r(t_1), we need to find the first intersection t^* of the curve with the circle, where t_1 leq t leq t_2, assuming that such an intersection exists. ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The procedure for this problem starts by computing an interval t_i t_j to be used for computing t^* using a bisection method. To find t_i and t_j, we initially set t_i = t_1 and t_j = t_2. Then, for n = 1 2 ldots 500: Compute t_n = t_1 + (n - 1)(t_2 - t_1)(500 - 1) and let q = vb r(t_n). If p - q  r we set t_j = t_n and return t_i t_j, else we set t_i = t_n and continue. There is also a method for finding t_i t_j using a lookup table, but we do not describe that here. Once we have this interval t_i t_j, a bisection method is used to find t^*, remembering that we are trying to solve vb r(t) - vb r(t^*) = r. An example of such an intersection is shown below. The red curve shows the portion of the curve over an interval t_1 t_2, and the green circle shows the circle of radius r centered at a point vb r(t_1). The blue point shows the first intersection of the curve with the circle. The other intersection is ignored as it is not on the red portion.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"fig # hide","category":"page"},{"location":"math/curves/#LineSegment","page":"Curves","title":"LineSegment","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Now we discuss in detail all the curves we provide in this package, starting with LineSegment. We represent line segments as oriented segments between points p and q parametrised by vb r(t) = p + t(q-p) for 0 leq t leq 1. The implementation of the above operations for LineSegment is straightforward, and we do not discuss them here.","category":"page"},{"location":"math/curves/#CircularArc","page":"Curves","title":"CircularArc","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The curve CircularArc is for representing a circular arc, meaning a part of a circle with radius r and center vb c spanning some angle theta_1 leq theta leq theta_2, parametrised over 0 leq t leq 1. We parametrise this arc using ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"vb r(t) = vb c + r(cos theta_t sin theta_t)","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where theta_t = theta_1 + tDeltatheta and Deltatheta=theta_2-theta_1.  With this parametrisation, we also have","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"beginaligned\nvb r(t) = left(-rDeltatheta sin theta_t rDeltatheta cos theta_tright) \nvb r(t) = left(rDeltatheta^2 cos theta_t rDeltatheta^2 sintheta_tright)\nendaligned","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"In addition:","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To determine the position of a point relative to the circle, we simply use the in_circle predicate. \nThe arc length s(t_1 t_2) is simply s(t_1 t_2) = rDeltatheta(t_2-t_1).\nThe curvature is kappa(t) = textsgn(Deltatheta)  r.\nThe total variation is TV(t_1 t_2) = Deltatheta(t_2 - t_1).\nThe equidistant and equivariation splits are both t^* = (t_1 + t_2)  2.\nGiven a point p on the circle, its inverse is t^* = (theta - theta_1)  Delta theta, where theta = arctan(p_y - c_y p_x - c_x). If t^*  0, the inverse is instead t^* + 2piDeltatheta; if t^*  1, the inverse is instead t^* - 2piDeltatheta.","category":"page"},{"location":"math/curves/#EllipticalArc","page":"Curves","title":"EllipticalArc","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"An EllipticalArc is used to represent an arc of an ellipse, defined by a center vb c, horizontal radius alpha, vertical radius beta, a rotation angle theta, a start angle theta_1 (as measured from the center), and a final angle theta_2. We define Deltatheta=theta_2-theta_1. The parametrisation of this arc is","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"vb r(t) = beginbmatrix c_x + alpha cos(theta_t) cos theta - beta sin(theta_t) sin theta  c_y + alpha cos(theta_t) sin theta + beta sin(theta_t) cos theta endbmatrix","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where theta_t = theta_1 + tDeltatheta. The derivatives of vb r(t) are given by","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"beginaligned\nvb r(t) = Deltathetabeginbmatrix -alpha sin(theta_t)costheta-beta cos(theta_t)sintheta  -alphasin(theta_t)sintheta+betacos(theta_t)costhetaendbmatrix \nvb r(t) = Deltatheta^2 beginbmatrix -alphacos(theta_t)+betasin(theta_t)sintheta  -alphacos(theta_t)sintheta-betasin(theta_t)costheta endbmatrix\nendaligned","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The curvature is given by","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"kappa(t) = textsgn(Deltatheta)fracalphabetaleft(alpha^2sin^2(theta_t)+beta^2cos^2(theta_t)right)^32","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The total variation is easily computed by simply taking the angle between the tangent vectors at the endpoints since the orientation is monotone.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To determine the position of a point relative to the arc, we transform into coordinates where the ellipse becomes a unit circle and consider the position of the transformed coordinates. In particular, for a point p = (x y), we transform it into ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"p = left(frac(x - c_x)cos theta + (y - c_y) sin thetaalpha frac-(x - c_x)sin theta + (y - c_y) cos thetabetaright)","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"and then compare it to the unit circle.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The inverse of a point p is computed as follows. First, compute","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"(x y) = left(frac(p_x - c_x)costheta + (p_y - c_y)sinthetaalpha frac-(p_x-c_x)sintheta+(p_y-c_y)costhetabetaright)","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"and then t = arctan(y x) modulo 2pi. Finally, t^* = (t - theta_1)  Deltatheta; if t^*  0, the inverse is instead t^* + 2piDeltatheta; if t^*  1, the inverse is instead t^* - 2piDeltatheta.","category":"page"},{"location":"math/curves/#BezierCurve","page":"Curves","title":"BezierCurve","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The next curve we discuss is the BezierCurve. Bézier curves are curves that are defined by a set of control points. They are not interpolating curves, but their shape can be highly controlled using the control points. A great resource on Bézier curves is this primer. The precise definition of Bézier curves will not be delved into here. ","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To write down the parametrisation of a Bézier curve, let the control points be vb p_1 ldots vb p_n. Our parametrisation is then","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"vb r(t) = sum_i=0^n-1 binomn-1i(1-t)^n-1-it^ivb p_i+1","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"This is not the form we use to evaluate vb r(t), though. Instead, de Casteljau's algorithm is used to evaluate the curve, a recursive algorithm for evaluating vb r(t).","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To differentiate vb r(t), we can use the fact that the derivative of an (n-1)th degree Bézier curve (our curve is of degree n-1) is an (n-2)th degree Bézier curve with control points vb p_i+1 - vb p_i. Thus, differentiating vb r(t) is the same as applying de Casteljau's algorithm to an (n-2)th degree Bézier curve with control points  vb p_i+1 - vb p_i. The same is true for twice and thrice differentiating vb r(t); for the second derivatives the control points are vb p_i+2 - 2vb p_i+1 + vb p_i, and for the third derivatives the control points are vb p_i+3 - 3vb p_i+2 + 3vb p_i+1 - vb p_i.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"For all the other operations, we use the generic approaches previously described, as Bézier curves do not lend themselves nicely to simple formulas for these operations.","category":"page"},{"location":"math/curves/#BSpline","page":"Curves","title":"BSpline","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"The next curve we discuss is the BSpline. B-splines are controlled by a set of control points and a set of knots. They are not interpolating curves. In our implementation, we do not allow for general knots to be provided, and the spline always goes through the first and last points, but not any of the intermediate points. Rather than go through the precise definition here, you are better off reading for example this section of the primer here, or The NURBs Book by Piegl and Tiller (1997).","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"For our implementation, you just need to know that we use de Boor's algorithm for evaluating a B-spline. Similarly, since the derivative of a B-spline is just another B-spline, we can use de Boor's algorithm to differentiate a B-spline, and similarly for its second and third derivatives. For all the other operations we use the generic approaches previously described just as we did for Bézier curves.","category":"page"},{"location":"math/curves/#CatmullRomSpline","page":"Curves","title":"CatmullRomSpline","text":"","category":"section"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"We now discuss Catmull-Rom splines, which is an interpolating spline defined by a set of piecewise cubic polynomials. To discuss these splines, we need to consider the Catmull-Rom spline defined by a set of four points vb p_0 vb p_1 vb p_2 vb p_3. This is a cubic polynomial of the form vb q(t) = vb a t^3 + vb b t^2 + vb c t + vb d over 0 leq t leq 1 that interpolates the four points, but is drawn only between vb p_2 and vb p_3 with vb q(0) = vb p_1 and vb q(1) = vb p_2. We also define two parameters alpha and tau that define the type of the parametrisation and the tightness of the spline, respectively; alpha = 0 is called a uniform parmetrisation, alpha = 12 is called a centripetal parametrisation, and alpha = 1 is called a chordal parametrisation. Increasing tau makes the spline tighter, and tau = 1 turns the spline into a piecewise linear curve. In this package, we only directly support alpha=12 and tau=0.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Using these control points and parameters, following this article, we can compute the coefficients of our polynomial as follows:","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"beginaligned\nvb m_1 = (1 - tau) (t_2 - t_1) left(fracvb p_1 - vb p_0t_1 - t_0 - fracvb p_2 - vb p_0t_2 - t_0 + fracvb p_2 - vb p_1t_2 - t_1right) \nvb m_2 = (1 - tau) (t_2 - t_1) left(fracvb p_2 - vb p_1t_2 - t_1 - fracvb p_3 - vb p_1t_3 - t_1 + fracvb p_3 - vb p_2t_3 - t_2right) \nvb a = 2(vb p_1 - vb p_2) + vb m_1 + vb m_2 \nvb b = -3(vb p_1 - vb p_2) - 2vb m_1 - vb m_2 \nvb c = vb m_1 \nvb d = vb p_1\nendaligned","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"where t_i = t_i-1 + vb p_i - vb p_i-1^alpha and t_0=0 for i=123.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"Using this definition of a Catmull-Rom spline through four points, we can generalise it to a set of n control points vb p_1ldotsvb p_n. Firstly, since a Catmull-Rom spline through four points only draws through the inner two points, if we want the spline to interpolate through all of the control points then we need to define two new control points vb p_0 and vb p_n+1 so that vb p_1 and vb p_n are included in the interior of some spline segment (if the spline is closed so that vb p_1 = vb p_n, no new points are needed). Using ideas from CatmullRom.jl, we define vb p_0 as follows: We reflect x_2, the x coordinate of vb p_2, left of x_1 to a point x = x_1 - (x_2 - x_1) = 2x_1 - x_2. We then need to find the point y that best suits the spline at this point x. We do this using rational interpolation, specifically Thiele's quartic rational interpolant. If the resulting y is not finite, we use the cubic rational interpolant and, if that fails, we use quadratic interpolation. If x_1 = x_2, we instead apply this idea to y. We then set vb p_0 = (x y), and apply the same ideas to vb p_n+1.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"We now have a set of control points vb p_0 vb p_1 ldots vb p_n vb p_n+1, and are interested in a Catmull-Rom spline that interpolates through vb p_1ldotsvb p_n. To evlauate the spline vb r(t), we start by defining the knots t_i= t_i-1 + vb p_i - vb p_i-1^alpha, where t_1=0, and then set t_i = t_it_n so that 0 leq t_i leq 1. We then find the knot interval t_j t_j+1 that contains t, and map t into this interval using t = (t - t_j)(t_j+1 - t_j). Next, we construct the Catmull-Rom spline segment through vb p_j-1, vb p_j, vb p_j+1, and vb p_j+2, and evaluate this segment at t to get vb r(t).","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To differentiate vb r(t), we apply similar ideas as above except that we differentiate the Catmull-Rom spline segment through vb p_j-1, vb p_j, vb p_j+1, and vb p_j+2, and evaluate this derivative at t to get vb r(t) (after multiplying by 1(t_j+1 - t_j)). Similar ideas apply for computing vb r(t) and vb r(t).","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"To compute the arc length s(t_1 t_2), we store the arc lengths of each spline segment (computed using numerical integration) to quickly compute the arc length across any segments entirely covered in t_1 leq t leq t_2, and then use numerical integration for any remaining segments not completely covered.","category":"page"},{"location":"math/curves/","page":"Curves","title":"Curves","text":"For the remaining operations, we use the generic approaches previously described.","category":"page"},{"location":"applications/cell_simulations/#Cellular-Biology","page":"Cellular Biology","title":"Cellular Biology","text":"","category":"section"},{"location":"applications/cell_simulations/","page":"Cellular Biology","title":"Cellular Biology","text":"This example has been moved to Agent.jl's documentation. Please see the example here.","category":"page"},{"location":"applications/cell_simulations/#Just-the-code","page":"Cellular Biology","title":"Just the code","text":"","category":"section"},{"location":"applications/cell_simulations/","page":"Cellular Biology","title":"Cellular Biology","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"applications/cell_simulations/","page":"Cellular Biology","title":"Cellular Biology","text":"","category":"page"},{"location":"applications/cell_simulations/","page":"Cellular Biology","title":"Cellular Biology","text":"","category":"page"},{"location":"applications/cell_simulations/","page":"Cellular Biology","title":"Cellular Biology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/operations_flip_edge/#Triangulation-Operations","page":"Edge Flipping","title":"Triangulation Operations","text":"","category":"section"},{"location":"tutorials/operations_flip_edge/#Edge-Flipping","page":"Edge Flipping","title":"Edge Flipping","text":"","category":"section"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"This tutorial shows we can flip edges in a triangulation. Edge flipping is the flipping of some edge (i, j) to the edge (k, ℓ), where (i, j) and (k, ℓ) are diagonals of the quadrilateral formed by p_ip_jp_kp_l. The edge flip is illustrated below.","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"using CairoMakie #hide\npoints = [(0.0, -1.0), (1.0, 0.0), (0.0, 1.0), (-1.0, 0.0)] #hide\nT1 = points[[1, 2, 3]] #hide\nT2 = points[[1, 3, 4]] #hide\nT3 = points[[1, 2, 4]] #hide\nT4 = points[[2, 3, 4]] #hide\nfig = Figure() #hide\nax1 = Axis(fig[1, 1], width = 600, height = 400) #hide\nax2 = Axis(fig[1, 2], width = 600, height = 400) #hide\npoly!(ax1, [T1; T2], color = (:white, 0.0), strokewidth = 3) #hide\npoly!(ax2, [T3; T4], color = (:white, 0.0), strokewidth = 3) #hide\nfor ax in (ax1, ax2) #hide\n    hidedecorations!(ax) #hide\n    hidespines!(ax) #hide\n    text!(ax, [(0.05, -1.1)]; text = [L\"p_j\"], fontsize = 43) #hide\n    text!(ax, [(0.9, 0.1)]; text = [L\"p_k\"], fontsize = 43) #hide\n    text!(ax, [(0.05, 1.0)]; text = [L\"p_i\"], fontsize = 43) #hide\n    text!(ax, [(-1.05, 0.05)]; text = [L\"p_\\ell\"], fontsize = 43) #hide\n    xlims!(ax, -1.1, 1.1) #hide\n    ylims!(ax, -1.3, 1.3) #hide\nend #hide\nresize_to_layout!(fig) #hide\nfig #hide","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"Note that this edge flip only makes sense if the quadrilateral is convex. If the quadrilateral is not convex, then the edge flip will not be valid; no checks are made for whether the quadrilateral is convex inside the flip_edge! function.","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"Let us now showcase how we can flip edges. First, we load in the packages we need.","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"using DelaunayTriangulation\nusing CairoMakie","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"Let us now define our initial triangulation.","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"points = [(0.0, 0.0), (0.8, 0.0), (1.3, 1.0), (0.0, 1.0)]\ntri = triangulate(points);\nnothing #hide","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"Now, flipping the edge is simple. We simply provide the indices i and j for the edge we want to flip. Let us flip the edge (2, 4).","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"fig, ax, sc = triplot(tri, axis = (title = \"Before flipping\",))\nax2 = Axis(fig[1, 2], title = \"After flipping\")\nflip_edge!(tri, 2, 4)\ntriplot!(ax2, tri)\nfig","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"As simple as that. Note that no checks are made for whether the edge is actually in the triangulation, on the boundary, or if the associated quadrilateral is convex. It is up to you to check this if needed; one way to check would be to use DelaunayTriangulation.is_legal, as is done inside legalise_edge! – see the next tutorial.","category":"page"},{"location":"tutorials/operations_flip_edge/#Just-the-code","page":"Edge Flipping","title":"Just the code","text":"","category":"section"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"An uncommented version of this example is given below. You can view the source code for this file here.","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"using DelaunayTriangulation\nusing CairoMakie\n\npoints = [(0.0, 0.0), (0.8, 0.0), (1.3, 1.0), (0.0, 1.0)]\ntri = triangulate(points);\n\nfig, ax, sc = triplot(tri, axis = (title = \"Before flipping\",))\nax2 = Axis(fig[1, 2], title = \"After flipping\")\nflip_edge!(tri, 2, 4)\ntriplot!(ax2, tri)\nfig","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"","category":"page"},{"location":"tutorials/operations_flip_edge/","page":"Edge Flipping","title":"Edge Flipping","text":"This page was generated using Literate.jl.","category":"page"}]
}
