<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predicates · DelaunayTriangulation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/predicates/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li></ul></li><li><a class="tocitem" href="../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../interface/edges/">Edges</a></li><li><a class="tocitem" href="../interface/points/">Points</a></li><li><a class="tocitem" href="../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../interface/example/">Example</a></li></ul></li><li class="is-active"><a class="tocitem" href>Predicates</a><ul class="internal"><li><a class="tocitem" href="#General"><span>General</span></a></li><li><a class="tocitem" href="#Boundaries-and-Ghosts"><span>Boundaries and Ghosts</span></a></li><li><a class="tocitem" href="#Index-and-Ghost-Handling"><span>Index and Ghost Handling</span></a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><a class="tocitem" href="../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Predicates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predicates</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/predicates.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Predicates"><a class="docs-heading-anchor" href="#Predicates">Predicates</a><a id="Predicates-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates" title="Permalink"></a></h1><p>The predicates that we use in this package are all built from ExactPredicates.jl, avoiding degeneracies from predicates owing to floating point arithmetic. The results from predicates are based on certificates, coming from a <code>Certificate</code> type defined with EnumX.jl. The definition of this is below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.Certificate" href="#DelaunayTriangulation.Certificate"><code>DelaunayTriangulation.Certificate</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Certificate</code></pre><p>An <code>Enum</code> type that represents results from a geometric  predicate. Below we provide a list of available certificates,  along with the function that can be used for testing if a given  <code>Certificate</code> matches that <code>certificate</code>.</p><ul><li><code>Inside</code>: <code>is_inside</code></li><li><code>Degenerate</code>: <code>is_degenerate</code></li><li><code>Outside</code>: <code>is_outside</code></li><li><code>On</code>: <code>is_on</code></li><li><code>Left</code>: <code>is_left</code></li><li><code>Right</code>: <code>is_right</code></li><li><code>PositivelyOriented</code>: <code>is_positively_oriented</code></li><li><code>NegativelyOriented</code>: <code>is_negatively_oriented</code></li><li><code>Collinear</code>: <code>is_collinear</code></li><li><code>None</code>: <code>is_none</code> or <code>has_no_intersections</code></li><li><code>Single</code>: <code>is_single</code> or <code>has_one_intersection</code></li><li><code>Multiple</code>: <code>is_multiple</code> or <code>has_multiple_intersections</code></li><li><code>Touching</code>: <code>is_touching</code></li><li><code>Legal</code>: <code>is_legal</code></li><li><code>Illegal</code>: <code>is_illegal</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/certificate.jl#L1-L24">source</a></section></article><h2 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h2><p>Below we list some general predicates. The core ones that all other predicates are based on are:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.orient_predicate" href="#DelaunayTriangulation.orient_predicate"><code>DelaunayTriangulation.orient_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orient_predicate(p, q, r)</code></pre><p>Returns <code>ExactPredicates.orient(p, q, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.incircle_predicate" href="#DelaunayTriangulation.incircle_predicate"><code>DelaunayTriangulation.incircle_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incircle_predicate(a, b, c, p)</code></pre><p>Returns <code>ExactPredicates.incircle(a, b, c, p)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L8-L12">source</a></section></article><p>The mathematical definitions for these predicates are:</p><ul><li><code>orient_predicate</code>: Let <span>$O(p, q, r)$</span> denote <code>orient_predicate(p, q, r)</code>. The definition is </li></ul><p class="math-container">\[O(p, q, r) = \text{sgn}\left(\begin{vmatrix} p_x - r_x &amp; p_y - r_y \\ q_x - r_x &amp; q_y - r_y \end{vmatrix}\right).\]</p><p>With this definition, <span>$O(p, q, r) &gt; 0$</span> means <span>$r$</span> is left of the line <span>$\overrightarrow{pq}$</span> or that the triangle <span>$pqr$</span> is positively oriented; <span>$O(p, q, r) = 0$</span> means <span>$r$</span> is collinear with <span>$\overrightarrow{pq}$</span> or that the triangle <span>$pqr$</span> is degenerate; <span>$O(p, q, r) &lt; 0$</span> means <span>$r$</span> is to the right of <span>$\overrightarrow{pq}$</span> or that the triangle <span>$pqr$</span> is negatively oriented.</p><ul><li><code>incircle_predicate</code>: Let <span>$O(p, q, r, s)$</span> denote <code>incircle_predicate(p, q, r, s)</code>. The definition is</li></ul><p class="math-container">\[O(p, q, r, s) = \text{sgn}\left(\begin{vmatrix} 
p_x - s_x &amp; p_y - s_y &amp; (p_x - s_x)^2 + (p_y - s_y)^2 \\
q_x - s_x &amp; q_y - s_y &amp; (q_x - s_x)^2 + (q_y - s_y)^2 \\
r_x - s_x &amp; r_y - s_y &amp; (r_x - s_x)^2 + (r_y - s_y)^2
\end{vmatrix}\right).\]</p><p>With this definition, <span>$O(p, q, r, s) &gt; 0$</span> means <span>$s$</span> is inside the circle through <span>$p$</span>, <span>$q$</span>, and <span>$r$</span>; <span>$O(p,q r)=0$</span> means <span>$s$</span> is cocircular with <span>$p$</span>, <span>$q$</span>, and <span>$r$</span>; <span>$O(p, q, r) &lt; 0$</span> means <span>$s$</span> is outside the circle through <span>$p$</span>, <span>$q$</span>, and <span>$r$</span>.</p><p>In code, these two predicates could be defined by (the actual definition with ExactPredicates.jl is much more involved):</p><pre><code class="language-julia hljs">_det(a, b, c, d) = a * d - b * c
_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion 
function orient_predicate(a, b, c)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    o = _det(ax - cx, ay - cy, bx - cx, by - cy)
    return Int(sign(o)) # need Int for xor
end
function incircle_predicate(a, b, c, d)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    dx, dy = getxy(d)
    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,
        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,
        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)
    return Int(sign(o)) # need Int for xor
end</code></pre><p>You could use this as a reference if you want to disconnect from using ExactPredicates.jl (or e.g. use the predicates also defined in GeometricalPredicates.jl). This could be useful if you are not too worried about robustness (although you should typically care about this, so be careful) and just want fast code. Let&#39;s see what happens if we randomly triangulate some set of <span>$100,000$</span> points using ExactPredicates.jl versus the definitions above.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
using BenchmarkTools 
n = 100_000
pts = 20randn(2, n)

## Benchmark the original definition 
b1 = @benchmark triangulate($pts)

## Now change the definitions 
_det(a, b, c, d) = a * d - b * c
_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion 
function DelaunayTriangulation.orient_predicate(a, b, c)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    o = _det(ax - cx, ay - cy, bx - cx, by - cy)
    return Int(sign(o)) 
end
function DelaunayTriangulation.incircle_predicate(a, b, c, d)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    dx, dy = getxy(d)
    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,
        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,
        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)
    return Int(sign(o))
end

## Benchmark these new definitions 
b2 = @benchmark triangulate($pts)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b1
BenchmarkTools.Trial: 3 samples with 1 evaluation.
 Range (min … max):  2.218 s …   2.386 s  ┊ GC (min … max): 5.61% … 7.91%
 Time  (median):     2.360 s              ┊ GC (median):    5.28%
 Time  (mean ± σ):   2.321 s ± 90.182 ms  ┊ GC (mean ± σ):  5.81% ± 2.02%

  █                                               █       █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█ ▁
  2.22 s         Histogram: frequency by time        2.39 s &lt;

 Memory estimate: 418.00 MiB, allocs estimate: 4079091.

julia&gt; b2
BenchmarkTools.Trial: 3 samples with 1 evaluation.
 Range (min … max):  2.343 s …   2.447 s  ┊ GC (min … max): 3.93% … 7.49%
 Time  (median):     2.370 s              ┊ GC (median):    6.31%
 Time  (mean ± σ):   2.387 s ± 53.921 ms  ┊ GC (mean ± σ):  5.93% ± 1.82%

  █             █                                         █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.34 s         Histogram: frequency by time        2.45 s &lt;

 Memory estimate: 417.99 MiB, allocs estimate: 4079731.</code></pre><p>Not much difference - ExactPredicates.jl probably never has to run the slow definition in this case. What if the numbers are all very small?</p><pre><code class="language-julia hljs">using ExactPredicates
## Go back to the original definitions 
DelaunayTriangulation.orient_predicate(p, q, r) = orient(getxy(p), getxy(q), getxy(r))
DelaunayTriangulation.incircle_predicate(a, b, c, p) = incircle(getxy(a), getxy(b), getxy(c), getxy(p))

## Get another set of points 
pts = 1e-8rand(2, 100_000)

## Do the benchmarks again 
b1 = @benchmark triangulate($pts)
function DelaunayTriangulation.orient_predicate(a, b, c)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    o = _det(ax - cx, ay - cy, bx - cx, by - cy)
    return Int(sign(o)) 
end
function DelaunayTriangulation.incircle_predicate(a, b, c, d)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    dx, dy = getxy(d)
    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,
        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,
        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)
    return Int(sign(o))
end
b2 = @benchmark triangulate($pts)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b1
BenchmarkTools.Trial: 3 samples with 1 evaluation.
 Range (min … max):  2.301 s …   2.423 s  ┊ GC (min … max): 2.34% … 3.96%
 Time  (median):     2.305 s              ┊ GC (median):    3.64%
 Time  (mean ± σ):   2.343 s ± 69.581 ms  ┊ GC (mean ± σ):  3.32% ± 0.85%

  ██                                                      █
  ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.3 s          Histogram: frequency by time        2.42 s &lt;

 Memory estimate: 430.78 MiB, allocs estimate: 4079516.

julia&gt; b2
BenchmarkTools.Trial: 3 samples with 1 evaluation.
 Range (min … max):  2.218 s …   2.269 s  ┊ GC (min … max): 4.03% … 2.51%
 Time  (median):     2.239 s              ┊ GC (median):    4.00%
 Time  (mean ± σ):   2.242 s ± 25.344 ms  ┊ GC (mean ± σ):  3.75% ± 1.14%

  █                      █                                █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.22 s         Histogram: frequency by time        2.27 s &lt;

 Memory estimate: 417.98 MiB, allocs estimate: 4079100.</code></pre><p>Still not much of a difference, so I would not really recommend bothering changing these definitions – but the option is there if your application calls for it. (With a million points in the above example, the changed definition is about two seconds faster at a total of 38 seconds).</p><p>The other predicates are:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.sameside_predicate" href="#DelaunayTriangulation.sameside_predicate"><code>DelaunayTriangulation.sameside_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sameside_predicate(a, b, p)</code></pre><p>Returns <code>ExactPredicates.sameside(p, a, b)</code> (but we redefine it here).</p><p>(The difference in the argument order is to match the convention that the  main point being tested is the last argument.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.meet_predicate" href="#DelaunayTriangulation.meet_predicate"><code>DelaunayTriangulation.meet_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meet_predicate(p, q, a, b)</code></pre><p>Returns <code>ExactPredicates.meet(p, q, a, b)</code>  (but we redefine it here).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation(p, q, r)</code></pre><p>Given a triangle with coordinates <code>(p, q, r)</code>, computes its orientation, returning:</p><ul><li><code>Certificate.PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Certificate.Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear. </li><li><code>Certificate.NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><p>See also <a href="#DelaunayTriangulation.orient_predicate"><code>orient_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circle" href="#DelaunayTriangulation.point_position_relative_to_circle"><code>DelaunayTriangulation.point_position_relative_to_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circle(a, b, c, p)</code></pre><p>Given a circle through the coordinates <code>(a, b, c)</code>, assumed to be positively oriented,  computes the position of <code>p</code> relative to the circle. In particular, returns:</p><ul><li><code>Certificate.Inside</code>: <code>p</code> is inside the circle.</li><li><code>Certificate.On</code>: <code>p</code> is on the circle. </li><li><code>Certificate.Outside</code>: <code>p</code> is outside the triangle.</li></ul><p>See also <a href="#DelaunayTriangulation.incircle_predicate"><code>incircle_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L83-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line(a, b, p)</code></pre><p>Given a point <code>p</code> and the oriented line <code>(a, b)</code>, computes the position  of <code>p</code> relative to the line, returning:</p><ul><li><code>Certificate.Left</code>: <code>p</code> is to the left of the line. </li><li><code>Certificate.Collinear</code>: <code>p</code> is on the line.</li><li><code>Certificate.Right</code>: <code>p</code> is to the right of the line. </li></ul><p>See also <a href="#DelaunayTriangulation.orient_predicate"><code>orient_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L100-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(a, b, p)</code></pre><p>Given a point <code>p</code> and the line segment <code>(a, b)</code>, assuming <code>p</code>  to be collinear with <code>a</code> and <code>b</code>, computes the position of <code>p</code> relative to the line segment. In particular, returns:</p><ul><li><code>Certificate.On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Certificate.Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints. </li><li><code>Certificate.Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Certificate.Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul><p>See also <a href="#DelaunayTriangulation.sameside_predicate"><code>sameside_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}" href="#DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type(p, q, a, b)</code></pre><p>Given the coordinates <code>(p, q)</code> and <code>(a, b)</code> defining two line segments,  tests the number of intersections between the two segments. In particular,  we return:</p><ul><li><code>Certificate.None</code>: The line segments do not meet at any points. </li><li><code>Certificate.Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>Certificate.Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point. </li><li><code>Certificate.Touching</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul><p>See also <a href="#DelaunayTriangulation.meet_predicate"><code>meet_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L143-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}" href="#DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(a, b, c, p)</code></pre><p>Given a positively oriented triangle with coordinates <code>(a, b, c)</code>, computes the  position of <code>p</code> relative to the triangle. In particular, returns: </p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L197-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane" href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_oriented_outer_halfplane(a, b, p)</code></pre><p>Given an edge with coordinates <code>(a, b)</code> and a point <code>p</code>,  tests the position of <code>p</code> relative to the oriented outer halfplane defined  by <code>(a, b)</code>. The oriented outer halfplane is the union of the open halfplane  defined by the region to the left of the oriented line <code>(a, b)</code>, and the  open line segment <code>(a, b)</code>. The returned values are:</p><ul><li><code>Cert.Outside</code>: <code>p</code> is outside of the oriented outer halfplane, meaning to the right of the line <code>(a, b)</code> or collinear with <code>a</code> and <code>b</code> but not on the line segment <code>(a, b)</code>.</li><li><code>Cert.On</code>: <code>p</code> is on the open line segment <code>(a, b)</code>.</li><li><code>Cert.Inside</code>: <code>p</code> is inside of the oriented outer halfplane, meaning to the left of the line <code>(a, b)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L226-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_legal-NTuple{4, Any}" href="#DelaunayTriangulation.is_legal-NTuple{4, Any}"><code>DelaunayTriangulation.is_legal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_legal(p, q, r, s)</code></pre><p>Given an edge <code>pq</code>, incident to two triangles <code>pqr</code> and <code>qps</code>, tests  if the edge <code>pq</code> is legal, i.e. if <code>s</code> is not inside the triangle through  <code>p</code>, <code>q</code>, and <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L255-L261">source</a></section></article><h2 id="Boundaries-and-Ghosts"><a class="docs-heading-anchor" href="#Boundaries-and-Ghosts">Boundaries and Ghosts</a><a id="Boundaries-and-Ghosts-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries-and-Ghosts" title="Permalink"></a></h2><p>Below we list some predicates for working with boundaries and ghost triangles. </p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_index" href="#DelaunayTriangulation.is_boundary_index"><code>DelaunayTriangulation.is_boundary_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_boundary_index(i::I) where {I}</code></pre><p>Given an index <code>i</code>, returns <code>i ≤ I(BoundaryIndex)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}" href="#DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}"><code>DelaunayTriangulation.is_boundary_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_edge(ij, adj::Adjacent)
is_boundary_edge(i, j, adj::Adjacent{I,E}) where {I,E}</code></pre><p>Given an edge <code>(i, j)</code> and an adjacent map <code>adj</code>, returns <code>true</code> if  <code>(i, j)</code> is a boundary edge and <code>false</code> otherwise.</p><p>Note that the orientation of <code>(i, j)</code> is important: even if <code>(i, j)</code> is an edge on the boundary, if there is a triangle <code>(i, j, k)</code> in the triangulation then  <code>(i, j)</code> is not a boundary edge but <code>(j, i)</code> would be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}" href="#DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}"><code>DelaunayTriangulation.is_boundary_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_triangle(i, j, k, adj)
is_boundary_triangle(T, adj)</code></pre><p>Given a triangle <code>T = (i, j, k)</code> and an adjacent map <code>adj</code>,  returns <code>true</code> if <code>T</code> is a boundary triangle. A boundary triangle  is still part of the triangulation, but it has at least one edge that  forms part of the boundary (so that at least one of <code>is_boundary_edge(j, i)</code>, <code>is_boundary_edge(k, j)</code>, and <code>is_boundary_edge(i, k)</code> is <code>true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_edge" href="#DelaunayTriangulation.is_ghost_edge"><code>DelaunayTriangulation.is_ghost_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_edge(i, j)</code></pre><p>Given an edge <code>(i, j)</code>, returns <code>true</code> if <code>(i, j)</code> is a  ghost edge. A ghost edge is an edge in which either <code>is_boundary_index(i)</code> or <code>is_boundary_index(j)</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_triangle" href="#DelaunayTriangulation.is_ghost_triangle"><code>DelaunayTriangulation.is_ghost_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_triangle(i, j, k)
is_ghost_triangle(T)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, returns <code>true</code>  if <code>T</code> is a ghost triangle and <code>false</code> otherwise. A ghost  triangle is one in which any of the vertices <code>(i, j, k)</code>  are a boundary index, as tested via <a href="#DelaunayTriangulation.is_boundary_index"><code>is_boundary_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_interior_curve" href="#DelaunayTriangulation.is_interior_curve"><code>DelaunayTriangulation.is_interior_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_interior_curve(i)
is_interior_curve(i, boundary_map)</code></pre><p>Given an index <code>i</code>, tests if the curve is an interior curve, i.e. if <code>i &gt; 1</code>. If  a map <code>boundary_map</code> is provided, <code>i</code> should be a boundary map so that <code>is_interior_curve(j)</code> is tested, where <code>j = get_curve_index(boundary_map, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}" href="#DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}"><code>DelaunayTriangulation.is_outer_boundary_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_index(i, boundary_map)</code></pre><p>Given an index <code>i</code>, tests if the index is a boundary index referring to the outermost boundary, making  use of the <code>boundary_map</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_ghost_triangle" href="#DelaunayTriangulation.is_outer_ghost_triangle"><code>DelaunayTriangulation.is_outer_ghost_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_outer_ghost_triangle(i, j, k, boundary_map)</code></pre><p>Given a ghost triangle <code>(i, j, k)</code> and a boundary map <code>boundary_map</code> taking boundary indices to their location in the boundary node array,  tests if <code>(i, j, k)</code> is a ghost triangle on the outermost boundary  (<code>true</code>) or on an interior boundary (<code>false</code>)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_ghost_edge" href="#DelaunayTriangulation.is_outer_ghost_edge"><code>DelaunayTriangulation.is_outer_ghost_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_outer_ghost_edge(i, j, boundary_map)</code></pre><p>Given a ghost edge <code>(i, j)</code> and a boundary map <code>boundary_map</code> taking boundary indices to their location in the boundary node array,  tests if <code>(i, j)</code> is a ghost edge on the outermost boundary  (<code>true</code>) or on an interior boundary (<code>false</code>)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I" href="#DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I"><code>DelaunayTriangulation.is_outer_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}</code></pre><p>Given a node index <code>i</code>, a <code>graph::Graph</code>, a <code>Dict</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, returns true if <code>i</code> corresponds to a node on the outermost boundary,  and <code>false</code> otherwise.</p><p>See also <a href="@ref"><code>is_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_exists-Tuple{I} where I" href="#DelaunayTriangulation.edge_exists-Tuple{I} where I"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_exists(i::I) where {I}</code></pre><p>Returns <code>i ≠ I(DefaultAdjacentValue)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}" href="#DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_exists(ij, adj::Adjacent{I,E}) where {I,E}</code></pre><p>Given an edge <code>ij</code> and an <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code>,  tests if the edge exists in the corresponding triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}" href="#DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}"><code>DelaunayTriangulation.has_ghost_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_ghost_triangles(adj::Adjacent{I,E}, adj2v) where {I,E}</code></pre><p>Given an <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code> and an <a href="../data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map <code>adj2v</code>, tests if the corresponding triangulation contains ghost triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/boundaries_and_ghosts.jl#L191-L196">source</a></section></article><h2 id="Index-and-Ghost-Handling"><a class="docs-heading-anchor" href="#Index-and-Ghost-Handling">Index and Ghost Handling</a><a id="Index-and-Ghost-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Index-and-Ghost-Handling" title="Permalink"></a></h2><p>Below we list methods for working with predicates that are used when we provide indices for points rather than points directly.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation-NTuple{5, Any}" href="#DelaunayTriangulation.triangle_orientation-NTuple{5, Any}"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation(i, j, k, pts, boundary_map)
triangle_orientation(T, pts, boundary_map)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, with indices corresponding  to points in <code>pts</code>, computes the orientation of the triangle. In particular, returns:</p><ul><li><code>Certificate.PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Certificate.Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear. </li><li><code>Certificate.NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><p>A test is also made for the case that <code>is_ghost_triangle(T)</code>: If  <code>T</code>  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly.  In case the boundary  index corresponds to an interior curve, this flip is not necessary.</p><p>The mapping of a boundary index is handled via the <code>boundary_map</code>  argument - see <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L2-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{6, Any}" href="#DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{6, Any}"><code>DelaunayTriangulation.point_position_relative_to_circumcircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circumcircle(i, j, k, ℓ, pts, boundary_map)
point_position_relative_to_circumcircle(T, ℓ, pts, boundary_map)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, with indices corresponding  to points in <code>pts</code>, and a point with index <code>ℓ</code>, <code>pₗ</code>, computes  the position this point <code>pₗ</code> relative to the triangle&#39;s circumcircle, making use of <a href="#DelaunayTriangulation.point_position_relative_to_circle"><code>point_position_relative_to_circle</code></a>.</p><p>The returned values are:</p><ul><li><code>Certificate.Outside</code>: <code>pₗ</code> is outside of the circumcircle.</li><li><code>Certificate.On</code>: <code>pₗ</code> is on the circumcircle.</li><li><code>Certificate.Inside</code>: <code>pₗ</code> is inside the circumcircle.</li></ul><p>A test is also made for the case that <code>is_ghost_triangle(T)</code>: When <code>T</code> is a ghost triangle, one of its indices is a boundary index, say <code>i</code>.  Since this vertex is treated as being out at infinity, the circumcircle  degenerates into the line through the other two vertices. Thus, we test  that <code>pₗ</code> is inside this circumcircle by seeing if it is in the oriented  outer halfplane defined by the two other vertices. See also  <a href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>point_position_relative_to_oriented_outer_halfplane</code></a>.</p><p>The mapping of a boundary index is handled via the <code>boundary_map</code>  argument - see <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L35-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line-NTuple{5, Any}" href="#DelaunayTriangulation.point_position_relative_to_line-NTuple{5, Any}"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line(i, j, u, pts, boundary_map)</code></pre><p>Given indices <code>i</code>, <code>j</code>, and <code>u</code> corresponding to indices  of points in the collection of points <code>pts</code>, corresponding to  coordinates say <code>a</code>, <code>b</code>, and <code>p</code>, respectively, computes the  position of <code>p</code> relative to the oriented line <code>(a, b)</code>. </p><p>The returned values are:</p><ul><li><code>Certificate.Left</code>: <code>p</code> is to the left of the line. </li><li><code>Certificate.Collinear</code>: <code>p</code> is on the line.</li><li><code>Certificate.Right</code>: <code>p</code> is to the right of the line.</li></ul><p>If <code>is_outer_ghost_edge(i, j, boundary_map)</code>, the oriented line <code>(a, b)</code> is flipped  since the point corresponding to the boundary index will be a  centroid which swaps the orientation.</p><p>The mapping of a boundary index is handled via the <code>boundary_map</code>  argument - see <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L77-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}" href="#DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(i, j, u, pts)</code></pre><p>Given indices <code>i</code>, <code>j</code>, and <code>u</code> corresponding to indices  of points in the collection of points <code>pts</code>, corresponding to  coordinates say <code>a</code>, <code>b</code>, and <code>p</code>, respectively, computes the  position of <code>p</code> relative to the oriented line segment <code>(a, b)</code>, assuming that the three points are collinear.</p><p>The returned values are:</p><ul><li><code>Certificate.On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Certificate.Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints. </li><li><code>Certificate.Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Certificate.Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L107-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}" href="#DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type(u, v, i, j, pts)</code></pre><p>Given two pairs of indices <code>(u, v)</code> and <code>(i, j)</code>, with  all indices corresponding to points in <code>pts</code>, tests  the number of intersections between the two line segments  associated with these indices.</p><p>Letting <code>p</code>, <code>q</code>, <code>a</code>, and <code>b</code> be the points referred to by  <code>u</code>, <code>v</code>, <code>i</code>, and <code>j</code>, respectively, we return:</p><ul><li><code>Certificate.None</code>: The line segments do not meet at any points. </li><li><code>Certificate.Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>Certificate.Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point.</li><li><code>Certificate.On</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L128-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, AbstractDict}" href="#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, AbstractDict}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(i, j, k, u, pts, boundary_map)
point_position_relative_to_triangle(T, u, pts, boundary_map)</code></pre><p>Given a triangle <code>T = (i, j, k)</code> and another index <code>u</code>,  with indices referring to points in <code>pts</code>, computes  the position of <code>u</code> relative to the triangle.</p><p>Letting <code>p</code>, <code>q</code>, <code>a</code>, and <code>b</code> be the points referred to by  <code>i</code>, <code>j</code>, <code>k</code>, and <code>u</code>, respectively, we return:</p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul><p>If necessary, the mapping of boundary indices is handled via  the boundary map argument from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/index_and_ghost_handling.jl#L149-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, AbstractDict}" href="#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, AbstractDict}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(a, b, c, p)</code></pre><p>Given a positively oriented triangle with coordinates <code>(a, b, c)</code>, computes the  position of <code>p</code> relative to the triangle. In particular, returns: </p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/00ce68a26415d9fa813f8a5af182de5ffa7e2dc3/src/predicates/general.jl#L197-L206">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/example/">« Example</a><a class="docs-footer-nextpage" href="../operations/">Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 25 March 2023 14:33">Saturday 25 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
