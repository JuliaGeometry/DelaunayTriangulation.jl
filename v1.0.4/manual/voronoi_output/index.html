<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Voronoi Tessellation Output · DelaunayTriangulation.jl</title><meta name="title" content="Voronoi Tessellation Output · DelaunayTriangulation.jl"/><meta property="og:title" content="Voronoi Tessellation Output · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Voronoi Tessellation Output · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/voronoi_output/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/voronoi_output/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/voronoi_output/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../triangulation_output/">Triangulation Output</a></li><li class="is-active"><a class="tocitem" href>Voronoi Tessellation Output</a><ul class="internal"><li><a class="tocitem" href="#[get_triangulation(vorn)](@ref-get_triangulation)"><span><code>get_triangulation(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_generators(vorn)](@ref-get_generators)"><span><code>get_generators(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_polygon_points(vorn)](@ref-get_polygon_points)"><span><code>get_polygon_points(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_polygons(vorn)](@ref-get_polygons)"><span><code>get_polygons(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)"><span><code>get_circumcenter_to_triangle(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)"><span><code>get_triangle_to_circumcenter(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)"><span><code>get_unbounded_polygons(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)"><span><code>get_cocircular_circumcenters(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_adjacent(vorn)](@ref-get_adjacent)"><span><code>get_adjacent(vorn)</code></span></a></li><li><a class="tocitem" href="#[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)"><span><code>get_boundary_polygons(vorn)</code></span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Voronoi Tessellation Output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Voronoi Tessellation Output</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/manual/voronoi_output.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Voronoi-Tessellation-output"><a class="docs-heading-anchor" href="#Voronoi-Tessellation-output">Voronoi Tessellation output</a><a id="Voronoi-Tessellation-output-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi-Tessellation-output" title="Permalink"></a></h1><p>In this section, we discuss the output given from <a href="../../api/voronoi/#DelaunayTriangulation.voronoi"><code>voronoi</code></a>. We consider a simple clipped example for examining this output.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
using StableRNGs
rng = StableRNG(123)
p1 = (0.0, 1.0)
p2 = (3.0, -1.0)
p3 = (2.0, 0.0)
p4 = (-1.0, 2.0)
p5 = (4.0, 2.0)
p6 = (-2.0, -1.0)
p7 = (2.0, 1.0)
p8 = (5.0, 1.0)
points = [p1, p2, p3, p4, p5, p6, p7, p8]
tri = triangulate(points; rng)
vorn = voronoi(tri, clip = true, rng = rng)
vorn</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Voronoi Tessellation.
    Number of generators: 8
    Number of polygon vertices: 21
    Number of polygons: 8</code></pre><p>Now let&#39;s inspect <code>vorn</code>. The fields in <code>vorn</code> are:</p><pre><code class="language-julia hljs">propertynames(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:triangulation, :generators, :polygon_points, :polygons, :circumcenter_to_triangle, :triangle_to_circumcenter, :unbounded_polygons, :cocircular_circumcenters, :adjacent, :boundary_polygons)</code></pre><p>Let&#39;s examine this fields one at a time.</p><h2 id="[get_triangulation(vorn)](@ref-get_triangulation)"><a class="docs-heading-anchor" href="#[get_triangulation(vorn)](@ref-get_triangulation)"><a href="../../api/voronoi/#DelaunayTriangulation.get_triangulation"><code>get_triangulation(vorn)</code></a></a><a id="[get_triangulation(vorn)](@ref-get_triangulation)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_triangulation(vorn)](@ref-get_triangulation)" title="Permalink"></a></h2><p>This field stores the triangulation object used to generate the Voronoi tessellation.</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_triangulation(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Delaunay Triangulation.
   Number of vertices: 8
   Number of triangles: 9
   Number of edges: 16
   Has boundary nodes: false
   Has ghost triangles: true
   Curve-bounded: false
   Weighted: false
   Constrained: false</code></pre><h2 id="[get_generators(vorn)](@ref-get_generators)"><a class="docs-heading-anchor" href="#[get_generators(vorn)](@ref-get_generators)"><a href="../../api/voronoi/#DelaunayTriangulation.get_generators"><code>get_generators(vorn)</code></a></a><a id="[get_generators(vorn)](@ref-get_generators)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_generators(vorn)](@ref-get_generators)" title="Permalink"></a></h2><p>This field stores the generators of the Voronoi tessellation, i.e. the points associated with the polygons in the tessellation. These are simply the points in the triangulation, but are stored differently in case some points are not present in the triangulation.</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_generators(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Tuple{Float64, Float64}} with 8 entries:
  5 =&gt; (4.0, 2.0)
  4 =&gt; (-1.0, 2.0)
  6 =&gt; (-2.0, -1.0)
  7 =&gt; (2.0, 1.0)
  2 =&gt; (3.0, -1.0)
  8 =&gt; (5.0, 1.0)
  3 =&gt; (2.0, 0.0)
  1 =&gt; (0.0, 1.0)</code></pre><p>See that the generators are stored as a <code>Dict</code>, with the vertices mapping to their associated coordinates. The preferred way to access the generators is through <a href="../../api/voronoi/#DelaunayTriangulation.get_generator"><code>get_generator</code></a>, which can be used to obtain the coordinates for a given vertex. For example:</p><pre><code class="language-julia hljs">get_generator(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 1.0)</code></pre><pre><code class="language-julia hljs">get_generator(vorn, 2, 6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((3.0, -1.0), (-2.0, -1.0))</code></pre><p>If you want to iterate over each generator, you should use <a href="../../api/iterators/#DelaunayTriangulation.each_generator"><code>each_generator</code></a>, which simply returns an unordered iterator over the generators.</p><pre><code class="language-julia hljs">each_generator(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KeySet for a Dict{Int64, Tuple{Float64, Float64}} with 8 entries. Keys:
  5
  4
  6
  7
  2
  8
  3
  1</code></pre><p>You can get the number of generators using <a href="../../api/voronoi/#DelaunayTriangulation.num_generators"><code>num_generators</code></a>:</p><pre><code class="language-julia hljs">DelaunayTriangulation.num_generators(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><h2 id="[get_polygon_points(vorn)](@ref-get_polygon_points)"><a class="docs-heading-anchor" href="#[get_polygon_points(vorn)](@ref-get_polygon_points)"><a href="../../api/voronoi/#DelaunayTriangulation.get_polygon_points"><code>get_polygon_points(vorn)</code></a></a><a id="[get_polygon_points(vorn)](@ref-get_polygon_points)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_polygon_points(vorn)](@ref-get_polygon_points)" title="Permalink"></a></h2><p>This field is used for storing the coordinates of the Voronoi polygons:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_polygon_points(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21-element Vector{Tuple{Float64, Float64}}:
 (3.5, 0.5)
 (0.16666666666666666, -1.1666666666666665)
 (-1.5, 0.5)
 (1.0, 0.5)
 (0.5, -2.5)
 (1.0, 3.0)
 (1.5, 4.5)
 (4.0, 0.0)
 (4.5, 1.5)
 (5.0, 1.0)
 ⋮
 (2.0, -1.0)
 (3.0, -1.0)
 (-1.5, 0.5)
 (0.0, 2.0)
 (-1.0, 2.0)
 (1.0, 2.0)
 (0.0, -1.0)
 (-2.0, -1.0)
 (0.25, -1.0)</code></pre><p>These coordinates are used to define the vertices of these polygons. It is important to note that these points are not guaranteed to be unique if a circumcenter appears on the boundary, or if the tessellation is clipped. To access the coordinate of a polygon associated with a given polygon vertex, use <a href="../../api/voronoi/#DelaunayTriangulation.get_polygon_point"><code>get_polygon_point</code></a>:</p><pre><code class="language-julia hljs">get_polygon_point(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3.5, 0.5)</code></pre><p>If you wanted the total number of polygon vertices, possibly counting duplicate vertices, you can use <a href="../../api/voronoi/#DelaunayTriangulation.num_polygon_vertices"><code>num_polygon_vertices</code></a>:</p><pre><code class="language-julia hljs">num_polygon_vertices(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21</code></pre><h2 id="[get_polygons(vorn)](@ref-get_polygons)"><a class="docs-heading-anchor" href="#[get_polygons(vorn)](@ref-get_polygons)"><a href="../../api/voronoi/#DelaunayTriangulation.get_polygons"><code>get_polygons(vorn)</code></a></a><a id="[get_polygons(vorn)](@ref-get_polygons)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_polygons(vorn)](@ref-get_polygons)" title="Permalink"></a></h2><p>This field is used for mapping polygon indices to their vertices, with these vertices referring to coordinates from <code>get_polygon_points(vorn)</code>:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Vector{Int64}} with 8 entries:
  5 =&gt; [1, 9, 12, 11, 1]
  4 =&gt; [3, 16, 17, 3]
  6 =&gt; [20, 19, 3, 20]
  7 =&gt; [4, 1, 11, 18, 4]
  2 =&gt; [13, 14, 8, 1, 13]
  8 =&gt; [1, 8, 10, 9, 1]
  3 =&gt; [21, 13, 1, 4, 21]
  1 =&gt; [19, 21, 4, 18, 16, 3, 19]</code></pre><p>For example, using <a href="../../api/voronoi/#DelaunayTriangulation.get_polygon"><code>get_polygon</code></a> with the first polygon:</p><pre><code class="language-julia hljs">get_polygon(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Int64}:
 19
 21
  4
 18
 16
  3
 19</code></pre><p>means that the first polygon has vertices <code>[19, 21, 4, 18, 16, 3, 19]</code>. All polygons are stored as a circular vector of counter-clockwise oriented vertices. Note also that polygon indices are the same as the generator vertex, so that e.g. this polygon <code>1</code> is that associated with generator <code>1</code>.  You can get the number of polygons using <a href="../../api/voronoi/#DelaunayTriangulation.num_polygons"><code>num_polygons</code></a>:</p><pre><code class="language-julia hljs">num_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><p>Of course, this is the same as the number of generators. If you wanted to get the coordinates instead of the vertices associated with a polygon, you use <a href="../../api/voronoi/#DelaunayTriangulation.get_polygon_coordinates"><code>get_polygon_coordinates</code></a>:</p><pre><code class="language-julia hljs">get_polygon_coordinates(vorn, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Tuple{Float64, Float64}}:
 (0.0, -1.0)
 (0.25, -1.0)
 (1.0, 0.5)
 (1.0, 2.0)
 (0.0, 2.0)
 (-1.5, 0.5)
 (0.0, -1.0)</code></pre><p>This is almost the same result as doing</p><pre><code class="language-julia hljs">get_polygon_point.(Ref(vorn), get_polygon(vorn, 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Tuple{Float64, Float64}}:
 (0.0, -1.0)
 (0.25, -1.0)
 (1.0, 0.5)
 (1.0, 2.0)
 (0.0, 2.0)
 (-1.5, 0.5)
 (0.0, -1.0)</code></pre><p>but is more efficient.</p><p>When the tessellation is unbounded, this field is slightly different. Let&#39;s consider an example.</p><pre><code class="language-julia hljs">rng2 = StableRNG(321)
points2 = rand(rng2, 2, 10)
tri2 = triangulate(points2; rng = rng2)
vorn2 = voronoi(tri2, rng = rng2)
DelaunayTriangulation.get_polygons(vorn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Vector{Int64}} with 10 entries:
  5  =&gt; [12, 7, 10, -1, -3, 5, 12]
  4  =&gt; [8, 9, 3, 1, 4, 2, 8]
  6  =&gt; [5, 6, 8, 2, 12, 5]
  7  =&gt; [9, 13, -4, -5, 3, 9]
  2  =&gt; [8, 6, 13, 9, 8]
  10 =&gt; [10, 11, -2, -1, 10]
  9  =&gt; [-3, -4, 13, 6, 5, -3]
  8  =&gt; [7, 4, 1, 11, 10, 7]
  3  =&gt; [3, -5, -2, 11, 1, 3]
  1  =&gt; [12, 2, 4, 7, 12]</code></pre><p>Notice that some of these polygons have negative vertices. These vertices are not the same as ghost vertices from triangulations. They do still represent points out at infinity, but their numbering is of no importance - only the fact that they are negative is. All polygons that have a negative vertex are unbounded, and the negative vertex is the vertex that is out at infinity. When we try to get the coordinates of a polygon with a negative vertex, we get an error:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_polygon_coordinates(vorn2, 5)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: The polygon is unbounded, so a bounding box must be provided. See DelaunayTriangulation.polygon_bounds for a reasonable default.</code></pre><p>We need to provide a bounding box to obtain these coordinates. As mentioned, we can obtain a reasonable default for a bounding box using <a href="../../api/voronoi/#DelaunayTriangulation.polygon_bounds"><code>polygon_bounds</code></a>, which returns the bounding box in the form <code>(xmin, xmax, ymin, ymax)</code>:</p><pre><code class="language-julia hljs">bbox = polygon_bounds(vorn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-0.0845250117400761, 0.7292550055392539, -0.07703000058813853, 0.8087847404970718)</code></pre><p>If we now use this bounding box to get the coordinates of the polygon, we get a polygon that will have been clipped with this box:</p><pre><code class="language-julia hljs">get_polygon_coordinates(vorn2, 4, bbox)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Tuple{Float64, Float64}}:
 (0.3800182607228671, 0.4195812181251387)
 (0.5248526830200166, 0.30356339617239647)
 (0.7292550055392539, 0.41037087429841546)
 (0.7292550055392539, 0.41037087429841546)
 (0.6204044502699297, 0.543145666748361)
 (0.5062082223280505, 0.6112493082368492)
 (0.36237000338690506, 0.5169933977507611)
 (0.3800182607228671, 0.4195812181251387)</code></pre><p>For iterating over polygons, there are two main methods. If you only care about the vertices and not the index associated with a polygon, you can use <a href="../../api/iterators/#DelaunayTriangulation.each_polygon"><code>each_polygon</code></a>:</p><pre><code class="language-julia hljs">each_polygon(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ValueIterator for a Dict{Int64, Vector{Int64}} with 8 entries. Values:
  [1, 9, 12, 11, 1]
  [3, 16, 17, 3]
  [20, 19, 3, 20]
  [4, 1, 11, 18, 4]
  [13, 14, 8, 1, 13]
  [1, 8, 10, 9, 1]
  [21, 13, 1, 4, 21]
  [19, 21, 4, 18, 16, 3, 19]</code></pre><p>Alternatively, <a href="../../api/iterators/#DelaunayTriangulation.each_polygon_index"><code>each_polygon_index</code></a> can be used  to iterate over the index of each polygon (equivalently, over each generator vertex), followed by <code>get_polygon</code> to access the associated vertices of that polygon:</p><pre><code class="language-julia hljs">for v in each_polygon_index(vorn)
    println(v, &quot;: &quot;, get_polygon(vorn, v))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5: [1, 9, 12, 11, 1]
4: [3, 16, 17, 3]
6: [20, 19, 3, 20]
7: [4, 1, 11, 18, 4]
2: [13, 14, 8, 1, 13]
8: [1, 8, 10, 9, 1]
3: [21, 13, 1, 4, 21]
1: [19, 21, 4, 18, 16, 3, 19]</code></pre><h2 id="[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)"><a class="docs-heading-anchor" href="#[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)"><a href="../../api/voronoi/#DelaunayTriangulation.get_circumcenter_to_triangle"><code>get_circumcenter_to_triangle(vorn)</code></a></a><a id="[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_circumcenter_to_triangle(vorn)](@ref-get_circumcenter_to_triangle)" title="Permalink"></a></h2><p>When a Voronoi tessellation is constructed, the circumcenters of the triangles from the underlying Delaunay triangulation are used to define the polygon vertices. This field is used to associate a given polygon vertex with the triangle that it came from:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_circumcenter_to_triangle(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Tuple{Int64, Int64, Int64}} with 12 entries:
  5  =&gt; (3, 6, 2)
  7  =&gt; (7, 5, 4)
  -3 =&gt; (8, 2, -1)
  1  =&gt; (8, 5, 3)
  4  =&gt; (3, 7, 1)
  6  =&gt; (7, 4, 1)
  -5 =&gt; (5, 8, -1)
  -1 =&gt; (2, 6, -1)
  2  =&gt; (6, 3, 1)
  -2 =&gt; (6, 4, -1)
  -4 =&gt; (4, 5, -1)
  3  =&gt; (4, 6, 1)</code></pre><p>We see, for example, that the fifth polygon vertex is derived from the circumcenter of the triangle <code>(3, 6, 2)</code>. We can verify this:</p><pre><code class="language-julia hljs">p = DelaunayTriangulation.triangle_circumcenter(tri, (3, 6, 2))
q = get_polygon_point(vorn, 5)
p == q</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The negative vertices show what ghost triangle is being associated with an unbounded edge of the tessellation. Since we clipped our tessellation, these no longer appear in the previously mentioned fields, but they are still stored in this field; they are used in clipping for determining the direction of the unbounded edges. If you wanted the triangle associated with a specific vertex, you could use </p><pre><code class="language-julia hljs">DelaunayTriangulation.get_circumcenter_to_triangle(vorn, 5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3, 6, 2)</code></pre><h2 id="[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)"><a class="docs-heading-anchor" href="#[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)"><a href="../../api/voronoi/#DelaunayTriangulation.get_triangle_to_circumcenter"><code>get_triangle_to_circumcenter(vorn)</code></a></a><a id="[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_triangle_to_circumcenter(vorn)](@ref-get_triangle_to_circumcenter)" title="Permalink"></a></h2><p>This map is the inverse of <code>get_circumcenter_to_triangle(vorn)</code>, and is used to map a triangle to its circumcenter:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_triangle_to_circumcenter(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Tuple{Int64, Int64, Int64}, Int64} with 14 entries:
  (8, 5, 3)  =&gt; 1
  (2, 6, -1) =&gt; -1
  (6, 4, -1) =&gt; -2
  (3, 7, 1)  =&gt; 4
  (5, 8, -1) =&gt; -5
  (6, 3, 1)  =&gt; 2
  (4, 6, 1)  =&gt; 3
  (3, 6, 2)  =&gt; 5
  (7, 5, 4)  =&gt; 7
  (5, 7, 3)  =&gt; 1
  (8, 2, -1) =&gt; -3
  (4, 5, -1) =&gt; -4
  (8, 3, 2)  =&gt; 1
  (7, 4, 1)  =&gt; 6</code></pre><p>The triangles are stored so that the minimum vertex is always last, maintaining the counter-clockwise orientation of each. You can get the circumcenter index associated with a given triangle using:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_triangle_to_circumcenter(vorn, (3, 7, 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><h2 id="[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)"><a class="docs-heading-anchor" href="#[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)"><a href="../../api/voronoi/#DelaunayTriangulation.get_unbounded_polygons"><code>get_unbounded_polygons(vorn)</code></a></a><a id="[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_unbounded_polygons(vorn)](@ref-get_unbounded_polygons)" title="Permalink"></a></h2><p>This field is used to store the polygons that are unbounded. For our clipped tessellation, this field is empty:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_unbounded_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set{Int64}()</code></pre><p>For our unclipped tessellation, we have</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_unbounded_polygons(vorn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set{Int64} with 5 elements:
  5
  7
  10
  9
  3</code></pre><p>and we can verify that this is consistent with our observation that each unbounded polygon has a negative vertex:</p><pre><code class="language-julia hljs">S1 = DelaunayTriangulation.get_unbounded_polygons(vorn2)
S2 = Set{Int}()
for v in each_polygon_index(vorn2)
    C = get_polygon(vorn2, v)
    if any(&lt;(0), C)
        push!(S2, v)
    end
end
S1 == S2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)"><a class="docs-heading-anchor" href="#[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)"><a href="../../api/voronoi/#DelaunayTriangulation.get_cocircular_circumcenters"><code>get_cocircular_circumcenters(vorn)</code></a></a><a id="[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_cocircular_circumcenters(vorn)](@ref-get_cocircular_circumcenters)" title="Permalink"></a></h2><p>In cases where pairs of triangles are cocircular, meaning lie on the same circle, their circumcenter will be equal and thus the polygon vertex associated with these two triangles will be the same. This field will store the vertices of these circumcenters that came from cocircular triangles. For our case, there is a single entry:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_cocircular_circumcenters(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set{Int64} with 1 element:
  1</code></pre><p>This means that the first polygon vertex is associated with at least two cocircular triangles, and is why, for example, the values from <code>get_triangle_to_circumcenter(vorn)</code> are not unique:</p><pre><code class="language-julia hljs">t2c = DelaunayTriangulation.get_triangle_to_circumcenter(vorn)
allunique(values(t2c))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>and also explains why <code>get_circumcenter_to_triangle(vorn)</code> and <code>get_triangle_to_circumcenter(vorn)</code> are not perfect inverses of each other. The triangle mapped to from <code>5</code> inside the <code>circumcenter_to_triangle</code> map is simply the first one that the algorithm happened to encounter. To find the two cocircular triangles, we could use the <code>triangle_to_circumcenter</code> map:</p><pre><code class="language-julia hljs">triangles = NTuple{3,Int}[]
for (t, c) in t2c
    c == 1 &amp;&amp; push!(triangles, t)
end</code></pre><p>In fact, there are three triangles that all have the same circumcenter!</p><pre><code class="language-julia hljs">DelaunayTriangulation.triangle_circumcenter.(Ref(tri), triangles)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Tuple{Float64, Float64}}:
 (3.5, 0.5)
 (3.5, 0.5)
 (3.5, 0.5)</code></pre><h2 id="[get_adjacent(vorn)](@ref-get_adjacent)"><a class="docs-heading-anchor" href="#[get_adjacent(vorn)](@ref-get_adjacent)"><a href="../../api/triangulation/#DelaunayTriangulation.get_adjacent"><code>get_adjacent(vorn)</code></a></a><a id="[get_adjacent(vorn)](@ref-get_adjacent)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_adjacent(vorn)](@ref-get_adjacent)" title="Permalink"></a></h2><p>This map is similar to the <a href="../../extended/data_structures/#Adjacent"><code>Adjacent</code></a> map for triangulations:</p><pre><code class="language-julia hljs">get_adjacent(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Adjacent{Int64, Tuple{Int64, Int64}}, with map:
Dict{Tuple{Int64, Int64}, Int64} with 33 entries:
  (18, 16) =&gt; 1
  (11, 18) =&gt; 7
  (19, 21) =&gt; 1
  (19, 3)  =&gt; 6
  (14, 8)  =&gt; 2
  (1, 9)   =&gt; 5
  (4, 21)  =&gt; 3
  (16, 17) =&gt; 4
  (13, 14) =&gt; 2
  (21, 13) =&gt; 3
  (21, 4)  =&gt; 1
  (9, 1)   =&gt; 8
  (10, 9)  =&gt; 8
  (3, 19)  =&gt; 1
  (17, 3)  =&gt; 4
  (1, 4)   =&gt; 3
  (1, 13)  =&gt; 2
  (9, 12)  =&gt; 5
  (4, 1)   =&gt; 7
  ⋮        =&gt; ⋮</code></pre><p>In this case, oriented edges are being mapped to the polygon it belongs to. For example,</p><pre><code class="language-julia hljs">get_adjacent(vorn, 3, 19)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>means that the edge <code>(3, 19)</code> belongs to the first polygon; these vertices <code>3</code> and <code>19</code> refer to the vertices from the polygon, while the <code>1</code> from the output refers to a generator.</p><h2 id="[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)"><a class="docs-heading-anchor" href="#[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)"><a href="../../api/voronoi/#DelaunayTriangulation.get_boundary_polygons"><code>get_boundary_polygons(vorn)</code></a></a><a id="[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)-1"></a><a class="docs-heading-anchor-permalink" href="#[get_boundary_polygons(vorn)](@ref-get_boundary_polygons)" title="Permalink"></a></h2><p>This field is used to store the polygons that are on the boundary of the tessellation, and is only relevant for clipped tessellations. For our clipped tessellation, we have:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_boundary_polygons(vorn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set{Int64} with 8 elements:
  5
  4
  6
  7
  2
  8
  3
  1</code></pre><p>For our unclipped tessellation, the field is empty:</p><pre><code class="language-julia hljs">DelaunayTriangulation.get_boundary_polygons(vorn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set{Int64}()</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../triangulation_output/">« Triangulation Output</a><a class="docs-footer-nextpage" href="../../api/overview/">Section Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 1 July 2024 15:47">Monday 1 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
