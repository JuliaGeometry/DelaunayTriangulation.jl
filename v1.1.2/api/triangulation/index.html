<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Triangulations · DelaunayTriangulation.jl</title><meta name="title" content="Triangulations · DelaunayTriangulation.jl"/><meta property="og:title" content="Triangulations · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Triangulations · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/triangulation/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/triangulation/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/triangulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Triangulations</a></li><li><a class="tocitem" href="../operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li><li><a class="tocitem" href="../point_location/">Point Location</a></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li><a class="tocitem" href="../statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Triangulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Triangulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/api/triangulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Triangulations"><a class="docs-heading-anchor" href="#Triangulations">Triangulations</a><a id="Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate" href="#DelaunayTriangulation.triangulate"><code>DelaunayTriangulation.triangulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangulate(points; segments=nothing, boundary_nodes=nothing, kwargs...) -&gt; Triangulation</code></pre><p>Computes the Delaunay triangulation of <code>points</code>, and then the constrained Delaunay triangulation if any of <code>segments</code> and <code>boundary_nodes</code> are not <code>nothing</code>.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The points to triangulate. (This might get mutated for curve-bounded domains.)</li></ul><p><strong>Keyword Arguments</strong></p><p>For the keyword arguments below, you may like to review the extended help as some of the arguments carry certain warnings.</p><ul><li><code>segments=nothing</code>: The segments to include in the triangulation. If <code>nothing</code>, then no segments are included.</li><li><code>boundary_nodes=nothing</code>: The boundary nodes to include in the triangulation. If <code>nothing</code>, then no boundary nodes are included, and the convex hull of <code>points</code> remains as the triangulation. These boundary nodes   should match the specification given in <a href="#DelaunayTriangulation.check_args"><code>check_args</code></a> if a boundary is provided as a set of vertices, meaning the boundary is a piecewise linear curve. To specify a curve-bounded domain, you should   follow the same specification, but use <a href="../../math/curves/#AbstractParametricCurve"><code>AbstractParametricCurve</code></a>s to fill out the vector, and any piecewise linear section should still be provided as a sequence of vertices. </li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>weights=ZeroWeight()</code>: NOT CURRENTLY IMPLEMENTED. The weights to use for the triangulation. By default, the triangulation is unweighted. The weights can also be provided as a vector, with the <code>i</code>th weight referring to the <code>i</code>th vertex, or more generally any object that defines <a href="#DelaunayTriangulation.get_weight"><code>get_weight</code></a>. The weights should be <code>Float64</code>.</li><li><code>IntegerType=Int</code>: The integer type to use for the triangulation. This is used for representing vertices.</li><li><code>EdgeType=isnothing(segments) ? NTuple{2,IntegerType} : (edge_type ∘ typeof)(segments)</code>: The edge type to use for the triangulation. </li><li><code>TriangleType=NTuple{3,IntegerType}</code>: The triangle type to use for the triangulation.</li><li><code>EdgesType=isnothing(segments) ? Set{EdgeType} : typeof(segments)</code>: The type to use for storing the edges of the triangulation.</li><li><code>TrianglesType=Set{TriangleType}</code>: The type to use for storing the triangles of the triangulation.</li><li><code>randomise=true</code>: Whether to randomise the order in which the points are inserted into the triangulation. This is done using <a href="#DelaunayTriangulation.get_insertion_order"><code>get_insertion_order</code></a>.</li><li><code>delete_ghosts=false</code>: Whether to delete the ghost triangles after the triangulation is computed. This is done using <a href="../operations/#DelaunayTriangulation.delete_ghost_triangles!"><code>delete_ghost_triangles!</code></a>.</li><li><code>delete_empty_features=true</code>: Whether to delete empty features after the triangulation is computed. This is done using <a href="../operations/#DelaunayTriangulation.clear_empty_features!"><code>clear_empty_features!</code></a>.</li><li><code>try_last_inserted_point=true</code>: Whether to try the last inserted point first when inserting points into the triangulation. </li><li><code>skip_points=()</code>: The points to skip when inserting points into the triangulation.   Note that, for curve-bounded domains, <code>skip_points</code> is ignored when using <a href="../../extended/algorithms/#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}"><code>enrich_boundary!</code></a>.</li><li><code>num_sample_rule=default_num_samples</code>: A function mapping a number of points <code>n</code> to a number of samples <code>m</code> to use for sampling the initial points during the point location step of the algorithm within <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>.</li><li><code>rng::Random.AbstractRNG=Random.default_rng()</code>: The random number generator.</li><li><code>insertion_order::Vector=get_insertion_order(points, randomise, skip_points, IntegerType, rng)</code>: The insertion order to use for inserting points into the triangulation. This is ignored if you are defining a curve-bounded domain.</li><li><code>recompute_representative_points=true</code>: Whether to recompute the representative points after the triangulation is computed. This is done using <a href="#DelaunayTriangulation.compute_representative_points!"><code>compute_representative_points!</code></a>. </li><li><code>delete_holes=true</code>: Whether to delete holes after the triangulation is computed. This is done using <a href="../operations/#DelaunayTriangulation.delete_holes!"><code>delete_holes!</code></a>.</li><li><code>check_arguments=true</code>: Whether to check the arguments <code>points</code> and <code>boundary_nodes</code> are valid. This is done using <a href="#DelaunayTriangulation.check_args"><code>check_args</code></a>.</li><li><code>polygonise_n=4096</code>: Number of points to use for polygonising the boundary when considering the poylgon hierarchy for a curve-bounded domain using <a href="../../extended/data_structures/#DelaunayTriangulation.polygonise-Tuple{Any, Any, Any}"><code>polygonise</code></a>. See <a href="../../extended/algorithms/#DelaunayTriangulation.triangulate_curve_bounded-Union{Tuple{I}, Tuple{P}} where {P, I}"><code>triangulate_curve_bounded</code></a>.</li><li><code>coarse_n=0</code>: Number of points to use for initialising a curve-bounded domain. See <a href="../../extended/algorithms/#DelaunayTriangulation.triangulate_curve_bounded-Union{Tuple{I}, Tuple{P}} where {P, I}"><code>triangulate_curve_bounded</code></a>. (A value of <code>0</code> means the number of points is chosen automatically until the diametral circles of all edges are empty.)</li></ul><p><strong>Outputs</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation.</li></ul><div class="admonition is-info"><header class="admonition-header">Type stability</header><div class="admonition-body"><p>The output from this function is currently not type stable. In particular, the inferred type is only <code>Triangulation</code> without any other information. If you are depending on the output from <code>triangulate</code> inside some other function, you should consider putting the output behind a function barrier; information about using function barriers is given <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">here</a>.</p></div></div><p><strong>Extended help</strong></p><p>Here are some warnings to consider for some of the arguments.</p><ul><li><code>points</code></li></ul><div class="admonition is-warning"><header class="admonition-header">Mutation</header><div class="admonition-body"><p>For curve-bounded domains, <code>points</code> may get mutated to include the endpoints of the provided curves, and when inserting  Steiner points to split segments or refine boundaries.</p></div></div><div class="admonition is-danger"><header class="admonition-header">Floating point precision</header><div class="admonition-body"><p>If your points are defined using non-<code>Float64</code> coordinates, you may run into precision issues that  lead to problems with robustness. The consequences of this could be potentially catastrophic, leading to  infinite loops for example. If you do encounter such issues, consider converting your coordinates to <code>Float64</code>.</p></div></div><ul><li><code>segments</code></li></ul><div class="admonition is-warning"><header class="admonition-header">Segments outside of the domain</header><div class="admonition-body"><p>When segments are outside of the domain, are if they are not entirely contained with the domain, you may run into issues - especially for curve-bounded domains. It is your responsibility to ensure that the segments are contained within the domain.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Mutation</header><div class="admonition-body"><p>The <code>segments</code> may get mutated in two ways: (1) Segments may get rotated so that <code>(i, j)</code> becomes <code>(j, i)</code>. (2) If there are segments that are collinear with other segments, then they may get split into chain of non-overlapping connecting segments (also see below). For  curve-bounded domains, segments are also split so that no subsegment&#39;s diametral circle contains any other point.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Intersecting segments</header><div class="admonition-body"><p>Currently, segments that intersect in their interiors (this excludes segments that only intersect by sharing a vertex) cause problems for triangulating. While there  is some support for collinear segments that lie on top of each other (they get split automatically), this is not the case for segments that intersect in their interiors. Moreover, this automatic splitting should not be heavily relied upon, and for curve-bounded domains you should not rely on it at all as it causes problems during the enrichment phase from <a href="../../extended/algorithms/#DelaunayTriangulation.enrich_boundary!-Tuple{DelaunayTriangulation.BoundaryEnricher}"><code>enrich_boundary!</code></a>.</p></div></div><ul><li><code>boundary_nodes</code></li></ul><div class="admonition is-warning"><header class="admonition-header">Points outside of boundary curves</header><div class="admonition-body"><p>While for standard domains with piecewise linear boundaries (or no boundaries) it is fine for points to be  outside of the domain (they just get automatically deleted if needed), they may cause problems for curve-bounded domains. Please ensure that all your points are inside the curve-bounded domain if you are providing curves in <code>boundary_nodes</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Aliasing</header><div class="admonition-body"><p>For curve-bounded domains, the <code>boundary_nodes</code> in the resulting <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> will not be aliased with the input boundary nodes.</p></div></div><div class="admonition is-info"><header class="admonition-header">Refinement</header><div class="admonition-body"><p>For curve-bounded domains, note that the triangulation produced from this function is really just an initial coarse discretisation of the true curved boundaries. You will need to  refine further, via <a href="#DelaunayTriangulation.refine!"><code>refine!</code></a>, to improve the discretisation, or increase <code>coarse_n</code> below. See also <a href="../../extended/data_structures/#DelaunayTriangulation.polygonise-Tuple{Any, Any, Any}"><code>polygonise</code></a> for a more direct approach to discretising a boundary (which  might not give as high-quality meshes as you can obtain from <a href="#DelaunayTriangulation.refine!"><code>refine!</code></a> though, note).</p></div></div><ul><li><code>weights</code></li></ul><div class="admonition is-danger"><header class="admonition-header">Weighted triangulations</header><div class="admonition-body"><p>Weighted triangulations are not yet fully implemented due to certain bugs with the implementation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/main.jl#L17-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_convex" href="#DelaunayTriangulation.triangulate_convex"><code>DelaunayTriangulation.triangulate_convex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangulate_convex(points, S; delete_ghosts=false, delete_empty_features=true, rng=Random.default_rng(), predicates::AbstractPredicateKernel=AdaptiveKernel(), kwargs...) -&gt; Triangulation</code></pre><p>Triangulates the convex polygon <code>S</code>.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The point set corresponding to the vertices in <code>S</code>.</li><li><code>S</code>: A convex polygon represented as a vector of vertices. The vertices should be given in counter-clockwise order, and must not be circular so that <code>S[begin] ≠ S[end]</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>delete_ghosts=false</code>: If <code>true</code>, the ghost triangles are deleted after triangulation. </li><li><code>delete_empty_features=true</code>: If <code>true</code>, the empty features are deleted after triangulation.</li><li><code>rng=Random.default_rng()</code>: The random number generator used to shuffle the vertices of <code>S</code> before triangulation.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>Triangulation</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Weighted triangulations</header><div class="admonition-body"><p>While weighted triangulations are not yet supported from <code>triangulate</code> directly, they are supported through this <code>triangulate_convex</code>. In particular, you can use the <code>weights</code> keyword argument to pass the weights of the vertices in <code>points</code>.</p></div></div><p><strong>Output</strong></p><ul><li><code>tri::Triangulation</code>: The triangulated polygon. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/triangulate_convex.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangulate_rectangle" href="#DelaunayTriangulation.triangulate_rectangle"><code>DelaunayTriangulation.triangulate_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangulate_rectangle(a, b, c, d, nx, ny; kwargs...) -&gt; Triangulation</code></pre><p>Triangulates the rectangle <code>[a, b] × [c, d]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The minimum <code>x</code>-coordinate. </li><li><code>b</code>: The maximum <code>x</code>-coordinate.</li><li><code>c</code>: The minimum <code>y</code>-coordinate.</li><li><code>d</code>: The maximum <code>y</code>-coordinate.</li><li><code>nx</code>: The number of points in the <code>x</code>-direction.</li><li><code>ny</code>: The number of points in the <code>y</code>-direction.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>single_boundary=false</code>: If <code>true</code>, then the boundary nodes are stored as a contiguous section. Otherwise, the boundary is split into four sections, in the order   bottom, right, top, left.</li><li><code>delete_ghosts=false</code>: If <code>true</code>, then the ghost triangles are deleted. Otherwise, they are kept.</li><li><code>IntegerType::Type{I}=Int</code>: The type of the vertices. </li><li><code>EdgeType::Type{E}=NTuple{2,IntegerType}</code>: The type of the edges.</li><li><code>TriangleType::Type{V}=NTuple{3,IntegerType}</code>: The type of the triangles.</li><li><code>EdgesType::Type{Es}=Set{EdgeType}</code>: The type of the edges container.</li><li><code>TrianglesType::Type{Ts}=Set{TriangleType}</code>: The type of the triangles container.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Outputs</strong></p><ul><li><code>tri</code>: The triangulation of the rectangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/triangulate_rectangle.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.refine!" href="#DelaunayTriangulation.refine!"><code>DelaunayTriangulation.refine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine!(tri::Triangulation; kwargs...)</code></pre><p>Refines the given <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> <code>tri</code> to meet the given quality constraints.</p><p>See the documentation for more information about mesh refinement, e.g. convergence issues and issues with small input-angles.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> to refine.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>min_angle=30.0</code>: The minimum angle constraint, in degrees.</li><li><code>max_angle=180.0</code>: The maximum angle constraint, in degrees. </li></ul><div class="admonition is-danger"><header class="admonition-header">Maximum angle constraints</header><div class="admonition-body"><p>Maximum angle constraints are not currently implemented.</p></div></div><ul><li><code>min_area=get_area(tri) / 1e9</code>: The minimum area constraint.</li><li><code>max_area=typemax(number_type(tri))</code>: The maximum area constraint.</li><li><code>max_points=max(1_000, num_solid_vertices(tri))^2</code>: The maximum number of vertices allowed in the triangulation. Note that this refers to <a href="../iterators/#DelaunayTriangulation.num_solid_vertices"><code>num_solid_vertices</code></a>, not the amount returned by <a href="#DelaunayTriangulation.num_points"><code>num_points</code></a>.</li><li><code>seditious_angle=20.0</code>: The angle at which a triangle is considered seditious, in degrees. See <a href="../../extended/algorithms/#DelaunayTriangulation.is_triangle_seditious-Tuple{Triangulation, Vararg{Any, 5}}"><code>is_triangle_seditious</code></a>.</li><li><code>custom_constraint=(tri, T) -&gt; false</code>: A custom constraint function that takes a <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> and a triangle, and returns <code>true</code> if the triangle should be refined and <code>false</code> otherwise.</li><li><code>use_circumcenter=true</code>: Whether to insert circumcenters for refining a triangle or generalised Steiner points.</li></ul><div class="admonition is-danger"><header class="admonition-header">Generalised Steiner points</header><div class="admonition-body"><p>Generalised Steiner points are not yet implemented. Thus, this argument must be <code>true</code> (and the <code>steiner_scale</code> keyword below is ignored).</p></div></div><ul><li><code>use_lens=true</code>: Whether to use the diametral lens or the diametral circle for checking encroachment.</li><li><code>steiner_scale=0.999</code>: The perturbation factor to use for generalised Steiner points if <code>use_circumcenter=false</code>. (Not currently used - see above.)</li><li><code>rng=Random.default_rng()</code>: The random number generator to use in case it is needed during point location.</li><li><code>concavity_protection=false</code>: Whether to use concavity protection or not for <a href="../point_location/#DelaunayTriangulation.find_triangle"><code>find_triangle</code></a>. Most likely not needed, but may help in pathological cases.</li><li><code>predicates::AbstractPredicateKernel=AdaptiveKernel()</code>: Method to use for computing predicates. Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>. See the documentation for a further discussion of these methods.</li></ul><p><strong>Output</strong></p><p>The triangulation is refined in-place.</p><div class="admonition is-warning"><header class="admonition-header">Duplicate points and unused points</header><div class="admonition-body"><p>During refinement, points are often deleted, which may often lead to points in <code>get_points(tri)</code> that do not  appear anywhere in the triangulation. (This is why we recommend e.g. <a href="../iterators/#DelaunayTriangulation.each_solid_vertex"><code>each_solid_vertex</code></a> over <a href="../iterators/#DelaunayTriangulation.each_point"><code>each_point</code></a>.) Similarly, since points are deleted, when two triangles have a common circumcenter it might happen (if they are near an input segment) that a point is duplicated inside <code>get_points(tri)</code>, in case one circumcenter was deleted previously.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/mesh_refinement.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.retriangulate" href="#DelaunayTriangulation.retriangulate"><code>DelaunayTriangulation.retriangulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retriangulate(tri::Triangulation, points=get_points(tri); kwargs...)</code></pre><p>Retriangulates the triangulation <code>tri</code> using the points <code>points</code>, returning a new <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>. </p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation to retriangulate.</li><li><code>points=get_points(tri)</code>: The points to use for retriangulating the triangulation. By default, this is simply <code>get_points(tri)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>skip_points=Set(filter(i -&gt; !has_vertex(tri, i), each_point_index(tri)))</code>: The points to skip when inserting points into the triangulation.</li><li><code>kwargs...</code>: Extra keyword arguments passed to <code>triangulate</code>. Other keyword arguments, like <code>segments</code> and <code>boundary_nodes</code>,   are automatically passed from the fields of <code>tri</code>, but may be overridden by passing the corresponding keyword arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/main.jl#L191-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.convert_boundary_points_to_indices" href="#DelaunayTriangulation.convert_boundary_points_to_indices"><code>DelaunayTriangulation.convert_boundary_points_to_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_boundary_points_to_indices(x, y; existing_points = NTuple{2, Float64}[], check_args=true) -&gt; (Vector, Vector)
convert_boundary_points_to_indices(xy; existing_points = NTuple{2, Float64}[], check_args=true) -&gt; (Vector, Vector)</code></pre><p>Converts a boundary represented by <code>(x, y)</code> or <code>xy</code>, where the points are combined rather than as separate sets of coordinates,  into a set of boundary nodes for use in <a href="#DelaunayTriangulation.triangulate"><code>triangulate</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>, <code>y</code>: The <code>x</code> and <code>y</code>-coordinates for the boundary points. The individual vectors must match the specification required for boundaries outlined in the documentation.</li><li><code>xy</code>: As above, except the coordinates are combined rather than given as separate vectors. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>existing_points</code>: The existing points to append the boundary points to. This is useful if you have a pre-existing set of points.</li><li><code>check_args</code>: Whether to check that the arguments match the specification in the documentation. </li></ul><p><strong>Outputs</strong></p><ul><li><code>boundary_nodes</code>: The boundary nodes. </li><li><code>points</code>: The point set, which is the same as <code>existing_points</code> but with the boundary points appended to it. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/constrained_triangulation.jl#L204-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.check_args" href="#DelaunayTriangulation.check_args"><code>DelaunayTriangulation.check_args</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_args(points, boundary_nodes, hierarchy::PolygonHierarchy, boundary_curves = ()) -&gt; Bool</code></pre><p>Check that the arguments <code>points</code> and <code>boundary_nodes</code> to <a href="#DelaunayTriangulation.triangulate"><code>triangulate</code></a>, and a constructed  <a href="../../extended/data_structures/#PolygonHierarchy"><code>PolygonHierarchy</code></a> given by <code>hierarchy</code>, are valid. In particular, the function checks:</p><ul><li>The points are all unique. If they are not, a <code>DuplicatePointsError</code> is thrown.</li><li>There are at least three points. If there are not, an <code>InsufficientPointsError</code> is thrown.</li></ul><p>If <code>boundary_nodes</code> are provided, meaning <a href="../predicates/#DelaunayTriangulation.has_boundary_nodes"><code>has_boundary_nodes</code></a>, then the function also checks:</p><ul><li>If the boundary curves all connect consistently. Here, this means that each section of a boundary curve ends at the start of the next boundary section;  for contiguous boundary curves, this means that the start and end boundary nodes are the same.</li><li>If the orientation of the boundary curves are all consistent. This means that the curves are all positively oriented relative to the domain,  so that e.g. the exterior boundary curves are all counter-clockwise (relative to just themselves), the next exterior-most curves inside those   exteriors are all clockwise (again, relative to just themselves), and so on.</li></ul><div class="admonition is-danger"><header class="admonition-header">Intersecting boundaries</header><div class="admonition-body"><p>Another requirement for <a href="#DelaunayTriangulation.triangulate"><code>triangulate</code></a> is that none of the boundaries intersect in their interior, which also prohibits  interior self-intersections. This is NOT checked. Similarly, segments should not intersect in their interior, which is not checked.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/check_args.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_points" href="#DelaunayTriangulation.get_points"><code>DelaunayTriangulation.get_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_points(convex_hull::ConvexHull) -&gt; Points</code></pre><p>Returns the underlying point set of <code>convex_hull</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/convex_hull.jl#L35-L39">source</a></section><section><div><pre><code class="language-julia hljs">get_points(tri::Triangulation) -&gt; Points</code></pre><p>Return the points of the triangulation. Note that this may include points not yet in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L150-L154">source</a></section><section><div><pre><code class="language-julia hljs">get_points(boundary_enricher::BoundaryEnricher{P}) -&gt; P</code></pre><p>Returns the point set associated with <code>boundary_enricher</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/mesh_refinement/boundary_enricher.jl#L430-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_triangles" href="#DelaunayTriangulation.get_triangles"><code>DelaunayTriangulation.get_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_triangles(tri::Triangulation) -&gt; Triangles</code></pre><p>Return the triangles of the triangulation. These triangles are all given in counter-clockwise order,  and may include ghost triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_nodes" href="#DelaunayTriangulation.get_boundary_nodes"><code>DelaunayTriangulation.get_boundary_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_boundary_nodes(boundary_nodes, mnℓ...)</code></pre><p>Given a collection of <code>boundary_nodes</code>, returns the specified component of the collection. There are several forms for the methods:</p><ol><li><code>get_boundary_nodes(boundary_nodes, m)</code>: If <code>boundary_nodes</code> has multiple curves, this returns the <code>m</code>th curve. If <code>boundary_nodes</code> has multiple sections, this returns the <code>m</code>th section. Otherwise, this returns the <code>m</code>th boundary node.</li><li><code>get_boundary_nodes(boundary_nodes, m, n)</code>: If <code>boundary_nodes</code> has multiple curves, this returns the <code>n</code>th section of the <code>m</code>th curve. Otherwise, if <code>boundary_nodes</code> has multiple sections, this returns the <code>n</code>th boundary node of the <code>m</code>th section.</li><li><code>get_boundary_nodes(boundary_nodes, (m, n))</code>: This is equivalent to <code>get_boundary_nodes(boundary_nodes, m, n)</code>.</li><li><code>get_boundary_nodes(boundary_nodes::A, ::A)</code>: This just returns <code>boundary_nodes</code>.  </li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 2)
2-element Vector{Vector{Int64}}:
 [6, 7, 8, 9]
 [9, 10, 6]

julia&gt; get_boundary_nodes([[1, 2, 3, 4], [4, 5, 1]], 1)
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; get_boundary_nodes([1, 2, 3, 4, 5, 6, 1], 4)
4

julia&gt; get_boundary_nodes([[[1, 2, 3, 4], [4, 5, 1]], [[6, 7, 8, 9], [9, 10, 6]]], 1, 2)
3-element Vector{Int64}:
 4
 5
 1

julia&gt; get_boundary_nodes([[1, 2, 3, 4], [4, 5, 6, 1]], 2, 3)
6

julia&gt; get_boundary_nodes([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 5, 1])
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/boundary_nodes.jl#L144-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_interior_segments" href="#DelaunayTriangulation.get_interior_segments"><code>DelaunayTriangulation.get_interior_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_interior_segments(tri::Triangulation) -&gt; Edges</code></pre><p>Return the interior segments of the triangulation. These are segments that are forced to be in the triangulation -  they are not the same as edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L174-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_all_segments" href="#DelaunayTriangulation.get_all_segments"><code>DelaunayTriangulation.get_all_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_all_segments(tri::Triangulation) -&gt; Edges</code></pre><p>Return all segments of the triangulation. This includes interior segments and boundary segments. Segments are  edges that are forced to be in the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_weights" href="#DelaunayTriangulation.get_weights"><code>DelaunayTriangulation.get_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_weights(tri::Triangulation) -&gt; Weights</code></pre><p>Return the weights of the triangulation. These are the weights of the vertices of the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent" href="#DelaunayTriangulation.get_adjacent"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(adj::Adjacent) -&gt; Dict</code></pre><p>Returns the <code>adjacent</code> map of <code>adj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; d = Dict((1, 2) =&gt; 3, (2, 3) =&gt; 1, (3, 1) =&gt; 2);

julia&gt; adj = DelaunayTriangulation.Adjacent(d)
Adjacent{Int64, Tuple{Int64, Int64}}, with map:
Dict{Tuple{Int64, Int64}, Int64} with 3 entries:
  (1, 2) =&gt; 3
  (3, 1) =&gt; 2
  (2, 3) =&gt; 1

julia&gt; get_adjacent(adj)
Dict{Tuple{Int64, Int64}, Int64} with 3 entries:
  (1, 2) =&gt; 3
  (3, 1) =&gt; 2
  (2, 3) =&gt; 1

julia&gt; get_adjacent(adj) == d
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/adjacent.jl#L26-L53">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(adj::Adjacent{I, E}, uv::E) -&gt; Vertex
get_adjacent(adj::Adjacent{I, E}, u, v) -&gt; Vertex</code></pre><p>Returns the vertex <code>w</code> such that <code>(u, v, w)</code> is a positively oriented triangle in the underlying triangulation, or <code>∅</code> if no such triangle exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; adj = DelaunayTriangulation.Adjacent(Dict((1, 2) =&gt; 3, (2, 3) =&gt; 1, (3, 1) =&gt; 2, (4, 5) =&gt; -1))
Adjacent{Int64, Tuple{Int64, Int64}}, with map:
Dict{Tuple{Int64, Int64}, Int64} with 4 entries:
  (4, 5) =&gt; -1
  (1, 2) =&gt; 3
  (3, 1) =&gt; 2
  (2, 3) =&gt; 1

julia&gt; get_adjacent(adj, 4, 5)
-1

julia&gt; get_adjacent(adj, (3, 1))
2

julia&gt; get_adjacent(adj, (1, 2))
3

julia&gt; get_adjacent(adj, 17, 5)
0

julia&gt; get_adjacent(adj, (1, 6))
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/adjacent.jl#L57-L91">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(tri::Triangulation) -&gt; Adjacent</code></pre><p>Returns the adjacency map of the triangulation. This is a map from each edge <code>(u, v)</code> to a vertex <code>w</code> such that <code>(u, v, w)</code>  is a positively oriented triangle in <code>tri</code>. </p><p>See also <a href="../../extended/data_structures/#Adjacent"><code>Adjacent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L197-L204">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(tri::Triangulation, uv) -&gt; Vertex
get_adjacent(tri::Triangulation, u, v) -&gt; Vertex</code></pre><p>Returns the vertex <code>w</code> such that <code>(u, v, w)</code> is a positively oriented triangle in the underlying triangulation, or <code>∅</code> if no such triangle exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/adjacent.jl#L1-L7">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(vorn::VoronoiTessellation) -&gt; Adjacent{Index,Edge}</code></pre><p>Gets the adjacency information of the Voronoi tessellation <code>vorn</code> as an <code>Adjacent</code> object. This object maps oriented edges  to the polygons that they belong to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/voronoi.jl#L110-L115">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent(vor::VoronoiTessellation, ij) -&gt; Index 
get_adjacent(vor::VoronoiTessellation, i, j) -&gt; Index</code></pre><p>Gets the polygon index associated with the oriented edge <code>ij</code> in the Voronoi tessellation <code>vor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/voronoi.jl#L315-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent2vertex" href="#DelaunayTriangulation.get_adjacent2vertex"><code>DelaunayTriangulation.get_adjacent2vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(adj2v::Adjacent2Vertex) -&gt; Dict</code></pre><p>Returns the <code>adjacent2vertex</code> map of <code>adj2v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; e1 = Set(((1, 2), (5, 3), (7, 8)));

julia&gt; e2 = Set(((2, 3), (13, 5), (-1, 7)));

julia&gt; d = Dict(9 =&gt; e1, 6 =&gt; e2);

julia&gt; adj2v = DelaunayTriangulation.Adjacent2Vertex(d)
Adjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:
Dict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:
  6 =&gt; Set([(13, 5), (-1, 7), (2, 3)])
  9 =&gt; Set([(1, 2), (7, 8), (5, 3)])

julia&gt; get_adjacent2vertex(adj2v)
Dict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:
  6 =&gt; Set([(13, 5), (-1, 7), (2, 3)])
  9 =&gt; Set([(1, 2), (7, 8), (5, 3)])

julia&gt; get_adjacent2vertex(adj2v) == d
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/adjacent2vertex.jl#L27-L56">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(adj2v::Adjacent2Vertex, w) -&gt; Edges</code></pre><p>Returns the set of edges <code>E</code> such that <code>(u, v, w)</code> is a positively oriented triangle in the underlying triangulation for each <code>(u, v) ∈ E</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; adj2v = DelaunayTriangulation.Adjacent2Vertex(Dict(1 =&gt; Set(((2, 3), (5, 7), (8, 9))), 5 =&gt; Set(((1, 2), (7, 9), (8, 3)))))
Adjacent2Vertex{Int64, Set{Tuple{Int64, Int64}}} with map:
Dict{Int64, Set{Tuple{Int64, Int64}}} with 2 entries:
  5 =&gt; Set([(1, 2), (8, 3), (7, 9)])
  1 =&gt; Set([(8, 9), (5, 7), (2, 3)])

julia&gt; get_adjacent2vertex(adj2v, 1)
Set{Tuple{Int64, Int64}} with 3 elements:
  (8, 9)
  (5, 7)
  (2, 3)

julia&gt; get_adjacent2vertex(adj2v, 5)
Set{Tuple{Int64, Int64}} with 3 elements:
  (1, 2)
  (8, 3)
  (7, 9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/adjacent2vertex.jl#L59-L87">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(tri::Triangulation) -&gt; Adjacent2Vertex</code></pre><p>Returns the <a href="../../extended/data_structures/#Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map of the triangulation <code>tri</code>. This is a map from a vertex <code>w</code> to a set of  all edges <code>(u, v)</code> such that <code>(u, v, w)</code> is a positively oriented triangle in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L207-L212">source</a></section><section><div><pre><code class="language-julia hljs">get_adjacent2vertex(tri::Triangulation, w) -&gt; Edges</code></pre><p>Returns the set of all edges <code>(u, v)</code> in <code>tri</code> such that <code>(u, v, w)</code> is a positively oriented triangle in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/adjacent2vertex.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_graph" href="#DelaunayTriangulation.get_graph"><code>DelaunayTriangulation.get_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_graph(tri::Triangulation) -&gt; Graph</code></pre><p>Returns the <a href="../../extended/data_structures/#Graph"><code>Graph</code></a> of the triangulation <code>tri</code>. This is an undirected graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_neighbours" href="#DelaunayTriangulation.get_neighbours"><code>DelaunayTriangulation.get_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_neighbours(graph::Graph) -&gt; Dict{Vertex, Set{Vertex}}</code></pre><p>Returns the <code>neighbours</code> map of <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L71-L75">source</a></section><section><div><pre><code class="language-julia hljs">get_neighbours(G::Graph, u) -&gt; Set{Vertex}</code></pre><p>Returns the set of neighbours of <code>u</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L78-L82">source</a></section><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation) -&gt; Dict{Vertex, Set{Vertex}}</code></pre><p>Returns the <code>neighbours</code> map of <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours and vertices will be ghost vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L22-L27">source</a></section><section><div><pre><code class="language-julia hljs">get_neighbours(tri::Triangulation, u) -&gt; Set{Vertex}</code></pre><p>Returns the set of neighbours of <code>u</code> in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours and vertices will be ghost vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_curves" href="#DelaunayTriangulation.get_boundary_curves"><code>DelaunayTriangulation.get_boundary_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_boundary_curves(tri::Triangulation) -&gt; NTuple{N, Function}</code></pre><p>Returns the functions defining the boundaries of <code>tri</code>. If <code>!is_curve_bounded(tri)</code>,  then this returns an empty <code>Tuple</code>. Otherwise, this returns a <code>Tuple</code> of functions, one for each section of the boundary,  where the <code>i</code>th element of the <code>Tuple</code> corresponds to the <code>i</code>th section of the boundary, which corresponds to the ghost vertex <code>-i</code>. For curves that are defined by boundary nodes rather than by a function, the function is <a href="../../extended/data_structures/#DelaunayTriangulation.PiecewiseLinear"><code>PiecewiseLinear</code></a>. For the other functions, these  are all defined by <code>t -&gt; NTuple{2, Number}</code>, where <code>t ∈ [0, 1]</code> and the <code>NTuple{2, Number}</code> is the coordinate on the curve at that <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L222-L230">source</a></section><section><div><pre><code class="language-julia hljs">get_boundary_curves(boundary_enricher::BoundaryEnricher{P,B,C}) -&gt; C</code></pre><p>Returns the boundary curves associated with <code>boundary_enricher</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/mesh_refinement/boundary_enricher.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_edge_map" href="#DelaunayTriangulation.get_boundary_edge_map"><code>DelaunayTriangulation.get_boundary_edge_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_boundary_edge_map(tri::Triangulation) -&gt; Dict</code></pre><p>Returns the boundary edge map of the triangulation <code>tri</code>. This is a <code>Dict</code> that maps  a boundary edge <code>(u, v)</code> to its position in <code>get_boundary_nodes(tri)</code>. In particular,  the returned value is a <code>Tuple</code> <code>(position, index)</code> so that <code>boundary_nodes = get_boundary_nodes(tri, position)</code> are the boundary nodes associated  with the section that <code>(u, v)</code> resides on, and <code>u = get_boundary_nodes(boundary_nodes, index)</code> and  <code>v = get_boundary_nodes(boundary_nodes, index + 1)</code>.</p><p>See also <a href="../../extended/data_structures/#DelaunayTriangulation.construct_boundary_edge_map-Union{Tuple{E}, Tuple{I}, Tuple{A}, Tuple{A, Type{I}}, Tuple{A, Type{I}, Type{E}}} where {A, I, E}"><code>construct_boundary_edge_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L233-L243">source</a></section><section><div><pre><code class="language-julia hljs">get_boundary_edge_map(boundary_enricher::BoundaryEnricher{P,B,C,I,BM}) -&gt; BM</code></pre><p>Returns the boundary edge map associated with <code>boundary_enricher</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/mesh_refinement/boundary_enricher.jl#L517-L521">source</a></section><section><div><pre><code class="language-julia hljs">get_boundary_edge_map(boundary_enricher::BoundaryEnricher, i, j)</code></pre><p>Returns the value from the key <code>(i, j)</code> in the boundary edge map of <code>boundary_enricher</code>. The returned value is a <code>Tuple</code>  <code>(position, index)</code> so that <code>boundary_nodes = get_boundary_nodes(get_boundary_nodes(boundary_enricher), position)</code> are the boundary nodes associated  with the section that <code>(i, j)</code> resides on, and <code>i = get_boundary_nodes(boundary_nodes, index)</code> and  <code>j = get_boundary_nodes(boundary_nodes, index + 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/mesh_refinement/boundary_enricher.jl#L524-L531">source</a></section><section><div><pre><code class="language-julia hljs">get_boundary_edge_map(tri::Triangulation, ij) 
get_boundary_edge_map(tri::Triangulation, i, j)</code></pre><p>Returns the value from the key <code>(i, j)</code> in the boundary edge map of <code>tri</code>. The returned value is a <code>Tuple</code>  <code>(position, index)</code> so that <code>boundary_nodes = get_boundary_nodes(tri, position)</code> are the boundary nodes associated  with the section that <code>(i, j)</code> resides on, and <code>i = get_boundary_nodes(boundary_nodes, index)</code> and  <code>j = get_boundary_nodes(boundary_nodes, index + 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_edge_map.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_ghost_vertex_map" href="#DelaunayTriangulation.get_ghost_vertex_map"><code>DelaunayTriangulation.get_ghost_vertex_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ghost_vertex_map(tri::Triangulation) -&gt; Dict</code></pre><p>Returns the ghost vertex map of the triangulation <code>tri</code>. This is a <code>Dict</code> that maps ghost vertices  to their associated section in <code>boundary_nodes</code>. There are three cases; below, <code>I</code> is <code>integer_type(tri)</code>:</p><ul><li><code>has_multiple_curves(tri)</code></li></ul><p>Returns <code>dict::Dict{I, NTuple{2, I}}</code>, mapping ghost vertices <code>i</code> to <code>Tuple</code>s <code>(m, n)</code> so that <code>get_boundary_nodes(tri, m, n)</code> are the boundary nodes associated with <code>i</code>,  i.e. the <code>n</code>th section of the <code>m</code>th curve is associated with the ghost vertex <code>i</code>.</p><ul><li><code>has_multiple_sections(tri)</code></li></ul><p>Returns <code>dict::Dict{I, I}</code>, mapping ghost vertices <code>i</code> to <code>n</code> so that <code>get_boundary_nodes(tri, n)</code> are the boundary nodes associated with <code>i</code>, i.e. the <code>n</code>th section of the boundary is associated with the ghost vertex <code>i</code>.</p><ul><li><code>otherwise</code></li></ul><p>Returns <code>dict::Dict{I, A}</code>, mapping the ghost vertex <code>i</code> to <code>get_boundary_nodes(tri)</code>, where <code>A = typeof(get_boundary_nodes(tri))</code>.</p><p>See also <a href="../../extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_map-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I"><code>construct_ghost_vertex_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L246-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_ghost_vertex_ranges" href="#DelaunayTriangulation.get_ghost_vertex_ranges"><code>DelaunayTriangulation.get_ghost_vertex_ranges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ghost_vertex_ranges(tri::Triangulation) -&gt; Dict</code></pre><p>Returns the ghost vertex ranges map of the triangulation <code>tri</code>. This is a <code>Dict</code> that maps ghost vertices <code>i</code>  to the range of all other ghost vertices associated with the curve that <code>i</code> is associated with. </p><p>See also <a href="../../extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_ranges-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I"><code>construct_ghost_vertex_ranges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_convex_hull" href="#DelaunayTriangulation.get_convex_hull"><code>DelaunayTriangulation.get_convex_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_convex_hull(tri::Triangulation) -&gt; ConvexHull</code></pre><p>Returns the convex hull of the points in <code>tri</code>. This is given as a <a href="../../extended/data_structures/#ConvexHull"><code>ConvexHull</code></a> object, where the vertices  are sorted counter-clockwise and defined so that the first and last vertices are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L280-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_representative_point_list" href="#DelaunayTriangulation.get_representative_point_list"><code>DelaunayTriangulation.get_representative_point_list</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_representative_point_list(tri::Triangulation) -&gt; Dict</code></pre><p>Returns the <code>Dict</code> of <a href="../../extended/data_structures/#RepresentativeCoordinates"><code>RepresentativeCoordinates</code></a> of <code>tri</code>, mapping curve indices <code>i</code> to the representative point for that  curve. These representative points are how we interpret ghost triangles relative to that curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/triangulation.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_curves" href="#DelaunayTriangulation.num_curves"><code>DelaunayTriangulation.num_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_curves(tri::Triangulation) -&gt; Integer</code></pre><p>Returns the number of curves in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L1-L5">source</a></section><section><div><pre><code class="language-julia hljs">num_curves(boundary_nodes) -&gt; Integer</code></pre><p>Get the number of curves in <code>boundary_nodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.num_curves([1, 2, 3, 1])
1

julia&gt; DelaunayTriangulation.num_curves([[1, 2, 3], [3, 4, 1]])
1

julia&gt; DelaunayTriangulation.num_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/boundary_nodes.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_sections" href="#DelaunayTriangulation.num_sections"><code>DelaunayTriangulation.num_sections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_sections(tri::Triangulation) -&gt; Integer</code></pre><p>Assuming <code>tri</code> only has one curve, returns the number of sections in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L8-L12">source</a></section><section><div><pre><code class="language-julia hljs">num_sections(boundary_nodes) -&gt; Integer</code></pre><p>Assuming <code>boundary_nodes</code> has only one curve, get the number of sections in <code>boundary_nodes</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.num_sections([1, 2, 3, 4, 5, 1])
1

julia&gt; DelaunayTriangulation.num_sections([[1, 2, 3, 4], [4, 5, 1]])
2

julia&gt; DelaunayTriangulation.num_sections([[1, 2, 3], [3, 4, 5, 6, 7, 8], [8, 9], [9, 1]])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/boundary_nodes.jl#L109-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_right_boundary_node" href="#DelaunayTriangulation.get_right_boundary_node"><code>DelaunayTriangulation.get_right_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_right_boundary_node(tri::Triangulation, k, ghost_vertex) -&gt; Vertex</code></pre><p>Returns the boundary node to the right of the vertex <code>k</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex. </li><li><code>ghost_vertex</code>: The ghost vertex associated with the boundary section that <code>k</code> is on. </li></ul><p><strong>Outputs</strong></p><ul><li><code>r</code>: The vertex right of <code>k</code> on the boundary. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_left_boundary_node" href="#DelaunayTriangulation.get_left_boundary_node"><code>DelaunayTriangulation.get_left_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_left_boundary_node(tri::Triangulation, k, ghost_vertex) -&gt; Vertex</code></pre><p>Returns the boundary node to the left of the vertex <code>k</code> in <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>k</code>: The boundary vertex.</li><li><code>ghost_vertex</code>: The ghost vertex associated with the boundary section that <code>k</code> is on.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ℓ</code>: The vertex left of <code>k</code> on the boundary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_all_boundary_nodes" href="#DelaunayTriangulation.get_all_boundary_nodes"><code>DelaunayTriangulation.get_all_boundary_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_all_boundary_nodes(tri::Triangulation) -&gt; Set{Vertex}</code></pre><p>Returns the set of all boundary vertices in <code>tri</code>, in no specific order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_boundary_edge" href="#DelaunayTriangulation.contains_boundary_edge"><code>DelaunayTriangulation.contains_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains_boundary_edge(tri::Triangulation, ij) -&gt; Bool 
contains_boundary_edge(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Returns <code>true</code> if the boundary edge <code>(i, j)</code> is in <code>tri</code>, and <code>false</code> otherwise. Orientation matters here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/boundary_nodes.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_vertex" href="#DelaunayTriangulation.has_vertex"><code>DelaunayTriangulation.has_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_vertex(G::Graph, u) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>u</code> is a vertex in <code>G</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L107-L111">source</a></section><section><div><pre><code class="language-julia hljs">has_vertex(tri::Triangulation, u) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>u</code> is a vertex in <code>tri</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.delete_ghost_vertices_from_graph!" href="#DelaunayTriangulation.delete_ghost_vertices_from_graph!"><code>DelaunayTriangulation.delete_ghost_vertices_from_graph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_ghost_vertices!(G::Graph)</code></pre><p>Deletes all ghost vertices from <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L254-L258">source</a></section><section><div><pre><code class="language-julia hljs">delete_ghost_vertices_from_graph!(tri::Triangulation)</code></pre><p>Deletes all ghost vertices from the graph of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_vertices" href="#DelaunayTriangulation.has_ghost_vertices"><code>DelaunayTriangulation.has_ghost_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_ghost_vertices(G::Graph) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>G</code> has ghost vertices, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L268-L272">source</a></section><section><div><pre><code class="language-julia hljs">has_ghost_vertices(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has ghost vertices, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_convex_hull_vertices" href="#DelaunayTriangulation.get_convex_hull_vertices"><code>DelaunayTriangulation.get_convex_hull_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_convex_hull_vertices(tri::Triangulation) -&gt; Vector{Vertex}</code></pre><p>Returns the vertices on the convex hull of <code>tri</code>, in counter-clockwise order. </p><p>See also <a href="../../extended/data_structures/#ConvexHull"><code>ConvexHull</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/convex_hull.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_exterior_ghost_vertex" href="#DelaunayTriangulation.is_exterior_ghost_vertex"><code>DelaunayTriangulation.is_exterior_ghost_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_exterior_ghost_vertex(tri::Triangulation, i) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ghost vertex <code>i</code> in <code>tri</code> is an exterior ghost vertex, and <code>false</code> otherwise. </p><p>See also <a href="../predicates/#DelaunayTriangulation.is_ghost_vertex"><code>is_ghost_vertex</code></a> and <a href="#DelaunayTriangulation.is_interior_ghost_vertex"><code>is_interior_ghost_vertex</code></a>.</p><p><strong>Extended help</strong></p><p>An exterior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the exterior boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_interior_ghost_vertex" href="#DelaunayTriangulation.is_interior_ghost_vertex"><code>DelaunayTriangulation.is_interior_ghost_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_interior_ghost_vertex(tri::Triangulation, i) -&gt; Bool</code></pre><p>Returns <code>true</code> if the ghost vertex <code>i</code> in <code>tri</code> is an interior ghost vertex, and <code>false</code> otherwise.</p><p>See also <a href="../predicates/#DelaunayTriangulation.is_ghost_vertex"><code>is_ghost_vertex</code></a> and <a href="#DelaunayTriangulation.is_exterior_ghost_vertex"><code>is_exterior_ghost_vertex</code></a>.</p><p><strong>Extended help</strong></p><p>An interior ghost vertex is a ghost vertex corresponding to a curve or section appearing on the interior boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_curve_index" href="#DelaunayTriangulation.get_curve_index"><code>DelaunayTriangulation.get_curve_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_curve_index(dict, ghost_vertex) -&gt; Int
get_curve_index(ghost_vertex) -&gt; Int</code></pre><p>Given a <code>Dict</code> from <a href="../../extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_map-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I"><code>construct_ghost_vertex_map</code></a> and a <code>ghost_vertex</code>, returns the index of the curve corresponding to that ghost vertex. The second method  maps <code>ghost_vertex</code> to <code>1</code> if it is an <code>Integer</code> or a <code>Vector</code>, and <code>ghost_vertex[1]</code> if it is a <code>Tuple</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.get_curve_index(-1)
1

julia&gt; DelaunayTriangulation.get_curve_index((5, 3))
5

julia&gt; gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])
Dict{Int64, Tuple{Int64, Int64}} with 4 entries:
  -1 =&gt; (1, 1)
  -3 =&gt; (2, 2)
  -2 =&gt; (2, 1)
  -4 =&gt; (2, 3)

julia&gt; DelaunayTriangulation.get_curve_index(gv_map, -1)
1

julia&gt; DelaunayTriangulation.get_curve_index(gv_map, -2)
2

julia&gt; DelaunayTriangulation.get_curve_index(gv_map, -3)
2

julia&gt; DelaunayTriangulation.get_curve_index(gv_map, -4)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/boundary_nodes.jl#L533-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_section_index" href="#DelaunayTriangulation.get_section_index"><code>DelaunayTriangulation.get_section_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_section_index(dict, ghost_vertex) -&gt; Int
get_section_index(ghost_vertex) -&gt; Int</code></pre><p>Given a <code>Dict</code> from <a href="../../extended/data_structures/#DelaunayTriangulation.construct_ghost_vertex_map-Union{Tuple{Any}, Tuple{I}, Tuple{Any, Type{I}}} where I"><code>construct_ghost_vertex_map</code></a> and a <code>ghost_vertex</code>, returns the index of the section corresponding to that ghost vertex. The second method maps <code>ghost_vertex</code> to itself if it is an <code>Integer</code>, <code>1</code> if it is a <code>Vector</code>, and  <code>ghost_vertex[2]</code> if it is a <code>Tuple</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.get_section_index((2, 3)) # 3rd section of the 2nd curve
3

julia&gt; DelaunayTriangulation.get_section_index(4)
4

julia&gt; DelaunayTriangulation.get_section_index([1, 2, 3, 4, 5, 1])
1

julia&gt; gv_map = DelaunayTriangulation.construct_ghost_vertex_map([[[1, 5, 17, 18, 1]], [[23, 29, 31, 33], [33, 107, 101], [101, 99, 85, 23]]])     
Dict{Int64, Tuple{Int64, Int64}} with 4 entries:
  -1 =&gt; (1, 1)
  -3 =&gt; (2, 2)
  -2 =&gt; (2, 1)
  -4 =&gt; (2, 3)

julia&gt; DelaunayTriangulation.get_section_index(gv_map, -1)
1

julia&gt; DelaunayTriangulation.get_section_index(gv_map, -2)
1

julia&gt; DelaunayTriangulation.get_section_index(gv_map, -3)
2

julia&gt; DelaunayTriangulation.get_section_index(gv_map, -4)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/boundary_nodes.jl#L576-L617">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.map_ghost_vertex" href="#DelaunayTriangulation.map_ghost_vertex"><code>DelaunayTriangulation.map_ghost_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_ghost_vertex(tri::Triangulation, ℓ) -&gt; Vertex</code></pre><p>Given a ghost vertex <code>ℓ</code> in <code>tri</code>, returns the corresponding section in the  <code>boundary_nodes</code> of <code>tri</code>. See also <a href="#DelaunayTriangulation.get_ghost_vertex_map"><code>get_ghost_vertex_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/ghost_vertex_map.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_ghost_vertex_range" href="#DelaunayTriangulation.get_ghost_vertex_range"><code>DelaunayTriangulation.get_ghost_vertex_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ghost_vertex_range(tri::Triangulation, ℓ) -&gt; UnitRange</code></pre><p>Given a ghost vertex <code>ℓ</code> of <code>tri</code>, returns the range of all  ghost vertices corresponding to the same curve or section as <code>ℓ</code> does.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/ghost_vertex_ranges.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.all_ghost_vertices" href="#DelaunayTriangulation.all_ghost_vertices"><code>DelaunayTriangulation.all_ghost_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_ghost_vertices(tri::Triangulation) -&gt; KeySet</code></pre><p>Returns the set of all ghost vertices in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/ghost_vertex_ranges.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_points" href="#DelaunayTriangulation.num_points"><code>DelaunayTriangulation.num_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_points(points) -&gt; Integer</code></pre><p>Returns the number of points in <code>points</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; points = [(1.0, 1.0), (2.3, 1.5), (0.0, -5.0)];

julia&gt; DelaunayTriangulation.num_points(points)
3

julia&gt; points = [1.0 5.5 10.0 -5.0; 5.0 2.0 0.0 0.0];

julia&gt; DelaunayTriangulation.num_points(points)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/geometric_primitives/points.jl#L279-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_representative_point_coordinates" href="#DelaunayTriangulation.get_representative_point_coordinates"><code>DelaunayTriangulation.get_representative_point_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_representative_point_coordinates(tri::Triangulation, curve_index) -&gt; NTuple{2, Number}</code></pre><p>Returns the coordinates of the representative point of the <code>curve_index</code>th curve in <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/representative_point_list.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.compute_representative_points!" href="#DelaunayTriangulation.compute_representative_points!"><code>DelaunayTriangulation.compute_representative_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_representative_points!(tri::Triangulation; use_convex_hull=!has_boundary_nodes(tri), precision=one(number_type(tri)))</code></pre><p>Computes a new set of representative points for <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a> for which to compute the representative points.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_convex_hull=!has_boundary_nodes(tri)</code>: If <code>true</code>, then the representative points are computed using the convex hull of the triangulation. Otherwise, the representative points are computed using the boundary nodes of the triangulation.</li><li><code>precision=one(number_type(tri))</code>: The precision to use when computing the representative points via <a href="../other/#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>.</li></ul><p><strong>Output</strong></p><p>There are no outputs as <code>tri</code> is updated in-place, but for each curve the representative point is computed using <a href="../other/#DelaunayTriangulation.pole_of_inaccessibility"><code>pole_of_inaccessibility</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Exterior curves</header><div class="admonition-body"><p>While <code>get_exterior_curve_indices(tri)</code> does store the curves corresponding to exterior curves, this function still treats the first  curve as the most important exterior curve, computing the representative point so that it is in no holes. In particular, other exterior curves  might have representative points that are in a hole of one of their interior holes. This isn&#39;t much of a problem, indeed it wouldn&#39;t be a significant  problem even if we had the representative point in a hole of the first curve, but it is something to be aware of.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/representative_point_list.jl#L79-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.add_weight!" href="#DelaunayTriangulation.add_weight!"><code>DelaunayTriangulation.add_weight!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_weight!(weights, w)</code></pre><p>Pushes the weight <code>w</code> into <code>weights</code>. The default definition for this is <code>push!(weights, w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/weights.jl#L1-L5">source</a></section><section><div><pre><code class="language-julia hljs">add_weight!(tri::Triangulation, w)</code></pre><p>Pushes the weight <code>w</code> into the weights of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/weights.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_weight" href="#DelaunayTriangulation.get_weight"><code>DelaunayTriangulation.get_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_weight(weights, i) -&gt; Float64</code></pre><p>Gets the <code>i</code>th weight from <code>weights</code>. The default definition for this is <code>weights[i]</code>, but this can be extended - e.g., <a href="#DelaunayTriangulation.ZeroWeight"><code>ZeroWeight</code></a> uses <code>get_weight(weights, i) = 0.0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/weights.jl#L8-L13">source</a></section><section><div><pre><code class="language-julia hljs">get_weight(tri::Triangulation, i) -&gt; Number</code></pre><p>Gets the <code>i</code>th weight from <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/weights.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.ZeroWeight" href="#DelaunayTriangulation.ZeroWeight"><code>DelaunayTriangulation.ZeroWeight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZeroWeight</code></pre><p>Struct used for indicating that a triangulation has zero weights. The weights are <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/weights.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_area" href="#DelaunayTriangulation.get_area"><code>DelaunayTriangulation.get_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_area(r::BoundingBox) -&gt; Float64</code></pre><p>Returns the area of <code>r</code>, i.e. <code>hspan(r) * vspan(r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/trees/rtree.jl#L164-L168">source</a></section><section><div><pre><code class="language-julia hljs">get_area(stats::TriangulationStatistics)</code></pre><p>Returns the area field from the <a href="../../extended/data_structures/#TriangulationStatistics"><code>TriangulationStatistics</code></a> <code>stats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/statistics/triangulation_statistics.jl#L154-L158">source</a></section><section><div><pre><code class="language-julia hljs">get_area(stats::TriangulationStatistics, T)</code></pre><p>Returns the area field from the individual triangle statistics for the triangle <code>T</code> in the <a href="../../extended/data_structures/#TriangulationStatistics"><code>TriangulationStatistics</code></a> <code>stats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/statistics/triangulation_statistics.jl#L173-L177">source</a></section><section><div><pre><code class="language-julia hljs">get_area(vor::VoronoiTessellation, i) -&gt; Number</code></pre><p>Gets the area of the <code>i</code>th Voronoi polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/voronoi.jl#L388-L392">source</a></section><section><div><pre><code class="language-julia hljs">get_area(tri::Triangulation) -&gt; Number</code></pre><p>Returns the area of <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/utils/utils.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.iterated_neighbourhood" href="#DelaunayTriangulation.iterated_neighbourhood"><code>DelaunayTriangulation.iterated_neighbourhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterated_neighbourhood(tri::Triangulation, i, d) -&gt; Set{Vertex}</code></pre><p>Returns the set of vertices of <code>tri</code> in the iterated neighbourhood of the vertex <code>i</code> of depth <code>d</code>. </p><p><strong>Extended help</strong></p><p>The <span>$d$</span>-times iterated neighbourhood is defined by </p><p class="math-container">\[N_i^d = \bigcup_{j \in N_i^{d-1}} N_j \setminus \{i\},\]</p><p>where <span>$N_i^1 = N_i$</span> is the set of neighbours of <span>$i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/utils/utils.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.dist" href="#DelaunayTriangulation.dist"><code>DelaunayTriangulation.dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dist(p, q) -&gt; Number</code></pre><p>Assuming <code>p</code> and <code>q</code> are two-dimensional, computes the Euclidean distance between <code>p</code> and <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/utils/utils.jl#L322-L326">source</a></section><section><div><pre><code class="language-julia hljs">dist(tri::Triangulation, p) -&gt; Number</code></pre><p>Given a point <code>p</code>, returns the distance from <code>p</code> to the triangulation, using the  conventions from <a href="../other/#DelaunayTriangulation.distance_to_polygon"><code>distance_to_polygon</code></a>:</p><ul><li><code>δ &gt; 0</code>: If the returned distance is positive, then <code>p</code> is inside the triangulation.</li><li><code>δ &lt; 0</code>: If the returned distance is negative, then <code>p</code> is outside the triangulation.</li><li><code>δ = 0</code>: If the returned distance is zero, then <code>p</code> is on the boundary of the triangulation.</li></ul><p>Where we say distance, we are referring to the distance from <code>p</code> to the boundary of the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/utils/utils.jl#L455-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_insertion_order" href="#DelaunayTriangulation.get_insertion_order"><code>DelaunayTriangulation.get_insertion_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_insertion_order(points, randomise, skip_points, ::Type{I}, rng) where {I} -&gt; Vector{I}
get_insertion_order(tri::Triangulation, randomise, skip_points, rng) -&gt; Vector{I}</code></pre><p>Gets the insertion order for points into a triangulation. </p><p><strong>Arguments</strong></p><ul><li><code>points</code>: The points to insert.</li><li><code>randomise</code>: If <code>true</code>, then the insertion order is randomised. Otherwise, the insertion order is the same as the order of the points.</li><li><code>skip_points</code>: The points to skip.</li><li><code>I::Type{I}</code>: The type of the vertices.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to use.</li></ul><p><strong>Output</strong></p><ul><li><code>order</code>: The order to insert the points in.</li></ul><div class="admonition is-warning"><header class="admonition-header">Mutation of `order`</header><div class="admonition-body"><p>This <code>order</code> might be mutated (by <code>circshift!</code>) in <a href="../../extended/algorithms/#DelaunayTriangulation.get_initial_triangle"><code>get_initial_triangle</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/algorithms/triangulation/unconstrained_triangulation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_vertices-Tuple{Triangulation}" href="#DelaunayTriangulation.get_vertices-Tuple{Triangulation}"><code>DelaunayTriangulation.get_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vertices(tri::Triangulation) -&gt; Set{Vertex}</code></pre><p>Returns the set of all vertices in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of these vertices will be ghost vertices.</p><p>See also <a href="../iterators/#DelaunayTriangulation.each_vertex"><code>each_vertex</code></a>, <a href="../iterators/#DelaunayTriangulation.each_solid_vertex"><code>each_solid_vertex</code></a>, and <a href="../iterators/#DelaunayTriangulation.each_ghost_vertex"><code>each_ghost_vertex</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.get_edges-Tuple{Triangulation}" href="#DelaunayTriangulation.get_edges-Tuple{Triangulation}"><code>DelaunayTriangulation.get_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_edges(tri::Triangulation) -&gt; Set{NTuple{2,Vertex}}</code></pre><p>Returns the set of all edges in <code>tri</code>. Orientation is ignored, so that  only one of <code>(i, j)</code> and <code>(j, i)</code> will appear in the result. Note that,  if <code>has_ghost_triangles(tri)</code>, then some of these edges will be ghost edges.</p><p>See also <a href="../iterators/#DelaunayTriangulation.each_edge"><code>each_edge</code></a>, <a href="../iterators/#DelaunayTriangulation.each_solid_edge"><code>each_solid_edge</code></a>, and <a href="../iterators/#DelaunayTriangulation.each_ghost_edge"><code>each_ghost_edge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.num_neighbours" href="#DelaunayTriangulation.num_neighbours"><code>DelaunayTriangulation.num_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_neighbours(G::Graph, u) -&gt; Integer</code></pre><p>Returns the number of neighbours of <code>u</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/graph.jl#L85-L89">source</a></section><section><div><pre><code class="language-julia hljs">num_neighbours(tri::Triangulation, u) -&gt; Integer</code></pre><p>Returns the number of neighbours of <code>u</code> in <code>tri</code>. Note that, if <code>has_ghost_triangles(tri)</code>, then some of the neighbours counted might be ghost vertices if <code>u</code> is a boundary vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/data_structures/triangulation/methods/graph.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.validate_triangulation" href="#DelaunayTriangulation.validate_triangulation"><code>DelaunayTriangulation.validate_triangulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate_triangulation(tri::Triangulation; print_result=true, predicates::AbstractPredicateKernel=ExactKernel()) -&gt; Bool</code></pre><p>Tests if <code>tri</code> is a valid <code>Triangulation</code>. Returns <code>true</code> if so,  and <code>false</code> otherwise. If <code>print_result=true</code> and <code>tri</code> is not a  valid triangulation, all the issues with <code>tri</code> will be printed.</p><p>Use the <code>predicates</code> keyword argument to control the method used for computing predicates.  Can be one of <a href="../predicates/#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, <a href="../predicates/#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, and <a href="../predicates/#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>.  See the documentation for a further discussion of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/fb56c79ac8d30905ad9ebe2a99de532516800d6c/src/validation.jl#L917-L927">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structures/">« Data Structures</a><a class="docs-footer-nextpage" href="../operations/">Triangulation Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 3 August 2024 09:42">Saturday 3 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
