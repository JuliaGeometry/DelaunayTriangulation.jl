<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Clipped Voronoi Tessellations · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/tessellations/clipped/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li class="is-active"><a class="tocitem" href>Clipped Voronoi Tessellations</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Algorithm"><span>Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li><li><a class="tocitem" href="../../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Voronoi Tessellations</a></li><li class="is-active"><a href>Clipped Voronoi Tessellations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Clipped Voronoi Tessellations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/tessellations/clipped.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Clipped-Voronoi-Tessellations"><a class="docs-heading-anchor" href="#Clipped-Voronoi-Tessellations">Clipped Voronoi Tessellations</a><a id="Clipped-Voronoi-Tessellations-1"></a><a class="docs-heading-anchor-permalink" href="#Clipped-Voronoi-Tessellations" title="Permalink"></a></h1><p>Often, it is useful to chop off the unbounded polygons in a tessellation, truncating them to some boundary. Usually this is just a box. We currently provide support for chopping to a convex hull, but the aim is to eventually support chopping to any boundary (the same algorithm we use should apply here, but there are some special cases that are really quite difficult). </p><p>The same function <code>voronoi</code> is used for this, just setting the second argument to be <code>true</code>. The algorithm is described at the end of this section.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Let us give an example.</p><pre><code class="language-julia hljs">using DelaunayTriangulation, CairoMakie
pts = randn(2, 250)
tri = triangulate(pts)
vorn = voronoi(tri)
vorn_clip = voronoi(tri, true)

fig = Figure()
ax = Axis(fig[1, 1], aspect=1)
voronoiplot!(ax, vorn, strokecolor=:red, strokewidth=0.2, show_generators=false)
triplot!(ax, tri, strokewidth=0.0, strokecolor=(:black, 0.4), show_convex_hull=true)
xlims!(ax, -5, 5)
ylims!(ax, -5, 5)
ax = Axis(fig[1, 2], aspect=1)
voronoiplot!(ax, vorn_clip, strokecolor=:red, strokewidth=0.2, show_generators=false)
triplot!(ax, tri, strokewidth=0.0, strokecolor=(:black, 0.4), show_convex_hull=true)
xlims!(ax, -5, 5)
ylims!(ax, -5, 5)</code></pre><figure>
    <img src='../figs/bounded.png', alt='Clipped Voronoi Tessellation'><br>
</figure><p>As we can see, all the polygons have now been chopped so that the entire tessellation fits into the original boundary of the dual triangulation. Also, the <code>unbounded_polygons</code> and <code>boundary_polygons</code> fields have been updated:</p><pre><code class="language-julia-repl hljs">julia&gt; DelaunayTriangulation.get_unbounded_polygons(vorn_clip)
Set{Int}()

julia&gt; DelaunayTriangulation.get_boundary_polygons(vorn_clip)
Set{Int} with 31 elements:
  169
  56
  200
  195
  72
  180
  221
  8
  37
  187
  32
  6
  171
  190
  69
  219
  73
  ⋮</code></pre><h2 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h2><p>Since the code for clipping is quite involved, most likely more involved than it should be, it is probably worthwhile describing the actual implementation here. I want to one day refine this approach, and allow it to work on any domain. The approach is mostly based on the ideas in the paper &quot;Efficient Computation of Clipped Voronoi Diagram for Mesh Generation&quot; by Yan, Wang, Lévy, and Liu. I imagine if I had access to their code, everything would be a lot nicer (that seems to be true in many computational geometry papers).</p><p>The function that performs the clipping is <code>clip_voronoi_tessellation!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.clip_voronoi_tessellation!" href="#DelaunayTriangulation.clip_voronoi_tessellation!"><code>DelaunayTriangulation.clip_voronoi_tessellation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clip_voronoi_tessellation!(vorn::VoronoiTessellation)</code></pre><p>Clip the Voronoi tessellation <code>vorn</code> to the convex hull of the points in <code>vorn</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/main.jl#L44-L48">source</a></section></article><p>This function starts off by finding all the intersections and then adding them into the point set, then using these new points to clip the polygons. We describe these steps below.</p><h3 id="Finding-all-intersections"><a class="docs-heading-anchor" href="#Finding-all-intersections">Finding all intersections</a><a id="Finding-all-intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-all-intersections" title="Permalink"></a></h3><p>The function <code>find_all_intersections</code> finds the intersections of the polygons with the boundary.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.find_all_intersections" href="#DelaunayTriangulation.find_all_intersections"><code>DelaunayTriangulation.find_all_intersections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_all_intersections(vorn::VoronoiTessellation)</code></pre><p>Find all intersections between the edges of the Voronoi tessellation and the boundary of the polygon.</p><p><strong>Outputs</strong></p><ul><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>segment_intersections</code>: The intersection points. </li><li><code>exterior_circumcenters</code>: The circumcenters that are outside of the domain.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L450-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.initialise_clipping_arrays" href="#DelaunayTriangulation.initialise_clipping_arrays"><code>DelaunayTriangulation.initialise_clipping_arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialise_clipping_arrays(vorn::VoronoiTessellation)</code></pre><p>Initialise the arrays used in the clipping algorithm.</p><p><strong>Outputs</strong></p><ul><li><code>edges_to_process</code>: The set of edges that are to be processed.</li><li><code>polygon_edge_queue</code>: The queue of edges that are to be processed.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>processed_pairs</code>: The set of pairs of edges and polygons that have been processed.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>left_edge_intersectors</code>: The set of sites that intersect the edge to the left of an edge currently being considered.</li><li><code>right_edge_intersectors</code>: The set of sites that intersect the edge to the right of an edge currently being considered.</li><li><code>current_edge_intersectors</code>: The set of sites that intersect the current edge being considered.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L148-L165">source</a></section></article><p>The idea is to use a first-in first-out (FIFO) queue to prioritise the edges and polygons to consider. In particular, we pick some random edge and then use its midpoint to find what polygon that midpoint is in (via <code>jump_and_march</code>). This edge and the polygon are then added into the queue to be processed. Starting with this edge-polygon pair, we keep looking for intersections until we have processed all boundary edges and there are no more pairs in the queue. The function that does this processing of queued pairs is <code>dequeue_and_process!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.dequeue_and_process!" href="#DelaunayTriangulation.dequeue_and_process!"><code>DelaunayTriangulation.dequeue_and_process!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dequeue_and_process!(vorn, polygon_edge_queue, edges_to_process, intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, processed_pairs, boundary_sites, segment_intersections, exterior_circumcenters, equal_circumcenter_mapping)</code></pre><p>Dequeue an edge from <code>polygon_edge_queue</code> and process it. If <code>polygon_edge_queue</code> is empty, then we process the first edge in <code>edges_to_process</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>polygon_edge_queue</code>: The queue of edges that need to be processed.</li><li><code>edges_to_process</code>: The edges that need to be processed.</li><li><code>intersected_edge_cache</code>: A cache of intersected edges.</li><li><code>left_edge_intersectors</code>: The intersection points of <code>left_edge</code> with other edges.</li><li><code>right_edge_intersectors</code>: The intersection points of <code>right_edge</code> with other edges.</li><li><code>current_edge_intersectors</code>: The intersection points of <code>current_edge</code> with other edges.</li><li><code>processed_pairs</code>: A set of pairs of edges and polygons that have already been processed.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>segment_intersections</code>: A dictionary of segment intersections.</li><li><code>exterior_circumcenters</code>: A dictionary of exterior circumcenters.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L403-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.enqueue_new_edge!" href="#DelaunayTriangulation.enqueue_new_edge!"><code>DelaunayTriangulation.enqueue_new_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enqueue_new_edge!(polygon_edge_queue, vorn::VoronoiTessellation, e)</code></pre><p>Enqueue the edge <code>e</code> of the boundary to be processed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L191-L195">source</a></section></article><p>Essentially, this function first checks if the pair has already been processed and, if so, returns. Otherwise, the first step is to go into <code>process_polygon!</code> to find the intersections of the polygons with the nearby boundary:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.process_polygon!" href="#DelaunayTriangulation.process_polygon!"><code>DelaunayTriangulation.process_polygon!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_polygon!(vorn::VoronoiTessellation, e, incident_polygon, boundary_sites, segment_intersections, intersected_edge_cache, exterior_circumcenters, equal_circumcenter_mapping)</code></pre><p>Process the polygon <code>incident_polygon</code> for all of its intersections based on the boundary edge <code>e</code>, updating the caches in-place and returning <code>(left_edge, right_edge, e)</code>, where  <code>left_edge</code> is the edge to the left of <code>e</code> on the boundary and <code>right_edge</code> is the edge to the right of <code>e</code> on the boundary.</p><p><strong>Arguments</strong></p><ul><li><code>vorn::VoronoiTessellation</code>: The Voronoi tessellation.</li><li><code>e</code>: The edge on the boundary being considered.</li><li><code>incident_polygon</code>: The index of the polygon being considered.</li><li><code>boundary_sites</code>: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>intersected_edge_cache</code>: A cache of the edges that have been intersected by the ray from <code>u</code> to <code>v</code>.</li><li><code>exterior_circumcenters</code>: A list of the circumcenters of the sites that are outside the convex hull of the sites on the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L281-L296">source</a></section></article><p>The goal of <code>process_polygon!</code> is to iterate over the edges of the current polygon to look for intersections, searching (1) the current edge, (2) the edge to the left of the current edge, and (3) the edge to the right of the current edge. Suppose we have an edge <span>$e_{uv}$</span> of the polygon being considered. There are four possibilities:</p><ol><li>First, both <span>$u$</span> and <span>$v$</span> could correspond to ghost vertices, meaning no intersection with the boundary is possible.</li><li>Alternatively, <span>$e_{uv}$</span> could be a ray going inwards, meaning <span>$u$</span> is a ghost vertex while <span>$v$</span> corresponds to an actual circumcenter. In this case, <code>process_ray_intersection!</code> is used to look for an intersection of <span>$e_{uv}$</span> with the edge of the ghost triangle corresponding to <span>$u$</span>. If an intersection is found, we do need to be careful of rays that intersect multiple boundary edges (as is common when we have very few triangles in the underlying triangulation). This check is done with <code>process_ray_intersection_with_other_edges!</code>, which simply looks at the left and right edges along with the current edge. </li><li>Same as the above, except <span>$e_{uv}$</span> could be a ray going inwards, meaning <span>$u$</span> now corresponds to an actual cicrcumcenter while <span>$v$</span> is a ghost vertex.</li><li>Lastly, <span>$e_{uv}$</span> could be a fniite segment, in which case we can use simple intersection formula to test for intersections with the left and right edges along with the current edge. This check is done via <code>process_segment_intersection!</code>.</li></ol><p>In these steps, when there are no intersections we also check if it was because a segment lies entirely outside of the domain. We keep track of these points as these will need to be deleted later.</p><p>Some of the relevant docstrings for working with <code>process_polygon!</code> are below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_segment_between_two_ghosts" href="#DelaunayTriangulation.is_segment_between_two_ghosts"><code>DelaunayTriangulation.is_segment_between_two_ghosts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_segment_between_two_ghosts(u, v)</code></pre><p>Check if the segment between the sites <code>u</code> and <code>v</code> is between two ghost sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ray_going_in" href="#DelaunayTriangulation.is_ray_going_in"><code>DelaunayTriangulation.is_ray_going_in</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ray_going_in(u, v)</code></pre><p>Check if the ray from the site <code>u</code> to the site <code>v</code> is going in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ray_going_out" href="#DelaunayTriangulation.is_ray_going_out"><code>DelaunayTriangulation.is_ray_going_out</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ray_going_out(u, v)</code></pre><p>Check if the ray from the site <code>u</code> to the site <code>v</code> is going out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_finite_segment" href="#DelaunayTriangulation.is_finite_segment"><code>DelaunayTriangulation.is_finite_segment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_finite_segment(u, v)</code></pre><p>Check if the segment between the sites <code>u</code> and <code>v</code> is finite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.process_segment_intersection!" href="#DelaunayTriangulation.process_segment_intersection!"><code>DelaunayTriangulation.process_segment_intersection!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_segment_intersection!(
    vorn::VoronoiTessellation,
    u,
    v,
    e,
    incident_polygon,
    intersected_edge_cache,
    segment_intersections,
    boundary_sites,
    exterior_circumcenters,
    equal_circumcenter_mapping)</code></pre><p>Process the intersection of the Voronoi polygon&#39;s edge <code>(u, v)</code> with the edge <code>e</code> of the boundary, returning the coordinates of the intersection and updating via <a href="tessellations/@ef"><code>add_segment_intersection</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>u</code>: The index of the site <code>u</code>.</li><li><code>v</code>: The index of the site <code>v</code>.</li><li><code>e</code>: The edge <code>e</code> of the boundary.</li><li><code>incident_polygon</code>: The index of the Voronoi polygon currently being considered <code>(u, v)</code>.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L88-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.process_ray_intersection!" href="#DelaunayTriangulation.process_ray_intersection!"><code>DelaunayTriangulation.process_ray_intersection!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_ray_intersection!(
    vorn::VoronoiTessellation,
    u,
    v,
    incident_polygon,
    intersected_edge_cache,
    segment_intersections,
    boundary_sites,
    exterior_circumcenters,
    equal_circumcenter_mapping)</code></pre><p>Process the intersection of the Voronoi polygon of the site <code>u</code> with the ray emanating from the circumcenter of the site <code>v</code>, returning the coordinates of the intersection and updating via <a href="tessellations/@ef"><code>add_segment_intersection</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>u</code>: The index of the site <code>u</code>, given as a boundary index for the associated ghost triangle.</li><li><code>v</code>: The index of the site <code>v</code>.</li><li><code>incident_polygon</code>: The index of the Voronoi polygon of the site <code>u</code> that is incident to the ray emanating from the circumcenter of the site <code>v</code>.</li><li><code>intersected_edge_cache</code>: The list of intersected edges currently being considered.</li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>exterior_circumcenters</code>: The list of circumcenters of sites that are outside the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L36-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_to_intersected_edge_cache!" href="#DelaunayTriangulation.add_to_intersected_edge_cache!"><code>DelaunayTriangulation.add_to_intersected_edge_cache!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_intersected_edge_cache!(intersected_edge_cache, u, v, a, b)</code></pre><p>Add the edge <code>uv</code> to the list of intersected edges, where <code>uv</code> is the edge of the Voronoi polygon intersecting the edge of the boundary <code>ab</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_segment_intersection!" href="#DelaunayTriangulation.add_segment_intersection!"><code>DelaunayTriangulation.add_segment_intersection!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_segment_intersection!(segment_intersections, boundary_sites, intersection_point, incident_polygon::I) where {I}</code></pre><p>Add the intersection point to the list of segment intersections and return the index of the intersection point in the list.  If the intersection point already exists in the list, then the index of the existing point is returned and used instead.</p><p><strong>Arguments</strong></p><ul><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.</li><li><code>intersection_point</code>: The intersection point to add.</li><li><code>incident_polygon</code>: The index of the polygon that is incident to the intersection point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.segment_intersection_coordinates" href="#DelaunayTriangulation.segment_intersection_coordinates"><code>DelaunayTriangulation.segment_intersection_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segment_intersection_coordinates(a, b, c, d)</code></pre><p>Finds the coordinates of the intersection of the line segment from <code>a</code> to <code>b</code>  with the line segment from <code>c</code> to <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/geometry_utils/intersections.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.intersection_of_edge_and_bisector_ray" href="#DelaunayTriangulation.intersection_of_edge_and_bisector_ray"><code>DelaunayTriangulation.intersection_of_edge_and_bisector_ray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intersection_of_edge_and_bisector_ray(a, b, c)</code></pre><p>Given an edge <code>(a, b)</code> and a ray emanating from <code>c</code> perpendicular   with the edge and collinear with its midpoint, tests if <code>c</code> intersects  the edge, and if so, returns the <code>(cert, p)</code>, where <code>p</code> is the intersection point (which is the midpoint) and <code>c</code> is the position of <code>c</code> relative to <code>(a, b)</code>. If there is no intersection, <code>p = (NaN, NaN)</code> is returned (together with <code>cert</code>). The ray should be directed to the left of the edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/geometry_utils/intersections.jl#L147-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.classify_and_compute_segment_intersection" href="#DelaunayTriangulation.classify_and_compute_segment_intersection"><code>DelaunayTriangulation.classify_and_compute_segment_intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">classify_and_compute_segment_intersection(a, b, c, d)</code></pre><p>Given two line segments <code>(a, b)</code> and <code>(c, d)</code>, classifies the intersection of the two segments, returning <code>(cert, cert_c, cert_d, p)</code>, where <code>p</code> is the intersection point or <code>(NaN, NaN)</code> if there is no intersection. The certificate <code>cert</code> determines the intersection  type, giving </p><ul><li><code>Cert.None</code>: No intersections.</li><li><code>Cert.Single</code>: There is an intersection point.</li><li><code>Cert.Touching</code>: There is an intersection point, and one of <code>c</code> and <code>d</code> is the intersection point.</li><li><code>Cert.Multiple</code>: The closed segments meet in one or several points.</li></ul><p>The certificates <code>cert_c</code> and <code>cert_d</code> similarly return the positions of <code>c</code> and <code>d</code> relative to <code>(a, b)</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/geometry_utils/intersections.jl#L170-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.process_ray_intersection_with_other_edges!" href="#DelaunayTriangulation.process_ray_intersection_with_other_edges!"><code>DelaunayTriangulation.process_ray_intersection_with_other_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_ray_intersection_with_other_edges!(vorn::VoronoiTessellation, u, v, e, left_edge, right_edge, r, segment_intersections,
boundary_sites, incident_polygon, equal_circumcenter_mapping, intersected_edge_cache)</code></pre><p>Process the intersection of the ray from the ghost site <code>u</code> to the site <code>v</code> with the edges <code>e</code>, <code>left_edge</code> and <code>right_edge</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vorn::VoronoiTessellation</code>: The Voronoi tessellation.</li><li><code>u</code>: The index of the ghost site.</li><li><code>v</code>: The index of the site <code>u</code> is going to.</li><li><code>e</code>: The edge on the boundary being considered.</li><li><code>left_edge</code>: The edge to the left of <code>e</code> on the boundary.</li><li><code>right_edge</code>: The edge to the right of <code>e</code> on the boundary.</li><li><code>r</code>: The coordinates of the intersection of the ray from <code>u</code> to <code>v</code> with some edge. If <code>any(isnan, r)</code>, then the ray does not intersect any edge and we skip. </li><li><code>segment_intersections</code>: The list of segment intersections.</li><li><code>boundary_sites</code>: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.</li><li><code>incident_polygon</code>: The index of the polygon that contains the intersection of the ray from <code>u</code> to <code>v</code> with the boundary.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>intersected_edge_cache</code>: A cache of the edges that have been intersected by the ray from <code>u</code> to <code>v</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L235-L254">source</a></section></article><p>Once we have gone through <code>process_polygon!</code>, we need to assign the identified intersections to the current edge, the left edge, or to the right edge. This is done with <code>classify_intersections!</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.classify_intersections!" href="#DelaunayTriangulation.classify_intersections!"><code>DelaunayTriangulation.classify_intersections!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">classify_intersections!(intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge)</code></pre><p>Classify the intersections in <code>intersected_edge_cache</code> into <code>left_edge_intersectors</code>, <code>right_edge_intersectors</code>, and <code>current_edge_intersectors</code> based on whether they intersect <code>left_edge</code>, <code>right_edge</code>, or <code>current_edge</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L324-L328">source</a></section></article><p>Once this is done, we need to actually consider the intersection points. The two goals here are: (1) Check if a corner point inside the polygon has to be added, and (2) look for other incident polygons to process. This processing is done via <code>process_intersection_points!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.process_intersection_points!" href="#DelaunayTriangulation.process_intersection_points!"><code>DelaunayTriangulation.process_intersection_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_intersection_points!(polygon_edge_queue, vorn, current_incident_polygon, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge, processed_pairs, segment_intersections, boundary_sites)</code></pre><p>Process the intersection points in <code>left_edge_intersectors</code>, <code>right_edge_intersectors</code>, and <code>current_edge_intersectors</code> and add the new edges to <code>polygon_edge_queue</code> if necessary. Special  care is taken to not miss any corner points. </p><p>The rules are based on the paper &quot;Efficient Computation of Clipped Voronoi Diagram for Mesh Generation&quot; by Yan, Wang, Levy, and Liu. Namely,  an edge that intersects a boundary edge and one to it has its shared vertex added to the queue together with the current polygon (<code>current_incident_polygon</code>) being  considered, and any intersections have the adjacent polygon added to the queue together with the intersecting edge. These are not strictly  the rules in the paper, but they are the rules that I was able to implement since they do not share their code.</p><p><strong>Arguments</strong></p><ul><li><code>polygon_edge_queue</code>: The queue of edges that need to be processed.</li><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>current_incident_polygon</code>: The index of the current polygon being processed.</li><li><code>left_edge_intersectors</code>: The intersection points of <code>left_edge</code> with other edges.</li><li><code>right_edge_intersectors</code>: The intersection points of <code>right_edge</code> with other edges.</li><li><code>current_edge_intersectors</code>: The intersection points of <code>current_edge</code> with other edges.</li><li><code>left_edge</code>: The left edge of the current polygon.</li><li><code>right_edge</code>: The right edge of the current polygon.</li><li><code>current_edge</code>: The current edge of the current polygon.</li><li><code>processed_pairs</code>: A set of pairs of edges and polygons that have already been processed.</li><li><code>segment_intersections</code>: A dictionary of segment intersections.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L342-L366">source</a></section></article><p>Basically, this function first looks at the left and right intersections. If we have intersections on the left and on the current edge, then we will also have the vertex shared by the two edges included as a point we need to chop to, unless the current polygon being considered corresponds to a generator not on a boundary. We check this for each intersection and update the intersections with <code>add_segment_intersection!</code> accordingly. In such a case, we add the current edge, together with the indices of the left edge (corresponding to polygons) to the queue, ready for the next iteration. The same is done for the right edge. After handling this case, we check all the intersections without worry for corner points. For each intersection, we take the polygon on the other side of the intersecting segment and add it to the queue together with the boundary ede that was intersected. </p><p>We do all the above steps until we run out of edges to process and the queue is empty, adding all the intersection points into the point list using <code>add_intersection_points!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_intersection_points!" href="#DelaunayTriangulation.add_intersection_points!"><code>DelaunayTriangulation.add_intersection_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_intersection_points!(vorn::VoronoiTessellation, segment_intersections)</code></pre><p>Add the intersection points to the polygon vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L489-L493">source</a></section></article><h3 id="Clipping-the-polygons"><a class="docs-heading-anchor" href="#Clipping-the-polygons">Clipping the polygons</a><a id="Clipping-the-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping-the-polygons" title="Permalink"></a></h3><p>The next step is to clip the polygons to the boundary using the computed intersections. This is handled via <code>clip_all_polygons!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.clip_all_polygons!" href="#DelaunayTriangulation.clip_all_polygons!"><code>DelaunayTriangulation.clip_all_polygons!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clip_all_polygons!(vorn::VoronoiTessellation, n, boundary_sites, exterior_circumcenters, equal_circumcenter_mapping, is_convex)</code></pre><p>Clip all of the polygons in the Voronoi tessellation.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>n</code>: The number of vertices in the tessellation before clipping.</li><li><code>boundary_sites</code>: A dictionary of boundary sites.</li><li><code>exterior_circumcenters</code>: Any exterior circumcenters to be filtered out.</li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>is_convex</code>: Whether the polygon is convex or not. Not currently used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L534-L546">source</a></section></article><p>This function iterates over all the identified boundary polygons and calls <code>clip_polygon!</code> on each:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.clip_polygon!" href="#DelaunayTriangulation.clip_polygon!"><code>DelaunayTriangulation.clip_polygon!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clip_polygon!(vorn::VoronoiTessellation, n, points, polygon, new_verts, exterior_circumcenters, equal_circumcenter_mapping, is_convex)</code></pre><p>Clip the polygon <code>polygon</code> by removing the vertices that are outside of the domain and adding the new vertices <code>new_verts</code> to the polygon.</p><p><strong>Arguments</strong></p><ul><li><code>vorn</code>: The Voronoi tessellation.</li><li><code>n</code>: The number of vertices in the tessellation before clipping.</li><li><code>points</code>: The points of the tessellation. </li><li><code>polygon</code>: The index of the polygon to be clipped.</li><li><code>new_verts</code>: The indices of the new vertices that are added to the polygon.</li><li><code>exterior_circumcenters</code>: Any exterior circumcenters to be filtered out. </li><li><code>equal_circumcenter_mapping</code>: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.</li><li><code>is_convex</code>: Whether the polygon is convex or not. Not currently used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L503-L517">source</a></section></article><p>Consider a single polygon. The <code>clip_polygon!</code> function starts by deleting the adjacencies for this polygon, ready for updating later. We then remove all ghost vertices from the vertex list, and all circumcenters identified from the previous step that lie outside of the domain. We then add all the vertices. With this processing, the vertex list is no longer sorted, so <code>sort_convex_polygon!</code> is called to get a counter-clockwise representation. Adding in the adjacencies via <code>add_polygon_adjacent!</code>, this completes the clipping of this polygon. </p><p>With all polygons processed, we add in all that we processed into the <code>boundary_polygons</code> field via <code>add_all_boundary_polygons!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_all_boundary_polygons!" href="#DelaunayTriangulation.add_all_boundary_polygons!"><code>DelaunayTriangulation.add_all_boundary_polygons!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_all_boundary_polygons!(vorn::VoronoiTessellation, boundary_sites)</code></pre><p>Add all of the boundary polygons to the Voronoi tessellation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/7762f1b32100e55f0c5f75161106cc917b13a857/src/voronoi/clipped_construction.jl#L554-L558">source</a></section></article><p>With this last step, the clipping is complete.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../voronoi/">« Voronoi Tessellations</a><a class="docs-footer-nextpage" href="../lloyd/">Centroidal Voronoi Tessellation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 23 November 2023 14:52">Thursday 23 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
