<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General and Defaults · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li class="is-active"><a class="tocitem" href>General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li><a class="tocitem" href="../edges/">Edges</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>General and Defaults</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General and Defaults</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/interface.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><p>The package makes its simple for customing the interface used for defining points, edges, and triangles, as described in the docstring for <code>Interfaces</code> (see the end of this section). Without any customisation, the default forms are:</p><ul><li>Edges: <code>NTuple{2, Int64}</code>.</li><li>Collections of edges: <code>Set{NTuple{2, Int64}}</code>.</li><li>Triangles: <code>NTuple{3, Int64}</code>.</li><li>Collections of triangles: <code>Set{NTuple{3, Int64}}</code></li></ul><p>We also give support for customing how points are represented, and by default we support collections of points given as matrices (with each point its own column), or vectors of vectors. The number type used for representing coordinates has to be Float64 to support ExactPredicates.jl, although if you like you could customise <code>orient_predicate</code> and <code>incircle_predicate</code>, even circumventing ExactPredicates.jl if you like. See the predicates section in the sidebar for a further discussion of changing these predicate definitions.</p><p>We also provide a customisable interface for representing boundary nodes, although for unconstrained triangulations this is relevant. By default, we support boundary nodes represented according to the following, where we let <code>BN</code> refer to the collection of boundary nodes:</p><ul><li><code>Vector{Int64}</code>: In this case, there is only one fixed boundary and it is represented as a contiguous set of nodes. We must have <code>BN[begin] == BN[end]</code>, and the nodes must be listed in counter-clockwise order.</li><li><code>Vector{Vector{Int64}}</code>: In this case, there is only one fixed boundary, but it is made up of separate segments, with <code>BN[n]</code> the nodes for the <code>n</code>th segment. This makes it possible to more easily support, for example, a domain with different boundary conditions on separate parts of the boundary. We must have <code>BN[n][end] == BN[n+1][begin]</code> and <code>BN[end][end] == BN[begin][begin]</code>, and each segment must be listed in counter-clockwise order.</li><li><code>Vector{Vector{Vector{Int64}}}</code>: In this case, there are multiple fixed boundaries, each of which are assumed to be made up of separate segments. This makes it possible to support multiply-connected domains, e.g. an annulus with each circle split into its lower and upper halves. Here, <code>BN[m][n]</code> is the set of nodes for the <code>n</code>th segment of the <code>m</code>th boundary curve, and <code>BN[begin]</code> the outer-most boundary curve and <code>BN[m]</code>, <code>m &gt; 1</code>, nodes for curves contained within <code>BN[begin]</code>. As in the previous case, <code>BN[m][n][end] == BN[m][n+1][end]</code> and <code>BN[m][end][end] == BN[m][begin][begin]</code> for each <code>m</code>. Moreover, <code>BN[begin]</code> should be a counter-clockwise list of nodes while <code>BN[m]</code> is a clockwise list of nodes for <code>m &gt; 1</code>.</li></ul><p>For more information about how we handle boundaries, and how they are handled in our data structures, see the boundary handling section in the sidebar. </p><p>The complete docstring that we use to also describe these interfaces is given below. (Accessible via <code>?Interfaces</code>). See the next subsections for further detail.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.Interfaces" href="#DelaunayTriangulation.Interfaces"><code>DelaunayTriangulation.Interfaces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Interfaces</code></pre><p>The main objects used throughout this package, namely  points, edges, triangles, and boundaries, have interfaces  that are fully customisable. We describe these interfaces  below, along with all the methods that need to be  defined. </p><p>For these interfaces, we define default methods that  support <code>Tuple</code>s, <code>AbstractVector</code>s, etc., so you do not need to extend any of these for normal use. Moreover,  while we do allow for different index types to be using,  all still have to subtypes of <code>Integer</code> (for now?).</p><p><strong>Triangle Interface</strong></p><p>Here we describe the interface used for describing  triangles and collections of triangles. </p><p><strong>Individual Triangles</strong></p><p>A triangle is assumed to be of the form <code>(i, j, k)</code>, but the object used for storing these three indices  can be customised. The following methods are used for   working with triangles; see their docstrings for more  information.</p><ul><li><a href="../triangles/#DelaunayTriangulation.construct_triangle"><code>construct_triangle</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.geti"><code>geti</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.getj"><code>getj</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.getk"><code>getk</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.indices"><code>indices</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.geti"><code>geti</code></a>, <a href="../triangles/#DelaunayTriangulation.getj"><code>getj</code></a>, and <a href="../triangles/#DelaunayTriangulation.getk"><code>getk</code></a> definitions.</li><li><a href="../triangles/#DelaunayTriangulation.integer_type"><code>integer_type</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.triangle_edges"><code>triangle_edges</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.geti"><code>geti</code></a>, <a href="../triangles/#DelaunayTriangulation.getj"><code>getj</code></a>, and <a href="../triangles/#DelaunayTriangulation.getk"><code>getk</code></a> definitions.</li><li><a href="../triangles/#DelaunayTriangulation.rotate_triangle"><code>rotate_triangle</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.geti"><code>geti</code></a>, <a href="../triangles/#DelaunayTriangulation.getj"><code>getj</code></a>, and <a href="../triangles/#DelaunayTriangulation.getk"><code>getk</code></a> definitions.</li><li><a href="../../data_structures/triangulation/#DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}"><code>construct_positively_oriented_triangle</code></a>: Uses existing definitions.</li><li><a href="../triangles/#DelaunayTriangulation.compare_triangles"><code>compare_triangles</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.geti"><code>geti</code></a>, <a href="../triangles/#DelaunayTriangulation.getj"><code>getj</code></a>, and <a href="../triangles/#DelaunayTriangulation.getk"><code>getk</code></a> definitions.</li><li><a href="../triangles/#DelaunayTriangulation.sort_triangle"><code>sort_triangle</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.indices"><code>indices</code></a> and <a href="../triangles/#DelaunayTriangulation.construct_triangle"><code>construct_triangle</code></a> definitions.</li></ul><p><strong>Collection of Triangles</strong></p><p>A collection of triangles simply stores many triangles. The  following methods are used for working with these collections; see their docstrings for more information. Note that these collections  must be mutable.</p><ul><li><a href="../triangles/#DelaunayTriangulation.initialise_triangles"><code>initialise_triangles</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.triangle_type"><code>triangle_type</code></a>: Must be defined. </li><li><a href="../triangles/#DelaunayTriangulation.num_triangles"><code>num_triangles</code></a>: Must be defined.</li><li><a href="../triangles/#DelaunayTriangulation.contains_triangle"><code>contains_triangle</code></a>: This calls <code>Base.in</code> and <a href="../triangles/#DelaunayTriangulation.contains_triangle"><code>contains_triangle</code></a>.</li><li><a href="../triangles/#DelaunayTriangulation.add_to_triangles!"><code>add_to_triangles!</code></a>: Must be defined. </li><li><a href="../../data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>add_triangle!</code></a>: This simply calls <a href="../triangles/#DelaunayTriangulation.add_to_triangles!"><code>add_to_triangles!</code></a>.</li><li><a href="../triangles/#DelaunayTriangulation.delete_from_triangles!"><code>delete_from_triangles!</code></a>: Must be defined. </li><li><a href="../../data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>delete_triangle!</code></a>: This simply calls <a href="../triangles/#DelaunayTriangulation.delete_from_triangles!"><code>delete_from_triangles!</code></a>.</li><li><a href="../triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a>: Must be defined. </li><li><code>Base.in</code>: Must be defined.</li><li><code>Base.sizehint!</code>: Must be defined.</li><li><code>Base.unique!</code>: Must be defined, unless your collection is a <code>Set</code>.</li><li><a href="../triangles/#DelaunayTriangulation.compare_triangle_collections"><code>compare_triangle_collections</code></a>: Calls <a href="../triangles/#DelaunayTriangulation.num_triangles"><code>num_triangles</code></a>, <a href="../triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a>, and <a href="../triangles/#DelaunayTriangulation.contains_triangle"><code>contains_triangle</code></a>.</li><li><a href="../triangles/#DelaunayTriangulation.sort_triangles"><code>sort_triangles</code></a>: Uses the <a href="../triangles/#DelaunayTriangulation.initialise_triangles"><code>initialise_triangles</code></a>, <a href="../triangles/#DelaunayTriangulation.each_triangle"><code>each_triangle</code></a>, <a href="../triangles/#DelaunayTriangulation.sort_triangle"><code>sort_triangle</code></a>, and <a href="../../data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>add_triangle!</code></a> definitions.</li><li><a href="../triangles/#DelaunayTriangulation.remove_duplicate_triangles"><code>remove_duplicate_triangles</code></a>: Uses <code>Base.unique!</code>.</li></ul><p>Note that <a href="../../data_structures/triangulation/#DelaunayTriangulation.Triangulation"><code>Triangulation</code></a>s also define <a href="../../data_structures/triangulation/#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}"><code>each_solid_triangle</code></a> and <a href="../../data_structures/triangulation/#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}"><code>each_ghost_triangle</code></a>.</p><p><strong>Edge Interface</strong></p><p>Here we describe the interface used for describing  edges and collections of edges. </p><p><strong>Individual Edges</strong></p><p>An edge is assumed to be of the form <code>(i, j)</code>, but the object used for storing these two indices  can be customised. The following methods are used for   working with edges; see their docstrings for more  information.</p><ul><li><a href="../edges/#DelaunayTriangulation.construct_edge"><code>construct_edge</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.initial"><code>initial</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.terminal"><code>terminal</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.edge_indices"><code>edge_indices</code></a>: Uses the <a href="../edges/#DelaunayTriangulation.initial"><code>initial</code></a> and <a href="../edges/#DelaunayTriangulation.terminal"><code>terminal</code></a> definitions.</li></ul><p><strong>Collection of Edges</strong></p><p>A collection of edges simply stores many edges. The  following methods are used for working with these collections; see their docstrings for more information. Note that these collections  must be mutable.</p><ul><li><a href="../edges/#DelaunayTriangulation.initialise_edges"><code>initialise_edges</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.edge_type"><code>edge_type</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.num_edges"><code>num_edges</code></a>: Must be defined.</li><li><a href="../edges/#DelaunayTriangulation.contains_edge"><code>contains_edge</code></a>: Must be defined.</li><li><a href="../edges/#DelaunayTriangulation.add_to_edges!"><code>add_to_edges!</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.add_edge!"><code>add_edge!</code></a>: This simply calls <a href="../edges/#DelaunayTriangulation.add_to_edges!"><code>add_to_edges!</code></a>.</li><li><a href="../edges/#DelaunayTriangulation.delete_from_edges!"><code>delete_from_edges!</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.delete_edge!"><code>delete_edge!</code></a>: This simply calls <a href="../edges/#DelaunayTriangulation.delete_from_edges!"><code>delete_from_edges!</code></a>.</li><li><a href="../edges/#DelaunayTriangulation.each_edge"><code>each_edge</code></a>: Must be defined. </li><li><a href="../edges/#DelaunayTriangulation.random_edge"><code>random_edge</code></a>: Uses the <a href="../edges/#DelaunayTriangulation.each_edge"><code>each_edge</code></a> definition.</li><li><a href="../edges/#DelaunayTriangulation.is_empty"><code>is_empty</code></a>: Simply uses the <code>isempty</code> definition from Base.</li></ul><p><strong>Point Interface</strong></p><p>Here we describe the interface used for describing  points and collections of points.</p><p><strong>Individual Points</strong></p><p>A point is assumed to be of the form <code>(x, y)</code>, but the object used for storing these two coordinates  can be customised. The following methods are used for   working with points; see their docstrings for more  information.</p><ul><li><a href="../points/#DelaunayTriangulation.getx"><code>getx</code></a>: Must be defined.</li><li><a href="../points/#DelaunayTriangulation.gety"><code>gety</code></a>: Must be defined.</li><li><a href="../points/#DelaunayTriangulation.getxy"><code>getxy</code></a>: Uses the <a href="../points/#DelaunayTriangulation.getx"><code>getx</code></a> and <a href="../points/#DelaunayTriangulation.gety"><code>gety</code></a> definitions.</li></ul><p><strong>Collection of Points</strong></p><p>A collection of points simply stores many points. The  following methods are used for working with these collections; see their docstrings for more information.</p><ul><li><a href="../points/#DelaunayTriangulation.getpoint"><code>getpoint</code></a>: Must be defined.</li><li><a href="../points/#DelaunayTriangulation.get_point"><code>get_point</code></a>: This simply calls <a href="../points/#DelaunayTriangulation.getpoint"><code>getpoint</code></a>.</li><li><a href="../points/#DelaunayTriangulation.each_point_index"><code>each_point_index</code></a>: Must be defined. </li><li><a href="../points/#DelaunayTriangulation.each_point"><code>each_point</code></a>: Must be defined.</li><li><a href="../points/#DelaunayTriangulation.num_points"><code>num_points</code></a>: Must be defined.</li><li><a href="../points/#DelaunayTriangulation.points_are_unique"><code>points_are_unique</code></a>: Makes use of the existing methods.</li><li><a href="../points/#DelaunayTriangulation.lexicographic_order"><code>lexicographic_order</code></a>: Makes use of the existing methods.</li><li><a href="../points/#DelaunayTriangulation.number_type"><code>number_type</code></a>: Must be defined.</li></ul><p><strong>Boundary Nodes Interface</strong></p><p>Here we describe the interface used for representing the boundaries. As  described in <a href="../../data_structures/triangulation/#DelaunayTriangulation.Triangulation"><code>Triangulation</code></a>, this interface can be used for  representing either a collection of curves each made up of multiple  segments, a collection of segments, or a single continuous curve.  The following functions facilitate these possibilities; see the corresponding docstrings for more information.</p><ul><li><a href="../boundary_nodes/#DelaunayTriangulation.has_multiple_curves"><code>has_multiple_curves</code></a>: Must be defined. </li><li><a href="../boundary_nodes/#DelaunayTriangulation.has_multiple_segments"><code>has_multiple_segments</code></a>: Must be defined.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.num_curves"><code>num_curves</code></a>: Must be defined. </li><li><a href="../boundary_nodes/#DelaunayTriangulation.num_segments"><code>num_segments</code></a>: Must be defined.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.num_boundary_edges"><code>num_boundary_edges</code></a>: Must be defined. </li><li><a href="../boundary_nodes/#DelaunayTriangulation.getboundarynodes"><code>getboundarynodes</code></a>: Must be defined. </li><li><a href="../../data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}"><code>get_boundary_nodes</code></a>: This just calls <a href="../boundary_nodes/#DelaunayTriangulation.getboundarynodes"><code>getboundarynodes</code></a>.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.each_boundary_node"><code>each_boundary_node</code></a>: Must be defined.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>: Makes use of the existing methods.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>: Makes use of the existing methods.</li><li><a href="../../data_structures/triangulation/#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}"><code>map_boundary_index</code></a>: Makes use of the result from <a href="../boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.get_curve_index"><code>get_curve_index</code></a>: Makes use of the result from <a href="../boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.get_segment_index"><code>get_segment_index</code></a>: Makes use of the result from <a href="../boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><a href="../boundary_nodes/#DelaunayTriangulation.num_outer_boundary_segments"><code>num_outer_boundary_segments</code></a>: Makes use of the existing methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/39a62ab033be6f3fe43222c6b04611efcb5e733c/src/DelaunayTriangulation.jl#L143-L299">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../data_structures/triangulation/">« Triangulation</a><a class="docs-footer-nextpage" href="../triangles/">Triangles »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 25 February 2023 22:25">Saturday 25 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
