<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bowyer-Watson Algorithm · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/tri_algs/bowyer/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li class="is-active"><a class="tocitem" href>Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Triangulation Algorithms</a></li><li class="is-active"><a href>Bowyer-Watson Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bowyer-Watson Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/tri_algs/bowyer.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bowyer-Watson-Algorithm"><a class="docs-heading-anchor" href="#Bowyer-Watson-Algorithm">Bowyer-Watson Algorithm</a><a id="Bowyer-Watson-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Bowyer-Watson-Algorithm" title="Permalink"></a></h1><p>Here we will give a description of the Bowyer-Watson algorithm. This algorithm is the algorithm used by <code>triangulate</code>.</p><p>The main idea behind the algorithm is to insert points one at a time, deleting triangles at each step whose circumcircles contain the point to be inserted, then repairing the cavity. We give the procedure in steps below.</p><ol><li>First, using <code>initialise_bowyer_watson</code>, we need to define the initial triangle. This triangle will be the first three points in the provided <code>point_order</code> (which is, by default, just a random permutation of the point indices - see the <code>point_order</code> keyword argument in <code>triangulate_bowyer_watson</code> and the <code>get_point_order</code> function). If these first three points are collinear, we do a circular shift of the point order until we get a non-degenerate triangle. See <code>get_initial_triangle</code>. At this step, we also reset <code>DelaunayTriangulation.RepresentativePointList</code> and initialise it with <code>DelaunayTriangulation.BoundaryIndex</code> mapping to the centroid of this initial triangle.</li><li>Once the initial triangle is selected, we move into <code>_triangulate_bowyer_watson</code>, where we loop over each point and add it in one at a time. In this loop, we start by selecting the initial point to start the jump and march algorithm at, making use of <code>select_initial_point</code>. Since points are added in one at a time, and a user&#39;s insertion order may often have points that are close together both in the order and in space, the <code>try_last_inserted_point</code> keyword argument is useful here in case we can start right next to the new point. With this point selected, we move into actually adding the point via <code>add_point_bowyer_watson!</code>.</li><li>The <code>add_point_bowyer_watson!</code> starts by using <code>jump_and_march</code> to find a triangle containing the point. The idea is to then find all triangles whose circumcircles, i.e. the circle through the three points of the triangle, contain this new point. These points need to be deleted since, by definition, these triangles are no longer Delaunay. This is done via a depth-first search, where we take the triangle we are currently in and step over its three edges into three new triangles, done via the recursive function <code>dig_cavity!</code>. If the new triangle also contains the point in its circumcircle, we delete it also, and we keep stepping. We stop at any triangles that don&#39;t contain the point in its circumcircle. Once we have stopped, we take the edge we did not step over and connect it with the new point, giving us a new triangle. </li><li>Still in <code>add_point_bowyer_watson!</code>, an important case to consider is when the point we find is directly on the triangle we found. This does not cause any problems with <code>dig_cavity!</code>, but it may cause issues with how we update the boundary, so not only do we check if the point is on the triangle, but we also check that the triangle is either a boundary triangle or a ghost triangle (meaning the edge is on the boundary). If this is the case, then we find the edge of the triangle that the point is on with <code>find_edge</code>, and split the edge in half at the point, placing the new point correctly on the boundary and giving two new triangles.</li><li>Lastly, still in <code>add_point_bowyer_watson!</code>, we use <code>update_centroid_after_addition!</code> to update the centroid of the points with the new point.</li><li>Steps 2–5 are repeated for each new point, until we have finally added all points. Once this is done, we compute the convex hull of the points with <code>convex_hull!</code>, stepping over the boundary using the ghost triangles from the triangulation to get all the boundary nodes efficiently.</li><li>Next, if the keyword argument <code>recompute_representative_point</code> is true, we can give a better representative point for the central part of the domain than the centroid by computing the pole of inaccessibility. This is done with <code>compute_representative_points!</code>.</li><li>Finally, to clean up, we can delete all ghost triangles (if the keyword argument <code>delete_ghosts</code> is true) with <code>delete_ghost_triangles!</code>. Then, if the keyword argument <code>delete_empty_features</code> is true, we can delete all keys from the <code>Adjacent</code> map that map to empty values with <code>clear_empty_features!</code>, which would also clean up empty sets from the <code>Adjacent2Vertex</code> map and empty neighbourhoods from the <code>Graph</code>.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../triangulations/plotting/">« Plotting</a><a class="docs-footer-nextpage" href="../../boundary_handling/">Ghost Triangles and Boundary Handling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 25 February 2023 22:25">Saturday 25 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
