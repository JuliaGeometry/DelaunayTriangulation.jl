var documenterSearchIndex = {"docs":
[{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/bowyer/#Bowyer-Watson-Algorithm","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"","category":"section"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"Here we will give a description of the Bowyer-Watson algorithm. This algorithm is the algorithm used by triangulate.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"The main idea behind the algorithm is to insert points one at a time, deleting triangles at each step whose circumcircles contain the point to be inserted, then repairing the cavity. We give the procedure in steps below.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"First, using initialise_bowyer_watson, we need to define the initial triangle. This triangle will be the first three points in the provided point_order (which is, by default, just a random permutation of the point indices - see the point_order keyword argument in triangulate_bowyer_watson and the get_point_order function). If these first three points are collinear, we do a circular shift of the point order until we get a non-degenerate triangle. See get_initial_triangle. At this step, we also reset DelaunayTriangulation.RepresentativePointList and initialise it with DelaunayTriangulation.BoundaryIndex mapping to the centroid of this initial triangle.\nOnce the initial triangle is selected, we move into _triangulate_bowyer_watson, where we loop over each point and add it in one at a time. In this loop, we start by selecting the initial point to start the jump and march algorithm at, making use of select_initial_point. Since points are added in one at a time, and a user's insertion order may often have points that are close together both in the order and in space, the try_last_inserted_point keyword argument is useful here in case we can start right next to the new point. With this point selected, we move into actually adding the point via add_point_bowyer_watson!.\nThe add_point_bowyer_watson! starts by using jump_and_march to find a triangle containing the point. The idea is to then find all triangles whose circumcircles, i.e. the circle through the three points of the triangle, contain this new point. These points need to be deleted since, by definition, these triangles are no longer Delaunay. This is done via a depth-first search, where we take the triangle we are currently in and step over its three edges into three new triangles, done via the recursive function dig_cavity!. If the new triangle also contains the point in its circumcircle, we delete it also, and we keep stepping. We stop at any triangles that don't contain the point in its circumcircle. Once we have stopped, we take the edge we did not step over and connect it with the new point, giving us a new triangle. \nStill in add_point_bowyer_watson!, an important case to consider is when the point we find is directly on the triangle we found. This does not cause any problems with dig_cavity!, but it may cause issues with how we update the boundary, so not only do we check if the point is on the triangle, but we also check that the triangle is either a boundary triangle or a ghost triangle (meaning the edge is on the boundary). If this is the case, then we find the edge of the triangle that the point is on with find_edge, and split the edge in half at the point, placing the new point correctly on the boundary and giving two new triangles.\nLastly, still in add_point_bowyer_watson!, we use update_centroid_after_addition! to update the centroid of the points with the new point.\nSteps 2–5 are repeated for each new point, until we have finally added all points. Once this is done, we compute the convex hull of the points with convex_hull!, stepping over the boundary using the ghost triangles from the triangulation to get all the boundary nodes efficiently.\nNext, if the keyword argument recompute_representative_point is true, we can give a better representative point for the central part of the domain than the centroid by computing the pole of inaccessibility. This is done with compute_representative_points!.\nFinally, to clean up, we can delete all ghost triangles (if the keyword argument delete_ghosts is true) with delete_ghost_triangles!. Then, if the keyword argument delete_empty_features is true, we can delete all keys from the Adjacent map that map to empty values with clear_empty_features!, which would also clean up empty sets from the Adjacent2Vertex map and empty neighbourhoods from the Graph.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/point_location/#Point-Location","page":"Point Location","title":"Point Location","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The most expensive step for building a Delaunay triangulation is the point location step, wherein we need to find a triangle that contains a given point. The code for this turns out to be very complicated so that we can correctly handle points outside of the domain, inside interior holes, collinear with other points, on the corner, etc. The main function that handles all of this is jump_and_march, derived from the jump-and-march algorithm of Mücke, Saias, and Zhu (1999). We also provide a method that simply searches over all triangles, given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"brute_force_search","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.brute_force_search","page":"Point Location","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q)\n\nGiven a point q, finds the triangle in the triangulation tri containing it by  searching over all triangles.\n\n\n\n\n\nbrute_force_search(T, r, pts, boundary_map)\n\nGiven a collection of triangles T, a point r, a collection of points  pts, and a boundary map handling the mapping of boundary indices from  construct_boundary_map, returns the triangle in T containing r  by searching over all triangles.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#The-Main-Method","page":"Point Location","title":"The Main Method","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Below we list docstrings for the main jump and march algorithm.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"jump_and_march ","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.jump_and_march","page":"Point Location","title":"DelaunayTriangulation.jump_and_march","text":"jump_and_march(tri::Triangulation, q;\n    m=default_num_samples(num_points(tri)),\n    point_indices=each_point_index(tri),\n    try_points=(),\n    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),\n    check_existence::C=Val(has_multiple_segments(tri)),\n    rng::AbstractRNG=Random.default_rng())\n\nUsing the jump and march algorithm, finds the triangle in the triangulation tri containing the  query point q.\n\nArguments\n\ntri: The Triangulation.\nq: The query point.\n\nKeyword Arguments\n\nm=default_num_samples(num_points(pts)): The number of samples to use when sampling an initial point from select_initial_point. Only relevant if k is not specified. \npoint_indices: The indices for the points. Only relevant if k is not specified. \ntry_points=(): Extra points to try when sampling an initial point from select_initial_point. Only relevant if k is not specified. \nk=select_initial_point(pts, q; m, point_indices, try_points): Where to start the algorithm.\ncheck_existence::C=Val(has_multiple_segments(tri)): Whether to check that the edge exists when using get_adjacent, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See get_adjacent.\n\nOutput\n\nReturns the triangle V containing the query point q.\n\n\n\n\n\njump_and_march(pts, adj, adj2v, graph::Graph{I}, boundary_index_ranges, boundary_map, q;\n    m=default_num_samples(num_points(pts)),\n    point_indices=each_point_index(pts),\n    try_points=(),\n    k=select_initial_point(pts, q; m, point_indices, try_points),\n    TriangleType::Type{V}=NTuple{3,I},\n    check_existence::C=Val(has_multiple_segments(boundary_map)),\n    rng::AbstractRNG = Random.default_rng()) where {I,V,C}\n\nUsing the jump and march algorithm, finds the triangle in the triangulation containing the  query point q.\n\nIf your triangulation does not have ghost triangles, and the point q is outside of the triangulation,  this function may fail to terminate. You may like to add ghost triangles in this case (using  add_ghost_triangles!), noting that there is no actual triangle that q is inside  when it is outside of the triangulation unless ghost triangles are present. \n\nArguments\n\npts: The collection of points.\nadj: The Adjacent map.\ngraph::Graph{I}: The Graph.\nboundary_index_ranges: The Dict mapping boundary indices to ranges from construct_boundary_index_ranges.\nboundary_map: The boundary map from construct_boundary_map handling the mapping of boundary indices. \nq: The query point.\n\nKeyword Arguments\n\nm=default_num_samples(num_points(pts)): The number of samples to use when sampling an initial point from select_initial_point. Only relevant if k is not specified. \npoint_indices: The indices for the points. Only relevant if k is not specified. \ntry_points=(): Extra points to try when sampling an initial point from select_initial_point. Only relevant if k is not specified. \nk=select_initial_point(pts, q; m, point_indices, try_points): Where to start the algorithm.\nTriangleType::Type{V}=NTuple{3,I}: The type used for representing the triangles. \ncheck_existence::C=Val(has_multiple_segments(boundary_map)): Whether to check that the edge exists when using get_adjacent, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See get_adjacent.\n\nOutput\n\nReturns the triangle V containing the query point q.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The variant of the jump and march algorithm for points outside of the triangle is also accessed via the jump_and_march, calling into exterior_jump_and_march:","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"exterior_jump_and_march","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.exterior_jump_and_march","page":"Point Location","title":"DelaunayTriangulation.exterior_jump_and_march","text":"exterior_jump_and_march(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E}\n\nGiven a collection of points pts, an Adjacent map adj, a Dict mapping boundary indices to ranges from  construct_boundary_index_ranges, a boundary map  from construct_boundary_map, a vertex k, and a point q outside of  the triangulation, returns the edge (i, j) such that the ghost triangle  (i, j, -1) contains q. \n\nThe check_existence argument is used to check that the edge exists when using get_adjacent,  helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See get_adjacent.\n\nThe result is meaningless if q is inside of the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"You should not need to call into this method directly.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The core complexity of the algorithm comes from having to find the direction of the point from an initial search point. The docstrings for some of these initialisers are given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"select_initial_point \nselect_initial_triangle_interior_node \ncheck_for_intersections_with_adjacent_boundary_edges\nsearch_down_adjacent_boundary_edges\ncheck_for_intersections_with_interior_edges_adjacent_to_boundary_node","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_point","page":"Point Location","title":"DelaunayTriangulation.select_initial_point","text":"select_initial_point(pts, q;\npoint_indices=each_point_index(pts),\nm=default_num_samples(length(point_indices)),\ntry_points=(),\nrng::AbstractRNG = Random.default_rng())\n\nGiven a collection of points and a point q, select m random points from pts  and return the index i that corresponds a point get_point(pts, i) closest to q,  out of all indices in point_indices and try_points. The indices are randomly  selected from point_indices, but you can guarantee points to try using  try_points. \n\nIf q is an integer, then the point compared to becomes get_point(pts, q).\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_triangle_interior_node","page":"Point Location","title":"DelaunayTriangulation.select_initial_triangle_interior_node","text":"select_initial_triangle_interior_node(pts, adj::Adjacent, adj2v::Adjacent2Vertex, boundary_map, k, q, boundary_index_ranges, check_existence::V = Val(has_multiple_segments(boundary_map)), rng::AbstractRNG = Random.default_rng()) where {V}\n\nSelects an initial triangle for the jump-and-march algorithm, starting from a point with index k and  searching for the point q. The point q should be contained within the outermost boundary (interior  holes are fine), and k should not be a point on the outer boundary.\n\nArguments\n\npts: The collection of points. \nadj: The Adjacent map.\nadj2v: The Adjacent2Vertex map.\nboundary_map: The map taking boundary indices to their boundary segment location. See construct_boundary_map.\nk: The index of the point in pts that we are starting at.\nq: The point being searched for.\nboundary_index_ranges: The Dict handling the mapping of boundary indices from construct_boundary_index_ranges.\ncheck_existence::V=Val(has_multiple_segments(boundary_map))): Checks for different possible boundary indices when there are multiple segments. See get_adjacent.\n\nOutputs\n\np: The kth point in pts. \ni, j: These are indices defining the edge of a triangle including the point p, such that i is to the left of the line pq and j is to the right of pq.\npᵢ, pⱼ: The points in pts corresponding to the indices in i and j, respectively.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","text":"check_for_intersections_with_adjacent_boundary_edges(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, check_existence::V = Val(has_multiple_segments(boundary_map))) where {I,E,V}\n\nGiven a collection of points pts, an Adjacent map adjacent, a list of boundary index ranges from construct_boundary_index_ranges, a boundary map from construct_boundary_map, an outer boundary point k, and a query point q,  checks the edges adjacent to k along the outer boundary for q.\n\nThe check_existence argument is the same keyword argument from get_adjacent, and is needed when you use multiple segments in your boundary.\n\nSee also search_down_adjacent_boundary_edges, which uses this function to determine an initial direction  to search along a straight boundary in case q is collinear with it.\n\nThe possible returned values are: \n\n(Certificate.Outside, Certificate.Outside, k)\n\nHere, the point q is not collinear with either of the adjacent boundary edges.\n\n(Certificate.Right, C, r), where C is either Certificate.On or Certificate.Right and r is the vertex to the right of k, i.e. get_adjacent(adj, k, -1)\n\nThis output means that q is collinear with the edge to the right of k. C = Certificate.On  means it is on this edge, while C = Certificate.Right means that q is to the right of this edge.\n\n(Certificate.Left, C, ℓ), where C is either Certificate.On or Certificate.Left and ℓ is the vertex to the left of k, i.e. get_adjacent(adj, -1, k)\n\nThis output means that q is collinear with the edge to the left of k. C = Certificate.On  means it is on this edge, while C = Certificate.Left means that q is to the left of this edge.\n\nIn these two outputs above, C could also mean Certificate.Degenerate, which means that q is get_point(pts, r) or get_point(pts, ℓ),  respectively.\n\nIn addition to these three returned values, the fourth and fifth returned values are (right_cert, left_cert), which give the  position of q relative to the edges (p, p_right) and (p, p_left), respectively, where p_right is the point on the boundary  to the right and p_left is the point on the boundary to the left of p. These returned values are useful in case we need  to go to check_for_intersections_with_interior_edges_adjacent_to_boundary_node, since we can reuse these certificates.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.search_down_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.search_down_adjacent_boundary_edges","text":"search_down_adjacent_boundary_edges(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, direction, q_pos, next_vertex, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E,V}\n\nGiven a collection of points pts, an Adjacent map adj, a list of boundary index ranges from construct_boundary_index_ranges, a boundary map from construct_boundary_map, an outer boundary index  k for a point in pts, a point q being searched for, a direction giving the direction of q from get_point(pts, k), a certificate for the position of q from this point, and the next vertex in the direction of q (these last three arguments  coming from check_for_intersections_with_adjacent_boundary_edges), walks down the edges that q is  collinear with until an edge is found that q is on or until finding that q is outside of the triangulation. \n\nThe returned value takes the form (cert, u, v, w), with cert = Certificate.On if q is on the edge (u, v) and  cert = Certificate.Outside if q is outside of the triangulation. If is_on(cert), then (u, v, w) is a positively  oriented triangle with q on the edge (u, v). Otherwise, (u, v, w) is a ghost triangle that should be close to q.\n\nThe check_existence argument is the same keyword argument from get_adjacent, and is needed when you use multiple segments in your boundary.\n\nNote that this function relies on the assumption that the geometry is convex.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","text":"check_for_intersections_with_interior_edges_adjacent_to_boundary_node(pts, adj::Adjacent{I,E}, graph::Graph{I}, boundary_index_ranges, boundary_map, k, q, right_cert, left_cert, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E,V}\n\nChecks if the line connecting the kth point of pts to q intersects any of the edges neighbouring the boundary node k.\n\nThis function should only be used after check_for_intersections_with_adjacent_boundary_edges, and currently is only guaranteed  to work on convex geometries. \n\nArguments\n\npts: The collection of points. \nadj::Adjacent{I,E}: The Adjacent map.\ngraph::Graph{I}: The Graph.\nboundary_index_ranges: The boundary index range mapping from construct_boundary_index_ranges.\nboundary_map: The map that handles the mapping of boundary indices to boundary segments. Sse construct_boundary_map.\nk: The boundary node.\nq: The point we are searching for. \nright_cert: A certificate giving the position of q to the right of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\nleft_cert: A certificate giving the position of q to the left of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\ncheck_existence::V=Val(has_multiple_segments(boundary_nodes))): Checks for different possible boundary indices when there are multiple segments. See get_adjacent.\n\nOutputs\n\nThere are several possible forms for the returned values. These are listed below, letting p be the kth point, pᵢ the point corresponding to  the index i, and pⱼ the point corresponding to the index j:\n\n(i, j, Certificate.Single, Certificate.Outside)\n\nThe line pq intersects the edge pᵢpⱼ, and (j, i, k) is a positively oriented triangle. In particular, pᵢ is left of pq and pⱼ is right of pq.\n\n(i, j, Certificate.None, Certificate.Inside)\n\nThe point q is inside the positively oriented triangle (i, j, k).\n\n(zero(I), zero(I), Cert.None, Cert.Outside)\n\nThe point q is outside of the triangulation.\n\n(i, j, Cert.On, Cert.Inside)\n\nThe point q is on the edge pᵢpⱼ, and so is inside the positively oriented triangle (i, j, k).\n\n(i, j, Cert.Right, Cert.Outside)\n\nThe point q is collinear with the edge pᵢpⱼ, but is off of it and further into the triangulation. \n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#Basic-Description-of-the-Algorithm","page":"Point Location","title":"Basic Description of the Algorithm","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us give a basic description of what jump_and_march does.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"First, using select_initial_point, an initial point to start the algorithm is selected. This function samples some number m of points, and then selects the point that is closest to the query point q.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let the initially selected point be p_k. We break the discussion into two cases, where p_k is an interior point and p_k is a point on the boundary.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"If p_k is not a point on the boundary, then it is possible to completely rotate around the point searching for a triangle such that line overrightarrowp_kq intersects an edge of the triangle. This will give us an edge e_ij that overrightarrowp_kq intersects, and we will put p_i to the left of overrightarrowp_kq and p_j to the right. The function that handles this selection is select_initial_triangle_interior_node, which starts by handling the case of collinear edges and then rotates around. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now suppose that p_k is a point on the outer boundary. There are several possibilities in this case. First, overrightarrowp_kq might intersect a neighbouring boundary edge; secondly, overrightarrowp_kq could intersect a neighbouring interior edge; thirdly, overrightarrowp_kq could point away from the boundary, meaning q is outside of the boundary. The function starts by checking the neighbouring boundary edges, done via check_for_intersections_with_adjacent_boundary_edges, making use of get_right_boundary_node and get_left_boundary_node to obtain the neighbouring boundary nodes. If we find that overrightarrowp_kq does intersect a neighbouring boundary edge, then we can search down adjacent boundary edges via search_down_adjacent_boundary_edges until we either find an edge that q is on, or until we identify that q is outside of the triangulation – this function assumes the domain is convex, as triangulations being built are. If q is outside of the triangulation, then we can use the exterior variant of the jump and march algorithm, exterior_jump_and_march, to find the ghost triangle containing q. This functon simply rotates around the boundary until we find two ghost edges enclosing the point q. Now let us assume we did not find a neighbouring boundary edge that intersects overrightarrowp_kq. When this happens, we need to check the neighbouring interior edges, done via check_for_intersections_with_interior_edges_adjacent_to_boundary_node, which just rotates around the edges until we find an intersection. If we have still not found any intersection then, again assuming convexity, q must be outside of the triangulation and so we use exterior_jump_and_march.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now, if the algorithm is still going, then we need to start marching along the triangulation from p_k towards q. The idea is to keep marching, keeping p_i and p_j to the left and right of overrightarrowp_kq, respectively, until we find a case where p_ip_jq is no longer a positively oriented triangle. When this happens, it must mean that we have passed q, and so we have found the triangle. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us describe how this marching is done in more detail. First, we need to be careful of boundary indices, first checking for an outer boundary index. If we have found an outer boundary index, then we have marched into the boundary, and so q will be outside of the domain, meaning we go into exterior_jump_and_march. If this is not the case, then we march using get_adjacent to step onto the next triangle from a given edge e_ij. Then, checking the positions of the new points relative to overrightarrowp_kq and rearranging accordingly, we can step forward. We keep doing this until we get a negatively oriented triangle p_ip_jq. Unfortunately, this loop could terminate even if q is not in the found triangle, which can occasionally happen if p_ip_jq is a degenerate triangle. In this case, we just restart the jump and march algorithm. This latter worry is a very rare concern and does not alter the runtime in any significant manner.","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"In the code below, we given an example of how we can provide a fully customised interface for cosntructing an unconstrained triangulation. ","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"using DelaunayTriangulation\nusing CairoMakie \n\n## Define the new types\nDT = DelaunayTriangulation\nstruct CustomPoint\n    x::Float64\n    y::Float64\nend\nDT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\n\nstruct CustomPoints\n    pts::Vector{CustomPoint}\nend\nDT.each_point_index(pts::CustomPoints) = eachindex(pts.pts)\nDT.num_points(pts::CustomPoints) = length(pts.pts)\nDT.each_point(pts::CustomPoints) = pts.pts\nDT.getpoint(pts::CustomPoints, n::Integer) = pts.pts[n]\nDT.number_type(::Type{CustomPoints}) = Float64\n\nstruct CustomEdge\n    i::Int32\n    j::Int32\nend\nDT.construct_edge(::Type{CustomEdge}, i, j) = CustomEdge(i, j)\nDT.initial(edge::CustomEdge) = edge.i\nDT.terminal(edge::CustomEdge) = edge.j\n\nstruct CustomEdges\n    edges::Vector{CustomEdge}\nend\nDT.initialise_edges(::Type{CustomEdges}) = CustomEdges(CustomEdge[])\nDT.add_to_edges!(edges::CustomEdges, e) = push!(edges.edges, e)\nDT.each_edge(edges::CustomEdges) = edges.edges\nDT.delete_from_edges!(edges::CustomEdges, e) = deleteat!(edges.edges, findfirst(==(e), edges.edges))\nDT.num_edges(edges::CustomEdges) = length(edges.edges)\nDT.is_empty(edges::CustomEdges) = isempty(edges.edges)\n\nstruct CustomTriangle\n    i::Int32\n    j::Int32\n    k::Int32\nend\nDT.geti(T::CustomTriangle) = T.i\nDT.getj(T::CustomTriangle) = T.j\nDT.getk(T::CustomTriangle) = T.k\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\nDT.integer_type(::Type{CustomTriangle}) = Int32\n\nstruct CustomTriangles\n    tris::Set{CustomTriangle}\nend\nDT.initialise_triangles(::Type{CustomTriangles}) = CustomTriangles(Set{CustomTriangle}())\nBase.sizehint!(tris::CustomTriangles, n) = sizehint!(tris.tris, n)\nDT.triangle_type(::Type{CustomTriangles}) = CustomTriangle\nDT.add_to_triangles!(tris::CustomTriangles, T) = push!(tris.tris, T)\nDT.num_triangles(tris::CustomTriangles) = length(tris.tris)\nDT.delete_from_triangles!(tris::CustomTriangles, T) = delete!(tris.tris, T)\nBase.in(T, V::CustomTriangles) = T ∈ V.tris\nDT.each_triangle(tris::CustomTriangles) = tris.tris\n\n## Triangulate\nx = rand(100)\ny = rand(100)\npts = CustomPoints(CustomPoint.(x, y))\ntri1 = triangulate(pts;\n    IntegerType=Int32,\n    EdgeType=CustomEdge,\n    EdgesType=CustomEdges,\n    TriangleType=CustomTriangle,\n    TrianglesType=CustomTriangles)\ntri2 = triangulate(pts)\n\nfig = Figure(fontsize=24)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\",aspect=1,width=300,height=300)\ntriplot!(ax, tri1; show_convex_hull=true, convex_hull_linewidth=4)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\",aspect=1,width=300,height=300)\ntriplot!(ax, tri2; show_convex_hull=true, convex_hull_linewidth=4)\nresize_to_layout!(fig)","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"(Image: A triangulation)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/gmsh/#Gmsh","page":"Gmsh","title":"Gmsh","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"We provide Gmsh support, making it possible to represent more complicated meshes. The discussion that follows assume you have installed Gmsh, and defined a corresponding GMSH_PATH. I have used the default,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> GMSH_PATH = \"./gmsh-4.11.1-Windows64/gmsh.exe\"","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The methods for generating meshes with Gmsh are shown below.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"generate_mesh","category":"page"},{"location":"triangulations/gmsh/#DelaunayTriangulation.generate_mesh","page":"Gmsh","title":"DelaunayTriangulation.generate_mesh","text":"generate_mesh(x, y, ref;\n    mesh_algorithm=6,\n    gmsh_path=\"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity=0,\n    convert_result=true,\n    add_ghost_triangles=false)\n\nUsing Gmsh, generates a mesh of the domain defined by (x, y). \n\nArguments\n\nx, y\n\nThese are the coordinates defining the curves that define the boundaries of the domain. All  curves are to be positively oriented, meaning the outermost boundary should be counter-clockwise  while the interior boundaries should be clockwise.\n\nThere are three accepted forms for x, y:\n\n– Vector{Vector{Vector{Float64}}}: Multiple holes \n\nThis form for x and y will separate the generated domain into separate curves,  where (x[1], y[1]) is the outer-most boundary and the remaining parts of x and y define holes inside the domain. In general, (x[m][n], y[m][n]) is the  nth segment of the mth curve. It is assumed that x[m][n][end] == x[m][n+1][begin], and that x[m][end][end] == x[m][begin][1], i.e. separate segments have shared endpoints. Similar conditions hold for y. In this case, (x[1], y[1]) should define a counter-clockwise  curve while (x[m], y[m]) should be a clockwise curve for m > 1.\n\n– Vector{Vector{Float64}}: One boundary, multiple segments \n\nThis form for x and y uses just one boundary, but splits the boundary into multiple  segments as described above. As in the case above, separate segments should have shared  endpoints. In this case, the boundary should be provided counter-clockwise.\n\n– Vector{Float64}: One boundary, one segment \n\nThis form for x and y uses just one boundary, and assumes the boundary is one  continuous segment. It is assumed that x[begin] == x[end] and similarly for y. The boundary  should be provided counter-clockwise.\n\nref\n\nThis is the refinement parameter - smaller ref means more elements. \n\nKeyword Arguments\n\nmesh_algorithm=6\n\nThe algorithm to use for meshing. 6 means Frontal-Delaunay.\n\ngmsh_path=\"./gmsh-4.11.1-Windows64/gmsh.exe\"\n\nThe location of the gmsh executable.\n\nverbosity=0\n\nThe verbosity level for Gmsh.\n\nconvert_result=true\n\nIf true, the final result is converted into a Triangulation type. Otherwise,  (triangles, points, boundary_nodes) is returned.\n\nadd_ghost_triangles=false\n\nIf convert_result, then this declares whether or not ghost triangles should be added when  converting the result into a Triangulation type. See also Triangulation.\n\nOutputs\n\nIf convert_result, then the final result is a Triangulation type. Otherwise,  the following values are returned:\n\nelements\n\nThe triangular elements for the mesh. \n\nnodes\n\nThe nodes in the mesh. \n\nboundary_nodes\n\nThe boundary nodes in the mesh. All boundaries are positively oriented relative to the interior,  meaning the outermost boundary is counter-clockwise while the interior boundaries are clockwise.\n\nThe form of boundary_nodes matches the form of x and y, i.e. (also  including matching endpoints):\n\n– Vector{Vector{Vector{Float64}}}\n\nIn this case, boundary_nodes[m][n] give the indices in nodes  corresponding to the boundary specified by (x[m][n], y[m][n]). The nodes  boundary_nodes[1] define a counter-clockwise curve, while boundary_nodes[m] is clockwise for m > 1.\n\n– Vector{Vector{Float64}}\n\nIn this case, boundary_nodes[n] gives the indices in nodes  corresponding to the boundary specified by (x[n], y[n]). The boundary nodes  define a counter-clockwise curve in this case.\n\n– Vector{Float64}\n\nIn this case, boundary_nodes gives the indices in nodes  corresponding to the boundary specified by (x, y). The boundary nodes  define a counter-clockwise curve in this case.\n\nExtended help\n\nThe function proceeds in four steps:\n\nMesh generation\n\nHere, we write a file \"meshgeometry.geo\" in the working directory. This file takes the form\n\nr = ref;\nMesh.Algorithm = mesh_algorithm; \nMesh.Format = 1;\nGeneral.Verbosity = 0;\nPoint(<point index>) = {<x>, <y>, 0, r}; # For each point\nLine(<line index>) = {<initial point>, <final point>}; # For each line \nCurve Loop(<boundary index>) = {<line 1>, <line 2>, ...}; # For each boundary \nPlane Surface(1) = {<curve 1>, <curve 2>, ...}; # <curve 1> = 1 and is the outermost boundary, while <curve i> = i, i > 1, are boundaries of interior holes \nPhysical Curve(<last line index + i>) = {<line 1>, <line 2>, ...}; # For i ranging over the number of segments, and the lines represent that segment \nPhysical Surface(1) = {1};\n\nMost importantly, every edge input into the function generate_mesh will be included in the mesh. An  older version of this function previously used cubic splines for defining boundary curves, but this  has the consequence that (1) not every edge put into the function is included, and (2) the boundary  is not exactly represented. \n\nThe function that handles this generation is write_gmsh.\n\nMesh writing \n\nThe \"meshgeometry.geo\" file is then used to mesh the domain, running the terminal command \n\ngmsh_path \"meshgeometry.geo\" -2 -format msh2\n\nThis creates a file \"meshgeometry.msh\" in the same working directory. \n\nThe function that handles this writing is run_gmsh.\n\nMesh reading \n\nOnce \"meshgeometry.msh\" is created, we need to read it. The format used (MeshFormat) is  2.2, but note that as of writing (13/01/2013), the most modern format is 4.1.\n\nThe \"meshgeometry.msh\" file is split into groups:\n\n3a. MeshFormat \n\nThis just reads off the format of the file used. This part of the file  is read using read_mesh_format!.\n\n3b. Nodes \n\nThis lists the node indices and all the coordinates of the nodes, with the  first line giving the number of nodes. A single line in this section,  after the first, takes the form \n\n<node index> <x> <y> 0\n\nand we read this using read_node_line. This entire part of the file  is read using read_nodes!.\n\n3c. Elements \n\nThe first line in this part of the file is the number of elements, though  here elements refer to both the lines and the triangles. The lines (edges)  are listed first, with each line taking the form \n\n<line index> 1 2 <boundary index> <> <left node> <right node>\n\nand will be in counter-clockwise order. After the lines are listed, all the triangles follow, with each line in this part taking the form\n\n<triangle index> 2 2 1 1 <node 1> <node 2> <node 3>\n\nwith each triangle positively oriented. These lines are read using  read_element_line. The entire part of the file is read using  read_elements!.\n\nConversion to Triangulation\n\nOnce the file \"meshgeometry.geo\" has been read, we have a list of  triangular elements, nodes, and boundary nodes. These need to all be  converted into a Triangulation type, and a constructor of  Triangulation is used to accomplish this.\n\n\n\n\n\ngenerate_mesh(a, b, c, d, ref; \n    mesh_algorithm=6,\n    gmsh_path=\"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity=0,\n    single_boundary=true,\n    convert_result=true,\n    add_ghost_triangles=false)\n\nGenerates a mesh of a rectangle [a, b] × [c, d]. Use single_boundary=true if  each side of the rectangle should be treated the same, and single_boundary=false if  you want boundary nodes for each side of the rectangle\n\nSee the main function generate_mesh for a description of the other  arguments.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let's give some examples. ","category":"page"},{"location":"triangulations/gmsh/#Example-I:-Contiguous-boundary","page":"Gmsh","title":"Example I: Contiguous boundary","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us mesh a domain with a single non-segmented boundary curve. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\na = 4 / 5\nt = LinRange(0, 2π, 100)\nx = @. a * (2cos(t) + cos(2t))\ny = @. a * (2sin(t) - sin(2t))\ntri = generate_mesh(x, y, 0.1)\ntri2 = generate_mesh(x, y, 1.0)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $ Dense mesh\", titlealign=:left)\ntriplot!(ax, tri)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $  Coarse mesh\", titlealign=:left)\ntriplot!(ax, tri2)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"In the figure, the red curve shows the convex hull. We note that we now have information in tri.boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n178-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  ⋮\n 97\n 98\n 99\n  1","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Similarly, tri.boundary_map is now populated:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Vector{Int64}} with 1 entry:\n  -1 => [1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1]","category":"page"},{"location":"triangulations/gmsh/#Example-II:-Single-boundary-curve-with-multiple-segments","page":"Gmsh","title":"Example II: Single boundary curve with multiple segments","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us now give an example where we still have just a single boundary curve, but we split it into multiple segments. Importantly, each segment must be counter-clockwise and join with the previous segment.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\n# The first segment \nt = LinRange(0, 1 / 4, 25)\nx1 = cos.(2π * t)\ny1 = sin.(2π * t)\n# The second segment \nt = LinRange(0, -3, 25)\nx2 = collect(t)\ny2 = repeat([1.0], length(t))\n# The third segment \nt = LinRange(1, 0, 25)\nx3 = -3.0 .+ (1 .- t) .* sin.(t)\ny3 = collect(t)\n# The fourth segment \nt = LinRange(0, 1, 25)\nx4 = collect(-3.0(1 .- t))\ny4 = collect(0.98t)\n# The fifth segment \nx5 = [0.073914, 0.0797, 0.1522, 0.1522, 0.2, 0.28128, 0.3659, 0.4127, 0.3922, 0.4068, 0.497, 0.631, 0.728, 0.804, 0.888, 1.0]\ny5 = [0.8815, 0.8056, 0.80268, 0.73258, 0.6, 0.598, 0.5777, 0.525, 0.4346, 0.3645, 0.3032, 0.2886, 0.2623, 0.1367, 0.08127, 0.0]\n# Now combine the vectors \nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\n# Mesh \ntri = generate_mesh(x, y, 0.05)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=600, height=300)\ntriplot!(ax, tri)\ncolors = [:red, :blue, :orange, :purple, :darkgreen]\nbn_map = get_boundary_map(tri)\nfor (i, segment_index) in enumerate(values(bn_map))\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    lines!(ax, get_points(tri)[:, bn_nodes], color=colors[i], linewidth=4)\nend\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"An important feature to note for this case is that the index now used to refer to boundaries is no longer constant. In particular, the nth segment will map to -n, as we can verify using:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Int64} with 5 entries:\n  -1 => 1\n  -2 => 2\n  -3 => 3\n  -4 => 4\n  -5 => 5","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This map makes it simple to iterate over all parts of a boundary, as we show in the above code when plotting.","category":"page"},{"location":"triangulations/gmsh/#Example-III:-Multiple-boundaries","page":"Gmsh","title":"Example III: Multiple boundaries","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Now let us give a more complicated example, meshing a multiply-connected domain. In this case, we provide the outer-most boundary in a counter-clockwise order, while all the inner boundaries are in a clockwise order.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\nx1 = [collect(LinRange(0, 2, 4)),\n    collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 0, 4)),\n    collect(LinRange(0, 0, 4))]\ny1 = [collect(LinRange(0, 0, 4)),\n    collect(LinRange(0, 6, 4)),\n    collect(LinRange(6, 6, 4)),\n    collect(LinRange(6, 0, 4))]\nr = 0.5\nh = k = 0.6\nθ = LinRange(2π, 0, 50)\nx2 = [h .+ r .* cos.(θ)]\ny2 = [k .+ r .* sin.(θ)]\nr = 0.2\nh = 1.5\nk = 0.5\nx3 = [h .+ r .* cos.(θ)]\ny3 = [k .+ r .* sin.(θ)]\nx4 = reverse(reverse.([collect(LinRange(1, 1.5, 4)),\n    collect(LinRange(1.5, 1.5, 4)),\n    collect(LinRange(1.5, 1, 4)),\n    collect(LinRange(1, 1, 4))]))\ny4 = reverse(reverse.([collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 5, 4)),\n    collect(LinRange(5, 5, 4)),\n    collect(LinRange(5, 2, 4))]))\nx5 = [reverse([0.2, 0.5, 0.75, 0.75, 0.2, 0.2])]\ny5 = [reverse([2.0, 2.0, 3.0, 4.0, 5.0, 2.0])]\nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\ntri = generate_mesh(x, y, 0.2)\nfig, ax, sc = triplot(tri; show_ghost_edges=true, convex_hull_linestyle=:solid, convex_hull_linewidth=4)\nxlims!(ax, -0.5, 2.5)\nylims!(ax, -0.5, 6.5)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_3.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The blue edges show the interpretation of the ghost edges (you can delete via delete_ghost_triangles! if you want). For the outer boundary, these edges are pointing away from the interior, collinear with a point in the center, as we can obtain via:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_representative_point_coordinates(1, Float64)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"or, alternatively,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.RepresentativePointList\nDict{Int64, DelaunayTriangulation.RepresentativeCoordinates{Int64, Float64}} with 5 entries:\n  5 => RepresentativeCoordinates{Int64, Float64}(0.475, 3.5, 0)\n  4 => RepresentativeCoordinates{Int64, Float64}(1.25, 3.5, 0)\n  2 => RepresentativeCoordinates{Int64, Float64}(0.6, 0.6, 0)\n  3 => RepresentativeCoordinates{Int64, Float64}(1.5, 0.5, 0)\n  1 => RepresentativeCoordinates{Int64, Float64}(1.5, 1.5, 0)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The keys are the indices for the boundary curve. These coordinates are visual centers, obtained via the pole of inaccessibility function; see the sidebar. For the inner boundaries, the ghost edges are no longer infinite and so they connect directly with these representative coordinates.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"To access more of the boundary information, we could first consider boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n5-element Vector{Vector{Vector{Int64}}}:\n [[1, 128, 129, 130, 2, 131, 132, 133, 3, 134, 135, 136, 4], [4, 137, 138, 139, 140, 141, 142, 143, 144, 145  …  155, 156, 157, 158, 159, 160, 161, 162, 163, 7], [7, 164, 165, 166, 8, 167, 168, 169, 9, 170, 171, 172, 10], [10, 173, 174, 175, 176, 177, 178, 179, 180, 181  …  191, 192, 193, 194, 195, 196, 197, 198, 199, 1]]\n [[13, 14, 15, 16, 17, 18, 19, 20, 21, 22  …  53, 54, 55, 56, 57, 58, 59, 60, 61, 13]]\n [[62, 63, 64, 65, 66, 67, 68, 69, 70, 71  …  102, 103, 104, 105, 106, 107, 108, 109, 110, 62]]\n [[111, 200, 201, 202, 203, 112, 204, 205, 206, 207, 113, 208, 209, 210, 211, 114], [114, 115, 116, 117], [117, 212, 213, 214, 215, 118, 216, 217, 218, 219, 119, 220, 221, 222, 223, 120], [120, 121, 122, 111]]  \n [[123, 224, 225, 226, 227, 228, 229, 230, 231, 232  …  246, 126, 247, 248, 249, 250, 251, 127, 252, 123]]","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This is simply a vector of curves, with each curve storing its segments. This vector itself does not tell us what boundary index corresponds to what segment of what curve, and this could be obtained from the boundary map:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Tuple{Int64, Int64}} with 11 entries:\n  -1  => (1, 1)\n  -2  => (1, 2)\n  -3  => (1, 3)\n  -4  => (1, 4)\n  -5  => (2, 1)\n  -6  => (3, 1)\n  -7  => (4, 1)\n  -8  => (4, 2)\n  -9  => (4, 3)\n  -10 => (4, 4)\n  -11 => (5, 1)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, the boundary index -8 comes from the second segment of the fourth curve. As before, this boundary map makes it simple to iterate over each segment as follows:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    nedges = num_boundary_edges(bn_nodes) # Note that nedges = length(bn_nodes) - 1\n    for edge_idx in 1:nedges \n        node = get_boundary_node(bn_nodes, edge_idx)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The form above is generic, and ignores the last part of each segment (since it is duplicated for the next segment). Of course, a version like","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    for i in bn_nodes\n        node = get_boundary_node(bn_nodes, i)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"(which includes the last part of each segment) could be used. It is up to you based on your interface how you prefer to write this. Notice also that in the previous example we used a similar style, using get_boundary_nodes(tri, segment_index) also. The function get_boundary_nodes can be used with either single integers or Tuples, making it simple to iterate with this exact pattern whether we have a contiguous boundary curve, a segmented boundary curve, or multiple boundaries. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"A last feature to note is tri.boundary_index_ranges, which will tell us what other boundary indices belong to a curve given a known boundary index for that curve. This can be useful if we want to rotate around a boundary curve based on a given boundary index (see e.g. how it is used in the get_left_boundary_node and get_right_boundary_node functions). This field is a major part of making point location work in these inner boundaries, making get_adjacent work properly in this case (see e.g. the code in _safe_get_adjacent).","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_index_ranges(tri)\nOrderedDict{Int64, UnitRange{Int64}} with 11 entries:\n  -1  => -4:-1\n  -2  => -4:-1\n  -3  => -4:-1\n  -4  => -4:-1\n  -5  => -5:-5\n  -6  => -6:-6\n  -7  => -10:-7\n  -8  => -10:-7\n  -9  => -10:-7\n  -10 => -10:-7\n  -11 => -11:-11","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, we see tha the boundary index -3 belongs to a curve that also has boundary indices -1, -2, and -4. If we wanted to go from a boundary index to the index for the curve, this is what the boundary map is also for:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_curve_index(tri, -3)\n1","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"boundary_handling/#Ghost-Triangles-and-Boundary-Handling","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"","category":"section"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"Here we will give a description about how we represent boundaries, and also how we use ghost triangles.","category":"page"},{"location":"boundary_handling/#Boundary-Indices","page":"Ghost Triangles and Boundary Handling","title":"Boundary Indices","text":"","category":"section"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"We use negative indices to denote vertices belonging to a boundary. For example, if tri is a triangulation and get_adjacent(adj, u, v) == -1, then this means that (u, v) is an edge on the boundary. We call this -1 a ghost vertex (positive vertices could also be called solid vertices), with -1 defined from DelaunayTriangulation.BoundaryIndex, which we discuss more in the next section.","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"In the case of a single contiguous outer boundary, having -1 as the only boundary index is simple and works fine. If we have multiple segments or multiple boundaries, then we need to somehow have multiple boundary indices so that we can refer to each segment separately. We accomplish this by simply subtracting 1 from the current boundary index for each new segment. This is handled by add_boundary_information!. For example, if we had","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"bn = [\n    [segment_1, segment_2, segment_3],\n    [segment_4, segment_5],\n    [segment_6],\n    [segment_7, segment_8, segment_9, segment_10]\n]","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"then the ith segment will map to -i. Note that this always means that -1 belongs to the outer-most boundary. There is a possible issue we can have with this when, for example, stepping around a boundary, since nodes will occur in two segments and hence nodes may not necessarily have a unique boundary index assigned to them. To handle this case, allowing us to check for all possible boundary indices when stepping around a boundary (or however else we might want to use Adjacent or similar), get_adjacent can call a safer version _safe_get_adjacent, which checks the boundary indices using boundary_index_ranges.","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"These issues are why the Triangulation data structure has the boundary_map and boundary_index_ranges fields. boundary_map, constructed with construct_boundary_map, is used to map a boundary index to its segment in the set of boundary nodes, so that get_boundary_nodes(boundary_nodes, map_boundary_index(boundary_map, g)) gives the nodes corresponding to the segment which has boundary index g. To handle the issue with a curve having multiple boundary indices, we use boundary_index_ranges, constructed with construct_boundary_index_ranges, to map a boundary index g to all other indices that could be found on the associated curve. For example, in the bn example above, -2 would map to -3:-1.","category":"page"},{"location":"boundary_handling/#Ghost-Triangles","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles","text":"","category":"section"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"Ghost triangles are a special triangle that has a solid edge (u, v) and a vertex g associated with some boundary index. These ghost triangles are needed to make point location actually work properly when points are outside of the triangle, provided we associate the ghost vertex g with a physical point. For the outer-most boundary, this physical point just has to be somewhat in the center of the domain, which we define using a centroid when building the triangulation and the pole of inaccessibility once we have built the entire triangulation. With this physical point, ghost edges (u, g) are then interpreted to be of infinite extent, pointing from u out to infinity, but collinear with this central point. ","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"In the case of an inner boundary, these ghost edges are of finite extent, simply connecting with the point g which is define via the pole of inaccessibility.","category":"page"},{"location":"boundary_handling/","page":"Ghost Triangles and Boundary Handling","title":"Ghost Triangles and Boundary Handling","text":"For the Bowyer-Watson algorithm, we need a definition for the circumcircle of a ghost triangle. For ghost triangles that belong to inner boundaries, we simply use the triangle that connects the points, since there is no issue with infinity here. For the outer ghost triangles, we need to be careful. Imagine taking a triangle and pulling away one of its vertices to infinity. The circumcircle would keep growing until it eventually covers the entire space on the side of the fixed edge that the point was on. In particular, the circle becomes the line through the fixed edge, dividing the plane into two half-planes. We then say that a point is in the circumcircle of an outer ghost triangle if it is in the open half-plane on the other side of the edge from the triangulation, or if it is on the edge itself (but is not one of the vertices). The union of the open half-plane and this open edge is called the outer half-plane of the edge.","category":"page"},{"location":"interface/points/","page":"Points","title":"Points","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/points/#Individual-Points","page":"Points","title":"Individual Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"Points are assumed to take the form (x, y), but we allow for customisation in how we represent these points. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getx \ngety ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getx","page":"Points","title":"DelaunayTriangulation.getx","text":"getx(p::P) where {P}\n\nGiven a point p, returns the x-coordinate. The  only methods currently defined are\n\ngetx(p::NTuple{N,T}) where {N,T}\ngetx(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.gety","page":"Points","title":"DelaunayTriangulation.gety","text":"gety(p::P) where {P}\n\nGiven a point p, returns the y-coordinate. The  only methods currently defined are\n\ngety(p::NTuple{N,T}) where {N,T}\ngety(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getxy ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getxy","page":"Points","title":"DelaunayTriangulation.getxy","text":"getxy(p)\n\nGiven a point p, returns (getx(p), gety(p)).\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Collection-of-Points","page":"Points","title":"Collection of Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"A collection of points simply store many points. It does not need to be mutable (this may change in the future if we support mesh refinement, but it will only be needed in that case). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods-2","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getpoint \neach_point_index \neach_point\nnum_points \nnumber_type ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getpoint","page":"Points","title":"DelaunayTriangulation.getpoint","text":"getpoint(pts::P, i)\n\nGiven a collection of points pts, returns a Tuple  of the x and y coordinates of the ith point in  the collection. The methods currently defined are \n\ngetpoint(pts::AbstractVector, i)\ngetpoint(pts::AbstractMatrix, i)\n\nYou can extend this function as you need. \n\nIt is assumed that whenever i is not an integer, i is meant to be  a point, so (getx(i), gety(i)) would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point_index","page":"Points","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(pts::P) where {P}\n\nGiven a collection of points pts, returns an iterator  over the indices of the collection. The methods currently  defined are \n\neach_point_index(pts::AbstractVector)\neach_point_index(pts::AbstractMatrix)\n\nwith the first returning eachindex(pts) and the second  returning axes(pts, 2). You can extend this function  as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point","page":"Points","title":"DelaunayTriangulation.each_point","text":"each_point(pts::P) where {p}\n\nFor a given collection of points p, returns an iterator that  goes over each point in the collection. The methods currently  defined are \n\neach_point(pts::AbstractVector)\neach_point(pts::AbstractMatrix)\n\nwith the first method simply returning pts, and the second returning  eachcol(pts). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.num_points","page":"Points","title":"DelaunayTriangulation.num_points","text":"num_points(pts)\n\nReturns the number of points in pts.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.number_type","page":"Points","title":"DelaunayTriangulation.number_type","text":"number_type(::Triangulation{P}) where {P}\n\nGiven a triangulation tri, returns the type used for representing  individual coordinates.\n\n\n\n\n\nnumber_type(x)\n\nGiven a container x, returns the number type used for storing coordinates.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods-2","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"get_point \npoints_are_unique \nlexicographic_order ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.get_point","page":"Points","title":"DelaunayTriangulation.get_point","text":"get_point(pts::P, i...)\n\nGiven a collection of points pts, returns the points  corresponding to the indices in i.... This simply  calls getpoint - you do not need to  extend this method. \n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.points_are_unique","page":"Points","title":"DelaunayTriangulation.points_are_unique","text":"points_are_unique(pts)\n\nReturns true if pts has no duplicate points, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.lexicographic_order","page":"Points","title":"DelaunayTriangulation.lexicographic_order","text":"lexicographic_order(pts)\n\nReturns a set of indices idx that gives the lexicographic ordering  of the set of points pts, i.e. sorting by x and then sorting points  with duplicate x-coordinates by y. The implementation is simply \n\nlexicographic_order(pts) = (sortperm ∘ collect ∘ each_point)(pts)\n\nwhich you might want to specialise for an easier representation of your  points pts.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/boundary_nodes/#Boundary-Nodes","page":"Boundary Nodes","title":"Boundary Nodes","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"As mentioned at the start of this section, the interface for representing boundary nodes allows for support for a contiguous boundary, a segmented boundary, and multiple separate boundaries. This interface is customisable, and we define the following methods for this.","category":"page"},{"location":"interface/boundary_nodes/#Necessary-Methods","page":"Boundary Nodes","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"has_multiple_curves \nhas_multiple_segments \nnum_curves \nnum_segments \nnum_boundary_edges \ngetboundarynodes \neach_boundary_node ","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn defines multiple curves,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_curves(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_curves(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_curves(::A) where {F<:Number,A<:AV{F}}\n\nwith the first method returning true, while the last two methods return false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn contains multiple segments,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_segments(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_segments(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_segments(::A) where {F<:Number,A<:AV{F}}\n\nwith the first and second methods returning true, while the last method returns false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.num_curves","text":"num_curves(bn::A)\n\nReturns the number of curves defined by the boundary nodes bn. We currently  define the methods\n\nnum_curves(bn::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}}\n\nwhich simply returns bn.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_segments","text":"num_segments(bn::A)\n\nReturns the number of segments defined by the boundary nodes bn. We currently  define the method\n\nnum_segments(bn::AA) where {F<:Number,A<:AV{F},AA<:AV{A}}\n\nwhich simply returns length(bn).\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_boundary_edges","page":"Boundary Nodes","title":"DelaunayTriangulation.num_boundary_edges","text":"num_boundary_edges(bn)\n\nGiven a collection of boundary nodes bn, returns the number of edges. This only  needs to be defined for individual segments. We define the method \n\nnum_boundary_edges(bn::A) where {A<:AbstractVector}\n\nwhich returns length(bn) -1 (-1 because it is assumed that bn[begin] == bn[end]).  This is the only method that needs to be extended.\n\nSee also getboundarynodes.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.getboundarynodes","page":"Boundary Nodes","title":"DelaunayTriangulation.getboundarynodes","text":"getboundarynodes(bn::A, mnℓ...)\n\nGiven a collection of boundary nodes bn, returns the specified component of the  collection. There are several forms for the methods. In these methods, it is assumed  that one-based indexing is used for accessing all the boundary nodes. If you want to  use offsets, for example, then define getboundarynodes appropriately (e.g. maybe  getboundarynodes(bn, m) could map m to m-4 if 4 is your offset).\n\nThe methods that you need to define are those that go down a level, i.e. from a set of curves  to a curve, from a set of segments to a set of nodes, and from a set of nodes to a node. Of course,  if you only ever use e.g. a set of nodes, then you need only define that method. The methods that  we define for this are\n\ngetboundarynodes(bn::AAA, m::Integer) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \ngetboundarynodes(bn::AA, n::Integer) where {F<:Number,A<:AV{F},AA<:AV{A}} \ngetboundarynodes(bn::A, ℓ::Integer) where {F<:Number,A<:AV{F}}\n\nThe first method takes a set of curves to the mth curve, the second takes a set of segments to the  nth segment, and the third takes a set of nodes to the ℓth node. These are the only methods  that need to be extended. For the set of curves case, we also define\n\ngetboundarynodes(bn, m::Integer, n::Integer)\ngetboundarynodes(bn, (m, n)::NTuple{2,Integer})\n\nwhich calls getboundarynodes(getboundarynodes(bn, m), n). This does not need to be extended. Lastly,  we also define \n\ngetboundarynodes(bn::A, ::A) where {A}\n\nwhich simply returns bn. This is useful when using the result of construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.each_boundary_node","page":"Boundary Nodes","title":"DelaunayTriangulation.each_boundary_node","text":"each_boundary_node(bn::A)\n\nReturns an iterator that goes over each node in bn. Only defined for  single segments so that bn acts like a vector of numbers. The only method  currently defined is \n\neach_boundary_node(bn::A) where {F<:Number,A<:AbstractVector{F}}\n\nwhich just returns bn. You can extend this function as you need. If you really  want to loop over every boundary node, you can make use of the result from  construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#Generic-Methods","page":"Boundary Nodes","title":"Generic Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"get_boundary_nodes(::Any, ::Vararg{Any})\nconstruct_boundary_map \nconstruct_boundary_index_ranges \nmap_boundary_index(::Any, ::Any) \nget_curve_index \nget_segment_index \nnum_outer_boundary_segments ","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_boundary_nodes-Tuple{Any, Vararg{Any}}","page":"Boundary Nodes","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(bn, mnℓ...)\n\nGet the boundary nodes from bn corresponding to the specified indices.  See getboundarynodes.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_map","text":"construct_boundary_map(bn; IntegerType::Type{I} = Int64) where {I}\n\nGiven a set of boundary nodes bn, returns a OrderedDict that maps boundary indices  to their position in bn. In particular:\n\nhas_multiple_curves(bn)\n\nIn this case, the result is a dict = OrderedDict{I, NTuple{2, I}}. The results will be of the form  dict[i] = (m, n), so that boundary indices with value i correspond to nodes at  get_boundary_nodes(bn, m, n), i.e. the nth segment of the mth curve.\n\nhas_multiple_segments(bn)\n\nIn this case, the result is a dict = OrderedDict{I, I}. The results will be of the form dict[i] = n, so that boundary indices with value i correspond to nodes at get_boundary_nodes(bn, n), i.e.  the nth segment.\n\nelse\n\nHere, the result is a dict = OrderedDict{I, F}, mapping -1 back to bn and F = typeof(bn).\n\nIteration Tips\n\nThis dict can be useful for iterating over all boundary nodes. For example, you could do\n\nbn_map = construct_boundary_map(bn)\nfor segment_index in values(bn_map)\n    nodes = get_boundary_nodes(bn, segment_index)\n    ## Do something with the nodes \nend \n\nThe above will work for any form of bn also.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_index_ranges","text":"construct_boundary_index_ranges(boundary_nodes; IntegerType::Type{I}=Int64) where {I}\n\nGiven a set of boundary_nodes, creates an OrderedDict that maps boundary indices  to the range of all boundary indices that the corresponding boundary curve could  correspond to. For example, suppose we have \n\njulia> boundary_nodes = [\n           [\n               [1, 2, 3, 4], [4, 5, 6, 1]\n           ],\n           [\n               [18, 19, 20, 25, 26, 30]\n           ],\n           [\n               [50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]\n           ]\n       ]\n\nThen the first curve, [[1, 2, 3, 4], [4, 5, 6, 1]] has boundary indices -1 and -2,  so the range would be -2:-1. The full Dict we obtain will be \n\njulia> construct_boundary_index_ranges(boundary_nodes)\nOrderedDict{Int64, UnitRange{Int64}} with 7 entries:\n  -1 => -2:-1\n  -2 => -2:-1\n  -3 => -3:-3\n  -4 => -7:-4\n  -5 => -7:-4\n  -6 => -7:-4\n  -7 => -7:-4\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.map_boundary_index-Tuple{Any, Any}","page":"Boundary Nodes","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(dict, i)\n\nGiven a dict from construct_boundary_map, returns dict[i]. Also works  for a dict from construct_boundary_index_ranges.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_curve_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(dict, i)\nget_curve_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the curve corresponding to that boundary index. The  second method maps i to 1 if it is an integer, and i[1] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_segment_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(dict, i)\nget_segment_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the segment corresponding to that boundary index. The  second method maps i to i if it is an integer, 1 if it is a vector,  and i[2] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_outer_boundary_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_outer_boundary_segments","text":"num_outer_boundary_segments(boundary_nodes)\n\nGiven a set of boundary_nodes, returns the number of segments  that correspond to the outer boundary. Note that this also gives  the range of outer boundary indices, i.e.  -1:-1:-num_outer_boundary_segments(boundary_nodes).\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"utils/#Other-Utilities","page":"Other Utilities","title":"Other Utilities","text":"","category":"section"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"Here are some docstrings for other utility functions.","category":"page"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"get_right_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nget_left_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nfind_edge(::Any, ::Any, ::Any)\nchoose_uvw(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\nis_circular \ncircular_equality","category":"page"},{"location":"utils/#DelaunayTriangulation.get_right_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nGiven an Adjacent map, a boundary node index k, a boundary_index corresponding to the curve,  and boundary_index_ranges from construct_boundary_index_ranges, returns the node on the boundary to the right of k. check_existence can be used if you need to check  over all outer boundary indices, in case there are multiple segments and thus multiple possible boundary indices  on the boundary.\n\nSee also get_left_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.get_left_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nGiven an Adjacent map, a boundary node index k, a boundary_index corresponding to the curve,  and boundary_index_ranges from construct_boundary_index_ranges, returns the node on the boundary to the left of k. check_existence can be used if you need to check  over all outer boundary indices, in case there are multiple segments and thus multiple possible boundary indices  on the boundary.\n\nSee also get_right_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.find_edge-Tuple{Any, Any, Any}","page":"Other Utilities","title":"DelaunayTriangulation.find_edge","text":"find_edge(T, points, ℓ)\n\nGiven a triangle T and a set of points points, with  the ℓth point of points on an edge of T, returns  the edge (u, v) that the point is on.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.choose_uvw-NTuple{6, Any}","page":"Other Utilities","title":"DelaunayTriangulation.choose_uvw","text":"choose_uvw(e1, e2, e3, u, v, w)\n\nChoose values for (u, v, w) based on the Booleans (e1, e2, e3),  assuming only one is true. The three cases are: \n\nIf e1, returns (u, v, w).\nIf e2, returns (v, w, u).\nIf e3, returns (w, u, v).\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.is_circular","page":"Other Utilities","title":"DelaunayTriangulation.is_circular","text":"is_circular(A)\n\nTests if A[begin] == A[end].\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.circular_equality","page":"Other Utilities","title":"DelaunayTriangulation.circular_equality","text":"circular_equality(A, B)\n\nTests if the arrays A and B are equal up to a circular shift.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/lattice/#Lattice-Triangulations","page":"Lattice","title":"Lattice Triangulations","text":"","category":"section"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"We provide a method for triangulation a lattice on some grid a b times c d with n_x times n_y points. The docstring for this method is given below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"triangulate_rectangle","category":"page"},{"location":"triangulations/lattice/#DelaunayTriangulation.triangulate_rectangle","page":"Lattice","title":"DelaunayTriangulation.triangulate_rectangle","text":"triangulate_rectangle(a, b, c, d, nx, ny;\n    single_boundary=false,\n    add_ghost_triangles=true,\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType}) where {I,E,V,Es,Ts}\n\nComputes a triangulation of the rectangular grid [a, b] × [c, d] with points (xᵢ, yⱼ),  i = 1, …, nx, j = 1, …, ny, where xᵢ = a + (i-1)(b-a)/(nx-1) and yⱼ = b + (j-1)(d-c)/(ny-1). If  the boundary of the rectangle should be considreed as one single boundary, use single_boundary = false, and if  you want the four sides of the boundary to be separated use single_boundary = true. \n\nReturns a Triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The single_boundary argument is useful if you want to, for example, have a boundary condition for the entire boundary or for each side of the boundary separately. ","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the single boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"a, b, c, d = 2.0, 10.0, -5.0, 7.5\nnx = 20\nny = 10\ntri = DT.triangulate_rectangle(a, b, c, d, nx, ny)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)\nxlims!(ax, a - 0.5, b + 0.5)\nylims!(ax, c - 0.5, d + 0.5)\nlines!(ax, tri.points[:, get_boundary_nodes(tri, 1)]; linewidth=4)\nlines!(ax, tri.points[:, get_boundary_nodes(tri, 2)]; linewidth=4)\nlines!(ax, tri.points[:, get_boundary_nodes(tri, 3)]; linewidth=4)\nlines!(ax, tri.points[:, get_boundary_nodes(tri, 4)]; linewidth=4)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The blue edges show the interpretation of the ghost edges.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the four boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"tri = DT.triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=true)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)\nxlims!(ax, a - 0.5, b + 0.5)\nylims!(ax, c - 0.5, d + 0.5)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"As defined in the data structures section, we have the ability for computing convex hulls. These can be computed outside of the triangulation process, using our implementation of Graham's scan. ","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"Here is an example.","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"pts = [Tuple(25randn(2)) for _ in 1:500]\nch = convex_hull(pts)\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, pts)\nlines!(ax, pts[ch.indices])","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"<figure>\n    <img src='../figs/convex_hull_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/pole_of_inaccessibility/#Pole-of-Inaccessibility-and-Polygons","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We provide a function for computing the pole of inaccessibility of a given polygon, namely the point inside the polygon that is furthest from the boundary. Our method is primarily based on this blogpost, recursively subdividing the polygon using quadtree partitioning. The function for this is pole_of_inaccessibility:","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pole_of_inaccessibility","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.pole_of_inaccessibility","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.pole_of_inaccessibility","text":"pole_of_inaccessibility(pts, boundary_nodes; precision = one(number_type(pts)))\n\nGiven a collection of points pts and a set of boundary_nodes defining  a polygon, finds the pole of inaccessibility. Works with holes, provided  boundary_nodes represents these as described in Interfaces.\n\nThe pole of inaccessibility is a point within a polygon that is further from an  edge. It is useful for our purposes since it is a representative point that is  guaranteed to be inside the polygon, in contrast to for example a centroid which  is not always inside the polygon.\n\nYou can control the tolerance of the method using atol and rtol,  so that results are compared to atol + rtol * w, where w is half the  extent of the polygon.\n\nSee https://blog.mapbox.com/a-new-algorithm-for-finding-a-visual-center-of-a-polygon-7c77e6492fbc or https://github.com/mapbox/polylabel for more information. This implementation was partially based  on https://github.com/Twista/python-polylabel and https://github.com/asinghvi17/Polylabel.jl.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We needed this method since the point we need to associate ghost vertices with must be inside the domain, and so other representative points like centroids or arithmetic averages would not be sufficient if the domain is non-convex.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below we also list some other relevant docstrings.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"polygon_features \nsquared_distance_to_segment \ndistance_to_polygon \npolygon_bounds ","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_features","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(pts, boundary_nodes)\n\nGiven some points pts and a collection of boundary nodes, returns (a, (cx, cy)),  where a is the area of the polygon represented by the nodes and (cx, cy) is the centroid.  Works with holes, provided boundary_nodes represents these as described in Interfaces.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.squared_distance_to_segment","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.squared_distance_to_segment","text":"squared_distance_to_segment(x₁, y₁, x₂, y₂, x, y)\n\nGiven a line segment (x₁, y₁) → (x₂, y₂) and a query point  (x, y), returns the squared distance from (x, y) to the  line segment.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.distance_to_polygon","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.distance_to_polygon","text":"distance_to_polygon(q, pts, boundary_nodes)\n\nGiven a query point q, a collection of points pts, and a set of boundary_nodes,  returns the distance from q to the combined polygon. If q is outside of the polygon,  then the returned distance is negative, and if it is inside then the distance  is positive. Works with holes, provided boundary_nodes  represents these as described in Interfaces.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_bounds","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(pts, boundary_nodes)\n\nGiven a collection of points pts and boundary_nodes, to be interpreted as a polygon, returns  the coordinates for a bounding box of the polygon, in the order (xmin, xmax, ymin, ymax).  Works with holes, provided boundary_nodes represents these as described in Interfaces.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"If you need to compute this for multiple boundaries, meaning multiple poles, use compute_representative_points!.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"compute_representative_points!","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.compute_representative_points!","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0))\n\nGiven a triangulation tri, computes representative points for each region using  pole_of_inaccessibility. If you only want to update the point for the convex hull, set use_convex_hull = true - this will only update RepresentativePointList[1].\n\nSee also RepresentativePointList.\n\nwarning: Warning\nWhile this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like update_centroid_after_addition  and update_centroid_after_deletion treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of triangulate).\n\n\n\n\n\ncompute_representative_points!(points, boundary_nodes; precision = 1.0)\n\nGiven a list of points and a list of boundary_nodes, computes visual centers for  the polygons represented by these curves using pole_of_inaccessibility. The  keyword argument precision is the precision used in pole_of_inaccessibility.\n\nSee also RepresentativePointList.\n\nwarning: Warning\nWhile this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like update_centroid_after_addition  and update_centroid_after_deletion treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of triangulate).\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#Example","page":"Pole of Inaccessibility and Polygons","title":"Example","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below is a simple example of computing this pole of inaccessibility.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pts = [0.0 8.0\n      2.0 5.0\n      3.0 7.0\n      1.81907 8.13422\n      3.22963 8.865\n      4.24931 7.74335\n      4.50423 5.87393\n      3.67149 4.3784\n      2.73678 2.62795\n      5.50691 1.38734\n      8.43 2.74691\n      9.7046 5.53404\n      8.56595 7.79433\n      6.71353 9.03494\n      4.13034 9.66375\n      2.75378 10.3775\n      1.0883 10.4965\n      -1.138 9.83369\n      -2.25965 8.45712\n      -2.78649 5.94191\n      -1.39292 3.64763\n      0.323538 4.97322\n      -0.900078 6.6217\n      0.98633 9.68074\n      0.153591 9.54478\n      0.272554 8.66106\n      2.90673 8.18521\n      2.12497 9.42582\n      7.27436 2.7979\n      3.0 4.0\n      5.33697 1.88019]'\nboundary_nodes = [\n      [[1, 4, 3, 2], [2, 9, 10, 11, 8, 7, 12], [12, 6, 13, 5, 14, 15, 16, 17, 16], [16, 17, 18, 19, 20, 21, 22, 23, 1]],\n      [[26, 25, 24], [24, 28, 27, 26]],\n      [[29, 30, 31, 29]]\n]\nx, y = DT.pole_of_inaccessibility(pts, boundary_nodes)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\nbn1 = pts[:, unique(reduce(vcat, boundary_nodes[1]))] |> x -> hcat(x, x[:, begin])\nbn2 = pts[:, unique(reduce(vcat, boundary_nodes[2]))] |> x -> hcat(x, x[:, begin])\nbn3 = pts[:, unique(reduce(vcat, boundary_nodes[3]))] |> x -> hcat(x, x[:, begin])\nlines!(ax, bn1, color=:red, linewidth=4)\nlines!(ax, bn2, color=:red, linewidth=4)\nlines!(ax, bn3, color=:red, linewidth=4)\nscatter!(ax, [x], [y], color=:blue, markersize=23)","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/pole_of_inaccessibility.png', alt='Pole of inaccessibility'><br>\n</figure>","category":"page"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/edges/#Individual-Edges","page":"Edges","title":"Individual Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"Edges are assumed to take the form (i, j), with customisation available for how we represent (i, j). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"construct_edge \ninitial\nterminal","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.construct_edge","page":"Edges","title":"DelaunayTriangulation.construct_edge","text":"construct_edge(::Type{E}, i, j) where {E}\n\nConstructs an edge with indices (i, j) with the type E. The  following methods are currently defined:\n\nconstruct_edge(::Type{NTuple{2, I}}, i, j) where {I}\nconstruct_edge(::Type{A}, i, j) where {I,A<:AbstractVector}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.initial","page":"Edges","title":"DelaunayTriangulation.initial","text":"initial(e::E)\n\nGiven an edge e, returns the index for the initial point. The following  methods are currently defined:\n\ninitial(e::NTuple{2,I}) where {I}\ninitial(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.terminal","page":"Edges","title":"DelaunayTriangulation.terminal","text":"terminal(e::E)\n\nGiven an edge e, returns the index for the terminal point. The following  methods are currently defined:\n\nterminal(e::NTuple{2,I}) where {I}\nterminal(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"edge_indices ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.edge_indices","page":"Edges","title":"DelaunayTriangulation.edge_indices","text":"edge_indices(e)\n\nGiven an edge e, returns (initial(e), terminal(e)). \n\nSee also initial and terminal.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Collection-of-Edges","page":"Edges","title":"Collection of Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"A collection of edges simply stores many edges, and this collection must be mutable so that edges can be deleted added and deleted. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods-2","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"initialise_edges \nedge_type \nnum_edges \ncontains_edge \nadd_to_edges! \ndelete_from_edges! \neach_edge ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.initialise_edges","page":"Edges","title":"DelaunayTriangulation.initialise_edges","text":"initialise_edges(::Type{S})\n\nFor a given type S for some collection (e.g. a Set), returns an empty instance of that collection. The only method defined is\n\ninitialise_edges(::Type{S}) where {E, S <: Set{E}}\ninitialise_edges(::Type{A}) where {E, A <: AbstractVector{E}}\n\nwhich returns a Set{E}() or a A(), respectively. You can extend this  function as you need, making sure you extend it for the type rather than  for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.edge_type","page":"Edges","title":"DelaunayTriangulation.edge_type","text":"edge_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of edges,  returns the type of triangle used inside S, e.g. NTuple{2, Int64} if S = Set{NTuple{2, Int64}}. The only methods defined are \n\nedge_type(::Type{S}) where {E,S<:Set{E}}\nedge_type(::Type{A}) where {E,A<:AbstractVector{E}}\n\nwhich return E. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.num_edges","page":"Edges","title":"DelaunayTriangulation.num_edges","text":"num_edges(E::S) where {S}\n\nGiven a collection of edges E, returns the number of edges in E. The only method currently defined is \n\nnum_edges(E::Set)\n\nwhich returns length(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.contains_edge","page":"Edges","title":"DelaunayTriangulation.contains_edge","text":"contains_edge(e::E, Es::S) where {E, S}\n\nGiven a collection of edges Es of type S, containing edges of type E, checks if Es includes the edge e, returning true  if so. The methods currently defined are\n\ncontains_edge(e::E, Es::Set{E}) where {E} \ncontains_edge(e::E, Es::A) where {E,A<:AbstractVector{E}}\ncontains_edge(i, j, Es::E)\n\nThe first two methods simply return e ∈ E, while the latter constructs the edge e = (i, j) of type edge_type(E) and call the first two  methods. Only the method contains_edge(::E, ::Es) needs to be extended if you need,  the last method makes use of this definition.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.add_to_edges!","page":"Edges","title":"DelaunayTriangulation.add_to_edges!","text":"add_to_edges!(E::S, e) where {S}\n\nGiven a collection of edges E, pushes e into it. The only  methods currently defined are\n\nadd_to_edges!(E::Set, e)\nadd_to_edges!(E::Vector, e)\n\nwhich simply call push!(E, e). You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_from_edges!","page":"Edges","title":"DelaunayTriangulation.delete_from_edges!","text":"delete_from_edges!(E::S, e::F) where {S}\n\nGiven a collection of edges E of type S, containing  edges of type F, deletes the edge e from E.  The  methods currently defined are\n\ndelete_from_edges!(E::Set{F}, T::F) where {F}\ndelete_from_edges!(Es::A, e::E) where {E, A<:AbstractVector{E}}\n\nwhich just calls delete! on E in the first case, or filter!  in the second case. This is the form of the function that needs  to be extended. We also define \n\ndelete_from_edges!(Es::E, i::Integer, j::Integer) where {E}\n\nwhich constructs the edge (i, j) and then deletes it from Es, calling  the methods above. You do not need to extend this last method.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.each_edge","page":"Edges","title":"DelaunayTriangulation.each_edge","text":"each_edge(E::F) where {F}\n\nFor a given collection of edges E, returns an iterator that  goes over each edge in the collection. The methods currently  defined are \n\neach_edge(E::Set)\neach_edge(E::AbstractMatrix)\n\nwith the first method simply returning E, and the second returning  eachcol(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods-2","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"add_edge!\ndelete_edge!\nrandom_edge \nis_empty ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.add_edge!","page":"Edges","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(E, e...)\n\nGiven a collection of edges E, adds all the triangles e... into it.  To extend this method to other collections, see add_to_edges!.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_edge!","page":"Edges","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(E, e...)\n\nGiven a collection of edges E, deletes all the edges e... from it.  To extend this method to other collections, see delete_from_edges!.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.random_edge","page":"Edges","title":"DelaunayTriangulation.random_edge","text":"random_edge(E)\n\nReturns a random edge from edge set E.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.is_empty","page":"Edges","title":"DelaunayTriangulation.is_empty","text":"is_empty(E)\n\nTests if the edge set E is empty.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/unconstrained/#Unconstrained-Triangulations","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"","category":"section"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"It is simple to construct unconstrained triangulations. The method for this is through the triangulate function, shown below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangulate ","category":"page"},{"location":"triangulations/unconstrained/#DelaunayTriangulation.triangulate","page":"Unconstrained Triangulations","title":"DelaunayTriangulation.triangulate","text":"triangulate(points::P;\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    randomise=true,\n    delete_ghosts=true,\n    delete_empty_features=true,\n    try_last_inserted_point=true,\n    skip_points=Set{IntegerType}(),\n    num_sample_rule::M=default_num_samples,\n    rng::AbstractRNG=Random.default_rng(),\n    point_order=get_point_order(points, randomise, skip_points, IntegerType, rng),\n    recompute_representative_point=true\n) where {P,I,E,V,Es,Ts,M}\n\nComputes the unconstrained Delaunay triangulation of a set of points.\n\nArguments\n\npoints::P: The set of points to compute the triangulation of. \n\nKeyword Arguments\n\nIntegerType::Type{I}=Int64: The integer type to use for indexing. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type to use for representing edges. \nTriangleType::Type{V}=NTuple{3,IntegerType}: The type to use for representing triangles. \nEdgesType::Type{Es}=Set{EdgeType}: The type to use for representing collections of edges. \nTrianglesType::Type{Ts}=Set{TriangleType}: The type to use for representing collections of triangles. \nrandomise=true: Whether to randomise the insertion order. \ndelete_ghosts=true: Whether to remove the ghost triangles at the end of the triangulation. \ndelete_empty_features=true: Whether to delete any empty neighbourhoods and adjacencies at the end of the triangulation. \ntry_last_inserted_point=true: When finding the next point, this decides if the previously inserted point should also be attempted. \nskip_points=Set{IntegerType}(): Points to skip over when triangulationg, i.e. points to not include in the triangulation. \nnum_sample_rule: A function of the form n -> Number, with n the number of points currently in the triangulation, that returns the number of points to sample during the point location steps. \nrng::AbstractRNG=Random.default_rng(): The RNG to use.\npoint_order=get_point_order(points, randomise, skip_points, IntegerType, rng): The insertion order. \nrecompute_representative_point=true: At the end of the triangulation, will recompute the RepresentativePointList if true.\n\nOutputs\n\nReturns a Triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"In the code below, we give an example, and show how we can plot the result.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"using DelaunayTriangulation, CairoMakie \na = [1.5, 4.0]\nb = [0.0, 3.5]\nc = [2.0, 1.5]\nd = [3.0, 2.5]\ne = [2.5, 3.5]\nf = [0.5, 3.0]\ng = [2.5, -2.0]\nh = [0.5, 1.5]\ni = [0.0, 0.5]\nj = [1.5, 3.0]\npts = [a, b, c, d, e, f, g, h, i, j]\ntri = triangulate(pts)\nfig, ax, sc = triplot(tri)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"<figure>\n    <img src='../figs/small_example.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object tri is a Triangulation.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> tri\nDelaunay Triangulation.\n    Constrained: false\n    Has ghost triangles: false\n    Number of points: 10\n    Number of triangles: 12\n    Number of edges: 27","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"As we describe in more detail in the data structures section in the sidebar, tri has several fields:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> propertynames(tri)\n(:points, :triangles, :adjacent, :adjacent2vertex, :graph, :boundary_nodes, :boundary_map, :boundary_index_ranges, :constrained_edges, :convex_hull)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We explain each field below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.points: This stores pts.\ntri.triangles: This stores all the triangles. In this case,","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_triangles(tri)\nSet{Tuple{Int64, Int64, Int64}} with 12 elements:\n  (10, 5, 1)\n  (9, 7, 3)\n  (2, 6, 1)\n  (3, 10, 8)\n  (10, 4, 5)\n  (9, 3, 8)\n  (3, 4, 10)\n  (8, 6, 2)\n  (9, 8, 2)\n  (10, 1, 6)\n  (8, 10, 6)\n  (3, 7, 4)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"More generally, you can iterate over these triangles via each_triangle(tri). For example, the area of the triangulation could be computed as follows:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangle_area(p, q, r) = 0.5 * (p[1] * q[2] + q[1] * r[2] + r[1] * p[2] - p[1] * r[2] - r[1] * q[2] - q[1] * p[2])\nA = 0.0\nfor T in each_triangle(tri)\n    i, j, k = indices(T)\n    p, q, r = get_point(tri, i, j, k)\n    A += triangle_area(p, q, r)\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent: This stores the adjacency relationships of the triangulation, mapping edges (u, v) to a vertex w so that (u, v, w) is a positively oriented triangle in tri. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent(tri)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDataStructures.DefaultDict{Tuple{Int64, Int64}, Int64, Int64} with 43 entries:\n  (9, 3)  => 8\n  (8, 9)  => 3\n  (4, 7)  => -1\n  (2, 1)  => -1\n  (10, 1) => 6\n  (2, 8)  => 6\n  (10, 8) => 3\n  (3, 9)  => 7\n  (4, 5)  => 10\n  (8, 3)  => 10\n  (9, 8)  => 2\n  ⋮       => ⋮","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (uv, w) in get_adjacent(tri)\n    u = initial(uv)\n    v = terminal(uv)\n    ...\nend","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent2vertex: This is a map that returns, given an index i, all other edges (j, k) such that (i, j, k) is a positively oriented triangle in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent2vertex(tri)\nAdjacent{Int64, Set{Tuple{Int64, Int64}}, Tuple{Int64, Int64}}, with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 11 entries:\n  5  => Set([(10, 4), (1, 10)])\n  8  => Set([(9, 3), (2, 9), (6, 2), (3, 10), (10, 6)])\n  1  => Set([(6, 10), (10, 5), (2, 6)])\n  6  => Set([(1, 2), (2, 8), (10, 1), (8, 10)])\n  -1 => Set([(7, 9), (4, 7), (2, 1), (9, 2), (5, 4), (1, 5)])\n  9  => Set([(7, 3), (3, 8), (8, 2)])\n  3  => Set([(7, 4), (4, 10), (10, 8), (8, 9), (9, 7)])\n  7  => Set([(3, 9), (4, 3)])\n  4  => Set([(5, 10), (3, 7), (10, 3)])\n  2  => Set([(8, 6), (9, 8), (6, 1)])\n  10 => Set([(4, 5), (6, 8), (8, 3), (5, 1), (1, 6), (3, 4)])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g. ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (w, S) in get_adjacent2vertex(w)\n    for (u, v) in S \n        ...\n    end\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.graph: This is a graph that returns, given an index i, all other indices j such that (i, j) is an edge in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_graph(tri)\nGraph\n    Number of edges: 27\n    Number of vertices: 11\n\njulia> get_edges(tri)\nSet{Tuple{Int64, Int64}} with 27 elements:\n  (2, 9)\n  (4, 5)\n  (1, 2)\n  (6, 8)\n  (6, 10)\n  (3, 7)\n  (-1, 2)\n  (4, 7)\n  (3, 4)\n  (1, 5)\n  (-1, 9)\n  (4, 10)\n  (2, 8)\n  (-1, 5)\n  (1, 6)\n  (3, 9)\n  (7, 9)\n  ⋮\n\njulia> get_neighbours(tri)\nDict{Int64, Set{Int64}} with 11 entries:\n  5  => Set([4, -1, 10, 1])\n  8  => Set([6, 2, 10, 9, 3])\n  1  => Set([5, 6, 2, 10, -1])\n  6  => Set([2, 10, 8, 1])\n  -1 => Set([5, 4, 7, 2, 9, 1])\n  9  => Set([7, 2, -1, 8, 3])\n  3  => Set([4, 7, 10, 9, 8])\n  7  => Set([4, -1, 9, 3])\n  4  => Set([5, 7, -1, 10, 3])\n  2  => Set([6, -1, 9, 8, 1])\n  10 => Set([5, 4, 6, 8, 3, 1])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.boundary_nodes: This is a list of all fixed boundary nodes in the triangulation. In our case, we have none. See the Gmsh section for an example. The actual nodes on the boundary in this case can be obtained via tri.convex_hull.\ntri.boundary_map: This would be a list mapping boundary indices to all the fixed boundary nodes in tri.boundary_nodes corresponding to that index. This map is empty in this case as we have no fixed boundary nodes,, but see the Gmsh section for an example.\ntri.boundary_index_ranges: This is be a list mapping indices of boundary curves to all boundary indices belonging to that curve. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_boundary_index_ranges(tri)\nOrderedCollections.OrderedDict{Int64, UnitRange{Int64}} with 1 entry:\n  -1 => -1:-1","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This tells us that whenever we see a -1 as a vertex, we have a ghost vertex corresponding to the outer curve, so e.g. if get_adjacent(tri, u, v) == -1, then (u, v) is an edge on the boundary. A better example is in the Gmsh section.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.constrained_edges: This would be the collection of constrained edges if we had any.\ntri.convex_hull: This is the ConvexHull of tri.points. In this case, we have","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_convex_hull(tri)\nConvex hull.\n    Indices:\n7-element Vector{Int64}:\n 7\n 4\n 5\n 1\n 2\n 9\n 7","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/interface/#Interface","page":"General and Defaults","title":"Interface","text":"","category":"section"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"The package makes its simple for customing the interface used for defining points, edges, and triangles, as described in the docstring for Interfaces (see the end of this section). Without any customisation, the default forms are:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Edges: NTuple{2, Int64}.\nCollections of edges: Set{NTuple{2, Int64}}.\nTriangles: NTuple{3, Int64}.\nCollections of triangles: Set{NTuple{3, Int64}}","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also give support for customing how points are represented, and by default we support collections of points given as matrices (with each point its own column), or vectors of vectors. The number type used for representing coordinates has to be Float64 to support ExactPredicates.jl, although if you like you could customise orient_predicate and incircle_predicate, even circumventing ExactPredicates.jl if you like. See the predicates section in the sidebar for a further discussion of changing these predicate definitions.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also provide a customisable interface for representing boundary nodes, although for unconstrained triangulations this is relevant. By default, we support boundary nodes represented according to the following, where we let BN refer to the collection of boundary nodes:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Vector{Int64}: In this case, there is only one fixed boundary and it is represented as a contiguous set of nodes. We must have BN[begin] == BN[end], and the nodes must be listed in counter-clockwise order.\nVector{Vector{Int64}}: In this case, there is only one fixed boundary, but it is made up of separate segments, with BN[n] the nodes for the nth segment. This makes it possible to more easily support, for example, a domain with different boundary conditions on separate parts of the boundary. We must have BN[n][end] == BN[n+1][begin] and BN[end][end] == BN[begin][begin], and each segment must be listed in counter-clockwise order.\nVector{Vector{Vector{Int64}}}: In this case, there are multiple fixed boundaries, each of which are assumed to be made up of separate segments. This makes it possible to support multiply-connected domains, e.g. an annulus with each circle split into its lower and upper halves. Here, BN[m][n] is the set of nodes for the nth segment of the mth boundary curve, and BN[begin] the outer-most boundary curve and BN[m], m > 1, nodes for curves contained within BN[begin]. As in the previous case, BN[m][n][end] == BN[m][n+1][end] and BN[m][end][end] == BN[m][begin][begin] for each m. Moreover, BN[begin] should be a counter-clockwise list of nodes while BN[m] is a clockwise list of nodes for m > 1.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"For more information about how we handle boundaries, and how they are handled in our data structures, see the boundary handling section in the sidebar. ","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"The complete docstring that we use to also describe these interfaces is given below. (Accessible via ?Interfaces). See the next subsections for further detail.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Interfaces ","category":"page"},{"location":"interface/interface/#DelaunayTriangulation.Interfaces","page":"General and Defaults","title":"DelaunayTriangulation.Interfaces","text":"Interfaces\n\nThe main objects used throughout this package, namely  points, edges, triangles, and boundaries, have interfaces  that are fully customisable. We describe these interfaces  below, along with all the methods that need to be  defined. \n\nFor these interfaces, we define default methods that  support Tuples, AbstractVectors, etc., so you do not need to extend any of these for normal use. Moreover,  while we do allow for different index types to be using,  all still have to subtypes of Integer (for now?).\n\nTriangle Interface\n\nHere we describe the interface used for describing  triangles and collections of triangles. \n\nIndividual Triangles\n\nA triangle is assumed to be of the form (i, j, k), but the object used for storing these three indices  can be customised. The following methods are used for   working with triangles; see their docstrings for more  information.\n\nconstruct_triangle: Must be defined.\ngeti: Must be defined.\ngetj: Must be defined.\ngetk: Must be defined.\nindices: Uses the geti, getj, and getk definitions.\ninteger_type: Must be defined.\ntriangle_edges: Uses the geti, getj, and getk definitions.\nrotate_triangle: Uses the geti, getj, and getk definitions.\nconstruct_positively_oriented_triangle: Uses existing definitions.\ncompare_triangles: Uses the geti, getj, and getk definitions.\nsort_triangle: Uses the indices and construct_triangle definitions.\n\nCollection of Triangles\n\nA collection of triangles simply stores many triangles. The  following methods are used for working with these collections; see their docstrings for more information. Note that these collections  must be mutable.\n\ninitialise_triangles: Must be defined.\ntriangle_type: Must be defined. \nnum_triangles: Must be defined.\ncontains_triangle: This calls Base.in and contains_triangle.\nadd_to_triangles!: Must be defined. \nadd_triangle!: This simply calls add_to_triangles!.\ndelete_from_triangles!: Must be defined. \ndelete_triangle!: This simply calls delete_from_triangles!.\neach_triangle: Must be defined. \nBase.in: Must be defined.\nBase.sizehint!: Must be defined.\nBase.unique!: Must be defined, unless your collection is a Set.\ncompare_triangle_collections: Calls num_triangles, each_triangle, and contains_triangle.\nsort_triangles: Uses the initialise_triangles, each_triangle, sort_triangle, and add_triangle! definitions.\nremove_duplicate_triangles: Uses Base.unique!.\n\nNote that Triangulations also define each_solid_triangle and each_ghost_triangle.\n\nEdge Interface\n\nHere we describe the interface used for describing  edges and collections of edges. \n\nIndividual Edges\n\nAn edge is assumed to be of the form (i, j), but the object used for storing these two indices  can be customised. The following methods are used for   working with edges; see their docstrings for more  information.\n\nconstruct_edge: Must be defined. \ninitial: Must be defined. \nterminal: Must be defined. \nedge_indices: Uses the initial and terminal definitions.\n\nCollection of Edges\n\nA collection of edges simply stores many edges. The  following methods are used for working with these collections; see their docstrings for more information. Note that these collections  must be mutable.\n\ninitialise_edges: Must be defined. \nedge_type: Must be defined. \nnum_edges: Must be defined.\ncontains_edge: Must be defined.\nadd_to_edges!: Must be defined. \nadd_edge!: This simply calls add_to_edges!.\ndelete_from_edges!: Must be defined. \ndelete_edge!: This simply calls delete_from_edges!.\neach_edge: Must be defined. \nrandom_edge: Uses the each_edge definition.\nis_empty: Simply uses the isempty definition from Base.\n\nPoint Interface\n\nHere we describe the interface used for describing  points and collections of points.\n\nIndividual Points\n\nA point is assumed to be of the form (x, y), but the object used for storing these two coordinates  can be customised. The following methods are used for   working with points; see their docstrings for more  information.\n\ngetx: Must be defined.\ngety: Must be defined.\ngetxy: Uses the getx and gety definitions.\n\nCollection of Points\n\nA collection of points simply stores many points. The  following methods are used for working with these collections; see their docstrings for more information.\n\ngetpoint: Must be defined.\nget_point: This simply calls getpoint.\neach_point_index: Must be defined. \neach_point: Must be defined.\nnum_points: Must be defined.\npoints_are_unique: Makes use of the existing methods.\nlexicographic_order: Makes use of the existing methods.\nnumber_type: Must be defined.\n\nBoundary Nodes Interface\n\nHere we describe the interface used for representing the boundaries. As  described in Triangulation, this interface can be used for  representing either a collection of curves each made up of multiple  segments, a collection of segments, or a single continuous curve.  The following functions facilitate these possibilities; see the corresponding docstrings for more information.\n\nhas_multiple_curves: Must be defined. \nhas_multiple_segments: Must be defined.\nnum_curves: Must be defined. \nnum_segments: Must be defined.\nnum_boundary_edges: Must be defined. \ngetboundarynodes: Must be defined. \nget_boundary_nodes: This just calls getboundarynodes.\neach_boundary_node: Must be defined.\nconstruct_boundary_map: Makes use of the existing methods.\nconstruct_boundary_index_ranges: Makes use of the existing methods.\nmap_boundary_index: Makes use of the result from construct_boundary_map.\nget_curve_index: Makes use of the result from construct_boundary_map.\nget_segment_index: Makes use of the result from construct_boundary_map.\nnum_outer_boundary_segments: Makes use of the existing methods.\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"Operations","title":"Operations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"We define some specific operations for acting on Triangulations directly. These are listed below.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"add_boundary_information!(::Triangulation)\nadd_ghost_triangles!(::Triangulation)\nadd_point!(::Triangulation, ::Any)\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}\ndelete_ghost_triangles!(::Triangulation)\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}","category":"page"},{"location":"operations/#DelaunayTriangulation.add_boundary_information!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_boundary_information!","text":"add_boundary_information!(tri::Triangulation)\n\nGiven a Triangulation tri, adds boundary information into tri. In particular,  the Adjacent, Adjacent2Vertex, and Graph fields are updated so that e.g.  boundary edges map to a corresponding boundary index from Adjacent, boundary indices map  to sets of boundary edges from Adjacent2Vertex, and boundary indices map to boundary  nodes from Graph. \n\nNo values are returned.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_ghost_triangles!","text":"add_ghost_triangles!(tri::Triangulation)\n\nGiven a Triangulation tri, adds the ghost triangles into tri. In particular,  the triangles, [Adjacent](@ref), and [Adjacent2Vertex`](@ref) fields are updated so that  ghost triangles are stored in them.\n\nA ghost triangle is a triangle of the form (i, j, k) where only one of the indices, say i,  satisfies is_boundary_index(i).\n\nNo values are returned.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_point!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.add_point!","text":"add_point!(tri::Triangulation, new_point;\npoint_indices=get_vertices(tri),\nm=default_num_samples(length(point_indices)),\ntry_points=(),\ninitial_search_point=integer_type(tri)(select_initial_point(get_points(tri),\n                                                            new_point;\n                                                            point_indices,\n                                                            m,\n                                                            try_points)))\n\nAdds the point new_point into the triangulation.\n\nThis function will not update the convex hull - if you need it to  be corrected, you could use e.g. convex_hull!. You should  also be careful with using this if you have deleted ghost triangles.\n\nArguments\n\ntri::Triangulation: The triangulation. \nnew_point: The index of the point in get_points(tri) to add. \n\nKeyword Arguments\n\npoint_indices=get_vertices(tri): The currently inserted points in tri. \nm=default_num_samples(length(point_indices)): How many points to sample. \ntry_points(): Points to consider when sampling for point location. \ninitial_search_point=integer_type(tri)(select_initial_point(get_points(tri), new_point; point_indices, m, try_points))): Where to start the point location. \n\nOutputs\n\nThere are no outputs, but tri is updated in-place.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(tri::Triangulation, T; update_ghost_edges=false)\nadd_triangle!(tri::Ts, u::Integer, v::Integer, w::Integer; update_ghost_edges=false) where {Ts<:Triangulation}\n\nGiven a triangle T, or a triple of integers u, v, w, adds the triangle into  the Triangulation type tri, updating the Adjacent,  Adjacent2Vertex, Graph, and triangles fields.\n\nTo update the ghost triangles directly, set update_ghost_edges=true. The other parts of the  boundary information will be handled, though.\n\nNo values are returned.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.delete_ghost_triangles!","text":"delete_ghost_triangles!(tri::Triangulation)\n\nGiven a Triangulation tri, deletes the ghost triangles from tri. In particular,  the triangles, Adjacent, and Adjacent2Vertex fields are updated so that  ghost triangles are no longer stored in them.\n\nA ghost triangle is a triangle of the form (i, j, k) where one of the indices, say i,  satisfies is_boundary_index(i).\n\nNo values are returned.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(tri::Triangulation, T)\ndelete_triangle!(tri::Ts, u::Integer, v::Integer, w::Integer) where {Ts<:Triangulation}\n\nGiven a triangle T, or a triple of integers u, v, w, deletes the triangle from  the Triangulation type tri, updating the Adjacent,  Adjacent2Vertex, Graph, and triangles fields.\n\nNo values are returned.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"We represent convex hulls using a ConvexHull type, which is simply a type containing points and indices:","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"ConvexHull","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.ConvexHull","page":"Convex Hull","title":"DelaunayTriangulation.ConvexHull","text":"ConvexHull{P,I}\n\nStruct storing the results for a convex hull.\n\nFields\n\npoints::P\n\nThe complete set of points.\n\nindices::I\n\nIndices of points in points corresponding to the convex hull, in counter-clockwise order,  and indices[begin] == indices[end].\n\n\n\n\n\n","category":"type"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"For a triangulation, convex hulls are obtained from the unconstrained form, but if they need to be reconstructed then we can do so with a Graham scan.","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"convex_hull(::Any)","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.convex_hull-Tuple{Any}","page":"Convex Hull","title":"DelaunayTriangulation.convex_hull","text":"convex_hull(points; IntegerType::Type{I}=Int64) where {I}\n\nComputes the convex hull of points using Graham's scan. Returns a ConvexHull object.\n\nNote that if there are a trio of points on the convex hull that are collinear, they will  all be included, instead of only taking the endpoints of the collinear points.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/graph/#Graph","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"To make it possible to iterate over all points that share an edge with a given vertex, we have a Graph struct that we define as follows:","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"struct Graph{I}\n    graph::UndirectedGraph{I}\n    function Graph{I}() where {I}\n        G = UndirectedGraph{I}()\n        return new{I}(G)\n    end\n    Graph() = Graph{Int64}()\n    Graph(G::UndirectedGraph{I}) where {I} = new{I}(G)\nend","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Note that this graph is undirected. ","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Graph \nget_graph(::Graph)\nget_edges(::Graph)\nget_vertices(::Graph)\nget_neighbours(::Graph)\nget_neighbours(::Graph, ::Any)\nnum_neighbours(::Graph, ::Any)\nnum_edges(::Graph)\nadd_vertex!(::Graph{I}, ::Vararg{I,N}) where {I,N}\nadd_neighbour!(::Graph{I}, ::I, ::I) where {I}\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\nadd_triangle!(::Graph, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\ndelete_triangle!(::Graph, ::Any)\ndelete_neighbour!(::Graph, ::Any, ::Any)\ndelete_vertex!(::Graph, ::Any)\ndelete_boundary_vertices_from_graph!(::Graph{I}) where {I}\nclear_empty_points!(::Graph)","category":"page"},{"location":"data_structures/graph/#DelaunayTriangulation.Graph","page":"Graph","title":"DelaunayTriangulation.Graph","text":"Graph{I}\n\nStruct for storing neighbourhood relationships that map vertices  to all other vertices that share an edge with that vertex.  The type I is the integer type.\n\nSee the docs for a description of how boundary edges  are handled.\n\nFields\n\ngraph::UndirectedGraph{I}\n\nThe UndirectedGraph that maps a vertex u to a list of edges, V, such that (u, v) is an edge of the triangulation for each  v in V. \n\nConstructors\n\nThe graph can be constructed in three ways:\n\nGraph{I}() where {I}\n\nCreates an empty graph. \n\nGraph()\n\nCreates an empty graph with I = Int64.\n\nGraph(G::UndirectedGraph{I}) where {I}\n\nCreates a Graph from an existing UndirectedGraph.\n\nExtended help\n\nYou should not work with the graph field directly. We provide  the following functions for working with Graph, where G denotes  a Graph{I} type. (Type information in the function signatures  is omitted.)\n\nAccessors\n\nget_graph(G)\nget_vertices(G)\nget_edges(G)\nget_neighbours(G)\nget_neighbours(G, u)\n\nMutators\n\nadd_vertex!(G, u...)\nadd_neighbour!(G, u, v...)\nadd_triangle!(G, i, j, k) or add_triangle!(G, T)\nadd_triangle!(G, T...)\ndelete_triangle!(G, i, j, k) or delete_triangle!(G, T)\ndelete_triangle!(G, T...)\ndelete_neighbour!(G, u, v...)\ndelete_vertex!(G, u...)\ndelete_boundary_vertices_from_graph!(G)\nclear_empty_points!(G)\n\nMiscellaneous\n\nnum_edges(G)\nnum_neighbours(G, u)\n\n\n\n\n\n","category":"type"},{"location":"data_structures/graph/#DelaunayTriangulation.get_graph-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_graph","text":"get_graph(G::Graph)\n\nReturns the field graph of G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_edges","text":"get_edges(G::Graph)\n\nReturns all the edges of the graph G. Edges  are unordered.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(G::Graph)\n\nGiven a graph, returns the current set of vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph)\n\nReturns the set of neighbourhoods of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph, u)\n\nReturns the neighbourhood of the points u of  the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(G::Graph, u)\n\nReturns the number of neighbours of the point u  of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.num_edges","text":"num_edges(G::Graph)\n\nReturns the number of edges G. The edges  (i, j) and (j, i) will only be counted once.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_vertex!-Union{Tuple{N}, Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Vararg{I, N}}} where {I, N}","page":"Graph","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., adds these  vertices into G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, I, I}} where I","page":"Graph","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(G::Graph, u, v...)\n\nGiven a graph G, adds v... into the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, adds the triangle (i, j, k) into G. In particular, the  indices (i, j, k) are added into G, and the indices are all in each other's  neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, T...)\n\nAdds the triangles T... into the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, deletes the triangle (i, j, k) deletes G. In particular, the  indices (i, j, k) will no longer be neighbours of each other.\n\nBe careful with using this function - you could have a triangle (j, i, ℓ), say,  which will also be affected since the graph is undirected. Note also  that the vertices (i, j, k) will not be removed - only the neighbourhoods  are affected.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, T...)\n\nDeletes the triangles T... from the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_neighbour!-Tuple{DelaunayTriangulation.Graph, Any, Any}","page":"Graph","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(G::Graph, u, v...)\n\nGiven a graph G and a vertex u, deletes the vertices v... from the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_vertex!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., deletes the vertices from G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Union{Tuple{DelaunayTriangulation.Graph{I}}, Tuple{I}} where I","page":"Graph","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(G::Graph{I}) where {I}\n\nGiven a graph G, deletes all the boundary indices from G, i.e.  all u such that u ≤ -1.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.clear_empty_points!-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.clear_empty_points!","text":"clear_empty_points!(G::Graph)\n\nGiven a graph, deletes any points that have empty neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"predicates/#Predicates","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The predicates that we use in this package are all built from ExactPredicates.jl, avoiding degeneracies from predicates owing to floating point arithmetic. The results from predicates are based on certificates, coming from a Certificate type defined with EnumX.jl. The definition of this is below.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Certificate","category":"page"},{"location":"predicates/#DelaunayTriangulation.Certificate","page":"Predicates","title":"DelaunayTriangulation.Certificate","text":"Certificate\n\nAn Enum type that represents results from a geometric  predicate. Below we provide a list of available certificates,  along with the function that can be used for testing if a given  Certificate matches that certificate.\n\nInside: is_inside\nDegenerate: is_degenerate\nOutside: is_outside\nOn: is_on\nLeft: is_left\nRight: is_right\nPositivelyOriented: is_positively_oriented\nNegativelyOriented: is_negatively_oriented\nCollinear: is_collinear\nNone: is_none or has_no_intersections\nSingle: is_single or has_one_intersection\nMultiple: is_multiple or has_multiple_intersections\nTouching: is_touching\n\n\n\n\n\n","category":"module"},{"location":"predicates/#General","page":"Predicates","title":"General","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some general predicates. The core ones that all other predicates are based on are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"orient_predicate\nincircle_predicate ","category":"page"},{"location":"predicates/#DelaunayTriangulation.orient_predicate","page":"Predicates","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate(p, q, r)\n\nReturns ExactPredicates.orient(p, q, r).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.incircle_predicate","page":"Predicates","title":"DelaunayTriangulation.incircle_predicate","text":"incircle_predicate(a, b, c, p)\n\nReturns ExactPredicates.incircle(a, b, c, p).\n\n\n\n\n\n","category":"function"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The mathematical definitions for these predicates are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"orient_predicate: Let O(p q r) denote orient_predicate(p, q, r). The definition is ","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"O(p q r) = textsgnleft(beginvmatrix p_x - r_x  p_y - r_y  q_x - r_x  q_y - r_y endvmatrixright)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"With this definition, O(p q r)  0 means r is left of the line overrightarrowpq or that the triangle pqr is positively oriented; O(p q r) = 0 means r is collinear with overrightarrowpq or that the triangle pqr is degenerate; O(p q r)  0 means r is to the right of overrightarrowpq or that the triangle pqr is negatively oriented.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"incircle_predicate: Let O(p q r s) denote incircle_predicate(p, q, r, s). The definition is","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"O(p q r s) = textsgnleft(beginvmatrix \np_x - s_x  p_y - s_y  (p_x - s_x)^2 + (p_y - s_y)^2 \nq_x - s_x  q_y - s_y  (q_x - s_x)^2 + (q_y - s_y)^2 \nr_x - s_x  r_y - s_y  (r_x - s_x)^2 + (r_y - s_y)^2\nendvmatrixright)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"With this definition, O(p q r s)  0 means s is inside the circle through p, q, and r; O(pq r)=0 means s is cocircular with p, q, and r; O(p q r)  0 means s is outside the circle through p, q, and r.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"In code, these two predicates could be defined by (the actual definition with ExactPredicates.jl is much more involved):","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"_det(a, b, c, d) = a * d - b * c\n_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion \nfunction orient_predicate(a, b, c)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    o = _det(ax - cx, ay - cy, bx - cx, by - cy)\n    return Int(sign(o)) # need Int for xor\nend\nfunction incircle_predicate(a, b, c, d)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    dx, dy = getxy(d)\n    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,\n        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,\n        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)\n    return Int(sign(o)) # need Int for xor\nend","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"You could use this as a reference if you want to disconnect from using ExactPredicates.jl (or e.g. use the predicates also defined in GeometricalPredicates.jl). This could be useful if you are not too worried about robustness (although you should typically care about this, so be careful) and just want fast code. Let's see what happens if we randomly triangulate some set of 100000 points using ExactPredicates.jl versus the definitions above.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"using DelaunayTriangulation\nusing BenchmarkTools \nn = 100_000\npts = 20randn(2, n)\n\n## Benchmark the original definition \nb1 = @benchmark triangulate($pts)\n\n## Now change the definitions \n_det(a, b, c, d) = a * d - b * c\n_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion \nfunction DelaunayTriangulation.orient_predicate(a, b, c)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    o = _det(ax - cx, ay - cy, bx - cx, by - cy)\n    return Int(sign(o)) \nend\nfunction DelaunayTriangulation.incircle_predicate(a, b, c, d)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    dx, dy = getxy(d)\n    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,\n        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,\n        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)\n    return Int(sign(o))\nend\n\n## Benchmark these new definitions \nb2 = @benchmark triangulate($pts)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"julia> b1\nBenchmarkTools.Trial: 3 samples with 1 evaluation.\n Range (min … max):  2.218 s …   2.386 s  ┊ GC (min … max): 5.61% … 7.91%\n Time  (median):     2.360 s              ┊ GC (median):    5.28%\n Time  (mean ± σ):   2.321 s ± 90.182 ms  ┊ GC (mean ± σ):  5.81% ± 2.02%\n\n  █                                               █       █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█ ▁\n  2.22 s         Histogram: frequency by time        2.39 s <\n\n Memory estimate: 418.00 MiB, allocs estimate: 4079091.\n\njulia> b2\nBenchmarkTools.Trial: 3 samples with 1 evaluation.\n Range (min … max):  2.343 s …   2.447 s  ┊ GC (min … max): 3.93% … 7.49%\n Time  (median):     2.370 s              ┊ GC (median):    6.31%\n Time  (mean ± σ):   2.387 s ± 53.921 ms  ┊ GC (mean ± σ):  5.93% ± 1.82%\n\n  █             █                                         █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  2.34 s         Histogram: frequency by time        2.45 s <\n\n Memory estimate: 417.99 MiB, allocs estimate: 4079731.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Not much difference - ExactPredicates.jl probably never has to run the slow definition in this case. What if the numbers are all very small?","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"using ExactPredicates\n## Go back to the original definitions \nDelaunayTriangulation.orient_predicate(p, q, r) = orient(getxy(p), getxy(q), getxy(r))\nDelaunayTriangulation.incircle_predicate(a, b, c, p) = incircle(getxy(a), getxy(b), getxy(c), getxy(p))\n\n## Get another set of points \npts = 1e-8rand(2, 100_000)\n\n## Do the benchmarks again \nb1 = @benchmark triangulate($pts)\nfunction DelaunayTriangulation.orient_predicate(a, b, c)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    o = _det(ax - cx, ay - cy, bx - cx, by - cy)\n    return Int(sign(o)) \nend\nfunction DelaunayTriangulation.incircle_predicate(a, b, c, d)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    dx, dy = getxy(d)\n    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,\n        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,\n        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)\n    return Int(sign(o))\nend\nb2 = @benchmark triangulate($pts)","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"julia> b1\nBenchmarkTools.Trial: 3 samples with 1 evaluation.\n Range (min … max):  2.301 s …   2.423 s  ┊ GC (min … max): 2.34% … 3.96%\n Time  (median):     2.305 s              ┊ GC (median):    3.64%\n Time  (mean ± σ):   2.343 s ± 69.581 ms  ┊ GC (mean ± σ):  3.32% ± 0.85%\n\n  ██                                                      █\n  ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  2.3 s          Histogram: frequency by time        2.42 s <\n\n Memory estimate: 430.78 MiB, allocs estimate: 4079516.\n\njulia> b2\nBenchmarkTools.Trial: 3 samples with 1 evaluation.\n Range (min … max):  2.218 s …   2.269 s  ┊ GC (min … max): 4.03% … 2.51%\n Time  (median):     2.239 s              ┊ GC (median):    4.00%\n Time  (mean ± σ):   2.242 s ± 25.344 ms  ┊ GC (mean ± σ):  3.75% ± 1.14%\n\n  █                      █                                █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  2.22 s         Histogram: frequency by time        2.27 s <\n\n Memory estimate: 417.98 MiB, allocs estimate: 4079100.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Still not much of a difference, so I would not really recommend bothering changing these definitions – but the option is there if your application calls for it. (With a million points in the above example, the changed definition is about two seconds faster at a total of 38 seconds).","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The other predicates are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"sameside_predicate \nmeet_predicate\ntriangle_orientation(::Any, ::Any, ::Any)\npoint_position_relative_to_circle \npoint_position_relative_to_line(::Any, ::Any, ::Any) \npoint_position_on_line_segment(::Any, ::Any, ::Any) \nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any) \npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any) \npoint_position_relative_to_oriented_outer_halfplane","category":"page"},{"location":"predicates/#DelaunayTriangulation.sameside_predicate","page":"Predicates","title":"DelaunayTriangulation.sameside_predicate","text":"sameside_predicate(a, b, p)\n\nReturns ExactPredicates.sameside(p, a, b) (but we redefine it here).\n\n(The difference in the argument order is to match the convention that the  main point being tested is the last argument.)\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.meet_predicate","page":"Predicates","title":"DelaunayTriangulation.meet_predicate","text":"meet_predicate(p, q, a, b)\n\nReturns ExactPredicates.meet(p, q, a, b)  (but we redefine it here).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(p, q, r)\n\nGiven a triangle with coordinates (p, q, r), computes its orientation, returning:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circle","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circle","text":"point_position_relative_to_circle(a, b, c, p)\n\nGiven a circle through the coordinates (a, b, c), assumed to be positively oriented,  computes the position of p relative to the circle. In particular, returns:\n\nCertificate.Inside: p is inside the circle.\nCertificate.On: p is on the circle. \nCertificate.Outside: p is outside the triangle.\n\nSee also incircle_predicate.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(a, b, p)\n\nGiven a point p and the oriented line (a, b), computes the position  of p relative to the line, returning:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line. \n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(a, b, p)\n\nGiven a point p and the line segment (a, b), assuming p  to be collinear with a and b, computes the position of p relative to the line segment. In particular, returns:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\nSee also sameside_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(p, q, a, b)\n\nGiven the coordinates (p, q) and (a, b) defining two line segments,  tests the number of intersections between the two segments. In particular,  we return:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point. \nCertificate.Touching: One of the endpoints is on [a, b], but there are no other intersections.\n\nSee also meet_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(a, b, c, p)\n\nGiven a positively oriented triangle with coordinates (a, b, c), computes the  position of p relative to the triangle. In particular, returns: \n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","text":"point_position_relative_to_oriented_outer_halfplane(a, b, p)\n\nGiven an edge with coordinates (a, b) and a point p,  tests the position of p relative to the oriented outer halfplane defined  by (a, b). The oriented outer halfplane is the union of the open halfplane  defined by the region to the left of the oriented line (a, b), and the  open line segment (a, b). The returned values are:\n\nCert.Outside: p is outside of the oriented outer halfplane, meaning to the right of the line (a, b) or collinear with a and b but not on the line segment (a, b).\nCert.On: p is on the open line segment (a, b).\nCert.Inside: p is inside of the oriented outer halfplane, meaning to the left of the line (a, b).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#Boundaries-and-Ghosts","page":"Predicates","title":"Boundaries and Ghosts","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some predicates for working with boundaries and ghost triangles. ","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"is_boundary_index \nis_boundary_edge(::Any, ::Adjacent) \nis_boundary_triangle(::Any, ::Any, ::Any, ::Any) \nis_ghost_edge \nis_ghost_triangle \nis_interior_curve\nis_outer_boundary_index(::Any, ::Any) \nis_outer_ghost_triangle \nis_outer_ghost_edge\nis_outer_boundary_node(::Any, ::Graph{I}, ::Any) where {I} \nedge_exists(::I) where {I}\nedge_exists(::Any, ::Adjacent{I,E}) where {I,E}\nhas_ghost_triangles(::Adjacent{I,E}, ::Any) where {I,E} ","category":"page"},{"location":"predicates/#DelaunayTriangulation.is_boundary_index","page":"Predicates","title":"DelaunayTriangulation.is_boundary_index","text":"is_boundary_index(i::I) where {I}\n\nGiven an index i, returns i ≤ I(BoundaryIndex).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(ij, adj::Adjacent)\nis_boundary_edge(i, j, adj::Adjacent{I,E}) where {I,E}\n\nGiven an edge (i, j) and an adjacent map adj, returns true if  (i, j) is a boundary edge and false otherwise.\n\nNote that the orientation of (i, j) is important: even if (i, j) is an edge on the boundary, if there is a triangle (i, j, k) in the triangulation then  (i, j) is not a boundary edge but (j, i) would be.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(i, j, k, adj)\nis_boundary_triangle(T, adj)\n\nGiven a triangle T = (i, j, k) and an adjacent map adj,  returns true if T is a boundary triangle. A boundary triangle  is still part of the triangulation, but it has at least one edge that  forms part of the boundary (so that at least one of is_boundary_edge(j, i), is_boundary_edge(k, j), and is_boundary_edge(i, k) is true).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_ghost_edge","page":"Predicates","title":"DelaunayTriangulation.is_ghost_edge","text":"is_ghost_edge(i, j)\n\nGiven an edge (i, j), returns true if (i, j) is a  ghost edge. A ghost edge is an edge in which either is_boundary_index(i) or is_boundary_index(j) is true.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_ghost_triangle","page":"Predicates","title":"DelaunayTriangulation.is_ghost_triangle","text":"is_ghost_triangle(i, j, k)\nis_ghost_triangle(T)\n\nGiven a triangle T = (i, j, k), returns true  if T is a ghost triangle and false otherwise. A ghost  triangle is one in which any of the vertices (i, j, k)  are a boundary index, as tested via is_boundary_index.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_interior_curve","page":"Predicates","title":"DelaunayTriangulation.is_interior_curve","text":"is_interior_curve(i)\nis_interior_curve(i, boundary_map)\n\nGiven an index i, tests if the curve is an interior curve, i.e. if i > 1. If  a map boundary_map is provided, i should be a boundary map so that is_interior_curve(j) is tested, where j = get_curve_index(boundary_map, i).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(i, boundary_map)\n\nGiven an index i, tests if the index is a boundary index referring to the outermost boundary, making  use of the boundary_map from construct_boundary_map.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_triangle","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_triangle","text":"is_outer_ghost_triangle(i, j, k, boundary_map)\n\nGiven a ghost triangle (i, j, k) and a boundary map boundary_map taking boundary indices to their location in the boundary node array,  tests if (i, j, k) is a ghost triangle on the outermost boundary  (true) or on an interior boundary (false)`.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_edge","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_edge","text":"is_outer_ghost_edge(i, j, boundary_map)\n\nGiven a ghost edge (i, j) and a boundary map boundary_map taking boundary indices to their location in the boundary node array,  tests if (i, j) is a ghost edge on the outermost boundary  (true) or on an interior boundary (false)`.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}\n\nGiven a node index i, a graph::Graph, a Dict from construct_boundary_index_ranges, returns true if i corresponds to a node on the outermost boundary,  and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Tuple{I} where I","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(i::I) where {I}\n\nReturns i ≠ I(DefaultAdjacentValue).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(ij, adj::Adjacent{I,E}) where {I,E}\n\nGiven an edge ij and an Adjacent map adj,  tests if the edge exists in the corresponding triangulation.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(adj::Adjacent{I,E}, adj2v) where {I,E}\n\nGiven an Adjacent map adj and an Adjacent2Vertex map adj2v, tests if the corresponding triangulation contains ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Index-and-Ghost-Handling","page":"Predicates","title":"Index and Ghost Handling","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list methods for working with predicates that are used when we provide indices for points rather than points directly.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"triangle_orientation(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_circumcircle(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Any, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any, ::Any, ::AbstractDict)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::AbstractDict)","category":"page"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(i, j, k, pts, boundary_map)\ntriangle_orientation(T, pts, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices corresponding  to points in pts, computes the orientation of the triangle. In particular, returns:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nA test is also made for the case that is_ghost_triangle(T): If  T  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly.  In case the boundary  index corresponds to an interior curve, this flip is not necessary.\n\nThe mapping of a boundary index is handled via the boundary_map  argument - see construct_boundary_map.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(i, j, k, ℓ, pts, boundary_map)\npoint_position_relative_to_circumcircle(T, ℓ, pts, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices corresponding  to points in pts, and a point with index ℓ, pₗ, computes  the position this point pₗ relative to the triangle's circumcircle, making use of point_position_relative_to_circle.\n\nThe returned values are:\n\nCertificate.Outside: pₗ is outside of the circumcircle.\nCertificate.On: pₗ is on the circumcircle.\nCertificate.Inside: pₗ is inside the circumcircle.\n\nA test is also made for the case that is_ghost_triangle(T): When T is a ghost triangle, one of its indices is a boundary index, say i.  Since this vertex is treated as being out at infinity, the circumcircle  degenerates into the line through the other two vertices. Thus, we test  that pₗ is inside this circumcircle by seeing if it is in the oriented  outer halfplane defined by the two other vertices. See also  point_position_relative_to_oriented_outer_halfplane.\n\nThe mapping of a boundary index is handled via the boundary_map  argument - see construct_boundary_map.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(i, j, u, pts, boundary_map)\n\nGiven indices i, j, and u corresponding to indices  of points in the collection of points pts, corresponding to  coordinates say a, b, and p, respectively, computes the  position of p relative to the oriented line (a, b). \n\nThe returned values are:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line.\n\nIf is_outer_ghost_edge(i, j, boundary_map), the oriented line (a, b) is flipped  since the point corresponding to the boundary index will be a  centroid which swaps the orientation.\n\nThe mapping of a boundary index is handled via the boundary_map  argument - see construct_boundary_map.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(i, j, u, pts)\n\nGiven indices i, j, and u corresponding to indices  of points in the collection of points pts, corresponding to  coordinates say a, b, and p, respectively, computes the  position of p relative to the oriented line segment (a, b), assuming that the three points are collinear.\n\nThe returned values are:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(u, v, i, j, pts)\n\nGiven two pairs of indices (u, v) and (i, j), with  all indices corresponding to points in pts, tests  the number of intersections between the two line segments  associated with these indices.\n\nLetting p, q, a, and b be the points referred to by  u, v, i, and j, respectively, we return:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point.\nCertificate.On: One of the endpoints is on [a, b], but there are no other intersections.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, AbstractDict}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(i, j, k, u, pts, boundary_map)\npoint_position_relative_to_triangle(T, u, pts, boundary_map)\n\nGiven a triangle T = (i, j, k) and another index u,  with indices referring to points in pts, computes  the position of u relative to the triangle.\n\nLetting p, q, a, and b be the points referred to by  i, j, k, and u, respectively, we return:\n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\nIf necessary, the mapping of boundary indices is handled via  the boundary map argument from construct_boundary_map.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, AbstractDict}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(a, b, c, p)\n\nGiven a positively oriented triangle with coordinates (a, b, c), computes the  position of p relative to the triangle. In particular, returns: \n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/triangles/#Individual-Triangles","page":"Triangles","title":"Individual Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"Triangles are assumed to be of the form (i, j, k), with positive orientation, but we allow for customisation in the way these indices are represented. The following methods are used for working with triangles. First, we list the methods that must be defined, and then methods that extend these former methods. ","category":"page"},{"location":"interface/triangles/#Necessary-Methods","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"construct_triangle \ngeti \ngetj \ngetk \ninteger_type ","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.construct_triangle","page":"Triangles","title":"DelaunayTriangulation.construct_triangle","text":"construct_triangle(::Type{T}, i, j, k) where {T}\n\nConstructs a triangle with indices (i, j, k) with the  type T. The following methods are currently defined:\n\nconstruct_triangle(::Type{NTuple{3, I}}, i, j, k) where {I} \nconstruct_triangle(::Type{A}, i, j, k) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.geti","page":"Triangles","title":"DelaunayTriangulation.geti","text":"geti(T::F) where {F}\n\nFrom a triangle T, extract the ith index, i.e. the first.  The following methods are currently defined: \n\ngeti(T::NTuple{3, I})\ngeti(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getj","page":"Triangles","title":"DelaunayTriangulation.getj","text":"getj(T::F) where {F}\n\nFrom a triangle T, extract the jth index, i.e. the second.  The following methods are currently defined: \n\ngetj(T::NTuple{3, I})\ngetj(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getk","page":"Triangles","title":"DelaunayTriangulation.getk","text":"getk(T::F) where {F}\n\nFrom a triangle T, extract the kth index, i.e. the third.  The following methods are currently defined: \n\ngetk(T::NTuple{3, I})\ngetk(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.integer_type","page":"Triangles","title":"DelaunayTriangulation.integer_type","text":"integer_type(::Type{T}) where {T}\n\nReturns the integer type used for representnig a triangle with indices  (i, j, k) with the type T. The following methods are currently defined:\n\ninteger_type(::Type{NTuple{N, I}}) where {N, I} \ninteger_type(::Type{A}) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Generic-Methods","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"indices \ntriangle_edges\nrotate_triangle \nconstruct_positively_oriented_triangle(::Type{V}, ::Any, ::Any, ::Any, ::Any) where {V}\ncompare_triangles \nsort_triangle","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.indices","page":"Triangles","title":"DelaunayTriangulation.indices","text":"indices(T)\n\nReturns a tuple (i, j, k) containing the indices of the triangle T. The  indices are obtained using geti, getj, and getk.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_edges","page":"Triangles","title":"DelaunayTriangulation.triangle_edges","text":"triangle_edges(T)\ntriangle_edges(i, j, k)\n\nReturns an iterator over each edge of the triangle T. In particular,  returns ((geti(T), getj(T)), (getj(T), getk(T)), (getk(T), geti(T))). The latter method uses the indices directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.rotate_triangle","page":"Triangles","title":"DelaunayTriangulation.rotate_triangle","text":"rotate_triangle(T::V, i) where {V}\n\nGiven a triangle T, rotates the indices an amount i. In particular, if T = (i, j, k):\n\ni = 0: Returns (i, j, k).\ni = 1: Returns (j, k, i).\ni = 2: Returns (k, i, j).\nOtherwise, return rotate_triangle(T, i % 3).\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Any, Any, Any, Any}} where V","page":"Triangles","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(::Type{V}, i, j, k, points) where {V}\n\nGiven a triangle type V, indices (i, j, k) corresponding to points in points,  returns either construct_triangle(V, i, j, k) or construct_triangle(V, j, i, k), whichever is not negatively oriented.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangles","page":"Triangles","title":"DelaunayTriangulation.compare_triangles","text":"compare_triangles(T, V)\n\nTests if the triangle T is equal to the triangle V, with equality  defined on the indices. In particular, compare_triangles((i, j, k), (i, j, k)), compare_triangles((i, j, k), (j, k, i)), and compare_triangles((i, j, k), (k, i, j)) are all true.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangle","page":"Triangles","title":"DelaunayTriangulation.sort_triangle","text":"sort_triangle(T::V) where {V}\n\nGiven a triangle T = (i, j, k), sorts it so that the first index is the smallest, maintaining  the orientation of T.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Collection-of-Triangles","page":"Triangles","title":"Collection of Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"A collection of triangles simply stores many triangles, and the collection itself must be mutable so that triangles can be added and deleted. The following methods are used for working with collections of triangles. First, we list the methods that must be defined, and then methods that extend these former methods.","category":"page"},{"location":"interface/triangles/#Necessary-Methods-2","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"initialise_triangles \ntriangle_type \nnum_triangles \nadd_to_triangles! \ndelete_from_triangles!\neach_triangle \nremove_duplicate_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.initialise_triangles","page":"Triangles","title":"DelaunayTriangulation.initialise_triangles","text":"initialise_triangles(::Type{S})\n\nFor a given type S for some collection (e.g. a Set), returns an empty instance of that collection. The only method defined is\n\ninitialise_triangles(::Type{S}) where {T, S <: Set{T}}\n\nwhich returns a Set{T}(). You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_type","page":"Triangles","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of triangles,  returns the type of triangle used inside S, e.g. NTuple{3, Int64} if S = Set{NTuple{3, Int64}}. The only methods defined are\n\ntriangle_type(::Type{S}) where {T, S <: Set{T}}\ntriangle_type(::Type{A}) where {T, A <: AbstractVector{E}}\n\nwhich returns T. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.num_triangles","page":"Triangles","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(T::S) where {S}\n\nGiven a collection of triangles T, returns the number of triangles  in T. The only method currently defined is \n\nnum_triangles(T::Set)\n\nwhich returns length(T). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_to_triangles!","page":"Triangles","title":"DelaunayTriangulation.add_to_triangles!","text":"add_to_triangles!(T::S, V) where {S}\n\nGiven a collection of triangles T, pushes V into it. The only  methods currently defined are\n\nadd_to_triangles!(T::Set{F}, V::F) where {F}\nadd_to_triangles!(T::Set{F}, V) where {F}\n\nwhich simply call push!(T, V). The latter method reconstructs V  using [indices] and construct_triangle. You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.delete_from_triangles!","page":"Triangles","title":"DelaunayTriangulation.delete_from_triangles!","text":"delete_from_triangles!(V::S, T::F) where {S}\n\nGiven a collection of triangles V of type S, containing  triangles of type F, deletes the triangle T from V.  The only method currently defined is \n\ndelete_from_triangles!(V::Set{F}, T::F) where {F}.\n\nwhich just calls delete! on V. The function already assumes that T  is already in V, and that T doesn't need to be rotated at all.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.each_triangle","page":"Triangles","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(V::F) where {F}\n\nFor a given collection of triangles V, returns an iterator that  goes over each triangle in the collection. The methods currently  defined are \n\neach_triangle(V::Set)\neach_triangle(V::AbstractMatrix)\n\nwith the first method simply returning V, and the second returning  eachcol(V). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.remove_duplicate_triangles","page":"Triangles","title":"DelaunayTriangulation.remove_duplicate_triangles","text":"remove_duplicate_triangles(T::Ts) where {Ts}\n\nRemoves duplicate triangles from T. This procedure also sorts the triangles  so that the first index of each triangle is the smallest. Orientations are  preserved.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"You must also provide definitions for Base.in and Base.sizehint! for your type. You need Base.unique! to use remove_duplicate_triangles, unless your collection is a Set. Note also that Triangulations also define each_solid_triangle and each_ghost_triangle.","category":"page"},{"location":"interface/triangles/#Generic-Methods-2","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"contains_triangle \nadd_triangle!(::Any, ::Vararg{F, N}) where {F, N}\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ndelete_triangle!(::Any, ::Vararg{F, N}) where {F, N}\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ncompare_triangle_collections \nsort_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.contains_triangle","page":"Triangles","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(T::F, V::S) where {F, S}\n\nGiven a collection of triangles V of type S, containing triangles  of type F, checks if V includes the triangle T. In particular,  the returned value is \n\n(rotate_triangle(T, m), true)\n\nif V includes the triangle T, and m is the integer such that  rotate_triangle(T, m) is the form of T that V contains. If there  is no such m, the returned value is simply \n\n(T, false).\n\nTo use this function, your type needs to only have a definition for T ∈ V for  testing specific rotations of a triangle. This function then performs the checks  by checking T, then rotate_triangle(T, 1), then rotate_triangle(T, 2), and if none of those succeed just returns  (T, false). You can extend this function as you need. We also define\n\ncontains_triangle(i, j, k, V::Ts) where {Ts},\n\nand this method just calls the two-argument method after constructing  the triangle with construct_triangle.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T, V...)\n\nGiven a collection of triangles T, adds all the triangles V... into it.  To extend this method to other collections, see add_to_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, adds the triangle (i, j, k) into it.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(V, T...)\n\nGiven a collection of triangles V, deletes all the triangles T... from it.  Checks are made for rotated forms of T that V includes. For example, if  T = (i, j, k) but V contains (j, k, i), then (j, k, i) will be deleted. The function also checks to see if the triangle is in V at all prior to deleting it. To extend this method to other collections, see delete_from_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, deletes the triangle (i, j, k) from it.  Checks are made to see if T needs to be rotated, or if (i, j, k) is in T  at all.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangle_collections","page":"Triangles","title":"DelaunayTriangulation.compare_triangle_collections","text":"compare_triangle_collections(T, V)\n\nGiven two collections of triangles T and V, tests if they are equal, with  equality defined according to compare_triangles.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangles","page":"Triangles","title":"DelaunayTriangulation.sort_triangles","text":"sort_triangles(T::Ts) where {Ts}\n\nSorts the triangles in the collection T so that each triangle's first vertex  has the smallest value. The orientation of each triangle is preserved.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/triangulation/#Triangulation","page":"Triangulation","title":"Triangulation","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"The most important structure of the package is the Triangulation data structure. Its complete definition is given below, and then afterwards we give all the docstrings for methods that are useful for working with triangulations.","category":"page"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"Triangulation","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.Triangulation","page":"Triangulation","title":"DelaunayTriangulation.Triangulation","text":"Triangulation{P,Ts,I,E,Es,BN,B,BIR}\n\nStruct for a triangulation.\n\nSee also triangulate and generate_mesh.\n\nFields\n\npoints::P\n\nThe nodes in the triangulation.\n\ntriangles::Ts\n\nThe triangles in the triangulation. All triangles are positively oriented.\n\nadjacent::Adjacent{I, E}\n\nThe Adjacent map, mapping edges to vertices that together form a  positively oriented triangle in triangles. See also Adjacent.\n\nadjacent2vertex::Adjacent2Vertex{I,Es,E}\n\nThe Adjacent2Vertex map, mapping vertices to all edges that together  form a positively oriented triangle in triangles. See also Adjacent2Vertex.\n\ngraph::Graph{I}\n\nThe Graph, mapping vertices to all other vertices that are connected with  that vertex via an edge of a triangle in triangles. See also Graph.\n\nboundary_nodes::BN\n\nThe boundary nodes, with the outer boundary given in counter-clockwise order and the inner boundaries given in clockwise order. The default  (default because you could customise it if you wish, see  Interfaces) form of this field depends on your domain:\n\n– Vector{Int64}\n\nIf you provide no boundary curves or provide a single connected boundary curve, this  will be a counter-clockwise vector of boundary nodes with boundary_nodes[begin] ==  boundary_nodes[end]. Note that if no boundary curve was provided, this gives the  convex hull of points.\n\n– Vector{Vector{Int64}}\n\nIn this case, you have provided a single boundary curve but separated into different parts.  In this case, boundary_nodes[n] gives the boundary nodes for the nth segment. Additionally, boundary_nodes[n][end] == boundary_nodes[n+1][begin] and boundary_nodes[end][end] == boundary_nodes[begin][begin]. The nodes should be counter-clockwise in this case also.\n\n– Vector{Vector{Vector{Int64}}}\n\nIn this case, you have provided multiple boundary curves each separated into different parts,  e.g. an annulus with each circle split into its lower and upper halves. The component  boundary_nodes[m][n] gives the boundary nodes for the nth segment of the mth  boundary curve, with boundary_nodes[begin] the outer-most boundary and boundary_nodes[i] the  inner boundaries (i > 1). As in the previous case, boundary_nodes[m][n][end] == boundary_nodes[m][n+1][begin] and boundary_nodes[m][end][end] == boundary_nodes[m][begin][begin].  With this form, boundary_nodes[m] should be a counter-clockwise list of nodes for m == 1, while for m > 1 it` should be a clockwise list of nodes.\n\nboundary_map::B\n\nThis is an OrderedDict that maps a given boundary index to its position in boundary_nodes. For example, if boundary_map[-4] = (2, 3), this means that the boundary index -4  corresponds to the nodes in get_boundary_nodes(boundary_nodes, 2, 3). If there is just a  single continuous curve, so that boundary_nodes acts like a vector of integers, then  boundary_map[-1] simply returns boundary_nodes. See also  construct_boundary_map and map_boundary_index. The ordering is so that  the lowest magnitude boundary index comes first.\n\nboundary_index_ranges::BIR\n\nThis is an OrderedDict that maps a boundary index to a range of all other boundary indices  that the corresponding boundary curve could correspond to. For example, for a curve with four  segments, there are four possible boundary indices that a segment could correspond to - this  Dict will extract this range. See also construct_boundary_index_ranges.\n\nconstrained_edges::Es\n\nThis is the set of extra edges added into the triangulation that you have provided. Note that  this will not included any of the other constrained edges from boundary_nodes.\n\nconvex_hull::ConvexHull{P,Vector{I}}\n\nThis will be a vector of integers corresponding to indices in the points that  together give the convex hull of the set of points, with convex_hull[begin] == convex_hull[end].\n\nConstructors\n\nThere are several ways to construct this struct directly (though you should probably  be using triangulate or generate_mesh).\n\nDefault Constructor\n\nThe default constructor is available, i.e. \n\nTriangulation(points, triangles, adjacent, adjacent2vertex, graph, boundary_nodes, constrained_edges, boundary_map, convex_hull)\n\nEmpty Triangulation\n\nIf you want to initialise the triangulation, you can use \n\nTriangulation(points::P;\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    boundary_nodes::BN=IntegerType[],\n    constrained_edges=initialise_edges(EdgesType)) where {P,Ts,I,E,Es,BN,V}\n\nExisting Triangulation Objects\n\nThe second constructor, mainly existing so that generate_mesh can convert  its results into a Triangulation, takes in existing triangles, points, and  boundary_nodes and creates a Triangulation:\n\nTriangulation(points::P, triangles::T, boundary_nodes::BN;\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    add_ghost_triangles=false) where {I, E, V, Es, Ts, T}\n\nYou can set add_ghost_triangles = true to add ghost triangles into the structure. \n\nExtended help\n\nThere are many functions available for working with a Triangulation, some of which  we list below. \n\nAccessors:\n\nget_points\nget_triangles\nget_adjacent\nget_adjacent2vertex\nget_graph\nget_boundary_nodes\nget_boundary_map\nget_boundary_index_ranges\nget_constrained_edges\nget_convex_hull\n\nOperations:\n\nadd_triangle!\ndelete_triangle!\nadd_ghost_triangles!\ndelete_ghost_triangles!\nadd_boundary_information!\n\nPoint location:\n\nbrute_force_search\njump_and_march\n\nWorking with the Adjacent field:\n\nget_adjacent\nadd_adjacent!\ndelete_adjacent!\n\nWorking with the Adjacent2Vertex field:\n\nget_adjacent2vertex\nadd_adjacent2vertex!\ndelete_adjacent2vertex!\n\nWorking with the Graph field:\n\nget_edges\nget_vertices\nget_neighbours\nadd_vertex!\nadd_neighbour!\ndelete_neighbour!\ndelete_vertex!\ndelete_boundary_vertices_from_graph!\n\nWorking with the boundary_nodes field:\n\nhas_multiple_curves\nhas_multiple_segments\nnum_curves\nnum_segments\nget_boundary_nodes\nmap_boundary_index\nget_curve_index\nget_segment_index\nnum_outer_boundary_segments\nget_right_boundary_node\nget_left_boundary_node\n\nWorking with the convex_hull field:\n\nget_convex_hull_indices\nconvex_hull!\n\nWorking with the triangles field:\n\ntriangle_type\nnum_triangles\neach_triangle\neach_solid_triangle\neach_ghost_triangle\ncontains_triangle\n\nWorking with edges:\n\nedge_type\nnum_edges\neach_edge\n\nWorking with the points field:\n\nget_point\neach_point_index\neach_point\nnum_points\n\nPredicates:\n\nis_boundary_edge\nis_boundary_triangle\ntriangle_orientation\npoint_position_relative_to_circumcircle\npoint_position_relative_to_line\npoint_position_on_line_segment\nline_segment_intersection_type\npoint_position_relative_to_triangle\nis_outer_boundary_index\nis_outer_boundary_node\nedge_exists\nhas_ghost_triangles\nhas_boundary_nodes\n\nMiscellaneous:\n\ninteger_type\nnumber_type\ncompute_representative_points!\nclear_empty_features!\nfind_edge\nis_constrained\nall_boundary_indices\n\n\n\n\n\n","category":"type"},{"location":"data_structures/triangulation/#Useful-Methods","page":"Triangulation","title":"Useful Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_adjacent(::Triangulation)\nget_adjacent(::Triangulation, ::Any)\nadd_adjacent!(::Triangulation, ::Any)\ndelete_adjacent!(::Triangulation, ::Any)\nget_adjacent2vertex(::Triangulation)\nget_adjacent2vertex(::Triangulation, ::Any)\nadd_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any)\nget_graph(::Triangulation)\nget_edges(::Triangulation)\nget_vertices(::Triangulation)\nget_neighbours(::Triangulation)\nget_neighbours(::Triangulation, ::Any)\nadd_vertex!(::Triangulation, ::Vararg)\nadd_neighbour!(::Triangulation, ::Any, ::Vararg)\ndelete_neighbour!(::Triangulation, ::Any, ::Vararg)\ndelete_vertex!(tri::Triangulation, ::Vararg)\ndelete_boundary_vertices_from_graph!(::Triangulation)\nget_boundary_nodes(::Triangulation)\nhas_multiple_curves(::Triangulation)\nhas_multiple_segments(::Triangulation)\nnum_curves(::Triangulation)\nnum_segments(::Triangulation)\nget_boundary_nodes(::Triangulation, ::Vararg)\nmap_boundary_index(::Triangulation, ::Any)\nget_curve_index(::Triangulation, ::Any)\nget_segment_index(::Triangulation, ::Any)\nget_right_boundary_node(::Triangulation, ::Any, ::Any)\nget_left_boundary_node(::Triangulation, ::Any, ::Any)\nget_convex_hull_indices(::Triangulation)\nget_convex_hull(::Triangulation)\nconvex_hull!(::Triangulation)\ntriangle_type(::Triangulation)\nget_triangles(::Triangulation)\nnum_triangles(::Triangulation)\neach_triangle(::Triangulation)\neach_solid_triangle(::Triangulation)\neach_ghost_triangle(::Triangulation)\ncontains_triangle(::Triangulation, ::Any)\nconstruct_positively_oriented_triangle(::Triangulation, ::Any, ::Any, ::Any)\nedge_type(::Triangulation)\nnum_edges(::Triangulation)\neach_edge(::Triangulation)\nget_points(::Triangulation)\nget_point(::Triangulation, ::Any)\neach_point_index(::Triangulation)\neach_point(::Triangulation)\nnum_points(::Triangulation)\nis_boundary_edge(::Triangulation, ::Any)\nget_boundary_map(::Triangulation)\nget_boundary_index_ranges(::Triangulation)\nis_boundary_triangle(::Triangulation, ::Any)\ntriangle_orientation(::Triangulation, ::Any)\npoint_position_relative_to_circumcircle(::Triangulation, ::Any, ::Any)\npoint_position_relative_to_line(::Triangulation, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Triangulation, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Triangulation, ::Any, ::Any)\nis_outer_boundary_index(tri::Triangulation, ::Any)\nis_outer_boundary_node(tri::Triangulation, ::Any)\nedge_exists(::Triangulation, ::Any)\nhas_ghost_triangles(::Triangulation)\nhas_boundary_nodes(::Triangulation)\nbrute_force_search(::Triangulation, ::Any)\njump_and_march(::Triangulation, ::Any)\ninteger_type(::Triangulation)\nnumber_type(::Triangulation)\ncompute_representative_points!(::Triangulation)\nclear_empty_features!(::Triangulation)\nfind_edge(::Triangulation, ::Any, ::Any)\nget_constrained_edges(::Triangulation)\nis_constrained(::Triangulation)\nall_boundary_indices(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation)\n\nReturns the adjacent field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation, uv; check_existence::V=Val(false)) where {V}\nget_adjacent(tri::Triangulation, u, v; check_existence::V=Val(false)) where {V}\n\nGiven the edge (u, v), gets the vertex w such that (u, v, w) is a positively oriented triangle in the triangulation tri.\n\nUse check_existence=Val(true) to be safe against ghost edges corresponding to  neighbouring boundary indices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(tri::Triangulation, uv, w)\nadd_adjacent!(tri::Triangulation, u, v, w)\n\nGiven the edge (u, v), adds the vertex w into the adjacent map  of the triangulation tri, so that (u, v, w) is a positively  oriented triangle in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(tri::Triangulation, uv)\ndelete_adjacent!(tri::Triangulation, u, v)\n\nGiven the edge (u, v), deletes the key (u, v) from the adjacent map  of the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation)\n\nReturns the adjacent2vertex field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation, w)\n\nGiven the vertex w, returns the set of edges (u, v) from  the adjacent2vertex map such that (u, v, w) is a positively oriented  triangle in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(tri::Triangulation, w, uv)\nadd_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nGiven the vertex w and an edge (u, v), pushes the edge (u, v)  into the set of edges defined by the key w in the adjacent2vertex map  of the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w, uv)\ndelete_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nGiven the vertex w and an edge (u, v), deletes the edge (u, v) from the set of edges defined by the key w in the adjacent2vertex map  of the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w)\n\nGiven the vertex w, deletes the set of edges (u, v) that define positively  oriented triangles (u, v, w) from the adjacent2vertex map of the triangulation  tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_graph-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_graph","text":"get_graph(tri::Triangulation)\n\nReturns the graph field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_edges","text":"get_edges(tri::Triangulation)\n\nGiven a triangulation tri, returns the set of edges in tri. These edges will  not be oriented, i.e. if (i, j) is in the set then (j, i) will not be.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_vertices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(tri::Triangulation)\n\nGiven a triangulation tri, returns the set of vertices in tri. Note that this  will include any ghost vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation)\n\nGiven a triangulation tri, returns the set of neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation, u)\n\nGiven a vertex u and a triangulation tri, returns the set of vertices v such that (u, v) is an edge of the triangulation for each v in the set.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg}","page":"Triangulation","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(tri::Triangulation, u...)\n\nGiven vertices u... and a triangulation tri, adds all the vertices u...  into the graph tri.graph. \n\nNote that this does not insert the vertex into the triangulation -  see add_point! for this.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg}","page":"Triangulation","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(tri::Triangulation, u, v...)\n\nGiven a vertex u and other vertices v..., adds all the vertices v...  into the neighbourhood of u from the triangulation tri, i.e. into tri.graph.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg}","page":"Triangulation","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(tri::Triangulation, u, v...)\n\nGiven a vertex u and other vertices v..., deletes all the vertices v... from the neighbourhood of u from the triangulation tri, i.e. from tri.graph.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg}","page":"Triangulation","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(tri::Triangulation, u...)\n\nGiven vertices u... and a triangulation tri, deletes all the vertices  u... from the graph tri.graph.\n\nNote that this does not remove the vertex from the triangulation -  see remove_point! for this.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(tri::Triangulation)\n\nGiven a triangulation tri, removes all boundary vertices from the  triangulation tri, i.e. all those with index less than -1 ( see is_boundary_index).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri::Triangulation)\n\nReturns the boundary_nodes field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(tri::Triangulation)\n\nReturns true if the triangulation tri has multiple boundary curves,  and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(tri::Triangulation)\n\nReturns true if the boundary curves of the triangulation tri  are broken into multiple segments. Note that if has_multiple_curves(tri), then has_multiple_segments(tri) == true.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_curves","text":"num_curves(tri::Triangulation)\n\nReturns the number of boundary curves of the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_segments","text":"num_segments(tri::Triangulation)\n\nReturns the number of segments of the boundary curve of the  triangulation tri. This is only defined if !has_multiple_curves(tri) and has_multiple_segments(tri).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Vararg}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri::Triangulation, mnℓ...)\n\nGiven a triangulation tri, returns the nodes corresponding to the  indices in mnℓ.... For example, if tri has multiple boundary curves,  then get_boundary_nodes(tri, m) returns the set of nodes for the  mth curve, and get_boundary_nodes(tri, m, n) the set of nodes for the  nth segment of the mth curve.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(tri::Triangulation, i)\n\nGiven a triangulation tri, returns the position in tri.boundary_nodes corresponding to the boundary index i, i.e. returns  tri.boundary_map[i].\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(tri::Triangulation, i)\n\nGiven a triangulation tri and a boundary index i, returns the curve number  that i corresponds to. For example, if map_boundary_index(tri, i) = (m, n), the curve index would be m. If !has_multiple_curves(tri), this just returns  1.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_segment_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(tri::Triangulation, i)\n\nGiven a triangulation tri and a boundary index i, returns the segment number  that i corresponds to. For example, if map_boundary_index(tri, i) = (m, n),  the segment index would be m. If !has_multiple_segments(tri), this just returns  1.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(tri::Triangulation, k, boundary_index)\n\nGiven a triangulation tri, a boundary node k, and a boundary_index for the associated  boundary, returns the index of the point to the right of k on the outer boundary.\n\nSee also get_left_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(tri::Triangulation, k)\n\nGiven a triangulation tri and an outer boundary node k, returns the index  of the point to the left of k on the outer boundary.\n\nSee also get_right_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull_indices","text":"get_convex_hull_indices(tri::Triangulation)\n\nReturns indices for the ConvexHull of the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull","text":"get_convex_hull(tri::Triangulation)\n\nReturns the convex_hull field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.convex_hull!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.convex_hull!","text":"convex_hull!(tri::Triangulation; reconstruct = is_constrained(tri))\n\nComputess the convex hull for the points in the triangulation tri, updating  the field tri.convex_hull. Note that this will only be needed if you are e.g.  constructing a convex hull from an existing set of points, triangles, and edges.  If you already have an unconstrained Delaunay triangulation, this field will  have also been updated. \n\nIf !reconstruct, the convex hull is reconstructed using convex_hull,  otherwise the ghost triangles are used to construct it (if there are no ghost  triangles, they are added and then removed afterwards).\n\nSee also convex_hull and ConvexHull.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_type-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation{P,Ts}) where {P,Ts}\n\nGiven a triangulation tri, returns the type used for  representing the triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_triangles","text":"get_triangles(tri::Triangulation)\n\nReturns the triangles field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(tri::Triangulation)\n\nGiven a triangulation tri, returns the number of triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_triangle-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the triangles. This iterator  will return both the ghost and solid triangles (if there are no ghost triangles,  then those of course are not included and each_triangle(tri) == each_solid_triangle(tri)).\n\nSee also each_ghost_triangle and each_solid_triangle.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_triangle-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_solid_triangle","text":"each_solid_triangle(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the solid (i.e. non-ghost) triangles.\n\nSee also each_ghost_triangle and each_triangle.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_triangle-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_triangle","text":"each_ghost_triangle(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the ghost triangles.\n\nSee also each_triangle and each_solid_triangle.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(tri::Triangulation, T) = contains_triangle(T, get_triangles(tri))\ncontains_triangle(tri::Triangulation, i, j, k) = contains_triangle(i, j, k, get_triangles(tri))\n\nGiven a triangulation tri, tests if the triangle T = (i, j, k) is in the triangulation (at least, in triangles).  The returned value is a tuple, with the first result being the form of T that is actually in  the triangulation (e.g., if T = (i, j, k) but the form of T in tri is (k, i, j), (k, i, j) is  returned). The second argument is a Bool, with true if T is contained in tri  and false otherwise. If false, the first output is T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(tri::Triangulation, i, j, k)\n\nGiven a triangulation tri and indices i, j, k for a proposed triangle, returns a triangle  with the indices ordered such that (i, j, k) is not negatively oriented.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_type-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation{P,Ts,I,E}) where {P,Ts,I,E}\n\nGiven a triangulation tri, returns the type used for  representing individual edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_edges","text":"num_edges(tri::Triangulation)\n\nGiven a triangulation tri, returns the number of edges. Note  that this does not double count edges, e.g. (i, j) and (j, i) do not count as two edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_edge-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_edge","text":"each_edge(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the edges  in the triangulation. Note that e.g. (i, j) and (j, i) will not  be iterated over twice, only one of them would be.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_points","text":"get_points(tri::Triangulation)\n\nReturns the points field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_point","text":"get_point(tri::Triangulation, i...)\n\nGiven a triangulation tri and some indices i..., returns  the ith point from the triangulation. If i is just a single integer,  the result is a Tuple of the coordinates, but if there are multiple  integers provided then a Tuple of Tuples of these coordinates  is returned, with the jth Tuple the coordinates for the i[j]th  point. \n\nIt is assumed that whenever i is not an integer, i is meant to be  a point, so (getx(i), gety(i)) would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.\n\nIf is_boundary_index(i), then instead of returning the ith point of the triangulation, the centroid for the boundary curve corresponding to the  boundary index i is returned. See also get_representative_point_coordinates.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point_index-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the indices  of the points in tri. This iterator does not include the boundary  indices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point","text":"each_point(tri::Triangulation)\n\nGiven a triangulation tri, returns an iterator over the coordinates  of the points in tri. This iterator does not include the centroids  of the boundary curves.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_points","text":"num_points(tri::Triangulation)\n\nGiven a triangulation tri, returns the number of points.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(tri::Triangulation, ij)\nis_boundary_edge(tri::Triangulation, i, j)\n\nGiven a triangulation tri and an edge (i, j), returns true  if (i, j) is a boundary edge or false if not. \n\nThis predicate takes care for the orientation of the edge: a boundary edge  is one that has only two solid vretices, so that get_adjacent(tri, ij) ≤ I(BoundaryIndex).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_map","text":"get_boundary_map(tri::Triangulation)\n\nReturns the boundary_map field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_index_ranges","text":"get_boundary_index_ranges(tri::Triangulation)\n\nReturns the boundaryindexranges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(tri::Triangulation, i, j, k)\nis_boundary_triangle(tri::Triangulation, T)\n\nGiven a triangulation tri and a triangle T, returns true  if T is a boundary triangle or false if not.\n\nNote that this is different from testing if T is a ghost  triangle - it is assumed that T is a solid triangle.   \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(tri::Triangulation, i, j, k)\ntriangle_orientation(tri::Triangulation, T)\n\nGiven a triangle T = (i, j, k) and a triangulation tri,  computes the orientation of the triangle. In particular, returns:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nA test is also made for the case that is_ghost_triangle(T): If  T  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly. In case the boundary  index corresponds to an interior curve, this flip is not necessary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(tri::Triangulation, i, j, k, ℓ)\npoint_position_relative_to_circumcircle(tri::Triangulation, T, ℓ)\n\nGiven a triangle T = (i, j, k), a triangulation tri, and a point  with index ℓ, pₗ, computes the position this point pₗ relative to the  triangle's circumcircle, making use of point_position_relative_to_circle.\n\nThe returned values are:\n\nCertificate.Outside: pₗ is outside of the circumcircle.\nCertificate.On: pₗ is on the circumcircle.\nCertificate.Inside: pₗ is inside the circumcircle.\n\nA test is also made for the case that is_ghost_triangle(T): When T is a ghost triangle, one of its indices is a boundary index, say i.  Since this vertex is treated as being out at infinity, the circumcircle  degenerates into the line through the other two vertices. Thus, we test  that pₗ is inside this circumcircle by seeing if it is in the oriented  outer halfplane defined by the two other vertices. See also  point_position_relative_to_oriented_outer_halfplane.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(tri::Triangulation, i, j, u)\n\nGiven indices i, j, and u corresponding to indices  of points in the triangulation tri, corresponding to  coordinates say a, b, and p, respectively, computes the  position of p relative to the oriented line (a, b). \n\nThe returned values are:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line.\n\nIf is_ghost_edge(i, j), the oriented line (a, b) is flipped  since the point corresponding to the boundary index will be a  centroid which swaps the orientation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(tri::Triangulation, i, j, u)\n\nGiven indices i, j, and u corresponding to indices  of points in the triangulation tri, corresponding to  coordinates say a, b, and p, respectively, computes the  position of p relative to the oriented line segment (a, b), assuming that the three points are collinear.\n\nThe returned values are:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(tri::Triangulation, u, v, i, j)\n\nGiven two pairs of indices (u, v) and (i, j), with  all indices corresponding to points in the triangulation tri, tests  the number of intersections between the two line segments  associated with these indices.\n\nLetting p, q, a, and b be the points referred to by  u, v, i, and j, respectively, we return:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point.\nCertificate.On: One of the endpoints is on [a, b], but there are no other intersections.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(tri::Triangulation, i, j, k, u)\npoint_position_relative_to_triangle(tri::Triangulation, T, u)\n\nGiven a triangle T = (i, j, k) and another index u,  with indices referring to points in the triangulation tri, computes  the position of u relative to the triangle.\n\nLetting p, q, a, and b be the points referred to by  i, j, k, and u, respectively, we return:\n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\nIf T is a ghost triangle, Certificate.Inside is returned.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(tri::Triangulation, i)\n\nGiven a triangulation tri and an index i, tests if i is the index of a boundary  corresponding to the outermost boundary of the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(tri::Triangulation, i)\n\nGiven a triangulation tri and an index i, tests if i is the index of a node  on the outermost boundary of the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(tri::Triangulation, i, j)\nedge_exists(tri::Triangulation, ij)\n\nGiven a triangulation tri and an edge (i, j), tests if the edge (i, j) is  in the triangulation. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(tri::Triangulation)\n\nGiven a triangulation tri, tests if the triangulation has ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_boundary_nodes","text":"has_boundary_nodes(tri::Triangulation)\n\nGiven a triangulation tri, tests if the triangulation has boundary nodes -  these are nodes that are constrained to be there, not those on the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q)\n\nGiven a point q, finds the triangle in the triangulation tri containing it by  searching over all triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.jump_and_march-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.jump_and_march","text":"jump_and_march(tri::Triangulation, q;\n    m=default_num_samples(num_points(tri)),\n    point_indices=each_point_index(tri),\n    try_points=(),\n    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),\n    check_existence::C=Val(has_multiple_segments(tri)),\n    rng::AbstractRNG=Random.default_rng())\n\nUsing the jump and march algorithm, finds the triangle in the triangulation tri containing the  query point q.\n\nArguments\n\ntri: The Triangulation.\nq: The query point.\n\nKeyword Arguments\n\nm=default_num_samples(num_points(pts)): The number of samples to use when sampling an initial point from select_initial_point. Only relevant if k is not specified. \npoint_indices: The indices for the points. Only relevant if k is not specified. \ntry_points=(): Extra points to try when sampling an initial point from select_initial_point. Only relevant if k is not specified. \nk=select_initial_point(pts, q; m, point_indices, try_points): Where to start the algorithm.\ncheck_existence::C=Val(has_multiple_segments(tri)): Whether to check that the edge exists when using get_adjacent, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See get_adjacent.\n\nOutput\n\nReturns the triangle V containing the query point q.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.integer_type-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.integer_type","text":"integer_type(tri::Triangulation{P,Ts,I}) where {P,Ts,I}\n\nGiven a triangulation tri, returns the type used for representing  the integers.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.number_type-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.number_type","text":"number_type(::Triangulation{P}) where {P}\n\nGiven a triangulation tri, returns the type used for representing  individual coordinates.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0))\n\nGiven a triangulation tri, computes representative points for each region using  pole_of_inaccessibility. If you only want to update the point for the convex hull, set use_convex_hull = true - this will only update RepresentativePointList[1].\n\nSee also RepresentativePointList.\n\nwarning: Warning\nWhile this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like update_centroid_after_addition  and update_centroid_after_deletion treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of triangulate).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.clear_empty_features!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.clear_empty_features!","text":"clear_empty_features!(tri::Triangulation)\n\nRemoves empty keys from the Adjacent and Adjacent2Vertex maps from the triangulation tri, and all points with empty neighbourhoods  from the Graph. \n\nSee also clear_empty_keys! and clear_empty_points!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.find_edge","text":"find_edge(tri::Triangulation, T, ℓ)\n\nGiven a triangle T, a triangulation tri, and a point index  ℓ which is assumed to correspond to some point on an edge of T,  returns the edge (u, v) that the point is on.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_constrained_edges","text":"get_constrained_edges(tri::Triangulation)\n\nReturns the constrained_edges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_constrained-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.is_constrained","text":"is_constrained(tri::Triangulation)\n\nReturns true if tri has any constrained edges, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.all_boundary_indices","text":"all_boundary_indices(tri::Triangulation)\n\nReturns an iterator over all boundary indices in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"triangulations/plotting/","page":"Plotting","title":"Plotting","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"triangulations/plotting/","page":"Plotting","title":"Plotting","text":"triplot!","category":"page"},{"location":"triangulations/plotting/#DelaunayTriangulation.triplot!","page":"Plotting","title":"DelaunayTriangulation.triplot!","text":"triplot(!)(points, triangles, boundary_nodes, convex_hull, args...; kwargs...)\ntriplot(!)(tri::Triangulation, args...; kwargs...)\n\nPlots a triangulation. The available attributes are:\n\nmarkersize=11\n\nMarkersize for the points. \n\nshow_ghost_edges=false\n\nWhether to plot interpretations of the ghost edges. If the ghost edges  are on the outermost boundary, then a ghost edge is a line starting at  the solid vertex and parallel with the vertex of the domain, pointing  outwards. If the ghost edge is an interior ghost edge, then an edge  is shown that connects with the centroid of the corresponding interior.\n\nrecompute_centers=true\n\nOnly relevant if show_ghost_edges. This will recompute the representative centers for  each region if needed. \n\nshow_all_points=false\n\nWhether to plot all points. If false, only plots those that correspond  to a solid triangle. \n\npoint_color=:red\n\nOnly relevant if show_all_points. Colour to use for the points.\n\nstrokecolor=:black\n\nColour to use for the edges of the triangles.\n\ntriangle_color=(:white, 0.0)\n\nColour to use for the triangles. \n\nghost_edge_color=:blue\n\nOnly relevant if show_ghost_edges. Colour to use for the ghost edges. \n\nghost_edge_linewidth=1\n\nOnly relevant if show_ghost_edges. Linewidth to use for the ghost edges.\n\nstrokewidth=1\n\nThe width of the triangle edges.\n\nghost_edge_extension_factor=10.0\n\nOnly relevant if show_ghost_edges. For the outermost ghost edges, we extrapolate  a line to decide its extent away from the boundary. This is the factor  used.\n\nplot_convex_hull=true\n\nWhether to also plot the convex hull of the points.\n\n`convexhullcolor=:grey'\n\nOnly relevant if plot_convex_hull. The linecolor to use for the convex hull.\n\nconvex_hull_linestyle=:dash\n\nOnly relevant if plot_convex_hull. The linestyle to use for the convex hull.\n\nconvex_hull_linewidth=2\n\nOnly relevant if plot_convex_hull. The linewidth to use for the convex hull.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent/#Adjacent","page":"Adjacent","title":"Adjacent","text":"","category":"section"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"The Adjacent map is used for mapping edges to vertices that together form a positively oriented triangle. The definition of the Adjacent map is below:","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"struct Adjacent{I,E}\n    adjacent::DefaultDict{E,I,I}\n    function Adjacent{I,E}() where {I,E}\n        A = DefaultDict{E,I,I}(I(DefaultAdjacentValue))\n        adj = new{I,E}(A)\n        return adj\n    end\n    Adjacent(adj::DefaultDict{E,I,I}) where {I,E} = new{I,E}(adj)\nend","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"We use a DefaultDict from DataStructures.jl for storing these relationships. We need to use a DefaultDict rather than a Dict so that we more efficiently check if an edge exists, simply seeing if get_adjacent(adj, u, v) returns a DefaultAdjacentValue (see the edge_exists function). We list the complete docstring for Adjacent below, along with individual docstrings for methods for working with Adjacent.","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"Adjacent\nget_adjacent(::Adjacent)\nget_adjacent(::Adjacent{I, E}, ::E) where {I, E, V}\nadd_adjacent!(::Adjacent, ::Any, ::Any)\ndelete_adjacent!(::Adjacent, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\nadd_triangle!(::Adjacent, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\ndelete_triangle!(::Adjacent, ::Any)\nclear_empty_keys!(::Adjacent)","category":"page"},{"location":"data_structures/adjacent/#DelaunayTriangulation.Adjacent","page":"Adjacent","title":"DelaunayTriangulation.Adjacent","text":"Adjacent{I,E}\n\nStruct for storing adjacency relationships for mapping edges to vertices that  together form a positively oriented triangle in an associated triangulation.  The type I is the integer type used, while E is the edge type.\n\nSee the docs for a description of how boundary edges  are handled.\n\nSee also Adjacent2Vertex.\n\nFields\n\nadjacent::DefaultDict{E,I,I}\n\nThe Dict used for storing the edges (the keys) and the associated vertices  (the values). If (u, v) is not a valid edge, then w = adjacent[(u, v)] returns 0 (this value is defined in DefaultAdjacentValue). Otherwise, (u, v, w) is a positively oriented triangle.\n\nConstructors\n\nThe adjacent map can be constructed in two ways:\n\nAdjacent{I, E}() where {I, E}\n\nCreates an empty map.\n\nAdjacent(adj::DefaultDict{E,I,I}) where {E,I,I}\n\nCreates an adjacent map from an existing DefaultDict.\n\nExtended help\n\nYou should not work with the adjacent field directly. We provide the following  functions for working with Adjacent, where adj denotes an Adjacent{I, E} type. (Type information in the function signatures is omitted.)\n\nAccessors\n\nget_adjacent(adj)\nget_adjacent(adj, uv) or get_adjacent(adj, u, v)\n\nIn the latter methods, you can also use the keyword argument check_existence to  declare whether to check that the edge exists. This would be used if you need  to be careful about different boundary indices on the same boundary curve. The  default value is Val(false), meaning this isn't checked.\n\nMutators\n\nadd_adjacent!(adj, uv, w) or add_adjacent!(adj, u, v, w)\ndelete_adjacent!(adj, uv) or delete_adjacent!(adj, u, v)\nadd_triangle!(adj, i, j, k) or add_triangle!(adj, T)\nadd_triangle!(adj, T...)\ndelete_triangle!(adj, i, j, k) or delete_triangle!(adj, T)\ndelete_triangle!(adj, T...)\nclear_empty_keys!(adj)\n\nIteration\n\nYou can also iterate over Adjacent maps the same way as you would  with a Dict, e.g.\n\nfor (edge, vertex) in adj \n    get_adjacent(adj, edge) == vertex \nend\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent)\n\nGiven the adjacent map adj, returns the adjacent field.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Union{Tuple{V}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E, V}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent{I,E}, uv::E; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\nget_adjacent(adj::Adjacent{I,E}, u, v; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\n\nGiven the adjacent map adj and an edge (u, v), returns the vertex w such that (u, v, w) is a positively oriented triangle in the underlying  triangulation.\n\nIn the case of a ghost edge, check_existence = Val(true) may be useful in case the  boundary curve has multiple segments, meaning multiple boundary indices correspond  to the same curve. Assuming the boundary index came from a neighbouring triangle,  setting check_existence = Val(true) will check neighbouring boundary indices  in case the found edge does not exist. When is_true(check_existence), you also need to provide the range of boundary indices to check via the keyword argument boundary_index_ranges. This should be  the Dict from construct_boundary_index_ranges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(adj::Adjacent, uv, w)\nadd_adjacent!(adj::Adjacent{I,E}, u, v, w) where {I,E}\n\nGiven the adjacent map adj, an edge (u, v), and a vertex w, adds  the edge (u, v) with corresponding value w into the adjacent map  so that (u, v, w) is a positively oriented triangle in the  underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(adj::Adjacent, uv)\ndelete_adjacent!(adj::Adjacent{I,E}, u, v) where {I,E}\n\nGiven the adjacent map adj and an edge (u, v), deletes the  edge (u, v) from the adjacent map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  adds that triangle into the adjacent map. In particular, adds the edges (i, j), (j, k), and (k, i) into adj with corresponding values k, i, and j,  respectively.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., adds the  triangles into adj. See also add_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  deletes that triangle into the adjacent map. In particular, deletes the edges (i, j), (j, k), and (k, i) from adj.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., deletes the  triangles from adj. See also delete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent}","page":"Adjacent","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj::Adjacent)\n\nGiven an Adjacent map adj, removes any edges that  map to 0`.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent2vertex/#Adjacent2Vertex","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"","category":"section"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"The Adjacent2Vertex map is closely related to the Adjacent map. Instead of mapping edges to vertices that together form positively oriented triangles, we map vertices to all edges that will form a positively oriented triangle with that vertex. The definition is simply via a Dict:","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"struct Adjacent2Vertex{I,Es,E}\n    adjacent2vertex::Dict{I,Es}\n    function Adjacent2Vertex{I,Es,E}() where {I,Es,E}\n        D = Dict{I,Es}()\n        TA2V = new{I,Es,E}(D)\n        return TA2V\n    end\n    Adjacent2Vertex(adj2v::Dict{I,Es}) where {I,Es} = new{I,Es,edge_type(Es)}(adj2v)\nend","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"A complete list of methods used for working with this struct, along with the struct's docstring itself, is shown below.","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"Adjacent2Vertex \nget_adjacent2vertex(::Adjacent2Vertex)\nget_adjacent2vertex(::Adjacent2Vertex, ::Any)\nadd_adjacent2vertex!(::Adjacent2Vertex{I,Es,E}, ::Any, ::Any) where {I,Es,E}\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any, ::Any)\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\nadd_triangle!(::Adjacent2Vertex, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\ndelete_triangle!(::Adjacent2Vertex, ::Any)\nclear_empty_keys!(::Adjacent2Vertex)","category":"page"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex","page":"Adjacent2Vertex","title":"DelaunayTriangulation.Adjacent2Vertex","text":"Adjacent2Vertex{I, Es, E}\n\nStruct for storing adjacency relationships for mapping vertices to  all other edges that together form a positively oriented triangle  in an associated triangulation. The type I is the integer type  used, Es is the type used for representing a collection of edges,  and E is the type for a single edge.\n\nSee the docs for a description of how boundary edges  are handled.\n\nSee also Adjacent.\n\nFields\n\nadjacent2vertex::Dict{I, Es}\n\nThe Dict used for storing the vertices (the keys) and the associated  collection of edges (the values). In particular, if w is a vertex,  then (u, v, w) is a positively oriented triangle for each  (u, v) in adjacent2vertex[w].\n\nConstructors\n\nThe adjacent2vertex map can be constructed in two ways:\n\nAdjacent2Vertex{I,Es,E}()\n\nCreates an empty map.\n\nAdjacent2Vertex(adj2v::Dict{I,E}) where {I,Es}\n\nCreates an adjacent2vertex map from an existing Dict. The type E is obtained from  edge_type(Es).\n\nExtended help\n\nYou should not work with the adjacent2vertex field directory. We provide the  following functions for working with Adjacent2Vertex, where adj2v  denotes an Adjacent2Vertex{I,Es,E} type. (Type information in the  function signatures is omitted.)\n\nAccessors\n\nget_adjacent2vertex(adj2v)\nget_adjacent2vertex(adj2v, w)\n\nMutators\n\nadd_adjacent2vertex!(adj2v, w, uv) or add_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w, uv) or delete_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w)\nadd_triangle!(adj2v, i, j, k) or add_triangle!(adj2v, T)\nadd_triangle!(adj2v, T...)\ndelete_triangle!(adj2v, i, j, k) or delete_triangle!(adj2v, T)\ndelete_triangle!(adj2v, T...)\nclear_empty_keys!(adj2v)\n\nIteration\n\nYou can also iterate over Adjacent2Vertex maps the same way as you would  with a Dict, e.g. if adj is a corresponding Adjacent map,\n\nfor (vertex, edge_list) in adj2v \n    for edge in each_edge(edge_list)\n        get_adjacent(adj, edge) == vertex \n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex)\n\nReturns the adjacent2vertex field from the adjacent2vertex map adj2v.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, returns the set of  edges associated with the vertex w, i.e. the set of edges (u, v) such that  (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_adjacent2vertex!-Union{Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent2Vertex{I, Es, E}, Any, Any}} where {I, Es, E}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, uv) where {I,Es,E}\nadd_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), adds  the edge (u, v) into the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w, uv)\ndelete_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), deletes  the edge (u, v) from the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, deletes  the key w from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, adds that triangle from the  map. In particular, adds the edges (i, j), (j, k), and (k, i)  into the set of edges associated with the vertices k, i, and j, respectively, in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent map adj2v and triangles T..., adds the  triangles into adj2v. See also add_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, deletes that triangle from the  map. In particular, deletes the edges (i, j), (j, k), and (k, i)  from the set of edges associated with the vertices k, i, and j, respectively, from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent2vertex map adj2v and triangles T..., deletes the  triangles from adj2v. See also delete_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj2v::Adjacent2Vertex)\n\nGiven an Adjacent2Vertex map adj2v, removes  any keys that map to empty sets.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"#DelaunayTriangulation","page":"Home","title":"DelaunayTriangulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DelaunayTriangulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for computing Delaunay triangulations of planar point sets. We currently only support unconstrained Delaunay triangulations, but we do have an interface that supports constrained Delaunay triangulations. Constrained Delaunay triangulations can be computed using Gmsh if needed; see the Gmsh discussion in the sidebar. Unconstrained Delaunay triangulations are computed with the Bowyer-Watson algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure that the triangulations are robust to degeneracies, we use ExactPredicates.jl for all geometrical predicates. The results from these predicates are handled through a Certificate module, as outlined in the predicates section in the sidebar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Much of the work in this package is derived from the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the future, the top priorities would be:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Triangulation of convex polygons, and hence support for vertex deletion.\nConstrained Delaunay triangulation.\nSpatial sorting.\n(Clipped) Voronoi tessellations.","category":"page"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/representative/#Representative-Coordinates","page":"Representative Coordinates","title":"Representative Coordinates","text":"","category":"section"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"When we are building the triangulations, we need to have a point that represents the center of the domain at each stage so that ghost triangles can be worked with for point location. The main type we use for this is RepresentativeCoordinates:","category":"page"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"RepresentativeCoordinates","category":"page"},{"location":"data_structures/representative/#DelaunayTriangulation.RepresentativeCoordinates","page":"Representative Coordinates","title":"DelaunayTriangulation.RepresentativeCoordinates","text":"mutable struct RepresentativeCoordinates{I,T}\n\nStruct representing the representative point of a region.\n\nSee also RepresentativePointList.\n\nFields\n\nx: The x-coordinate. \ny: The y-coordinate. \nn: The number of points defining the centroid, if that is what is being used.\n\nUsage\n\nSee reset!, add_point!, delete_point!, and compute_representative_point!.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"More accurately, we maintain a list of such coordinates, one for each boundary curve. This list is a const, given below.","category":"page"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"RepresentativePointList","category":"page"},{"location":"data_structures/representative/#DelaunayTriangulation.RepresentativePointList","page":"Representative Coordinates","title":"DelaunayTriangulation.RepresentativePointList","text":"const RepresentativePointList = Dict{Int64,RepresentativeCoordinates{Int64, Float64}}()\n\nThis is a list of points for a set of representative points corresponding to multiple  curves.\n\nSee also update_centroid_after_addition, update_centroid_after_deletion, reset_centroids!, empty_centroids!, get_representative_point_coordinates, and new_centroid.\n\nwarning: Warning\nWhile the function compute_representative_points! computes  an appropriate visual center of the polygon represented by the curves, i.e. by joining  points, the update functions like update_centroid_after_addition  and update_centroid_after_deletion treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse compute_representative_points! again (as is  done at the end of triangulate).\n\n\n\n\n\n","category":"constant"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"This list is updated at the end of a triangulation to be given by the poles of inaccessibilities (see the sidebar), but when the triangulation is being built it is given by the arithmetic mean of all points in the triangulation. Some other docstrings are below.","category":"page"},{"location":"data_structures/representative/","page":"Representative Coordinates","title":"Representative Coordinates","text":"get_representative_point_coordinates \ncompute_representative_points!(::Any, ::Any)","category":"page"},{"location":"data_structures/representative/#DelaunayTriangulation.get_representative_point_coordinates","page":"Representative Coordinates","title":"DelaunayTriangulation.get_representative_point_coordinates","text":"get_representative_point_coordinates(i::I, ::Type{T}) where {I, T}\n\nGiven an index i and some number type T, returns the coordinates  corresponding to the centroid in RepresentativePointList at the key i. The returned value is a Tuple (T(x), T(y)) of the coordinates.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/representative/#DelaunayTriangulation.compute_representative_points!-Tuple{Any, Any}","page":"Representative Coordinates","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(points, boundary_nodes; precision = 1.0)\n\nGiven a list of points and a list of boundary_nodes, computes visual centers for  the polygons represented by these curves using pole_of_inaccessibility. The  keyword argument precision is the precision used in pole_of_inaccessibility.\n\nSee also RepresentativePointList.\n\nwarning: Warning\nWhile this function computes an appropriate visual center of the polygon represented by the curves, i.e. by joining points, the update functions like update_centroid_after_addition  and update_centroid_after_deletion treat the centroid as if it is a  mean of all the points. If you need to use the actual visual centers of the  polygons, you will need to reuse this function again (as is  done at the end of triangulate).\n\n\n\n\n\n","category":"method"}]
}
