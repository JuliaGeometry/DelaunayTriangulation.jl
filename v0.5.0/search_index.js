var documenterSearchIndex = {"docs":
[{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/point_location/#Point-Location","page":"Point Location","title":"Point Location","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The most expensive step for building a Delaunay triangulation is the point location step, wherein we need to find a triangle that contains a given point. The code for this turns out to be very complicated so that we can correctly handle points outside of the domain, inside interior holes, collinear with other points, on the corner, etc. The main function that handles all of this is jump_and_march, derived from the jump-and-march algorithm of Mücke, Saias, and Zhu (1999). We also provide a method that simply searches over all triangles, given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"brute_force_search","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.brute_force_search","page":"Point Location","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q)\n\nReturns the triangle in tri containing q using brute force search.\n\n\n\n\n\nbrute_force_search(T, r, pts, representative_point_list, boundary_map)\n\nSearches for the triangle in T containing the point r in T using brute force, simply  searching over all triangles. Ghost triangles are handled via the representative_point_list and boundary_map from construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#The-Main-Method","page":"Point Location","title":"The Main Method","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Below we list docstrings for the main jump and march algorithm.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"jump_and_march ","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.jump_and_march","page":"Point Location","title":"DelaunayTriangulation.jump_and_march","text":"jump_and_march(tri::Triangulation, q;\n    point_indices=each_point_index(tri),\n    m=default_num_samples(length(point_indices)),\n    try_points=(),\n    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),\n    check_existence::C=Val(has_multiple_segments(tri)),\n    store_history::F=Val(false),\n    history=nothing,\n    rng::AbstractRNG=Random.default_rng(),\n    exterior_curve_index=1) where {C,F}\n\nReturns the triangle containing q using the jump-and-march algorithm.\n\nArguments\n\ntri::Triangulation: The triangulation.\nq: The query point.\n\nKeyword Arguments\n\npoint_indices=each_point_index(tri): The indices of the points in the triangulation.\nm=default_num_samples(length(point_indices)): The number of samples to use when sampling the point to start the algorithm at.\ntry_points=(): Additional points to try when determining which point to start at.\nk=select_initial_point(get_points(tri), q; m, point_indices, try_points): The index of the point to start the algorithm at. \ncheck_existence::C=Val(has_multiple_segments(tri)): This is used when we want to check the existence of certain ghost triangles. See [get_adjacent}(@ref).\nstore_history::F=Val(false): Whether to record the history of the algorithm. See also PointLocationHistory.\nhistory=nothing: The object to store the history into, if is_true(store_history).\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nmaxiters = num_triangles(tri): Maximum number of iterations to perform before restarting the algorithm at a new initial point. \n\nnote: Note\nYou shouldn't ever need maxiters if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the maxiters keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, the value of m is doubled each time.\n\nOutputs\n\nReturns V, the triangle in tri containing q.\n\n\n\n\n\njump_and_march(pts, adj, adj2v, graph, boundary_index_ranges, representative_point_list, boundary_map, q;\n    m=default_num_samples(num_points(pts)),\n    point_indices=each_point_index(pts),\n    try_points=(),\n    k=select_initial_point(pts, q; m, point_indices, try_points),\n    TriangleType::Type{V}=NTuple{3,I},\n    check_existence::C=Val(has_multiple_segments(boundary_map)),\n    store_history::F=Val(false),\n    history=nothing,\n    rng::AbstractRNG = Random.default_rng(),\n    exterior_curve_index=1,\n    maxiters = 2 + length(exterior_curve_index) - num_vertices(graph) + num_edges(graph)) where {I,V,C,F}\n\nUsing the jump and march algorithm, finds the triangle in the triangulation containing the  query point q.\n\nArguments\n\npts: The collection of points.\nadj: The Adjacent map.\ngraph: The Graph.\nboundary_index_ranges: The Dict mapping boundary indices to ranges from construct_boundary_index_ranges.\nrepresentative_point_list: The Dict mapping curve indices to representative points.\nboundary_map: The boundary map from construct_boundary_map handling the mapping of boundary indices. \nq: The query point.\n\nKeyword Arguments\n\nm=default_num_samples(num_points(pts)): The number of samples to use when sampling an initial point from select_initial_point. Only relevant if k is not specified. \npoint_indices: The indices for the points. Only relevant if k is not specified. \ntry_points=(): Extra points to try when sampling an initial point from select_initial_point. Only relevant if k is not specified. \nk=select_initial_point(pts, q; m, point_indices, try_points): Where to start the algorithm.\nTriangleType::Type{V}=NTuple{3,I}: The type used for representing the triangles. \ncheck_existence::C=Val(has_multiple_segments(boundary_map)): Whether to check that the edge exists when using get_adjacent, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See get_adjacent.\nstore_history::F=Val(false): Whether to store visited triangles. Exterior ghost triangles will not be stored.\nhistory=nothing: The history. This should be a PointLocationHistory type if store_history is true.\nrng::AbstractRNG: The RNG to use.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nmaxiters = 2 + length(exterior_curve_index) - num_vertices(graph) + num_edges(graph): Maximum number of iterations to perform before restarting the algorithm at a new initial point. The default comes from Euler's formula, rearranged for the number of triangles.\n\nnote: Note\nYou shouldn't ever need maxiters if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the maxiters keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, m is set to num_vertices(graph).\n\nOutput\n\nReturns the triangle V containing the query point q.\n\nwarning: Warning\nIf your triangulation does not have ghost triangles, and the point q is outside of the triangulation,  this function may fail to terminate. You may like to add ghost triangles in this case (using  add_ghost_triangles!), noting that there is no actual triangle that q is inside of when it is outside of the triangulation unless ghost triangles are present. \n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The variant of the jump and march algorithm for points outside of the triangle is also accessed via the jump_and_march, calling into exterior_jump_and_march:","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"exterior_jump_and_march","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.exterior_jump_and_march","page":"Point Location","title":"DelaunayTriangulation.exterior_jump_and_march","text":"exterior_jump_and_march(\n    pts, \n    adj, \n    boundary_index_ranges, \n    representative_point_list,\n    boundary_map, \n    k, \n    q, \n    check_existence=Val(has_multiple_segments(boundary_map)),\n    bnd_idx=I(BoundaryIndex))\n\nGiven a point q outside of the triangulation, finds the ghost triangle containing it.\n\nArguments\n\npts: The collection of points.\nadj: The Adjacent map.\nboundary_index_ranges: A Dict mapping boundary indices to ranges from construct_boundary_index_ranges.\nrepresentative_point_list: A Dict mapping curve indices to representative points.\nboundary_map: A boundary map from construct_boundary_map.\nk: The vertex to start from.\nq: The point outside of the triangulation.\ncheck_existence=Val(has_multiple_segments(boundary_map))): Used to check that the edge exists when using get_adjacent, in case there are multiple segments.\nbnd_idx=I(BoundaryIndex): A boundary index corresponding to the boundary that k is on.\n\nOuptut\n\nThe edge (i, j) such that the ghost triangle (i, j, g) contains q, and g = get_adjacent(adj, i, j).\n\nwarning: Warning\nThe result is meaningless if q is inside of the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"You should not need to call into this method directly.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The core complexity of the algorithm comes from having to find the direction of the point from an initial search point. The docstrings for some of these initialisers are given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"default_num_samples\nselect_initial_point \nselect_initial_triangle_interior_node \ncheck_for_intersections_with_adjacent_boundary_edges\nsearch_down_adjacent_boundary_edges\ncheck_for_intersections_with_interior_edges_adjacent_to_boundary_node","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.default_num_samples","page":"Point Location","title":"DelaunayTriangulation.default_num_samples","text":"default_num_samples(num_points)\n\nReturns ceil(cbrt(num_points)). This is the default number of samples  to use when sampling in the jump-and-march algorithm.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_point","page":"Point Location","title":"DelaunayTriangulation.select_initial_point","text":"select_initial_point(pts, q;\n    point_indices=each_point_index(pts),\n    m=default_num_samples(length(point_indices)),\n    try_points=(),\n    rng::AbstractRNG=Random.default_rng())\n\nGiven a collection of points and a point q, select m random points from pts and return  the one that is closet to q.\n\nArguments\n\npts: The set of points.\nq: The coordinates of the query point, or its index in pts.\n\nKeyword Arguments\n\npoint_indices=each_point_index(pts): The indices of the points to consider.\nm=default_num_samples(length(point_indices)): The number of points to sample.\ntry_points=(): The indices of points to try in addition to the sampled points.\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\n\nOutputs\n\nk: The index of the point in pts that is closest to q out of the points sampled.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_triangle_interior_node","page":"Point Location","title":"DelaunayTriangulation.select_initial_triangle_interior_node","text":"select_initial_triangle_interior_node(\n    pts, \n    adj, \n    adj2v, \n    graph,\n    representative_point_list, \n    boundary_map, \n    k, \n    q, \n    boundary_index_ranges, \n    check_existence=Val(has_multiple_segments(boundary_map)),\n    store_history=Val(false),\n    history=nothing,\n    rng::AbstractRNG = Random.default_rng())\n\nSelects an initial triangle for the jump-and-march algorithm, starting from a point with index k  and finding the triangle such that the line from the kth point to q intersects it. It is assumed  that k is a point that is not on the boundary. \n\nArguments\n\npts: The set of points. \nadj: The Adjacent map.\nadj2v: The Adjacent2Vertex map.\ngraph: The Graph of the triangulation.\nrepresentative_point_list: The list of representative points, giving the coordinates of points corresponding to boundary indices.\nboundary_map: The map taking boundary indices to their corresponding segment in the boundary nodes. See construct_boundary_map.\nk: The index of the point in pts that we are starting at.\nq: The point being searched for.\nboundary_index_ranges: The Dict handling the mapping of boundary indices to the range of boundary indices belonging to the same curve. See construct_boundary_index_ranges.\ncheck_existence=Val(has_multiple_segments(boundary_map)): Checks for different possible boundary indices when there are multiple segments. See get_adjacent.\nstore_history=Val(false): Whether to store visited triangles. Exterior ghost triangles will not be stored.\nhistory=nothing: The history. This should be a PointLocationHistory type if store_history is true.\nrng::AbstractRNG = Random.default_rng(): The random number generator.\n\nOutputs\n\np: The kth point in pts.\ni, j: These are indices defining the edge of a triangle including the point p, such that i is to the left of the line pq and j is to the right of pq.\npᵢ, pⱼ: The points in pts corresponding to the indices in i and j, respectively.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","text":"check_for_intersections_with_adjacent_boundary_edges(\n    pts, \n    adj, \n    boundary_index_ranges, \n    boundary_map, \n    k, \n    q, \n    check_existence = Val(has_multiple_segments(boundary_map)),\n    bnd_idx=I(BoundaryIndex))\n\nAssuming that k is on the outer boundary, this function searches down the boundary edges adjacent to k to try and locate a triangle  or edge containing q.\n\nSee also search_down_adjacent_boundary_edges, which uses this function to determine an initial direction to search along a  straight boundary in case q is collinear with it.\n\nArguments\n\npts: The set of points. \nadj: The Adjacent map.\nboundary_index_ranges: The list of boundary index ranges from construct_boundary_index_ranges, giving a range of boundary indices for a given boundary index all belonging to the same curve. \nboundary_map: The boundary map from construct_boundary_map, which maps a boundary index to its corresponding segment. \nk: The outer boundary point k to start searching from.\nq: The query point q.\ncheck_existence: The same keyword argument from get_adjacent, and is needed when you use multiple segments in your boundary.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThe output is a 5-tuple, with the first three elements having several possible forms:\n\n(Certificate.Outside, Certificate.Outside, k): The point q is not collinear with either of the adjacent boundary edges.\n(Certificate.Right, C, r), where C is either Certificate.On or Certificate.Right and r is the vertex right of k: The point q is collinear with the edge to the right of k. If C is Certificate.On, then q is on the edge, whereas C being Certificate.Right means it is right of the edge. \n(Certificate.Left, C, ℓ), where C is either Certificate.On or Certificate.Left and ℓ is the vertex left of k: The point q is collinear with the edge to the left of k. If C is Certificate.On, then q is on the edge, whereas C being Certificate.Left means it is left of the edge.\n\nIn the latter two outputs above, C could also be Certificate.Degenerate, which means that q is get_point(pts, r) or get_point(pts, ℓ), respectively.\n\nThe latter two elements of the tuple are: \n\nright_cert: The position of q relative to the edge (p, p_right), where p_right is the point on the boundary to the right of p.\nleft_cert: The position of q relative to the edge (p, p_left), where p_left is the point on the boundary to the left of p.\n\nThese returned values are useful in case we need to go to check_for_intersections_with_interior_edges_adjacent_to_boundary_node, since we can reuse these certificates.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.search_down_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.search_down_adjacent_boundary_edges","text":"search_down_adjacent_boundary_edges(\n    pts, \n    adj,\n    boundary_index_ranges, \n    representative_point_list, \n    boundary_map, \n    k, \n    q,\n    direction, \n    q_pos, \n    next_vertex,\n    check_existence=Val(has_multiple_segments(boundary_map)),\n    store_history=Val(false),\n    history=nothing,\n    bnd_idx=I(BoundaryIndex))\n\nStarting at the outer boundary node k, walks down the boundary in the direction of q until finding q or finding that it is outside of the triangulation. \n\nArguments\n\npts: The collection of points.\nadj: The Adjacent map.\nboundary_index_ranges: The list of boundary index ranges from construct_boundary_index_ranges.\nrepresentative_point_list: The list of representative points. \nboundary_map: The boundary map from construct_boundary_map.\nk: The outer boundary index.\nq: The point being searched for.\ndirection: The direction of q from get_point(pts, k).\nq_pos: The certificate for the position of q from this point k.\nnext_vertex: The next vertex in the direction of q (this argument comes from check_for_intersections_with_adjacent_boundary_edges).\ncheck_existence=Val(has_multiple_segments(boundary_map)): The same keyword argument from get_adjacent, and is needed when you use multiple segments in your boundary.\nstore_history=Val(false): Whether to store the history of the search.\nhistory=nothing: The history of the search.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThe output takes the form (cert, u, v, w), where: \n\ncert: This is Certificate.On if q is on the edge (u, v), and Certificate.Outside if q is outside of the triangulation.\n(u, v, w): If is_on(cert), then this is a positively oriented triangle with q on the edge (u, v). Otherwise, (u, v, w) is a ghost triangle close to q.\n\nwarning: Warning\nThis function relies on the assumption that the geometry is convex.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","text":"check_for_intersections_with_interior_edges_adjacent_to_boundary_node(\n    pts,\n    adj, \n    graph, \n    boundary_index_ranges, \n    representative_point_list,\n    boundary_map, \n    k, \n    q, \n    right_cert, \n    left_cert, \n    check_existence=Val(has_multiple_segments(boundary_map)), \n    store_history=Val(false), \n    history=nothing,\n    bnd_idx=I(BoundaryIndex))\n\nChecks if the line connecting the kth point of pts to q intersects any of the edges neighbouring the boundary node k.\n\nArguments\n\npts: The collection of points. \nadj: The Adjacent map.\ngraph: The Graph.\nboundary_index_ranges: The boundary index range mapping from construct_boundary_index_ranges.\nrepresentative_point_list: The list of representative points.\nboundary_map: The map that handles the mapping of boundary indices to boundary segments. Sse construct_boundary_map.\nk: The boundary node.\nq: The point we are searching for. \nright_cert: A certificate giving the position of q to the right of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\nleft_cert: A certificate giving the position of q to the left of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\ncheck_existence=Val(has_multiple_segments(boundary_nodes))): Checks for different possible boundary indices when there are multiple segments. See get_adjacent.\nstore_history=Val(false): Whether to store visited triangles. Exterior ghost triangles will not be stored.\nhistory=nothing: The history. This should be a PointLocationHistory type if store_history is true.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThere are several possible forms for the returned values. These are listed below, letting p be the kth point, pᵢ the point corresponding to  the index i, and pⱼ the point corresponding to the index j:\n\n(i, j, Certificate.Single, Certificate.Outside)\n\nThe line pq intersects the edge pᵢpⱼ, and (j, i, k) is a positively oriented triangle. In particular, pᵢ is left of pq and pⱼ is right of pq.\n\n(i, j, Certificate.None, Certificate.Inside)\n\nThe point q is inside the positively oriented triangle (i, j, k).\n\n(zero(I), zero(I), Cert.None, Cert.Outside)\n\nThe point q is outside of the triangulation. Note that I is the integer type.\n\n(i, j, Cert.On, Cert.Inside)\n\nThe point q is on the edge pᵢpⱼ, and so is inside the positively oriented triangle (i, j, k).\n\n(i, j, Cert.Right, Cert.Outside)\n\nThe point q is collinear with the edge pᵢpⱼ, but is off of it and further into the triangulation. \n\nwarning: Warning\nThis function should only be used after check_for_intersections_with_adjacent_boundary_edges, and currently is only guaranteed to work on convex geometries. \n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#History","page":"Point Location","title":"History","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"If you need to, you can also store the history of the algorithm. This is primarily only used for (and only tested for) constrained triangulations, as it helps us locate which triangles to delete. The struct we use for storing history is given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"PointLocationHistory ","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.PointLocationHistory","page":"Point Location","title":"DelaunayTriangulation.PointLocationHistory","text":"PointLocationHistory{T,E,I}\n\nHistory from using jump_and_march.\n\nFields\n\ntriangles::Vector{T}: The visited triangles. \ncollinear_segments::Vector{E}: Segments collinear with the original line pq using to jump.\ncollinear_point_indices::Vector{I}: This field contains indices to segments in collinear_segments that refer to points that were on the original segment, but there is no valid segment for them. We use manually fix this after the fact. For example, we could add an edge (1, 14), when really we mean something like (7, 14) which isn't a valid edge.\nleft_vertices::Vector{I}: Vertices from the visited triangles to the left of pq.\nright_verices::Vector{I}: Vertices from the visited triangles to the right of pq.\n\n\n\n\n\n","category":"type"},{"location":"other_features/point_location/#Basic-Description-of-the-Algorithm","page":"Point Location","title":"Basic Description of the Algorithm","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us give a basic description of what jump_and_march does.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"First, using select_initial_point, an initial point to start the algorithm is selected. This function samples some number m of points, and then selects the point that is closest to the query point q.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let the initially selected point be p_k. We break the discussion into two cases, where p_k is an interior point and p_k is a point on the boundary.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"If p_k is not a point on the boundary, then it is possible to completely rotate around the point searching for a triangle such that line overrightarrowp_kq intersects an edge of the triangle. This will give us an edge e_ij that overrightarrowp_kq intersects, and we will put p_i to the left of overrightarrowp_kq and p_j to the right. The function that handles this selection is select_initial_triangle_interior_node, which starts by handling the case of collinear edges and then rotates around. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now suppose that p_k is a point on the outer boundary. There are several possibilities in this case. First, overrightarrowp_kq might intersect a neighbouring boundary edge; secondly, overrightarrowp_kq could intersect a neighbouring interior edge; thirdly, overrightarrowp_kq could point away from the boundary, meaning q is outside of the boundary. The function starts by checking the neighbouring boundary edges, done via check_for_intersections_with_adjacent_boundary_edges, making use of get_right_boundary_node and get_left_boundary_node to obtain the neighbouring boundary nodes. If we find that overrightarrowp_kq does intersect a neighbouring boundary edge, then we can search down adjacent boundary edges via search_down_adjacent_boundary_edges until we either find an edge that q is on, or until we identify that q is outside of the triangulation – this function assumes the domain is convex, as triangulations being built are. If q is outside of the triangulation, then we can use the exterior variant of the jump and march algorithm, exterior_jump_and_march, to find the ghost triangle containing q. This functon simply rotates around the boundary until we find two ghost edges enclosing the point q. Now let us assume we did not find a neighbouring boundary edge that intersects overrightarrowp_kq. When this happens, we need to check the neighbouring interior edges, done via check_for_intersections_with_interior_edges_adjacent_to_boundary_node, which just rotates around the edges until we find an intersection. If we have still not found any intersection then, again assuming convexity, q must be outside of the triangulation and so we use exterior_jump_and_march.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now, if the algorithm is still going, then we need to start marching along the triangulation from p_k towards q. The idea is to keep marching, keeping p_i and p_j to the left and right of overrightarrowp_kq, respectively, until we find a case where p_ip_jq is no longer a positively oriented triangle. When this happens, it must mean that we have passed q, and so we have found the triangle. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us describe how this marching is done in more detail. First, we need to be careful of boundary indices, first checking for an outer boundary index. If we have found an outer boundary index, then we have marched into the boundary, and so q will be outside of the domain, meaning we go into exterior_jump_and_march. If this is not the case, then we march using get_adjacent to step onto the next triangle from a given edge e_ij. Then, checking the positions of the new points relative to overrightarrowp_kq and rearranging accordingly, we can step forward. We keep doing this until we get a negatively oriented triangle p_ip_jq. Unfortunately, this loop could terminate even if q is not in the found triangle, which can occasionally happen if p_ip_jq is a degenerate triangle. In this case, we just restart the jump and march algorithm. This latter worry is a very rare concern and does not alter the runtime in any significant manner.","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"In the code below, we given an example of how we can provide a fully customised interface for cosntructing an unconstrained triangulation. ","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"using DelaunayTriangulation\nusing CairoMakie \n\n## Define the new types\nDT = DelaunayTriangulation\nstruct CustomPoint\n    x::Float64\n    y::Float64\nend\nDT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\n\nstruct CustomPoints\n    pts::Vector{CustomPoint}\nend\nDT.each_point_index(pts::CustomPoints) = eachindex(pts.pts)\nDT.num_points(pts::CustomPoints) = length(pts.pts)\nDT.each_point(pts::CustomPoints) = pts.pts\nDT.getpoint(pts::CustomPoints, n::Integer) = pts.pts[n]\nDT.number_type(::Type{CustomPoints}) = Float64\n\nstruct CustomEdge\n    i::Int32\n    j::Int32\nend\nDT.construct_edge(::Type{CustomEdge}, i, j) = CustomEdge(i, j)\nDT.initial(edge::CustomEdge) = edge.i\nDT.terminal(edge::CustomEdge) = edge.j\n\nstruct CustomEdges\n    edges::Vector{CustomEdge}\nend\nDT.initialise_edges(::Type{CustomEdges}) = CustomEdges(CustomEdge[])\nDT.add_to_edges!(edges::CustomEdges, e) = push!(edges.edges, e)\nDT.each_edge(edges::CustomEdges) = edges.edges\nDT.delete_from_edges!(edges::CustomEdges, e) =\n        let idx = findfirst(==(e), edges.edges)\n            isnothing(idx) || deleteat!(edges.edges, idx)\n        end\nDT.num_edges(edges::CustomEdges) = length(edges.edges)\nDT.is_empty(edges::CustomEdges) = isempty(edges.edges)\nDT.edge_type(::Type{CustomEdges}) = CustomEdge\nDT.contains_edge(e::CustomEdge, edges::CustomEdges) = e ∈ edges.edges\n\nstruct CustomTriangle\n    i::Int32\n    j::Int32\n    k::Int32\nend\nDT.geti(T::CustomTriangle) = T.i\nDT.getj(T::CustomTriangle) = T.j\nDT.getk(T::CustomTriangle) = T.k\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\nDT.integer_type(::Type{CustomTriangle}) = Int32\n\nstruct CustomTriangles\n    tris::Set{CustomTriangle}\nend\nDT.initialise_triangles(::Type{CustomTriangles}) = CustomTriangles(Set{CustomTriangle}())\nBase.sizehint!(tris::CustomTriangles, n) = sizehint!(tris.tris, n)\nDT.triangle_type(::Type{CustomTriangles}) = CustomTriangle\nDT.add_to_triangles!(tris::CustomTriangles, T) = push!(tris.tris, T)\nDT.num_triangles(tris::CustomTriangles) = length(tris.tris)\nDT.delete_from_triangles!(tris::CustomTriangles, T) = delete!(tris.tris, T)\nBase.in(T, V::CustomTriangles) = T ∈ V.tris\nDT.each_triangle(tris::CustomTriangles) = tris.tris\n\n## Triangulate\nx = rand(100)\ny = rand(100)\npts = CustomPoints(CustomPoint.(x, y))\ntri1 = triangulate(pts;\n    IntegerType=Int32,\n    EdgeType=CustomEdge,\n    EdgesType=CustomEdges,\n    TriangleType=CustomTriangle,\n    TrianglesType=CustomTriangles)\ntri2 = triangulate(pts)\n\nfig = Figure(fontsize=24)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\",aspect=1,width=300,height=300)\ntriplot!(ax, tri1; show_convex_hull=true, convex_hull_linewidth=4)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\",aspect=1,width=300,height=300)\ntriplot!(ax, tri2; show_convex_hull=true, convex_hull_linewidth=4)\nresize_to_layout!(fig)","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"(Image: A triangulation)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/gmsh/#Gmsh","page":"Gmsh","title":"Gmsh","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"We provide Gmsh support, making it possible to represent more complicated meshes. The discussion that follows assume you have installed Gmsh, and defined a corresponding GMSH_PATH. I have used the default,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> GMSH_PATH = \"./gmsh-4.11.1-Windows64/gmsh.exe\"","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The methods for generating meshes with Gmsh are shown below.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"generate_mesh","category":"page"},{"location":"triangulations/gmsh/#DelaunayTriangulation.generate_mesh","page":"Gmsh","title":"DelaunayTriangulation.generate_mesh","text":"generate_mesh(x, y, ref;\n    mesh_algorithm = 6, \n    gmsh_path = \"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity = 0, \n    convert_result = true, \n    add_ghost_triangles = false, \n    check_args = true)\n\nUsing Gmsh, generates a mesh of the domain defined by (x, y).\n\nArguments\n\nx, y: These are the coordinates defining the curves that define the boundaries of the domain. All curves are to be positively oriented, meaning the outermost boundary should be counter-clockwise while the interior boundaries should be clockwise. The accepted forms of x, y are outlined in in the boundary handling section of the docs.\nref: The refinement parameter – smaller ref means more elements. \n\nKeyword Arguments\n\nmesh_algorithm = 6: The meshing algorithm to use. See the Gmsh documentation for more information. The default 6 means Frontal-Delaunay. \ngmsh_path = \"./gmsh-4.11.1-Windows64/gmsh.exe\": The path to the Gmsh executable.\nverbosity = 0: The verbosity of the Gmsh output.\nconvert_result = true: Whether to convert the Gmsh output to a Triangulation.\nadd_ghost_triangles = false: Whether to add ghost triangles to the triangulation.\ncheck_args = true: Whether to check the validity of the arguments.\n\nOutputs\n\nIf convert_result, then the final result is a Triangulation type for the mesh. Otherwise,  the following values are returned: \n\nelements: The triangular elements of the mesh. \nnodes: The nodes in the mesh. \nboundary_nodes: The bonudary nodes in the mesh.  All boundaries are positively oriented relative to the interior, meaning the outermost boundary is counter-clockwise while the interior boundaries are clockwise, and match the form of (x, y). \n\nExtended help\n\nThe function proceeds in four steps:\n\nMesh generation\n\nHere, we write a file \"meshgeometry.geo\" in the working directory. This file takes the form\n\nr = ref;\nMesh.Algorithm = mesh_algorithm; \nMesh.Format = 1;\nGeneral.Verbosity = 0;\nPoint(<point index>) = {<x>, <y>, 0, r}; # For each point\nLine(<line index>) = {<initial point>, <final point>}; # For each line \nCurve Loop(<boundary index>) = {<line 1>, <line 2>, ...}; # For each boundary \nPlane Surface(1) = {<curve 1>, <curve 2>, ...}; # <curve 1> = 1 and is the outermost boundary, while <curve i> = i, i > 1, are boundaries of interior holes \nPhysical Curve(<last line index + i>) = {<line 1>, <line 2>, ...}; # For i ranging over the number of segments, and the lines represent that segment \nPhysical Surface(1) = {1};\n\nMost importantly, every edge input into the function generate_mesh will be included in the mesh. An  older version of this function previously used cubic splines for defining boundary curves, but this  has the consequence that (1) not every edge put into the function is included, and (2) the boundary  is not exactly represented. \n\nThe function that handles this generation is write_gmsh.\n\nMesh writing \n\nThe \"meshgeometry.geo\" file is then used to mesh the domain, running the terminal command \n\ngmsh_path \"meshgeometry.geo\" -2 -format msh2\n\nThis creates a file \"meshgeometry.msh\" in the same working directory. \n\nThe function that handles this writing is run_gmsh.\n\nMesh reading \n\nOnce \"meshgeometry.msh\" is created, we need to read it. The format used (MeshFormat) is  2.2, but note that as of writing (13/01/2013), the most modern format is 4.1.\n\nThe \"meshgeometry.msh\" file is split into groups:\n\n3a. MeshFormat \n\nThis just reads off the format of the file used. This part of the file  is read using read_mesh_format!.\n\n3b. Nodes \n\nThis lists the node indices and all the coordinates of the nodes, with the  first line giving the number of nodes. A single line in this section,  after the first, takes the form \n\n<node index> <x> <y> 0\n\nand we read this using read_node_line. This entire part of the file  is read using read_nodes!.\n\n3c. Elements \n\nThe first line in this part of the file is the number of elements, though  here elements refer to both the lines and the triangles. The lines (edges)  are listed first, with each line taking the form \n\n<line index> 1 2 <boundary index> <> <left node> <right node>\n\nand will be in counter-clockwise order. After the lines are listed, all the triangles follow, with each line in this part taking the form\n\n<triangle index> 2 2 1 1 <node 1> <node 2> <node 3>\n\nwith each triangle positively oriented. These lines are read using  read_element_line. The entire part of the file is read using  read_elements!.\n\nConversion to Triangulation\n\nOnce the file \"meshgeometry.geo\" has been read, we have a list of  triangular elements, nodes, and boundary nodes. These need to all be  converted into a Triangulation type, and a constructor of  Triangulation is used to accomplish this.\n\n\n\n\n\ngenerate_mesh(a, b, c, d, ref; \n    mesh_algorithm=6,\n    gmsh_path=\"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity=0,\n    single_boundary=true,\n    convert_result=true,\n    add_ghost_triangles=false)\n\nGenerates a mesh of a rectangle [a, b] × [c, d]. Use single_boundary=true if  each side of the rectangle should be treated the same, and single_boundary=false if  you want the boundary nodes to be segmented each side of the rectangle.\n\nSee the main function generate_mesh for a description of the other  arguments.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let's give some examples. ","category":"page"},{"location":"triangulations/gmsh/#Example-I:-Contiguous-boundary","page":"Gmsh","title":"Example I: Contiguous boundary","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us mesh a domain with a single non-segmented boundary curve. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\na = 4 / 5\nt = LinRange(0, 2π, 100)\nx = @. a * (2cos(t) + cos(2t))\ny = @. a * (2sin(t) - sin(2t))\ntri = generate_mesh(x, y, 0.1)\ntri2 = generate_mesh(x, y, 1.0)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $ Dense mesh\", titlealign=:left)\ntriplot!(ax, tri)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(b):$ $  Coarse mesh\", titlealign=:left)\ntriplot!(ax, tri2)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"In the figure, the red curve shows the convex hull. We note that we now have information in tri.boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n178-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  ⋮\n 97\n 98\n 99\n  1","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Similarly, tri.boundary_map is now populated:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Vector{Int64}} with 1 entry:\n  -1 => [1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1]","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"We now also have tri.boundary_edge_map:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> tri.boundary_edge_map\nDict{Tuple{Int64, Int64}, Tuple{Vector{Int64}, Int64}} with 177 entries:\n  (116, 20)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 36)\n  (78, 158)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 136)\n  (11, 105)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 16)\n  (106, 13)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 19)\n  (103, 10)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 13)\n  (145, 56)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 101)\n  (169, 87)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 156)\n  (110, 111) => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 27)\n  (128, 42)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 70)\n  (43, 130)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 73)\n  (30, 31)   => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 56)\n  (156, 77)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 133)\n  (3, 4)     => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 3)\n  (112, 113) => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 30)\n  (41, 128)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 69)\n  (153, 74)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 127)\n  (133, 47)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 80)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"In this case, each output of (i, j) is the Tuple (get_boundary_nodes(tri), k). For example,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> u, v = 133, 47;\n\njulia> pos = get_boundary_edge_map(tri, u, v);\n\njulia> segment_nodes = get_boundary_nodes(tri, pos[1]);\n\njulia> get_boundary_nodes(segment_nodes, pos[2]) == u # edges start at the left\ntrue\n\njulia> get_boundary_nodes(segment_nodes, pos[2]+1) == v\ntrue","category":"page"},{"location":"triangulations/gmsh/#Example-II:-Single-boundary-curve-with-multiple-segments","page":"Gmsh","title":"Example II: Single boundary curve with multiple segments","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us now give an example where we still have just a single boundary curve, but we split it into multiple segments. Importantly, each segment must be counter-clockwise and join with the previous segment.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\n# The first segment \nt = LinRange(0, 1 / 4, 25)\nx1 = cos.(2π * t)\ny1 = sin.(2π * t)\n# The second segment \nt = LinRange(0, -3, 25)\nx2 = collect(t)\ny2 = repeat([1.0], length(t))\n# The third segment \nt = LinRange(1, 0, 25)\nx3 = -3.0 .+ (1 .- t) .* sin.(t)\ny3 = collect(t)\n# The fourth segment \nt = LinRange(0, 1, 25)\nx4 = collect(-3.0(1 .- t))\ny4 = collect(0.98t)\n# The fifth segment \nx5 = [0.073914, 0.0797, 0.1522, 0.1522, 0.2, 0.28128, 0.3659, 0.4127, 0.3922, 0.4068, 0.497, 0.631, 0.728, 0.804, 0.888, 1.0]\ny5 = [0.8815, 0.8056, 0.80268, 0.73258, 0.6, 0.598, 0.5777, 0.525, 0.4346, 0.3645, 0.3032, 0.2886, 0.2623, 0.1367, 0.08127, 0.0]\n# Now combine the vectors \nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\n# Mesh \ntri = generate_mesh(x, y, 0.05)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=600, height=300)\ntriplot!(ax, tri)\ncolors = [:red, :blue, :orange, :purple, :darkgreen]\nbn_map = get_boundary_map(tri)\nfor (i, segment_index) in enumerate(values(bn_map))\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    lines!(ax, get_points(tri)[:, bn_nodes], color=colors[i], linewidth=4)\nend\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"An important feature to note for this case is that the index now used to refer to boundaries is no longer constant. In particular, the nth segment will map to -n, as we can verify using:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Int64} with 5 entries:\n  -1 => 1\n  -2 => 2\n  -3 => 3\n  -4 => 4\n  -5 => 5","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This map makes it simple to iterate over all parts of a boundary, as we show in the above code when plotting. The tri.boundary_edge_map in this case is:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_edge_map(tri)\nDict{Tuple{Int64, Int64}, Tuple{Int64, Int64}} with 262 entries:\n  (118, 8)   => (1, 14)\n  (55, 56)   => (3, 10)\n  (34, 154)  => (2, 28)\n  (213, 214) => (4, 35)\n  (223, 224) => (4, 50)\n  (143, 29)  => (2, 12)\n  (24, 135)  => (1, 47)\n  (178, 179) => (2, 65)\n  (132, 22)  => (1, 42)\n  (46, 178)  => (2, 64)\n  (169, 42)  => (2, 51)\n  (154, 155) => (2, 29)\n  (115, 5)   => (1, 8)\n  (43, 172)  => (2, 55)\n  (261, 262) => (5, 38)\n  (146, 147) => (2, 17)\n  (49, 184)  => (3, 1)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"For example, ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> let pos = get_boundary_edge_map(tri, 115, 5)\n       segment_nodes = get_boundary_nodes(tri, pos[1])\n       u′ = get_boundary_nodes(segment_nodes, pos[2])\n       v′ = get_boundary_nodes(segment_nodes, pos[2]+1)\n       u′ == 115 && v′ == 5\n       end\ntrue","category":"page"},{"location":"triangulations/gmsh/#Example-III:-Multiple-boundaries","page":"Gmsh","title":"Example III: Multiple boundaries","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Now let us give a more complicated example, meshing a multiply-connected domain. In this case, we provide the outer-most boundary in a counter-clockwise order, while all the inner boundaries are in a clockwise order.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\nx1 = [collect(LinRange(0, 2, 4)),\n    collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 0, 4)),\n    collect(LinRange(0, 0, 4))]\ny1 = [collect(LinRange(0, 0, 4)),\n    collect(LinRange(0, 6, 4)),\n    collect(LinRange(6, 6, 4)),\n    collect(LinRange(6, 0, 4))]\nr = 0.5\nh = k = 0.6\nθ = LinRange(2π, 0, 50)\nx2 = [h .+ r .* cos.(θ)]\ny2 = [k .+ r .* sin.(θ)]\nr = 0.2\nh = 1.5\nk = 0.5\nx3 = [h .+ r .* cos.(θ)]\ny3 = [k .+ r .* sin.(θ)]\nx4 = reverse(reverse.([collect(LinRange(1, 1.5, 4)),\n    collect(LinRange(1.5, 1.5, 4)),\n    collect(LinRange(1.5, 1, 4)),\n    collect(LinRange(1, 1, 4))]))\ny4 = reverse(reverse.([collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 5, 4)),\n    collect(LinRange(5, 5, 4)),\n    collect(LinRange(5, 2, 4))]))\nx5 = [reverse([0.2, 0.5, 0.75, 0.75, 0.2, 0.2])]\ny5 = [reverse([2.0, 2.0, 3.0, 4.0, 5.0, 2.0])]\nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\ntri = generate_mesh(x, y, 0.2)\nfig, ax, sc = triplot(tri; show_ghost_edges=true, convex_hull_linestyle=:solid, convex_hull_linewidth=4)\nxlims!(ax, -0.5, 2.5)\nylims!(ax, -0.5, 6.5)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_3.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The blue edges show the interpretation of the ghost edges (you can delete via delete_ghost_triangles! if you want). For the outer boundary, these edges are pointing away from the interior, collinear with a point in the center, as we can obtain via:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_representative_point_coordinates(tri, 1)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"or, alternatively,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_representative_point_list(tri)\nDict{Int64, DelaunayTriangulation.RepresentativeCoordinates{Int64, Float64}} with 5 entries:\n  5 => RepresentativeCoordinates{Int64, Float64}(0.475, 3.5, 0)\n  4 => RepresentativeCoordinates{Int64, Float64}(1.25, 3.5, 0)\n  2 => RepresentativeCoordinates{Int64, Float64}(0.6, 0.6, 0)\n  3 => RepresentativeCoordinates{Int64, Float64}(1.5, 0.5, 0)\n  1 => RepresentativeCoordinates{Int64, Float64}(1.5, 1.5, 0)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The keys are the indices for the boundary curve. These coordinates are visual centers, obtained via the pole of inaccessibility function; see the sidebar. For the inner boundaries, the ghost edges are no longer infinite and so they connect directly with these representative coordinates.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"To access more of the boundary information, we could first consider boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n5-element Vector{Vector{Vector{Int64}}}:\n [[1, 128, 129, 130, 2, 131, 132, 133, 3, 134, 135, 136, 4], [4, 137, 138, 139, 140, 141, 142, 143, 144, 145  …  155, 156, 157, 158, 159, 160, 161, 162, 163, 7], [7, 164, 165, 166, 8, 167, 168, 169, 9, 170, 171, 172, 10], [10, 173, 174, 175, 176, 177, 178, 179, 180, 181  …  191, 192, 193, 194, 195, 196, 197, 198, 199, 1]]\n [[13, 14, 15, 16, 17, 18, 19, 20, 21, 22  …  53, 54, 55, 56, 57, 58, 59, 60, 61, 13]]\n [[62, 63, 64, 65, 66, 67, 68, 69, 70, 71  …  102, 103, 104, 105, 106, 107, 108, 109, 110, 62]]\n [[111, 200, 201, 202, 203, 112, 204, 205, 206, 207, 113, 208, 209, 210, 211, 114], [114, 115, 116, 117], [117, 212, 213, 214, 215, 118, 216, 217, 218, 219, 119, 220, 221, 222, 223, 120], [120, 121, 122, 111]]  \n [[123, 224, 225, 226, 227, 228, 229, 230, 231, 232  …  246, 126, 247, 248, 249, 250, 251, 127, 252, 123]]","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This is simply a vector of curves, with each curve storing its segments. This vector itself does not tell us what boundary index corresponds to what segment of what curve, and this could be obtained from the boundary map:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int64, Tuple{Int64, Int64}} with 11 entries:\n  -1  => (1, 1)\n  -2  => (1, 2)\n  -3  => (1, 3)\n  -4  => (1, 4)\n  -5  => (2, 1)\n  -6  => (3, 1)\n  -7  => (4, 1)\n  -8  => (4, 2)\n  -9  => (4, 3)\n  -10 => (4, 4)\n  -11 => (5, 1)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, the boundary index -8 comes from the second segment of the fourth curve. As before, this boundary map makes it simple to iterate over each segment as follows:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    nedges = num_boundary_edges(bn_nodes) # Note that nedges = length(bn_nodes) - 1\n    for edge_idx in 1:nedges \n        node = get_boundary_node(bn_nodes, edge_idx)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The form above is generic, and ignores the last part of each segment (since it is duplicated for the next segment). Of course, a version like","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    for i in bn_nodes\n        node = get_boundary_node(bn_nodes, i)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"(which includes the last part of each segment) could be used. It is up to you based on your interface how you prefer to write this. Notice also that in the previous example we used a similar style, using get_boundary_nodes(tri, segment_index) also. The function get_boundary_nodes can be used with either single integers or Tuples, making it simple to iterate with this exact pattern whether we have a contiguous boundary curve, a segmented boundary curve, or multiple boundaries. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Another feature to note is tri.boundary_index_ranges, which will tell us what other boundary indices belong to a curve given a known boundary index for that curve. This can be useful if we want to rotate around a boundary curve based on a given boundary index (see e.g. how it is used in the get_left_boundary_node and get_right_boundary_node functions). This field is a major part of making point location work in these inner boundaries, making get_adjacent work properly in this case (see e.g. the code in _safe_get_adjacent).","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_index_ranges(tri)\nOrderedDict{Int64, UnitRange{Int64}} with 11 entries:\n  -1  => -4:-1\n  -2  => -4:-1\n  -3  => -4:-1\n  -4  => -4:-1\n  -5  => -5:-5\n  -6  => -6:-6\n  -7  => -10:-7\n  -8  => -10:-7\n  -9  => -10:-7\n  -10 => -10:-7\n  -11 => -11:-11","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, we see tha the boundary index -3 belongs to a curve that also has boundary indices -1, -2, and -4. If we wanted to go from a boundary index to the index for the curve, this is what the boundary map is also for:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_curve_index(tri, -3)\n1","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The last feature to show is the new tri.boundary_edge_map for this case, given by","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_edge_map(tri)\nDict{Tuple{Int64, Int64}, Tuple{Tuple{Int64, Int64}, Int64}} with 252 entries:\n  (55, 56)   => ((2, 1), 43)\n  (130, 2)   => ((1, 1), 4)\n  (92, 93)   => ((3, 1), 31)\n  (213, 214) => ((4, 3), 3)\n  (14, 15)   => ((2, 1), 2)\n  (172, 10)  => ((1, 3), 12)\n  (203, 112) => ((4, 1), 5)\n  (178, 179) => ((1, 4), 7)\n  (121, 122) => ((4, 4), 2)\n  (151, 152) => ((1, 2), 17)\n  (26, 27)   => ((2, 1), 14)\n  (171, 172) => ((1, 3), 11)\n  (88, 89)   => ((3, 1), 27)\n  (132, 133) => ((1, 1), 7)\n  (133, 3)   => ((1, 1), 8)\n  (146, 147) => ((1, 2), 12)\n  (46, 47)   => ((2, 1), 34)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"As before, (u, v) = (get_boundary_nodes(segment_nodes, pos[2]), get_boundary_nodes(segment_nodes, pos[2]+1), where segment_nodes = get_boundary_nodes(tri, pos[1]) and pos = get_boundary_edge_map(tri, u, v). This pattern is true for any form of boundary nodes, in fact.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/refinement/#Mesh-Refinement","page":"Mesh Refinement","title":"Mesh Refinement","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Here we show how we can use mesh refinement to improve the quality of a triangulation. In this package, the algorithm used is Ruppert's algorithm, and we permit constraints on the minimum angle and maximum area of a triangle in a triangulation. This algorithm works on any type of geometry. The function used for refinement is refine!. Some of the relevant docstrings are:","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"refine!\nRefinementTargets \nRefinementQueue ","category":"page"},{"location":"triangulations/refinement/#DelaunayTriangulation.refine!","page":"Mesh Refinement","title":"DelaunayTriangulation.refine!","text":"refine!(tri::Triangulation;\n    min_area=1e-9get_total_area(tri),\n    max_area=typemax(number_type(tri)),\n    max_radius_edge_ratio=nothing,\n    max_points=typemax(Int64),\n    min_angle=nothing,\n    rng::AbstractRNG=Random.default_rng(),\n    maxiters=100,\n    lock_convex_hull=!has_boundary_nodes(tri),\n    exterior_curve_index=1\n    )\n\nRefine the triangulation tri according to the given refinement targets.\n\nArguments\n\ntri::Triangulation: The triangulation to refine.\n\nKeyword Arguments\n\nmin_area=1e-9get_total_area(tri)\n\nThe minimum permissible area of a triangle. Any circumcenter insertion attempts into a triangle with area below this minimum will be prevented, and the triangle will never be queued for refinement. This is useful for preventing the mesh from becoming too fine in certain regions and preventing convergence.\n\nmax_area=typemax(number_type(tri))\n\nThe maximum permissible area of a triangle.\n\nmax_radius_edge_ratio=nothing\n\nThe maximum allowed radius-edge ratio (the ratio of the circumradius to the shortest edge length) of a triangle.  This ratio is related to a min_angle constraint by the formula min_angle = asin(0.5 / max_radius_edge_ratio). If max_radius_edge_ratio=nothing, then it is computed from the provided min_angle if it is not nothing,  or we set max_radius_edge_ratio = 1. This can also be a function of the form f(T, p, q, r, ρ), where T is the triangle's indices, p, q, r its coordinates, and ρ is the triangle's radius-edge  ratio. This function should return true if it should be refined, and false otherwise.\n\nThe maximum radius-edge ratio cannot be less than 1/√3. If it is, it is replaced with 1/√3.\n\nmin_angle=nothing\n\nThe minimum allowed angle of a triangle, given in degrees. If max_radius_edge_ratio is not nothing, then this is ignored. Otheriwse,  we set max_radius_edge_ratio = 1 / (2sind(min_angle)).\n\nIf min_angle > 33.9°, a warning is given as convergence of the algorithm may struggle to converge in this case. Additionally, ifminangle < 0.0orminangle > 60.00005, thenminangleis replaced with30°(maxradiusedgeratio = 1`). You should also be cautious that, for some domains (e.g. ones with many small angles), an even smaller angle might be needed to accommodate floating point arithmetic.\n\nnote: Note\nA minimum angle constraint of θₘᵢₙ° corresponds to a maximum angle constraint of 180° - 2θₘᵢₙ, e.g. θₘᵢₙ° = 30° gives θₘₐₓ° = 120°.\n\nmax_points=typemax(Int64)\n\nHow many points are allowed to be in the triangulation before terminating.\n\nrng::AbstractRNG=Random.default_rng()\n\nThe random number generator to use.\n\nmaxiters=5000\n\nThe maximum number of iterations to perform.\n\nlock_convex_hull=!has_boundary_nodes(tri)\n\nWhether to lock the convex hull of the triangulation. If true, then the convex hull edges are put into the constrained edges of the triangulation. This  is only relevant if the triangulation has no boundary nodes.\n\ndanger: Danger\nNot enabling this option can lead to the triangulation being refined in a way that  continually adds points that go out to infinity. Do so at your own peril.\n\nexterior_curve_index=1\n\nThe curve (or curves) corresponding to the outermost boundary. Only seems to be needed  in rare cases, even with multiple exterior curves (disjoint domains). If you are having issues with the triangulation not being refined correctly, try setting this to be the  correct values.\n\nOutputs\n\nThe TriangulationStatistics of tri are returned. The triangulation is refined in-place.\n\nSee also RefinementTargets.\n\nnote: Note\nIt is not strictly guaranteed that the refinement targets will be met. For example, precision  issues may cause small angles from near-degenerate triangles. Despite this, the algorithm will still typically give no angle larger than 180° - 2θ°, where θ° = asind[1 / (2max_radius_edge_ratio)] is the minimum angle constraint associated with max_radius_edge_ratio. Moreover, domains with  small angles (between constrained segments) will cause issues, forcing small angles to be  introduced into the triangulation to accommodate them, but only between the constrained  segments with small angles. If you are finding issues with small angles, try increasing the max_radius_edge_ratio (or reduce min_angle). Basically, be aware that arithmetic is not perfected and floating point arithmetic  only has so much precision to offer.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/refinement/#DelaunayTriangulation.RefinementTargets","page":"Mesh Refinement","title":"DelaunayTriangulation.RefinementTargets","text":"RefinementTargets{A,M,R,P}\n\nA struct containing the user-specified refinement targets. \n\nFields\n\nmax_area::A\n\nThe maximum area of a triangle. This can also be a function of the form f(T, p, q, r, A), where T is the trianglewith area and coordinatesp,q,r, returningtrue` if the triangle should be refined.\n\nmin_area::M\n\nThe minimum area of a triangle. This is used to test for the presence of small triangles, which can be a sign of poor quality / convergence. For example, if a circumcenter is attempted to be added into a triangle with area below min_area, it is prevented. Defaults to 0.0.\n\nmax_radius_edge_ratio::R\n\nThe maximum permitted radius-edge ratio. This can also be a function of the form f(T, p, q, r, ρ), where T is the trianglewith ratioρand coordinatesp,q,r, returningtrue` if the triangle should be refined. Defaults to 1.0, corresponding to a minimum angle of 30°.\n\nmax_points::P\n\nThe maximum number of points in the mesh. Defaults to Inf.\n\nConstructors\n\nThe constructor is \n\nRefinementTargets(;\n        max_area=typemax(Float64),\n        max_radius_edge_ratio=nothing,\n        max_points=typemax(Int64),\n        min_angle = nothing\n        )\n\nwhich allows for a user to specify either the maximum radius-edge ratio ρ or the minimum angle min_angle in degrees, using the relationship min_angle = asin[1/(2ρ)]. If both are provided, the minimum angle is ignored. If neither are provided, the default value of ρ = 1.0 is used, corresponding to a minimum angle of 30°.\n\nNote that you cannot use min_angle as a function, unlike max_radius_edge_ratio. If you want to use a function, use max_radius_edge_ratio instead.\n\n\n\n\n\n","category":"type"},{"location":"triangulations/refinement/#DelaunayTriangulation.RefinementQueue","page":"Mesh Refinement","title":"DelaunayTriangulation.RefinementQueue","text":"RefinementQueue{T,E,F}\n\nA queue for storing encroachment and triangle refinement priority queues. \n\nFields\n\nencroachment_queue::PriorityQueue{T,E,F,Base.Order.ReverseOrdering}\n\nA priority queue for storing encroached segments to be split. The keys are the squared edge lengths.\n\ntriangle_queue::PriorityQueue{T,E,F,Base.Order.ReverseOrdering}\n\nA priority queue for storing triangles to be refined. The keys are radius-edge ratio.\n\n\n\n\n\n","category":"type"},{"location":"triangulations/refinement/#Unconstrained-triangulations","page":"Mesh Refinement","title":"Unconstrained triangulations","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Although rarely needed, let us start with an unconstrained triangulation example. To prevent points from being inserted into the triangulation outside of the convex hull (and typically out to infinity), the convex hull of the triangulation's points (i.e. the triangulation's boundary) are locked in place and treated as constrained segments. Once the refinement is done, they are unlocked.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"First, let us take some point cloud and build its triangulation.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"using DelaunayTriangulation, CairoMakie\npts = [(rand(), rand()) for _ in 1:50]\ntri = triangulate(pts)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We now refine it. We will use a minimum angle constraint of 30 degrees, and a maximum area constraint of 1% of the total area.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = get_total_area(tri)\nstats = refine!(tri; min_angle=30.0, max_area=0.01A)\nDelaunay Triangulation Statistics.\n   Triangulation area: 0.8744517117708429\n   Number of vertices: 283\n   Number of solid vertices: 282\n   Number of ghost vertices: 1\n   Number of edges: 843\n   Number of solid edges: 771\n   Number of ghost edges: 72\n   Number of triangles: 490\n   Number of solid triangles: 490\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 72\n   Smallest angle: 30.04506696762518°\n   Largest angle: 116.57834703069716°\n   Smallest area: 1.8915322852892662e-5\n   Largest area: 0.008731595421089517\n   Smallest radius-edge ratio: 0.5784601192132447\n   Largest radius-edge ratio: 0.9986397882266155","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"As we can tell from the output, indeed each angle is above 30 degrees. Below we show a comparison of the original triangulation, its refinement, and a histogram of the minimum angle and (relative) areas of each triangle.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.001:0.01)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=20:2:60)\nvlines!(ax, [30.0], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/unconstrained_refinement.png', alt='Unconstrained refinement'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The triangulation is now quite uniform, and the angles are all satisfactory. If we wanted to refine further, just call refine! again with your new quality targets.","category":"page"},{"location":"triangulations/refinement/#Constrained-triangulations","page":"Mesh Refinement","title":"Constrained triangulations","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"From now, we focus on examples that have constrained segments or boundaries. ","category":"page"},{"location":"triangulations/refinement/#A-rectangle","page":"Mesh Refinement","title":"A rectangle","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A typical scenario in meshing is to start with a boundary, and then insert the vertices. Below we show how we can create a rectangle with a constrained diagonal, and then mesh it. We use a minimum angle of 33 degrees.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"p1 = (0.0, 0.0)\np2 = (1.0, 0.0)\np3 = (1.0, 0.5)\np4 = (0.0, 0.5)\npts = [p1, p2, p3, p4, p1]\nboundary_nodes, points = convert_boundary_points_to_indices(pts)\nC = Set(((2, 4),))\ntri = triangulate(points; boundary_nodes, edges=C)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; min_angle=33.0, max_area=0.001A)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.0001:0.001)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:2:60)\nvlines!(ax, [30.0], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/square_constrained_refinement.png', alt='Refined rectangle'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In this case, there are some angles below the minimum angle because the input domain has small angles. Typically, there will only be very few triangles that are forced to have a minimum angle. Moreover, from this paper, the maximum angle will still satisfy theta_max leq maxpi - 2kappa pi - 2arcsin(sqrt 3 - 1)2, where kappa is our minimum angle constraint. In our case, this gives theta_max to be bounded by about 137 degrees, which is true for this example (the maximum is about 112 degrees).","category":"page"},{"location":"triangulations/refinement/#Multiply-connected-domain","page":"Mesh Refinement","title":"Multiply-connected domain","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We can refine triangulations that are multiply-connected. Here is an example that shows that, even if the triangulation is quite complicated, we can still get a reasonably fine mesh.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = (0.0, 0.0)\nB = (0.0, 25.0)\nC = (5.0, 25.0)\nD = (5.0, 5.0)\nE = (10.0, 5.0)\nF = (10.0, 10.0)\nG = (25.0, 10.0)\nH = (25.0, 15.0)\nI = (10.0, 15.0)\nJ = (10.0, 25.0)\nK = (45.0, 25.0)\nL = (45.0, 20.0)\nM = (40.0, 20.0)\nN = (40.0, 5.0)\nO = (45.0, 5.0)\nP = (45.0, 0.0)\nQ = (10.0, 0.0)\nR = (10.0, -5.0)\nS = (15.0, -5.0)\nT = (15.0, -10.0)\nU = (10.0, -10.0)\nV = (5.0, -10.0)\nW = (5.0, -5.0)\nZ = (5.0, 0.0)\nA1 = (5.0, 2.5)\nB1 = (10.0, 2.5)\nC1 = (38.0, 2.5)\nD1 = (38.0, 20.0)\nE1 = (27.0, 20.0)\nF1 = (27.0, 11.0)\nG1 = (27.0, 4.0)\nH1 = (2.0, 4.0)\nI1 = (2.0, 0.0)\npts = [A, I1, H1, G1, F1, E1, D1, C1, B1, A1, Z, W, V, U, T, S, R, Q, P, O, N, M, L, K, J, I, H, G, F, E, D, C, B, A]\nJ1 = (17.0603265896789, 7.623652007194)\nK1 = (14.8552854162067, 6.5423337394336)\nL1 = (16.6998871670921, 6.9875824379232)\nM1 = (16.0, 6.0)\nN1 = (16.9755173137761, 6.6483453343121)\nO1 = (17.0391242707032, 4.8885528593294)\nP1 = (17.4207660122657, 6.4575244635308)\nQ1 = (17.6327892020226, 4.9945644542079)\nR1 = (22.6789411182379, 6.1818943168468)\nS1 = (21.8096460402344, 6.4787267825065)\nT1 = (26.0, 8.0)\nU1 = (15.0673086059636, 9.086612016517)\nW1 = (15.0, 8.5)\nZ1 = (17.7913089332764, 8.3603005983396)\ninner_pts = [Z1, W1, U1, T1, S1, R1, Q1, P1, O1, N1, M1, L1, K1, J1, Z1]\nboundary_pts = [[pts], [inner_pts]]\nnodes, points = convert_boundary_points_to_indices(boundary_pts)\npush!(points, (20.0, 20.0))\nC = Set{NTuple{2,Int64}}()\nfor i in 1:50\n    θ = 2π * rand()\n    r = 4sqrt(rand())\n    x = 20 + r * cos(θ)\n    y = 20 + r * sin(θ)\n    push!(points, (x, y))\n    push!(C, (48, 48 + i))\nend\ntri = triangulate(points; boundary_nodes=nodes, edges=C)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; max_area=0.001A, min_angle = 27.3)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.0000001:0.000001)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:0.5:40)\nvlines!(ax, [27.3], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/mc_constrained_refinement.png', alt='Refined rectangle'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Most of the triangles are the same size as we see in (c). Moreover, most angles are above the minimum, except for between segments that subtend a small angle (those coming from all the spokes in the upper part of the domain).","category":"page"},{"location":"triangulations/refinement/#Multipolygons","page":"Mesh Refinement","title":"Multipolygons","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Refinement even works on multipolygons. Here's an example using the Julia logo example.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"C = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\n\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\ntri = triangulate(points; boundary_nodes=nodes, check_arguments=false)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; min_angle=26.45, max_area=0.005A / 9)\n@test validate_triangulation(tri; check_planarity=false, check_ghost_triangle_orientation=false, check_ghost_triangle_delaunay=false)\nvalidate_statistics(tri)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri, show_convex_hull=false) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri, show_convex_hull=false)\nareas = get_all_stat(stats, :area) ./ (0.005A)\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.001:0.1)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:0.2:40)\nvlines!(ax, [26.45], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/julia_constrained_refinement.png', alt='Refined Julia logo'><br>\n</figure>","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"boundary_handling/#Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations","page":"Boundary Handling","title":"Ghost Triangles, Boundary Handling, and Boundary Specifcations","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Here we will give a description about how we represent boundaries, and also how we use ghost triangles.","category":"page"},{"location":"boundary_handling/#Boundary-Indices","page":"Boundary Handling","title":"Boundary Indices","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"We use negative indices to denote vertices belonging to a boundary. For example, if tri is a triangulation and get_adjacent(adj, u, v) == -1, then this means that (u, v) is an edge on the boundary. We call this -1 a ghost vertex or a boundary index (positive vertices could also be called solid vertices), with -1 defined from DelaunayTriangulation.BoundaryIndex, which we discuss more in the next section.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"In the case of a single contiguous outer boundary, having -1 as the only boundary index is simple and works fine. If we have multiple segments or multiple boundaries, then we need to somehow have multiple boundary indices so that we can refer to each segment separately. We accomplish this by simply subtracting 1 from the current boundary index for each new segment. This is handled by add_boundary_information!. For example, if we had","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"bn = [\n    [segment_1, segment_2, segment_3],\n    [segment_4, segment_5],\n    [segment_6],\n    [segment_7, segment_8, segment_9, segment_10]\n]","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"then the ith segment will map to -i. Note that this always means that -1 belongs to the outer-most boundary. There is a possible issue we can have with this when, for example, stepping around a boundary, since nodes will occur in two segments and hence nodes may not necessarily have a unique boundary index assigned to them. To handle this case, allowing us to check for all possible boundary indices when stepping around a boundary (or however else we might want to use Adjacent or similar), get_adjacent can call a safer version _safe_get_adjacent, which checks the boundary indices using boundary_index_ranges.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"These issues are why the Triangulation data structure has the boundary_map and boundary_index_ranges fields. boundary_map, constructed with construct_boundary_map, is used to map a boundary index to its segment in the set of boundary nodes, so that get_boundary_nodes(boundary_nodes, map_boundary_index(boundary_map, g)) gives the nodes corresponding to the segment which has boundary index g. To handle the issue with a curve having multiple boundary indices, we use boundary_index_ranges, constructed with construct_boundary_index_ranges, to map a boundary index g to all other indices that could be found on the associated curve. For example, in the bn example above, -2 would map to -3:-1.","category":"page"},{"location":"boundary_handling/#Ghost-Triangles","page":"Boundary Handling","title":"Ghost Triangles","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Ghost triangles are a special triangle that has a solid edge (u, v) and a vertex g associated with some boundary index. These ghost triangles are needed to make point location actually work properly when points are outside of the triangle, provided we associate the ghost vertex g with a physical point. For the outer-most boundary, this physical point just has to be somewhat in the center of the domain, which we define using a centroid when building the triangulation and the pole of inaccessibility once we have built the entire triangulation. With this physical point, ghost edges (u, g) are then interpreted to be of infinite extent, pointing from u out to infinity, but collinear with this central point. ","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"In the case of an inner boundary, these ghost edges are of finite extent, simply connecting with the point g which is define via the pole of inaccessibility.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"For the Bowyer-Watson algorithm, we need a definition for the circumcircle of a ghost triangle. For ghost triangles that belong to inner boundaries, we simply use the triangle that connects the points, since there is no issue with infinity here. For the outer ghost triangles, we need to be careful. Imagine taking a triangle and pulling away one of its vertices to infinity. The circumcircle would keep growing until it eventually covers the entire space on the side of the fixed edge that the point was on. In particular, the circle becomes the line through the fixed edge, dividing the plane into two half-planes. We then say that a point is in the circumcircle of an outer ghost triangle if it is in the open half-plane on the other side of the edge from the triangulation, or if it is on the edge itself (but is not one of the vertices). The union of the open half-plane and this open edge is called the outer half-plane of the edge.","category":"page"},{"location":"boundary_handling/#Boundary-Specification","page":"Boundary Handling","title":"Boundary Specification","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"When considering constrained triangulations, we allow for a set of boundary nodes to be provided. These nodes can be defined to represent three possible domains:","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"A contiguous boundary with no holes. For example, a circle.\nA single boundary with no holes, but the boundary is split into multiple segments that can be identified separately via boundary indices. For example, a square with a boundary index for each side.\nA boundary comprising multiple disjoint curves, i.e. a multiply-connected domain. For example, a square with a circular hole inside. The most support is provided for the case where no interior hole contains another interior, but it is allowed (see the discussion in the constrained triangulation section).","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"We do also provide support for much more complex geometries, such as disjoint regions, but the support is only for constructing the mesh. Limited support exists, for example, for point location in such regions. See the examples in the constrained triangulation section. There might also be issues with domains that are non-convex.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"The way to represent boundaries can be customised as needed (see the Interfaces section), but by default we provide the following specifications; this specification is what we use in the convert_boundary_points_to_indices function. The specification that follows is also valid for generate_mesh where coordinates are used instead of indices. Let bn be the set of boundary nodes and I the integer type.","category":"page"},{"location":"boundary_handling/#Contiguous-boundary","page":"Boundary Handling","title":"Contiguous boundary","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"For a contiguous boundary, bn should be a single Vector{I} such that bn[begin] == bn[end], defining a boundary in counter-clockwise order. ","category":"page"},{"location":"boundary_handling/#Single-boundary-split-into-segments","page":"Boundary Handling","title":"Single boundary split into segments","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Now consider a single boundary with no holes, but given by multiple segments, say into ns segments. Then bn should be a Vector{Vector{I}} with length(bn) = ns. The vectors should be defined such that the endpoints connect, meaning bn[i][end] == bn[i+1][begin] for i < ns or bn[end][end] == bn[begin][begin]. Additionally, the nodes should be defined in counter-clockwise order. ","category":"page"},{"location":"boundary_handling/#Multiply-connected-domain","page":"Boundary Handling","title":"Multiply-connected domain","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Now suppose we have a boundary that is split into multiple curves, say into nc curves. In this case, bn is a Vector{Vector{Vector{I}}} where each individual curve bn[i] is assumed to represent a single boundary split into segments, with each bn[i] matching the previous specification. In this case, we provide the most support for the case where bn[1] is the outermost boundary curve, and all curves bn[i] for i > 1 are inside bn[1]. With this, bn[1] should be counter-clockwise, while bn[i] for i > 1 should be clockwise. While it is possible to place interior curves inside other interior curves, e.g. bn[j] could be inside bn[i] as long as bn[j] is counter-clockwise, less support for point location and other features is provided for this case. See the constrained triangulation section.","category":"page"},{"location":"interface/points/","page":"Points","title":"Points","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/points/#Individual-Points","page":"Points","title":"Individual Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"Points are assumed to take the form (x, y), but we allow for customisation in how we represent these points. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getx \ngety ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getx","page":"Points","title":"DelaunayTriangulation.getx","text":"getx(p::P) where {P}\n\nGiven a point p, returns the x-coordinate. The  only methods currently defined are\n\ngetx(p::NTuple{N,T}) where {N,T}\ngetx(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.gety","page":"Points","title":"DelaunayTriangulation.gety","text":"gety(p::P) where {P}\n\nGiven a point p, returns the y-coordinate. The  only methods currently defined are\n\ngety(p::NTuple{N,T}) where {N,T}\ngety(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getxy ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getxy","page":"Points","title":"DelaunayTriangulation.getxy","text":"getxy(p)\n\nGiven a point p, returns (getx(p), gety(p)).\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Collection-of-Points","page":"Points","title":"Collection of Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"A collection of points simply store many points. It does not need to be mutable (unless you want to add points into the triangulation not already in tri.points, or if you want mesh refinement). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods-2","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getpoint \neach_point_index \neach_point\nnum_points \nnumber_type \npush_point!\npop_point!","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getpoint","page":"Points","title":"DelaunayTriangulation.getpoint","text":"getpoint(pts::P, i)\n\nGiven a collection of points pts, returns a Tuple  of the x and y coordinates of the ith point in  the collection. The methods currently defined are \n\ngetpoint(pts::AbstractVector, i)\ngetpoint(pts::AbstractMatrix, i)\n\nYou can extend this function as you need. \n\nIt is assumed that whenever i is not an integer, i is meant to be  a point, so (getx(i), gety(i)) would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point_index","page":"Points","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(pts::P) where {P}\n\nGiven a collection of points pts, returns an iterator  over the indices of the collection. The methods currently  defined are \n\neach_point_index(pts::AbstractVector)\neach_point_index(pts::AbstractMatrix)\n\nwith the first returning eachindex(pts) and the second  returning axes(pts, 2). You can extend this function  as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point","page":"Points","title":"DelaunayTriangulation.each_point","text":"each_point(pts::P) where {p}\n\nFor a given collection of points p, returns an iterator that  goes over each point in the collection. The methods currently  defined are \n\neach_point(pts::AbstractVector)\neach_point(pts::AbstractMatrix)\n\nwith the first method simply returning pts, and the second returning  eachcol(pts). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.num_points","page":"Points","title":"DelaunayTriangulation.num_points","text":"num_points(pts)\n\nReturns the number of points in pts.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.number_type","page":"Points","title":"DelaunayTriangulation.number_type","text":"number_type(x)\n\nGiven a container x, returns the number type used for storing coordinates.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.push_point!","page":"Points","title":"DelaunayTriangulation.push_point!","text":"push_point!(pts, x, y)\n\nPushes the point (x, y) into pts. The only methods currently  defined are  \n\npush_point!(pts::AbstractVector{T}, x, y) where {F,T<:NTuple{2,F}} = push!(pts, (F(x), F(y)))\npush_point!(pts::AbstractVector{T}, x, y) where {F<:Number,T<:AbstractVector{F}} = push!(pts, F[x, y])\n\nYou can extend this function as needed. We also provide the method \n\npush_point!(pts, p) = push_point!(pts, getx(p), gety(p))\n\nwhich you can extend if you have a point type p that has getx and gety.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.pop_point!","page":"Points","title":"DelaunayTriangulation.pop_point!","text":"pop_point!(pts)\n\nPops the last point from pts. The only method currently defined is\n\npop_point!(pts::AbstractVector) = pop!(pts)\n\nYou can extend this function as needed.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods-2","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"get_point \npoints_are_unique \nlexicographic_order ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.get_point","page":"Points","title":"DelaunayTriangulation.get_point","text":"get_point(pts::P, i...)\n\nGiven a collection of points pts, returns the points  corresponding to the indices in i.... This simply  calls getpoint - you do not need to  extend this method. \n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.points_are_unique","page":"Points","title":"DelaunayTriangulation.points_are_unique","text":"points_are_unique(pts)\n\nReturns true if pts has no duplicate points, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.lexicographic_order","page":"Points","title":"DelaunayTriangulation.lexicographic_order","text":"lexicographic_order(pts)\n\nReturns a set of indices idx that gives the lexicographic ordering  of the set of points pts, i.e. sorting by x and then sorting points  with duplicate x-coordinates by y. The implementation is simply \n\nlexicographic_order(pts) = (sortperm ∘ collect ∘ each_point)(pts)\n\nwhich you might want to specialise for an easier representation of your  points pts.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/convex/#Chew's-Algorithm-for-Triangulating-Convex-Polygons","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"","category":"section"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"Our algorithm for triangulating convex polygons comes from L. Paul Chew's \"Building Voronoi diagrams for convex polygons in linear expected time\" back in 1990, following the presentation of it in the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013). The idea is that we can utilise the neighbour information already provided by the definition of a polygon to avoid the point location step, which turns out to be the most expensive step when computing triangulations normally. This algorithm is mainly used so that we can delete vertices from a Delaunay triangulation - see the referenced book for more detail.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"A basic overview of the algorithm is as follows: Let us suppose that S is a sequence that lists the k vertices of some convex polygon in counterclockwise order, say S = v_1 ldots v_k, as obtained via get_surrounding_polygon:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"get_surrounding_polygon","category":"page"},{"location":"tri_algs/convex/#DelaunayTriangulation.get_surrounding_polygon","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surronding_polygon(tri, u; skip_boundary_indices=false)\n\nReturns the set of neighbours of u in counter-clockwise order. If skip_boundary_indices is true, then boundary indices are not included in the set.\n\n\n\n\n\nget_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}\n\nGiven a point u, returns a vector S which gives a counter-clockwise sequence of the neighbours of u. \n\nArguments\n\nadj::Adjacent{I,E}: The Adjacent map.\ngraph::Graph: The Graph.\nu: The vertex.\nboundary_index_ranges: The output of construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nKeyword Arguments\n\nskip_boundary_indices=false: Whether to remove all boundary indices from the result at the end.\n\nOutputs\n\nS: The surrounding polygon.\n\nnote: Note\nWhen u is an outer boundary index, the returned polygon is clockwise.\nWhen u is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"To improve the complexity of our algorithm, we should randomise the insertion order for the polygon vertices to reduce the work needed, noting that the average degree of a vertex in a triangulation should typically be around six. So, we construct some permutation pi of 1 ldots k that will define how we insert the points, taking the first three vertices pi_1 pi_2 pi_3 as our initial triangle. Then, using the Bowyer-Watson algorithm, we can add in points one at a time, simply walking along the polygon to find triangles rather than the jump and march algorithm used in our main Bowyer-Watson algorithm. Note that when we add some vertex u, only one edge can separate it from the triangulation's interior, else the polygon wouldn't be convex. Hence, when u is inserted, we just take the union of this disk with all other triangles whose open circumdisks contain u. This will give us our triangulation.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"Let us now describe the algorithm in more detail. The main complexity in the algorithm comes in from devising a smart way for avoiding point location. This is done with backward analysis, where instead of imagining points in one at a time, we think about what happens if we delete vertices one at a time. Suppose we have a vertex u with neighbours v and w. When we delete u, the only way to reform the poylgon and keep it convex is to join v and w, i.e. a deletion of a vertex also implies a new edge from its neighbours. This edge is exactly what we need for point location: the edge we need is simply the edge from a point's neighbours, thus allowing us to skip the jump and march algorithm. With this knowledge, we construct a circularly-, doubly-linked list of our polygon vertices, called mathcal N (next) and mathcal P (previous) for the two neighbours of each vertex, and then we imagine deleting vertices one at a time by simply editing this linked list. The steps are as follows:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"First, take S = v_1 ldots v_k and a permutation pi of 1ldotsk.\nNext, compute mathcal N = 2 3 ldots 1 and mathcal P = k 1 ldots k-1.\nThen, from i=k down to i=4:  a. To delete v_pi_i from the polygon, we can set mathcal Nmathcal P(pi_i) mapsfrom mathcal N(pi_i) and mathcal Pmathcal N(pi_i) = mathcal P(pi_i), i.e. just connect the two neighbours together.\nNow, start the triangulation with the initial triangle through (v_pi_1, v_mathcal N(pi_1), v_mathcal P(pi_1). If this triangle is degenerate, just repeat the above steps until you find a non-degenerate triangular.\nNow that we have our initial triangle, we can start adding points in. So, for i = 4 up to i = k:  a. Call the routine mathcal C(v_pi_i v_mathcal N(pi_i) v_mathcal P(pi_i)) to insert v_pi_i, defined below.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"This routine mathcal C(u v w) is defined as follows:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"First, take x = mathcal A(w v) where mathcal A is the adjacent map. With this definition, the triangle wvx is opposite the ede vw from u.\nIt is possible that x is not on the polygon, i.e. x might be emptyset or, if this algorithm is being used for deleting a vertex so that the polygon is embedded inside a larger triangulation, x could be a vertex away from the polygon, so we must check that x in S. Moreover, we must check that x is actually inside the triangle through u, v, and w. If these two conditions hold, then the triangles uvw and wvx must not be Delaunay, so delete the triangle wvx, and continue stepping through the triangulation by calling mathcal C(u v x) and mathcal C(u x w) so that more non-Delaunay triangles can be identified and deleted.\nIf the two conditions in the last step did not hold, we start this third step (otherwise, return in step 2 above). These two conditions holding mean that vw is still a Delaunay edge, so we can edge the triangle uvw into the triangle.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"With this routine and the steps for the original algorithm, we can triangulate convex polygons.","category":"page"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/boundary_nodes/#Boundary-Nodes","page":"Boundary Nodes","title":"Boundary Nodes","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"As mentioned at the start of this section, the interface for representing boundary nodes allows for support for a contiguous boundary, a segmented boundary, and multiple separate boundaries. (There is also support for more complex geometries, as described in the constrained triangulation section, although features like point location have limited support for e.g. non-convex domains and regions with holes inside holes.) This interface is customisable, and we define the following methods for this.","category":"page"},{"location":"interface/boundary_nodes/#Necessary-Methods","page":"Boundary Nodes","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"has_multiple_curves \nhas_multiple_segments \nnum_curves \nnum_segments \nnum_boundary_edges \ngetboundarynodes \neach_boundary_node ","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn defines multiple curves,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_curves(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_curves(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_curves(::A) where {F<:Number,A<:AV{F}}\n\nwith the first method returning true, while the last two methods return false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn contains multiple segments,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_segments(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_segments(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_segments(::A) where {F<:Number,A<:AV{F}}\n\nwith the first and second methods returning true, while the last method returns false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.num_curves","text":"num_curves(bn::A)\n\nReturns the number of curves defined by the boundary nodes bn. We currently  define the methods\n\nnum_curves(bn::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}}\n\nwhich simply returns bn.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_segments","text":"num_segments(bn::A)\n\nReturns the number of segments defined by the boundary nodes bn. We currently  define the method\n\nnum_segments(bn::AA) where {F<:Number,A<:AV{F},AA<:AV{A}}\n\nwhich simply returns length(bn).\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_boundary_edges","page":"Boundary Nodes","title":"DelaunayTriangulation.num_boundary_edges","text":"num_boundary_edges(bn)\n\nGiven a collection of boundary nodes bn, returns the number of edges. This only  needs to be defined for individual segments. We define the method \n\nnum_boundary_edges(bn::A) where {A<:AbstractVector}\n\nwhich returns length(bn) - 1 (-1 because it is assumed that bn[begin] == bn[end]).  This is the only method that needs to be extended.\n\nSee also getboundarynodes.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.getboundarynodes","page":"Boundary Nodes","title":"DelaunayTriangulation.getboundarynodes","text":"getboundarynodes(bn::A, mnℓ...)\n\nGiven a collection of boundary nodes bn, returns the specified component of the  collection. There are several forms for the methods. In these methods, it is assumed  that one-based indexing is used for accessing all the boundary nodes. If you want to  use offsets, for example, then define getboundarynodes appropriately (e.g. maybe  getboundarynodes(bn, m) could map m to m-4 if 4 is your offset).\n\nThe methods that you need to define are those that go down a level, i.e. from a set of curves  to a curve, from a set of segments to a set of nodes, and from a set of nodes to a node. Of course,  if you only ever use e.g. a set of nodes, then you need only define that method. The methods that  we define for this are\n\ngetboundarynodes(bn::AAA, m::Integer) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \ngetboundarynodes(bn::AA, n::Integer) where {F<:Number,A<:AV{F},AA<:AV{A}} \ngetboundarynodes(bn::A, ℓ::Integer) where {F<:Number,A<:AV{F}}\n\nThe first method takes a set of curves to the mth curve, the second takes a set of segments to the  nth segment, and the third takes a set of nodes to the ℓth node. These are the only methods  that need to be extended. For the set of curves case, we also define\n\ngetboundarynodes(bn, m::Integer, n::Integer)\ngetboundarynodes(bn, (m, n)::NTuple{2,Integer})\n\nwhich calls getboundarynodes(getboundarynodes(bn, m), n). This does not need to be extended. Lastly,  we also define \n\ngetboundarynodes(bn::A, ::A) where {A}\n\nwhich simply returns bn. This is useful when using the result of construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.each_boundary_node","page":"Boundary Nodes","title":"DelaunayTriangulation.each_boundary_node","text":"each_boundary_node(bn::A)\n\nReturns an iterator that goes over each node in bn. Only defined for  single segments so that bn acts like a vector of numbers. The only method  currently defined is \n\neach_boundary_node(bn::A) where {F<:Number,A<:AbstractVector{F}}\n\nwhich just returns bn. You can extend this function as you need. If you really  want to loop over every boundary node, you can make use of the result from  construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#Generic-Methods","page":"Boundary Nodes","title":"Generic Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"get_boundary_nodes(::Any, ::Vararg{Any})\nconstruct_boundary_map \nconstruct_boundary_index_ranges \nmap_boundary_index(::Any, ::Any) \nget_curve_index \nget_segment_index \nnum_outer_boundary_segments \nconstruct_boundary_edge_map\ninsert_boundary_node!\ndelete_boundary_node!","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_boundary_nodes-Tuple{Any, Vararg{Any}}","page":"Boundary Nodes","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(bn, mnℓ...)\n\nGet the boundary nodes from bn corresponding to the specified indices.  See getboundarynodes.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_map","text":"construct_boundary_map(bn; IntegerType::Type{I} = Int64) where {I}\n\nGiven a set of boundary nodes bn, returns a OrderedDict that maps boundary indices  to their position in bn. In particular:\n\nhas_multiple_curves(bn)\n\nIn this case, the result is a dict = OrderedDict{I, NTuple{2, I}}. The results will be of the form  dict[i] = (m, n), so that boundary indices with value i correspond to nodes at  get_boundary_nodes(bn, m, n), i.e. the nth segment of the mth curve.\n\nhas_multiple_segments(bn)\n\nIn this case, the result is a dict = OrderedDict{I, I}. The results will be of the form dict[i] = n, so that boundary indices with value i correspond to nodes at get_boundary_nodes(bn, n), i.e.  the nth segment.\n\nelse\n\nHere, the result is a dict = OrderedDict{I, F}, mapping -1 back to bn and F = typeof(bn).\n\nIteration Tips\n\nThis dict can be useful for iterating over all boundary nodes. For example, you could do\n\nbn_map = construct_boundary_map(bn)\nfor segment_index in values(bn_map)\n    nodes = get_boundary_nodes(bn, segment_index)\n    ## Do something with the nodes \nend \n\nThe above will work for any form of bn also.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_index_ranges","text":"construct_boundary_index_ranges(boundary_nodes; IntegerType::Type{I}=Int64) where {I}\n\nGiven a set of boundary_nodes, creates an OrderedDict that maps boundary indices  to the range of all boundary indices that the corresponding boundary curve could  correspond to. For example, suppose we have \n\njulia> boundary_nodes = [\n           [\n               [1, 2, 3, 4], [4, 5, 6, 1]\n           ],\n           [\n               [18, 19, 20, 25, 26, 30]\n           ],\n           [\n               [50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]\n           ]\n       ]\n\nThen the first curve, [[1, 2, 3, 4], [4, 5, 6, 1]] has boundary indices -1 and -2,  so the range would be -2:-1. The full Dict we obtain will be \n\njulia> construct_boundary_index_ranges(boundary_nodes)\nOrderedDict{Int64, UnitRange{Int64}} with 7 entries:\n  -1 => -2:-1\n  -2 => -2:-1\n  -3 => -3:-3\n  -4 => -7:-4\n  -5 => -7:-4\n  -6 => -7:-4\n  -7 => -7:-4\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.map_boundary_index-Tuple{Any, Any}","page":"Boundary Nodes","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(dict, i)\n\nGiven a dict from construct_boundary_map, returns dict[i]. Also works  for a dict from construct_boundary_index_ranges.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_curve_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(dict, i)\nget_curve_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the curve corresponding to that boundary index. The  second method maps i to 1 if it is an integer, and i[1] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_segment_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(dict, i)\nget_segment_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the segment corresponding to that boundary index. The  second method maps i to i if it is an integer, 1 if it is a vector,  and i[2] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_outer_boundary_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_outer_boundary_segments","text":"num_outer_boundary_segments(boundary_nodes)\n\nGiven a set of boundary_nodes, returns the number of segments  that correspond to the outer boundary. Note that this also gives  the range of outer boundary indices, i.e.  -1:-1:-num_outer_boundary_segments(boundary_nodes).\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_edge_map","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_edge_map","text":"construct_boundary_edge_map(bn::A; IntegerType::Type{I}=Int64, EdgeType::Type{E}=NTuple{2,IntegerType}) where {A,I,E}\n\nConstructs a map that takes boundary edges (i,j) to a Tuple giving the edge's position in the corresponding  set of boundary nodes.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.insert_boundary_node!","page":"Boundary Nodes","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(bn, pos, node)\n\nInserts a boundary node node into the set of boundary nodes bn at the position pos. The first element of pos  finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the  second element of pos gives the position of the array to insert node into. In particular, \n\ninsert_boundary_node!(bn, pos, node)\n\nis the same as \n\ninsert!(get_boundary_nodes(bn, pos[1]), pos[2], node)\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.delete_boundary_node!","page":"Boundary Nodes","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(bn, pos)\n\nDeletes a boundary node from the set of boundary nodes bn at the position pos. The first element of pos finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the second element of pos gives the position of the array to delete. In particular,\n\ndelete_boundary_node!(bn, pos)\n\nis the same as\n\ndeleteat!(get_boundary_nodes(bn, pos[1]), pos[2])\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"utils/#Other-Utilities","page":"Other Utilities","title":"Other Utilities","text":"","category":"section"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"Here are some docstrings for other utility functions.","category":"page"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"is_true\nget_boundary_index\nrotate_ghost_triangle_to_standard_form \nget_right_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nget_left_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nfind_edge(::Any, ::Any, ::Any)\nchoose_uvw \nis_circular \ncircular_equality \nget_surrounding_polygon(::Adjacent{I,E}, ::Graph, ::Any, ::Any, ::C) where {I,E,C}\nsort_edge_by_degree(::E, ::Graph) where {E}\nsplit_constrained_edge!(::Any, ::E, ::Any) where {E}\nfix_segments!(::AbstractVector{E}, bad_indices) where {E}\nconnect_segments!(::AbstractVector{E}) where {E}\nextend_segments!(::AbstractVector{E}, ::Any) where {E}\nconvert_boundary_points_to_indices(::AAA, ::AAA) where {F<:Number,A<:AbstractVector{F},AA<:AbstractVector{A},AAA<:AbstractVector{AA}}\nget_ordinal_suffix \ncheck_args\nmin_max \nmin_med_max \nbalanced_power_of_two_ternary_split\nbalanced_power_of_two_quarternary_split \nsegment_vertices_adjoin_other_segments\nedge_lies_on_two_distinct_segments","category":"page"},{"location":"utils/#DelaunayTriangulation.is_true","page":"Other Utilities","title":"DelaunayTriangulation.is_true","text":"is_true(b)\n\nReturns true if b is true, Val{true}, or Val(true). Returns false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_boundary_index","page":"Other Utilities","title":"DelaunayTriangulation.get_boundary_index","text":"get_boundary_index(i, j, k)\nget_boundary_index(i, j)\n\nGiven three indices i, j, and k, returns the index corresponding to a boundary index. If no boundary index is provided, an ArgumentError is thrown. Similarly for the second method, which takes two indices.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.rotate_ghost_triangle_to_standard_form","page":"Other Utilities","title":"DelaunayTriangulation.rotate_ghost_triangle_to_standard_form","text":"rotate_ghost_triangle_to_standard_form(i, j, k)\nrotate_ghost_triangle_to_standard_form(T::V) where {V}\n\nGiven a triangle T = (i, j, k), rotates it to a new triangle T′ = (u, v, w) such that w is a boundary index.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_right_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nReturns the node on the boundary that is to the right of k.\n\nArguments\n\nadj::Adjacent: The Adjacent map.\nk: The boundary node index.\nboundary_index: The boundary index corresponding to the curve.\nboundary_index_ranges: The boundary index ranges from construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nOutputs\n\ni: The node on the boundary to the right of k.\n\nSee also get_left_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.get_left_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nReturns the node on the boundary that is to the left of k.\n\nArguments\n\nadj::Adjacent: The Adjacent map.\nk: The boundary node index.\nboundary_index: The boundary index corresponding to the curve.\nboundary_index_ranges: The boundary index ranges from construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nOutputs\n\ni: The node on the boundary to the left of k.\n\nSee also get_right_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.find_edge-Tuple{Any, Any, Any}","page":"Other Utilities","title":"DelaunayTriangulation.find_edge","text":"find_edge(T, points, ℓ)\n\nGiven a triangle T with indices corresponding to points, returns the edge of T that contains the point ℓ. It is assumed that the point ℓ is on an edge of T. If this is not the case, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.choose_uvw","page":"Other Utilities","title":"DelaunayTriangulation.choose_uvw","text":"choose_uvw(e1, e2, e3, u, v, w)\n\nChoose values for (u, v, w) based on the Booleans (e1, e2, e3),  assuming only one is true. The three cases are: \n\nIf e1, returns (u, v, w).\nIf e2, returns (v, w, u).\nIf e3, returns (w, u, v).\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.is_circular","page":"Other Utilities","title":"DelaunayTriangulation.is_circular","text":"is_circular(A)\n\nTests if A[begin] == A[end]. Also returns true if A is empty.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.circular_equality","page":"Other Utilities","title":"DelaunayTriangulation.circular_equality","text":"circular_equality(A, B)\n\nTests if the arrays A and B are equal up to a circular shift, assuming A  and B are circular.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_surrounding_polygon-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, DelaunayTriangulation.Graph, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}\n\nGiven a point u, returns a vector S which gives a counter-clockwise sequence of the neighbours of u. \n\nArguments\n\nadj::Adjacent{I,E}: The Adjacent map.\ngraph::Graph: The Graph.\nu: The vertex.\nboundary_index_ranges: The output of construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nKeyword Arguments\n\nskip_boundary_indices=false: Whether to remove all boundary indices from the result at the end.\n\nOutputs\n\nS: The surrounding polygon.\n\nnote: Note\nWhen u is an outer boundary index, the returned polygon is clockwise.\nWhen u is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.sort_edge_by_degree-Union{Tuple{E}, Tuple{E, DelaunayTriangulation.Graph}} where E","page":"Other Utilities","title":"DelaunayTriangulation.sort_edge_by_degree","text":"sort_edge_by_degree(e::E, graph::Graph)\n\nGiven an edge e of a graph, say e = (u, v), returns:\n\nIf deg(u) ≤ deg(v), returns e;\nIf deg(u) > deg(v), returns (v, u).\n\nIn particular, e is sorted so that initial(e) is the vertex of e  with the smallest degree.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.split_constrained_edge!-Union{Tuple{E}, Tuple{Any, E, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.split_constrained_edge!","text":"split_constrained_edge!(constrained_edges, constrained_edge::E, collinear_segments) where {E}\n\nSplits the constrained_edge at the segments in collinear_segments, updating constrained_edges accordingly.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.fix_segments!","text":"fix_segments!(segments::AbstractVector{E}, bad_indices) where {E}\n\nFixes the overlapping segments in segments, referred to via bad_indices.\n\nExample\n\nFor example, if we had \n\njulia> c = [(2, 15), (2, 28), (2, 41)]\n\nthen these edges come from connecting the start of a constrained segment with a point that  it goes through, but they are not actual segments in the triangulation (because they  all start with 2). So, using bad_indices = [1, 2, 3], the function mutates c  to give \n\njulia> bad_indices = [1, 2, 3]\njulia> fix_segments!(c, bad_indices)\njulia> c\n3-element Vector{Tuple{Int64, Int64}}:\n (2, 15)\n (15, 28)\n (28, 41)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E","page":"Other Utilities","title":"DelaunayTriangulation.connect_segments!","text":"connect_segments!(segments::AbstractVector{E}) where {E}\n\nGiven an ordered vector of segments, mutates so that the endpoints connect, preserving order.\n\nExample\n\njulia> C = [(7, 12), (12, 17), (17, 22), (32, 37), (37, 42), (42, 47)];\n\njulia> DelaunayTriangulation.connect_segments!(C);\n\njulia> C\n7-element Vector{Tuple{Int64, Int64}}:\n (7, 12)\n (12, 17)\n (17, 22)\n (32, 37)\n (37, 42)\n (42, 47)\n (22, 32)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.extend_segments!","text":"extend_segments!(segments::AbstractVector{E}, constrained_edge) where {E}\n\nGiven an ordered vector of segments, ensures that they also represent the  replacement of constrained_edge.\n\nExample\n\njulia> segments = [(2, 7), (7, 12), (12, 49)];\njulia> constrained_edge = (1, 68);\njulia> extend_segments!(segments, constrained_edge);\njulia> segments\n5-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (2, 7)\n (7, 12)\n (12, 49)\n (49, 68)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.convert_boundary_points_to_indices-Union{Tuple{AAA}, Tuple{AA}, Tuple{A}, Tuple{F}, Tuple{AAA, AAA}} where {F<:Number, A<:AbstractVector{F}, AA<:AbstractVector{A}, AAA<:AbstractVector{AA}}","page":"Other Utilities","title":"DelaunayTriangulation.convert_boundary_points_to_indices","text":"convert_boundary_points_to_indices(x, y; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)\nconvert_boundary_points_to_indices(xy; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)\n\nGiven some points (x, y) representing a boundary, or xy giving the points combined rather than separated, converts their representation into a set of  indices corresponding to each boundary. The points should match the specification of a boundary  defined in the documentation. These points also get appended onto the set of points given by the  existing_points keyword argument, which should be used if you have a pre-existing set of points.\n\nThe returned value is (nodes, points), with nodes the indices and points the modified  existing_points (which are mutated in-place also).\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.get_ordinal_suffix","page":"Other Utilities","title":"DelaunayTriangulation.get_ordinal_suffix","text":"get_ordinal_suffix(i)\n\nReturns the ordinal suffix for the given integer i. \n\nExample\n\njulia> get_ordinal_suffix(1)\n\"st\"\njulia> get_ordinal_suffix(2)\n\"nd\"\njulia> get_ordinal_suffix(3)\n\"rd\"    \njulia> get_ordinal_suffix(4)\n\"th\"\njulia> get_ordinal_suffix(11)\n\"th\"\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.check_args","page":"Other Utilities","title":"DelaunayTriangulation.check_args","text":"check_args(points, boundary_nodes)\n\nChecks the arguments points and boundary_nodes to make sure that they are valid. If they are not, an error is thrown. This function is called by triangulate if the check_args keyword argument is set to true. If you are sure that your arguments are valid, you can set this keyword argument to false to speed up the triangulation process.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.min_max","page":"Other Utilities","title":"DelaunayTriangulation.min_max","text":"min_max(a, b)\n\nReturns (min(a, b), max(a, b)).\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.min_med_max","page":"Other Utilities","title":"DelaunayTriangulation.min_med_max","text":"min_med_max(a, b, c)\n\nReturns (min(a, b, c), med(a, b, c), max(a, b, c)), wheremed(a, b, c)is the value that is neithermin(a, b, c)ormax(a, b, c)`.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.balanced_power_of_two_ternary_split","page":"Other Utilities","title":"DelaunayTriangulation.balanced_power_of_two_ternary_split","text":"balanced_power_of_two_ternary_split(ℓ)\n\nCompute the the power of two that is closest  to ℓ/3 or to ℓ/1.5.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.balanced_power_of_two_quarternary_split","page":"Other Utilities","title":"DelaunayTriangulation.balanced_power_of_two_quarternary_split","text":"balanced_power_of_two_quarternary_split(ℓ)\n\nCompute the the power of two that is closest to ℓ/4 or to ℓ/0.5.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.segment_vertices_adjoin_other_segments","page":"Other Utilities","title":"DelaunayTriangulation.segment_vertices_adjoin_other_segments","text":"segment_vertices_adjoin_other_segments(tri::Triangulation, e)\n\nTest if the segment e's vertices adjoin other segments. Returns:\n\n0: No vertex adjoins another segment.\n1: One vertex adjoins another segment.\n2: Both vertices adjoin another segment.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.edge_lies_on_two_distinct_segments","page":"Other Utilities","title":"DelaunayTriangulation.edge_lies_on_two_distinct_segments","text":"edge_lies_on_two_distinct_segments(tri::Triangulation, e)\n\nTests if the edge (i, j) lies on two distinct segments. The returned value is:\n\n(true, common_vertex): If e lies on two distinct segments, and the common vertex is common_vertex.\n(false, 0): Otherwise.\n\nIf there are multiple common vertices. In this case, the function returns the vertex that is closest to e.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/constrained/#Constrained-Triangulations","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we show to compute constrained triangulations. The interface for this is via triangulate just as it was with unconstrained triangulations, or  you can do it manually with add_edge!. We will go through several examples.","category":"page"},{"location":"triangulations/constrained/#Constrained-edges-only","page":"Constrained Triangulations","title":"Constrained edges only","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Let us start with an example that shows the computation of a constrained triangulation, with constrained edges only rather than handling boundary nodes. Here, any edges can be used as long as they do not intersect (they can run into each other if they are collinear, in which case they are split automatically).","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\na = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]\nC = Set([(2,1),(2,11),(2, 7), (2, 5)])\nuncons_tri = triangulate(pts)\ncons_tri=triangulate(pts;edges=C)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $ Unconstrained\", titlealign=:left)\ntriplot!(ax, uncons_tri)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(b):$ $  Constrained\", titlealign=:left)\ntriplot!(ax, cons_tri)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/simple_constrained.png', alt='Constrained triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#With-an-outer-boundary","page":"Constrained Triangulations","title":"With an outer boundary","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let us define an outer boundary also. For this, the convert_boundary_points_to_indices function will be useful to convert a set of boundary coordinates to indices correctly. Note also that the boundary points we specify must connect, matching the specification defined in the boundary handling section of the sidebar.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\npts = [\n    (-7.36, 12.55), (-9.32, 8.59), (-9.0, 3.0), (-6.32, -0.27),\n    (-4.78, -1.53), (2.78, -1.41), (-5.42, 1.45), (7.86, 0.67),\n    (10.92, 0.23), (9.9, 7.39), (8.14, 4.77), (13.4, 8.61),\n    (7.4, 12.27), (2.2, 13.85), (-3.48, 10.21), (-4.56, 7.35),\n    (3.44, 8.99), (3.74, 5.87), (-2.0, 8.0), (-2.52, 4.81),\n    (1.34, 6.77), (1.24, 4.15)\n]\nboundary_points = [\n    (0.0, 0.0), (2.0, 1.0), (3.98, 2.85), (6.0, 5.0),\n    (7.0, 7.0), (7.0, 9.0), (6.0, 11.0), (4.0, 12.0),\n    (2.0, 12.0), (1.0, 11.0), (0.0, 9.13), (-1.0, 11.0),\n    (-2.0, 12.0), (-4.0, 12.0), (-6.0, 11.0), (-7.0, 9.0),\n    (-6.94, 7.13), (-6.0, 5.0), (-4.0, 3.0), (-2.0, 1.0), (0.0, 0.0)\n]\nboundary_nodes, pts = convert_boundary_points_to_indices(boundary_points; existing_points=pts)\nuncons_tri = triangulate(pts, delete_ghosts = false)\ncons_tri = triangulate(pts; boundary_nodes, delete_ghosts = false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/heart_constrained.png', alt='Constrained triangulation with a boundary'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"If we wanted to, we could add an edge in after the construction or a point. We would need to add back in the ghost triangles, though, or use delete_ghosts=false in triangulate (as we did above).","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"add_point!(cons_tri, 0.0, 5.0)\nadd_edge!(cons_tri, 40, 26)\nadd_edge!(cons_tri, 39, 27)\nadd_edge!(cons_tri, 38, 28)\nadd_point!(cons_tri, -3.0, 12.0) # can add points onto segments ","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/heart_add_constrained.png', alt='Constrained triangulation with a boundary and additions'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"You do need to be careful not to add segments that intersect each other at an angle, though.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Since we have used just a single boundary, there is just a single boundary index:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> DelaunayTriangulation.all_boundary_indices(cons_tri)\nKeySet for a OrderedCollections.OrderedDict{Int64, UnitRange{Int64}} with 1 entry. Keys:\n  -1\n\njulia> get_adjacent2vertex(cons_tri, -1)\nSet{Tuple{Int64, Int64}} with 21 elements:\n  (37, 36)\n  (44, 35)\n  (35, 34)\n  (33, 32)\n  (27, 26)\n  (36, 44)\n  (31, 30)\n  (39, 38)\n  (24, 23)\n  (23, 42)\n  (30, 29)\n  (42, 41)\n  ⋮\n\njulia> get_neighbours(cons_tri, -1)\nSet{Int64} with 21 elements:\n  35\n  30\n  28\n  24\n  37\n  23\n  32\n  41\n  44\n  36\n  31\n  39\n  ⋮","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"If needed, you can get all the constrained edges using the all_constrained_edges field:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> each_constrained_edge(cons_tri)\nSet{Tuple{Int64, Int64}} with 25 elements:\n  (23, 24)\n  (40, 43)\n  (40, 41)\n  (26, 43)\n  (25, 26)\n  (39, 27)\n  (30, 31)\n  (29, 30)\n  (44, 35)\n  (42, 23)\n  (33, 34)\n  (38, 39)\n  ⋮","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"which includes all constrained edges, i.e. the boundary edges and the constrained edges we just added. If you just want to iterate over each boundary edge, you could use the boundary_edge_map:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> get_boundary_edge_map(cons_tri)\nDict{Tuple{Int64, Int64}, Tuple{Vector{Int64}, Int64}} with 21 entries:\n  (23, 24) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 1)\n  (40, 41) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 19)\n  (25, 26) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 3)\n  (35, 44) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 13)\n  (30, 31) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 8)\n  (29, 30) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 7)\n  (42, 23) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 21)\n  (33, 34) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 11)\n  (38, 39) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 17)\n  (27, 28) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 5)\n  (26, 27) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 4)\n  (39, 40) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 18)\n  ⋮        => ⋮","category":"page"},{"location":"triangulations/constrained/#Segmented-outer-boundary","page":"Constrained Triangulations","title":"Segmented outer boundary","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now we give an example where we split the boundary into segments, allowing each part of the boundary to be identified separately. For this, we define the boundary nodes on each segment, but making sure the segments connect at the endpoints.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\npoints = [\n    (2.0, 8.0), (6.0, 4.0), (2.0, 6.0),\n    (2.0, 4.0), (8.0, 2.0)\n]\nsegment_1 = [(0.0, 0.0), (14.0, 0.0)]\nsegment_2 = [(14.0, 0.0), (10.0, 4.0), (4.0, 6.0), (2.0, 12.0), (0.0, 14.0)]\nsegment_3 = [(0.0, 14.0), (0.0, 0.0)]\nboundary_points = [segment_1, segment_2, segment_3]\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points; existing_points=points)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/triangle_triangulation.png', alt='Constrained triangulation of a dented triangle'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"In this case, we can now identify the bottom, diagonal, and left sides:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> get_adjacent2vertex(cons_tri, -1) # bottom\nSet{Tuple{Int64, Int64}} with 1 element:\n  (7, 6)\n\njulia> get_adjacent2vertex(cons_tri, -2) # diagonal\nSet{Tuple{Int64, Int64}} with 4 elements:\n  (10, 9)\n  (8, 7)\n  (11, 10)\n  (9, 8)\n\njulia> get_adjacent2vertex(cons_tri, -3) # left\nSet{Tuple{Int64, Int64}} with 1 element:\n  (6, 11)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The triangulation we've built has few triangles around the boundaries, since we've defined the boundary using few points. We can add more points onto the boundary if we want, being careful not to add points on top of other points, and noting that we need to have ghost triangles to do this. Note also that floating point arithmetic isn't perfect, so some points aren't detected as being on the boundary unfortunately:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"add_ghost_triangles!(cons_tri)\nadd_ghost_triangles!(uncons_tri)\nfor x in LinRange(0.1, 13.9, 10) # bottom side\n    add_point!(uncons_tri, x, 0.0)\n    add_point!(cons_tri, x, 0.0)\nend\nfor x in LinRange(13.9, 10.1, 10) # first part of diagonal\n    add_point!(uncons_tri, x, 14 - x)\n    add_point!(cons_tri, x, 14 - x)\nend\nfor x in LinRange(9.9, 4.1, 10) # second part of diagonal \n    add_point!(uncons_tri, x, 22 // 3 - x / 3)\n    add_point!(cons_tri, x, 22 // 3 - x / 3)\nend\nfor x in LinRange(3.9, 2.1, 10) # third part of diagonal \n    add_point!(uncons_tri, x, 18 - 3x)\n    add_point!(cons_tri, x, 18 - 3x)\nend\nfor x in LinRange(1.9, 0.1, 10) # last part of diagonal\n    add_point!(uncons_tri, x, 14 - x)\n    add_point!(cons_tri, x, 14 - x)\nend\nfor y in LinRange(13.9, 0.1, 10) # left \n    add_point!(uncons_tri, 0.0, y)\n    add_point!(cons_tri, 0.0, y)\nend\ndelete_ghost_triangles!(cons_tri)\ndelete_ghost_triangles!(uncons_tri)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/triangle_triangulation_refined.png', alt='Constrained triangulation of a dented triangle with refinements'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"A better way could be to use e.g. the split_edge! operation. This would be better handled by the mesh refinement methods.","category":"page"},{"location":"triangulations/constrained/#Domain-with-interior-holes","page":"Constrained Triangulations","title":"Domain with interior holes","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let us consider a domain with interior holes. In this case, the outer boundary should be given counter-clockwise, while the interiors should be clockwise. Additionally, each curve should be given as if it were split into segments, even if there is only a single segment.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\ncurve_1 = [[\n    (0.0, 0.0), (4.0, 0.0), (8.0, 0.0), (12.0, 0.0), (12.0, 4.0),\n    (12.0, 8.0), (14.0, 10.0), (16.0, 12.0), (16.0, 16.0),\n    (14.0, 18.0), (12.0, 20.0), (12.0, 24.0), (12.0, 28.0),\n    (8.0, 28.0), (4.0, 28.0), (0.0, 28.0), (-2.0, 26.0), (0.0, 22.0),\n    (0.0, 18.0), (0.0, 10.0), (0.0, 8.0), (0.0, 4.0), (-4.0, 4.0),\n    (-4.0, 0.0), (0.0, 0.0),\n]]\ncurve_2 = [[\n    (4.0, 26.0), (8.0, 26.0), (10.0, 26.0), (10.0, 24.0),\n    (10.0, 22.0), (10.0, 20.0), (8.0, 20.0), (6.0, 20.0),\n    (4.0, 20.0), (4.0, 22.0), (4.0, 24.0), (4.0, 26.0)\n]]\ncurve_3 = [[(4.0, 16.0), (12.0, 16.0), (12.0, 14.0), (4.0, 14.0), (4.0, 16.0)]]\ncurve_4 = [[(4.0, 8.0), (10.0, 8.0), (8.0, 6.0), (6.0, 6.0), (4.0, 8.0)]]\ncurves = [curve_1, curve_2, curve_3, curve_4]\npoints = [\n    (2.0, 26.0), (2.0, 24.0), (6.0, 24.0), (6.0, 22.0), (8.0, 24.0), (8.0, 22.0),\n    (2.0, 22.0), (0.0, 26.0), (10.0, 18.0), (8.0, 18.0), (4.0, 18.0), (2.0, 16.0),\n    (2.0, 12.0), (6.0, 12.0), (2.0, 8.0), (2.0, 4.0), (4.0, 2.0),\n    (-2.0, 2.0), (4.0, 6.0), (10.0, 2.0), (10.0, 6.0), (8.0, 10.0), (4.0, 10.0),\n    (10.0, 12.0), (12.0, 12.0), (14.0, 26.0), (16.0, 24.0), (18.0, 28.0),\n    (16.0, 20.0), (18.0, 12.0), (16.0, 8.0), (14.0, 4.0), (14.0, -2.0),\n    (6.0, -2.0), (2.0, -4.0), (-4.0, -2.0), (-2.0, 8.0), (-2.0, 16.0),\n    (-4.0, 22.0), (-4.0, 26.0), (-2.0, 28.0), (6.0, 15.0), (7.0, 15.0),\n    (8.0, 15.0), (9.0, 15.0), (10.0, 15.0), (6.2, 7.8),\n    (5.6, 7.8), (5.6, 7.6), (5.6, 7.4), (6.2, 7.4), (6.0, 7.6),\n    (7.0, 7.8), (7.0, 7.4)]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points=points)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/multiply_connected.png', alt='Constrained triangulation of a multiply-connected domain'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#More-complex-geometries","page":"Constrained Triangulations","title":"More complex geometries","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"It is possible to represent more complex geometries than those above. While the package assumes that boundaries are continguous boundaries, segmented contiguous boundaries, or an outer boundary with interior holes that themselves have no interior holes, e.g. for point location, we can still construct them. If you are only going to use the mesh without worrying about adding points or further edges, this works great.","category":"page"},{"location":"triangulations/constrained/#Interior-holes-within-interiors","page":"Constrained Triangulations","title":"Interior holes within interiors","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Let us give an example which has interiors within interiors. This can be represented by swapping the orientation of an interior to be counter-clockwise.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"curve_1 = [\n    [(0.0, 0.0), (5.0, 0.0), (10.0, 0.0), (15.0, 0.0), (20.0, 0.0), (25.0, 0.0)],\n    [(25.0, 0.0), (25.0, 5.0), (25.0, 10.0), (25.0, 15.0), (25.0, 20.0), (25.0, 25.0)],\n    [(25.0, 25.0), (20.0, 25.0), (15.0, 25.0), (10.0, 25.0), (5.0, 25.0), (0.0, 25.0)],\n    [(0.0, 25.0), (0.0, 20.0), (0.0, 15.0), (0.0, 10.0), (0.0, 5.0), (0.0, 0.0)]\n] # outer-most boundary: counter-clockwise  \ncurve_2 = [\n    [(4.0, 6.0), (4.0, 14.0), (4.0, 20.0), (18.0, 20.0), (20.0, 20.0)],\n    [(20.0, 20.0), (20.0, 16.0), (20.0, 12.0), (20.0, 8.0), (20.0, 4.0)],\n    [(20.0, 4.0), (16.0, 4.0), (12.0, 4.0), (8.0, 4.0), (4.0, 4.0), (4.0, 6.0)]\n] # inner boundary: clockwise \ncurve_3 = [\n    [(12.906, 10.912), (16.0, 12.0), (16.16, 14.46), (16.29, 17.06),\n    (13.13, 16.86), (8.92, 16.4), (8.8, 10.9), (12.906, 10.912)]\n] # this is inside curve_2, so it's counter-clockwise \ncurves = [curve_1, curve_2, curve_3]\npoints = [\n    (3.0, 23.0), (9.0, 24.0), (9.2, 22.0), (14.8, 22.8), (16.0, 22.0),\n    (23.0, 23.0), (22.6, 19.0), (23.8, 17.8), (22.0, 14.0), (22.0, 11.0),\n    (24.0, 6.0), (23.0, 2.0), (19.0, 1.0), (16.0, 3.0), (10.0, 1.0), (11.0, 3.0),\n    (6.0, 2.0), (6.2, 3.0), (2.0, 3.0), (2.6, 6.2), (2.0, 8.0), (2.0, 11.0),\n    (5.0, 12.0), (2.0, 17.0), (3.0, 19.0), (6.0, 18.0), (6.5, 14.5),\n    (13.0, 19.0), (13.0, 12.0), (16.0, 8.0), (9.8, 8.0), (7.5, 6.0),\n    (12.0, 13.0), (19.0, 15.0)\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points=points)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we try and triangulate this, we get an error:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"cons_tri = triangulate(points; boundary_nodes=boundary_nodes)\nERROR: AssertionError: The 3rd boundary curve is counter-clockwise when it should be clockwise. If this is a mistake, e.g. if this curve is inside of another one in which case it should be counter-clockwise, recall triangulate with check_arguments = false.\nStacktrace:\n [1] check_args(points::Vector{Tuple{Float64, Float64}}, boundary_nodes::Vector{Vector{Vector{Int64}}})\n   @ DelaunayTriangulation c:\\Users\\User\\.julia\\dev\\DelaunayTriangulation\\src\\utils.jl:515\n [2] triangulate(points::Vector{Tuple{Float64, Float64}}; edges::Nothing, boundary_nodes::Vector{Vector{Vector{Int64}}}, IntegerType::Type{Int64}, EdgeType::Type{Tuple{Int64, Int64}}, TriangleType::Type{Tuple{Int64, Int64, Int64}}, EdgesType::Type{Set{Tuple{Int64, Int64}}}, TrianglesType::Type{Set{Tuple{Int64, Int64, Int64}}}, randomise::Bool, delete_ghosts::Bool, delete_empty_features::Bool, try_last_inserted_point::Bool, skip_points::Set{Int64}, num_sample_rule::typeof(DelaunayTriangulation.default_num_samples), rng::TaskLocalRNG, point_order::Vector{Int64}, recompute_representative_point::Bool, delete_holes::Bool, check_arguments::Bool)\n   @ DelaunayTriangulation c:\\Users\\User\\.julia\\dev\\DelaunayTriangulation\\src\\triangulation\\triangulate.jl:69\n [3] top-level scope\n   @ Untitled-1:198","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"We have this as a default to try and make the process a bit simpler for the most common geometries. A workaround though, as suggested, is to no longer check the arguments.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"uncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes, check_arguments=false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/multiply_connected_interior_interior.png', alt='Constrained triangulation of a multiply-connected domain with holes inside holes'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#Disjoint-domains","page":"Constrained Triangulations","title":"Disjoint domains","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let's give a more complex example, where we consider multiple disjoint domains. This is the domain that is furthest from being supported, and I'm not sure whether proper support for it is planned. (Perhaps the best way to represent it is via something like a UnionTriangulation type, storing the triangulation information for each domain? Maybe.) The way to do it is to simply treat each domain as you would a standard domain, with the outer boundary being counter-clockwise, interiors clockwise (and other interiors inside interiors counter-clockwise, if you so please). The delete_holes! function will handle everything.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"First, a simple example.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"θ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2,Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes, check_arguments=false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/simple_disjoint.png', alt='Simple example with two separated circles'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here's a more cheeky example.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"C = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\n\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes = nodes, check_arguments = false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/julia.png', alt='Julia logo'><br>\n</figure>","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/lattice/#Lattice-Triangulations","page":"Lattice","title":"Lattice Triangulations","text":"","category":"section"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"We provide a method for triangulation a lattice on some grid a b times c d with n_x times n_y points. The docstring for this method is given below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"triangulate_rectangle","category":"page"},{"location":"triangulations/lattice/#DelaunayTriangulation.triangulate_rectangle","page":"Lattice","title":"DelaunayTriangulation.triangulate_rectangle","text":"triangulate_rectangle(a, b, c, d, nx, ny;\n    single_boundary=false,\n    add_ghost_triangles=true,\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType}) where {I,E,V,Es,Ts}\n\nComputes a triangulation of the rectangular grid [a, b] × [c, d] with points (xᵢ, yⱼ),  i = 1, …, nx, j = 1, …, ny, where xᵢ = a + (i-1)(b-a)/(nx-1) and yⱼ = b + (j-1)(d-c)/(ny-1). If  the boundary of the rectangle should be considered as one single boundary, use single_boundary = false, and if  you want the four sides of the boundary to be separated use single_boundary = true. \n\nReturns a Triangulation representing the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The single_boundary argument is useful if you want to, for example, have a boundary condition for the entire boundary or for each side of the boundary separately. ","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the four boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"a, b, c, d = 2.0, 10.0, -5.0, 7.5\nnx = 20\nny = 10\ntri = DT.triangulate_rectangle(a, b, c, d, nx, ny)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)\nxlims!(ax, a - 0.5, b + 0.5)\nylims!(ax, c - 0.5, d + 0.5)\nlines!(ax, tri.points[get_boundary_nodes(tri, 1)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 2)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 3)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 4)]; linewidth=4)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The blue edges show the interpretation of the ghost edges.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the single boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"tri = DT.triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=true)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)\nxlims!(ax, a - 0.5, b + 0.5)\nylims!(ax, c - 0.5, d + 0.5)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"As defined in the data structures section, we have the ability for computing convex hulls. These can be computed outside of the triangulation process, using our implementation of Graham's scan. ","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"Here is an example.","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"pts = [Tuple(25randn(2)) for _ in 1:500]\nch = convex_hull(pts)\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, pts)\nlines!(ax, pts[ch.indices])","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"<figure>\n    <img src='../figs/convex_hull_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/pole_of_inaccessibility/#Pole-of-Inaccessibility-and-Polygons","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We provide a function for computing the pole of inaccessibility of a given polygon, namely the point inside the polygon that is furthest from the boundary. Our method is primarily based on this blogpost, recursively subdividing the polygon using quadtree partitioning. The function for this is pole_of_inaccessibility:","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pole_of_inaccessibility","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.pole_of_inaccessibility","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.pole_of_inaccessibility","text":"pole_of_inaccessibility(pts, boundary_nodes; precision = one(number_type(pts)))\n\nGiven a collection of points pts and a set of boundary_nodes defining the polygon connections, finds the pole of inaccessibility. This works for multiply-connected polygons,  provided boundary_nodes matches the specification given in the documentation. You can  control the tolerance of the returned pole using precision.\n\nThis function is also commonly called polylabel.\n\nnote: Note\nThe pole of inaccessibility is a point within a polygon that is furthest from an  edge. It is useful for our purposes since it is a representative point that is  guaranteed to be inside the polygon, in contrast to for example a centroid which  is not always inside the polygon.For more information about this, see e.g. this blog post or the original repo. This implementation was partially based  on the python implementation and this other Julia implementation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We needed this method since the point we need to associate ghost vertices with must be inside the domain, and so other representative points like centroids or arithmetic averages would not be sufficient if the domain is non-convex.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below we also list some other relevant docstrings.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Cell \nCellQueue \npolygon_features \nsquared_distance_to_segment \ndistance_to_polygon \npolygon_bounds ","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.Cell","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.Cell","text":"Cell{T}\n\nA cell in a grid. The cell is a square with side length 2half_width. The cell is centered at (x, y). The cell is  assumed to live in a polygon.\n\nFields\n\nx::T\n\nThe x-coordinate of the center of the cell.\n\ny::T\n\nThe y-coordinate of the center of the cell.\n\nhalf_width::T\n\nThe half-width of the cell.\n\ndist::T\n\nThe distance from the center of the cell to the polygon.\n\nmax_dist::T\n\nThe maximum distance from the center of the cell to the polygon. This is dist + half_width * sqrt(2).\n\nConstructors\n\n`Cell(x::T, y::T, half_width::T, pts, boundary_nodes)`\n\nConstructs a cell with center (x, y) and half-width half_width. The cell is assumed to live in the polygon defined by pts and boundary_nodes.\n\n\n\n\n\n","category":"type"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.CellQueue","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.CellQueue","text":"CellQueue{T}\n\nA struct representing the priority queue of Cells, used for sorting the cells in a grid according to their maximum distance.\n\nFields\n\nqueue::PriorityQueue{Cell{T},T,typeof(Base.Order.Reverse)}\n\nThe priority queue of cells.\n\nConstructors\n\nCellQueue{T}()\n\nConstructs a new CellQueue with elements of type Cell{T}.\n\n\n\n\n\n","category":"type"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_features","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(pts, boundary_nodes)\n\nReturns features of the polygon represented by the points pts with boundary_nodes defining the polygon  connections. The features returned are (a, c), where a is the area of the polygon and  c = (cx, cy) is the centroid. \n\nnote: Note\nThe polygon is assumed to be simple, i.e. no self-intersections.\nThe function works with holes, provided boundary_nodes represents these as described in the documentation.\nThe polygon is assumed to have a consistent orientation for each boundary. If the orientation is positive, a > 0, and a < 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.squared_distance_to_segment","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.squared_distance_to_segment","text":"squared_distance_to_segment(x₁, y₁, x₂, y₂, x, y)\n\nGiven a line segment (x₁, y₁) → (x₂, y₂) and a query point (x, y), returns the  squared distance from (x, y) to the line segment.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.distance_to_polygon","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.distance_to_polygon","text":"distance_to_polygon(q, pts, boundary_nodes)\n\nGiven a polygon represented by the points pts with boundary_nodes defining the polygon  connections, and a query point q, returns the signed distance from q to the polygon. If  q is outside of the polygon, then the returned distance is negative, and if it is inside  then the distance is positive. Works with holes, provided boundary_nodes matches the  specification of a boundary given in the documentation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_bounds","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(pts, boundary_nodes, check_all_curves = Val(false))\n\nGiven a polygon represented by the points pts with boundary_nodes defining the polygon  connections, returns a bounding box of the polygon. The bounding box is returned  in the order (xmin, xmax, ymin, ymax). If your polygon is not a multiple polygon,  check_all_curves = Val(false) is sufficient, otherwise you might want to use Val(true).\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"distance_to_polygon is also useful for point location, as shown in the examples below.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"If you need to compute this for multiple boundaries, meaning multiple poles, use compute_representative_points!.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"compute_representative_points!","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.compute_representative_points!","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0)\n\nUpdates get_representative_point_list(tri) to match the current position of the boundaries. If there are no boundary nodes, use_convex_hull instead represents them using the indices of the convex hull.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#Example:-Pole-of-inaccessibility","page":"Pole of Inaccessibility and Polygons","title":"Example: Pole of inaccessibility","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below is a simple example of computing this pole of inaccessibility.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pts = [0.0 8.0\n      2.0 5.0\n      3.0 7.0\n      1.81907 8.13422\n      3.22963 8.865\n      4.24931 7.74335\n      4.50423 5.87393\n      3.67149 4.3784\n      2.73678 2.62795\n      5.50691 1.38734\n      8.43 2.74691\n      9.7046 5.53404\n      8.56595 7.79433\n      6.71353 9.03494\n      4.13034 9.66375\n      2.75378 10.3775\n      1.0883 10.4965\n      -1.138 9.83369\n      -2.25965 8.45712\n      -2.78649 5.94191\n      -1.39292 3.64763\n      0.323538 4.97322\n      -0.900078 6.6217\n      0.98633 9.68074\n      0.153591 9.54478\n      0.272554 8.66106\n      2.90673 8.18521\n      2.12497 9.42582\n      7.27436 2.7979\n      3.0 4.0\n      5.33697 1.88019]'\nboundary_nodes = [\n      [[1, 4, 3, 2], [2, 9, 10, 11, 8, 7, 12], [12, 6, 13, 5, 14, 15, 16, 17, 16], [16, 17, 18, 19, 20, 21, 22, 23, 1]],\n      [[26, 25, 24], [24, 28, 27, 26]],\n      [[29, 30, 31, 29]]\n]\nx, y = DT.pole_of_inaccessibility(pts, boundary_nodes)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\nbn1 = pts[:, unique(reduce(vcat, boundary_nodes[1]))] |> x -> hcat(x, x[:, begin])\nbn2 = pts[:, unique(reduce(vcat, boundary_nodes[2]))] |> x -> hcat(x, x[:, begin])\nbn3 = pts[:, unique(reduce(vcat, boundary_nodes[3]))] |> x -> hcat(x, x[:, begin])\nlines!(ax, bn1, color=:red, linewidth=4)\nlines!(ax, bn2, color=:red, linewidth=4)\nlines!(ax, bn3, color=:red, linewidth=4)\nscatter!(ax, [x], [y], color=:blue, markersize=23)","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/pole_of_inaccessibility.png', alt='Pole of inaccessibility'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/#Example:-Querying-if-points-are-in-a-polygon","page":"Pole of Inaccessibility and Polygons","title":"Example: Querying if points are in a polygon","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"If we need to, distance_to_polygon is a nice way for querying whether a point is inside or outside of a given polygon. Let's use the Julia example. Let us start by defining the polygon (this is a multiple polygon, it works for even simpler polygons obviously) and placing random points inside its bounding box:","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"D = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nxmin, xmax, ymin, ymax = DelaunayTriangulation.polygon_bounds(points, nodes, Val(true)) # Val(true) => check all parts of the polygon\nquery_points = [((xmax - xmin) * rand() + xmin, (ymax - ymin) * rand() + ymin) for _ in 1:1000]\n\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, query_points)\nfor nodes in nodes\n    lines!(ax, points[reduce(vcat, nodes)], color=:magenta, linewidth=3)\nend","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/scattered_julia.png', alt='Scattered Julia'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Now let's use distance_to_polygon to test if points are inside or outside of the logo. We colour points inside in blue, and points outside in red.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"is_inside = [DelaunayTriangulation.distance_to_polygon(q, points, nodes) > 0 for q in query_points]\nscatter!(ax, query_points[is_inside], color=:blue)\nscatter!(ax, query_points[.!is_inside], color=:red)","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/point_in_polygon.png', alt='Point-in-polygon'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Works perfectly! ","category":"page"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/edges/#Individual-Edges","page":"Edges","title":"Individual Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"Edges are assumed to take the form (i, j), with customisation available for how we represent (i, j). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"construct_edge \ninitial\nterminal","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.construct_edge","page":"Edges","title":"DelaunayTriangulation.construct_edge","text":"construct_edge(::Type{E}, i, j) where {E}\n\nConstructs an edge with indices (i, j) with the type E. The  following methods are currently defined:\n\nconstruct_edge(::Type{NTuple{2, I}}, i, j) where {I}\nconstruct_edge(::Type{A}, i, j) where {I,A<:AbstractVector}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.initial","page":"Edges","title":"DelaunayTriangulation.initial","text":"initial(e::E)\n\nGiven an edge e, returns the index for the initial point. The following  methods are currently defined:\n\ninitial(e::NTuple{2,I}) where {I}\ninitial(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.terminal","page":"Edges","title":"DelaunayTriangulation.terminal","text":"terminal(e::E)\n\nGiven an edge e, returns the index for the terminal point. The following  methods are currently defined:\n\nterminal(e::NTuple{2,I}) where {I}\nterminal(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"edge_indices \nreverse_edge","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.edge_indices","page":"Edges","title":"DelaunayTriangulation.edge_indices","text":"edge_indices(e)\n\nGiven an edge e, returns (initial(e), terminal(e)). \n\nSee also initial and terminal.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.reverse_edge","page":"Edges","title":"DelaunayTriangulation.reverse_edge","text":"reverse_edge(e)\n\nGiven an edge e, returns (terminal(e), initial(e)).\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Collection-of-Edges","page":"Edges","title":"Collection of Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"A collection of edges simply stores many edges, and this collection must be mutable so that edges can be deleted added and deleted. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods-2","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"initialise_edges \nedge_type \nnum_edges \ncontains_edge \nadd_to_edges! \ndelete_from_edges! \neach_edge ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.initialise_edges","page":"Edges","title":"DelaunayTriangulation.initialise_edges","text":"initialise_edges(::Type{S})\n\nFor a given type S for some collection (e.g. a Set), returns an empty instance of that collection. The only method defined is\n\ninitialise_edges(::Type{S}) where {E, S <: Set{E}}\ninitialise_edges(::Type{A}) where {E, A <: AbstractVector{E}}\n\nwhich returns a Set{E}() or a A(), respectively. You can extend this  function as you need, making sure you extend it for the type rather than  for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.edge_type","page":"Edges","title":"DelaunayTriangulation.edge_type","text":"edge_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of edges,  returns the type of triangle used inside S, e.g. NTuple{2, Int64} if S = Set{NTuple{2, Int64}}. The only methods defined are \n\nedge_type(::Type{S}) where {E,S<:Set{E}}\nedge_type(::Type{A}) where {E,A<:AbstractVector{E}}\n\nwhich return E. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.num_edges","page":"Edges","title":"DelaunayTriangulation.num_edges","text":"num_edges(E::S) where {S}\n\nGiven a collection of edges E, returns the number of edges in E. The only method currently defined is \n\nnum_edges(E::Set)\nnum_edges(E::AbstractVector)\n\nwhich returns length(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.contains_edge","page":"Edges","title":"DelaunayTriangulation.contains_edge","text":"contains_edge(e::E, Es::S) where {E, S}\n\nGiven a collection of edges Es of type S, containing edges of type E, checks if Es includes the edge e, returning true  if so. The methods currently defined are\n\ncontains_edge(e::E, Es::Set{E}) where {E} \ncontains_edge(e::E, Es::A) where {E,A<:AbstractVector{E}}\ncontains_edge(i, j, Es::E)\n\nThe first two methods simply return e ∈ E, while the latter constructs the edge e = (i, j) of type edge_type(E) and call the first two  methods. Only the method contains_edge(::E, ::Es) needs to be extended if you need,  the last method makes use of this definition.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.add_to_edges!","page":"Edges","title":"DelaunayTriangulation.add_to_edges!","text":"add_to_edges!(E::S, e) where {S}\n\nGiven a collection of edges E, pushes e into it. The only  methods currently defined are\n\nadd_to_edges!(E::Set, e)\nadd_to_edges!(E::Vector, e)\n\nwhich simply call push!(E, e). You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_from_edges!","page":"Edges","title":"DelaunayTriangulation.delete_from_edges!","text":"delete_from_edges!(E::S, e::F) where {S}\n\nGiven a collection of edges E of type S, containing  edges of type F, deletes the edge e from E.  The  methods currently defined are\n\ndelete_from_edges!(E::Set{F}, T::F) where {F}\ndelete_from_edges!(Es::A, e::E) where {E, A<:AbstractVector{E}}\n\nwhich just calls delete! on E in the first case, or filter!  in the second case. This is the form of the function that needs  to be extended. We also define \n\ndelete_from_edges!(Es::E, i::Integer, j::Integer) where {E}\n\nwhich constructs the edge (i, j) and then deletes it from Es, calling  the methods above. You do not need to extend this last method.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.each_edge","page":"Edges","title":"DelaunayTriangulation.each_edge","text":"each_edge(E::F) where {F}\n\nFor a given collection of edges E, returns an iterator that  goes over each edge in the collection. The methods currently  defined are \n\neach_edge(E::Set)\neach_edge(E::AbstractMatrix)\neach_edge(E::AbstractVector)\n\nwith the first and third methods simply returning E, and the second returning  eachcol(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods-2","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"add_edge!\ndelete_edge!\nrandom_edge \nis_empty ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.add_edge!","page":"Edges","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(E, e...)\n\nGiven a collection of edges E, adds all the triangles e... into it.  To extend this method to other collections, see add_to_edges!.\n\n\n\n\n\nadd_edge!(tri::Triangulation, segment; rng::AbstractRNG=Random.default_rng())\nadd_edge!(tri::Triangulation, i, j; rng::AbstractRNG=Random.default_rng())\n\nAdds the edge segment = (i, j) into the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_edge!","page":"Edges","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(E, e...)\n\nGiven a collection of edges E, deletes all the edges e... from it.  To extend this method to other collections, see delete_from_edges!.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.random_edge","page":"Edges","title":"DelaunayTriangulation.random_edge","text":"random_edge(E)\n\nReturns a random edge from edge set E.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.is_empty","page":"Edges","title":"DelaunayTriangulation.is_empty","text":"is_empty(E)\n\nTests if the edge set E is empty.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/unconstrained/#Unconstrained-Triangulations","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"","category":"section"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"It is simple to construct unconstrained triangulations. The method for this is through the triangulate function, shown below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangulate ","category":"page"},{"location":"triangulations/unconstrained/#DelaunayTriangulation.triangulate","page":"Unconstrained Triangulations","title":"DelaunayTriangulation.triangulate","text":"triangulate(points::P; edges=nothing, boundary_nodes=nothing,\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    randomise=true,\n    delete_ghosts=true,\n    delete_empty_features=true,\n    try_last_inserted_point=true,\n    skip_points=Set{IntegerType}(),\n    num_sample_rule::M=default_num_samples,\n    rng::AbstractRNG=Random.default_rng(),\n    point_order=get_point_order(points, randomise, skip_points, IntegerType, rng),\n    recompute_representative_point=true,\n    delete_holes=true,\n    check_arguments=true\n) where {P,I,E,V,Es,Ts,M}\n\nComputes the unconstrained Delaunay triangulation of a set of points. If edges is provided,  they will be inserted. If boundary_nodes is provided, a boundary will also be made from these  nodes, with all triangles inside the boundaries deleted.\n\nArguments\n\npoints::P: The set of points to compute the triangulation of. \n\nKeyword Arguments\n\nedges=nothing: Any constrained edges to insert. If nothing, an unconstrained triangulation is built. The constrained edges should not intersect each other, and they should not cross over boundary edges.\nboundary_nodes=nothing: Any boundaries to define. The specification of these boundary nodes is outlined in the boundary handling section of the documentation. All triangles away from a defined boundary are deleted if delete_holes.\nIntegerType::Type{I}=Int64: The integer type to use for indexing. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type to use for representing edges. \nTriangleType::Type{V}=NTuple{3,IntegerType}: The type to use for representing triangles. \nEdgesType::Type{Es}=Set{EdgeType}: The type to use for representing collections of edges. \nTrianglesType::Type{Ts}=Set{TriangleType}: The type to use for representing collections of triangles. \nrandomise=true: Whether to randomise the insertion order. \ndelete_ghosts=true: Whether to remove the ghost triangles at the end of the triangulation. \ndelete_empty_features=true: Whether to delete any empty neighbourhoods and adjacencies at the end of the triangulation. \ntry_last_inserted_point=true: When finding the next point, this decides if the previously inserted point should also be attempted. \nskip_points=Set{IntegerType}(): Points to skip over when triangulationg, i.e. points to not include in the triangulation. \nnum_sample_rule::M=default_num_samples: A function of the form n -> Number, with n the number of points currently in the triangulation, that returns the number of points to sample during the point location steps. \nrng::AbstractRNG=Random.default_rng(): The RNG to use.\npoint_order=get_point_order(points, randomise, skip_points, IntegerType, rng): The insertion order. \nrecompute_representative_point=true: At the end of the triangulation, will recompute the RepresentativePointList if true.\ndelete_holes=true: Whether to delete the exterior faces of all boundaries. There may be issues if you have boundary nodes but have this set to false - this kwarg is mostly for debugging.\ncheck_arguments=true: Whether to check the arguments for validity.\n\nOutputs\n\nReturns a Triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"In the code below, we give an example, and show how we can plot the result.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"using DelaunayTriangulation, CairoMakie \na = [1.5, 4.0]\nb = [0.0, 3.5]\nc = [2.0, 1.5]\nd = [3.0, 2.5]\ne = [2.5, 3.5]\nf = [0.5, 3.0]\ng = [2.5, -2.0]\nh = [0.5, 1.5]\ni = [0.0, 0.5]\nj = [1.5, 3.0]\npts = [a, b, c, d, e, f, g, h, i, j]\ntri = triangulate(pts)\nfig, ax, sc = triplot(tri)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"<figure>\n    <img src='../figs/small_example.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object tri is a Triangulation.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> tri\nDelaunay Triangulation.\n    Constrained: false\n    Has ghost triangles: false\n    Number of points: 10\n    Number of triangles: 12\n    Number of edges: 27","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"As we describe in more detail in the data structures section in the sidebar, tri has several fields:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> propertynames(tri)\n(:points, :triangles, :adjacent, :adjacent2vertex, :graph, :boundary_nodes, :boundary_edge_map, :boundary_map, :boundary_index_ranges, :constrained_edges, :all_constrained_edges, :convex_hull, :representative_point_list)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We explain each field below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.points: This stores pts.\ntri.triangles: This stores all the triangles. In this case,","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_triangles(tri)\nSet{Tuple{Int64, Int64, Int64}} with 12 elements:\n  (10, 5, 1)\n  (9, 7, 3)\n  (2, 6, 1)\n  (3, 10, 8)\n  (10, 4, 5)\n  (9, 3, 8)\n  (3, 4, 10)\n  (8, 6, 2)\n  (9, 8, 2)\n  (10, 1, 6)\n  (8, 10, 6)\n  (3, 7, 4)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"More generally, you can iterate over these triangles via each_triangle(tri). For example, the area of the triangulation could be computed as follows:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangle_area(p, q, r) = 0.5 * (p[1] * q[2] + q[1] * r[2] + r[1] * p[2] - p[1] * r[2] - r[1] * q[2] - q[1] * p[2])\nA = 0.0\nfor T in each_triangle(tri)\n    i, j, k = indices(T)\n    p, q, r = get_point(tri, i, j, k)\n    A += triangle_area(p, q, r)\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent: This stores the adjacency relationships of the triangulation, mapping edges (u, v) to a vertex w so that (u, v, w) is a positively oriented triangle in tri. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent(tri)\nAdjacent{Int64, Tuple{Int64, Int64}}, with map:\nDataStructures.DefaultDict{Tuple{Int64, Int64}, Int64, Int64} with 43 entries:\n  (9, 3)  => 8\n  (8, 9)  => 3\n  (4, 7)  => -1\n  (2, 1)  => -1\n  (10, 1) => 6\n  (2, 8)  => 6\n  (10, 8) => 3\n  (3, 9)  => 7\n  (4, 5)  => 10\n  (8, 3)  => 10\n  (9, 8)  => 2\n  ⋮       => ⋮","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (uv, w) in get_adjacent(tri)\n    u = initial(uv)\n    v = terminal(uv)\n    ...\nend","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent2vertex: This is a map that returns, given an index i, all other edges (j, k) such that (i, j, k) is a positively oriented triangle in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent2vertex(tri)\nAdjacent{Int64, Set{Tuple{Int64, Int64}}, Tuple{Int64, Int64}}, with map:\nDict{Int64, Set{Tuple{Int64, Int64}}} with 11 entries:\n  5  => Set([(10, 4), (1, 10)])\n  8  => Set([(9, 3), (2, 9), (6, 2), (3, 10), (10, 6)])\n  1  => Set([(6, 10), (10, 5), (2, 6)])\n  6  => Set([(1, 2), (2, 8), (10, 1), (8, 10)])\n  -1 => Set([(7, 9), (4, 7), (2, 1), (9, 2), (5, 4), (1, 5)])\n  9  => Set([(7, 3), (3, 8), (8, 2)])\n  3  => Set([(7, 4), (4, 10), (10, 8), (8, 9), (9, 7)])\n  7  => Set([(3, 9), (4, 3)])\n  4  => Set([(5, 10), (3, 7), (10, 3)])\n  2  => Set([(8, 6), (9, 8), (6, 1)])\n  10 => Set([(4, 5), (6, 8), (8, 3), (5, 1), (1, 6), (3, 4)])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g. ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (w, S) in get_adjacent2vertex(w)\n    for (u, v) in S \n        ...\n    end\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.graph: This is a graph that returns, given an index i, all other indices j such that (i, j) is an edge in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_graph(tri)\nGraph\n    Number of edges: 27\n    Number of vertices: 11\n\njulia> get_edges(tri)\nSet{Tuple{Int64, Int64}} with 27 elements:\n  (2, 9)\n  (4, 5)\n  (1, 2)\n  (6, 8)\n  (6, 10)\n  (3, 7)\n  (-1, 2)\n  (4, 7)\n  (3, 4)\n  (1, 5)\n  (-1, 9)\n  (4, 10)\n  (2, 8)\n  (-1, 5)\n  (1, 6)\n  (3, 9)\n  (7, 9)\n  ⋮\n\njulia> get_neighbours(tri)\nDict{Int64, Set{Int64}} with 11 entries:\n  5  => Set([4, -1, 10, 1])\n  8  => Set([6, 2, 10, 9, 3])\n  1  => Set([5, 6, 2, 10, -1])\n  6  => Set([2, 10, 8, 1])\n  -1 => Set([5, 4, 7, 2, 9, 1])\n  9  => Set([7, 2, -1, 8, 3])\n  3  => Set([4, 7, 10, 9, 8])\n  7  => Set([4, -1, 9, 3])\n  4  => Set([5, 7, -1, 10, 3])\n  2  => Set([6, -1, 9, 8, 1])\n  10 => Set([5, 4, 6, 8, 3, 1])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.boundary_nodes: This is a list of all fixed boundary nodes in the triangulation. In our case, we have none. See the Gmsh section for an example. The actual nodes on the boundary in this case can be obtained via tri.convex_hull.\ntri.boundary_edge_map: This is a Dict that maps all boundary edges to their position in tri.boundary_nodes. See the Gmsh section for an example.\ntri.boundary_map: This would be a list mapping boundary indices to all the fixed boundary nodes in tri.boundary_nodes corresponding to that index. This map is empty in this case as we have no fixed boundary nodes,, but see the Gmsh section for an example.\ntri.boundary_index_ranges: This is be a list mapping indices of boundary curves to all boundary indices belonging to that curve. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_boundary_index_ranges(tri)\nOrderedCollections.OrderedDict{Int64, UnitRange{Int64}} with 1 entry:\n  -1 => -1:-1","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This tells us that whenever we see a -1 as a vertex, we have a ghost vertex corresponding to the outer curve, so e.g. if get_adjacent(tri, u, v) == -1, then (u, v) is an edge on the boundary. A better example is in the Gmsh section.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.constrained_edges: This would be the collection of constrained edges if we had any. See the constrained trangulation section.\ntri.all_constrained_edges: This is a collection of all constrained edges currently in the triangulation, including the boundary edges. We have none here, but see the constrained triangulation section.\ntri.convex_hull: This is the ConvexHull of tri.points. In this case, we have","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_convex_hull(tri)\nConvex hull.\n    Indices:\n7-element Vector{Int64}:\n 7\n 4\n 5\n 1\n 2\n 9\n 7","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.representative_point_list: This is the Dict that maps curve indices to the coordinate used for representing corresponding boundary indices. Typically, these points are near the centroid of the curve; see the pole_of_inaccessibility function. In our case,","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> tri.representative_point_list\nDict{Int64, DelaunayTriangulation.RepresentativeCoordinates{Int64, Float64}} with 1 entry:\n  1 => RepresentativeCoordinates{Int64, Float64}(1.51155, 1.43234, 0)","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/interface/#Interface","page":"General and Defaults","title":"Interface","text":"","category":"section"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"The package makes its simple for customing the interface used for defining points, edges, and triangles, as described in the docstring for Interfaces (see the end of this section). Without any customisation, the default forms are:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Edges: NTuple{2, Int64}.\nCollections of edges: Set{NTuple{2, Int64}}.\nTriangles: NTuple{3, Int64}.\nCollections of triangles: Set{NTuple{3, Int64}}","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also give support for customing how points are represented, and by default we support collections of points given as matrices (with each point its own column), or vectors of vectors. The number type used for representing coordinates has to be Float64 to support ExactPredicates.jl, although if you like you could customise orient_predicate and incircle_predicate, even circumventing ExactPredicates.jl if you like. See the predicates section in the sidebar for a further discussion of changing these predicate definitions.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also provide a customisable interface for representing boundary nodes, although for unconstrained triangulations this is relevant. By default, we support boundary nodes represented according to the following, where we let BN refer to the collection of boundary nodes:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Vector{Int64}: In this case, there is only one fixed boundary and it is represented as a contiguous set of nodes. We must have BN[begin] == BN[end], and the nodes must be listed in counter-clockwise order.\nVector{Vector{Int64}}: In this case, there is only one fixed boundary, but it is made up of separate segments, with BN[n] the nodes for the nth segment. This makes it possible to more easily support, for example, a domain with different boundary conditions on separate parts of the boundary. We must have BN[n][end] == BN[n+1][begin] and BN[end][end] == BN[begin][begin], and each segment must be listed in counter-clockwise order.\nVector{Vector{Vector{Int64}}}: In this case, there are multiple fixed boundaries, each of which are assumed to be made up of separate segments. This makes it possible to support multiply-connected domains, e.g. an annulus with each circle split into its lower and upper halves. Here, BN[m][n] is the set of nodes for the nth segment of the mth boundary curve, and BN[begin] the outer-most boundary curve and BN[m], m > 1, nodes for curves contained within BN[begin]. As in the previous case, BN[m][n][end] == BN[m][n+1][end] and BN[m][end][end] == BN[m][begin][begin] for each m. Moreover, BN[begin] should be a counter-clockwise list of nodes while BN[m] is a clockwise list of nodes for m > 1.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"For more information about how we handle boundaries, and how they are handled in our data structures, see the boundary handling section in the sidebar. ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/constrained/#Constrained-Triangulations","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we describe the algorithm used for computing a constrained triangulation. We assume that we have some point set mathcal P, a set of edges mathcal E to be inserted, and some boundary edges mathcal B. The algorithm we implement is given here and is built upon the basic idea of Chew's algorithm for triangulating convex polygons, namely solving the point location problem by deleting an associated cavity in a clever way.","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"First, suppose we have computed the unconstrained Delaunay triangulation mathcal Dmathcal T(mathcal P) of our point set. The algorithm for then computing the constrained Delaunay triangulation mathcal Dmathcal T(mathcal P mathcal E mathcal B) then works incrementally, inserting edges one at a time. Let us, then, describe the procedure for inserting some edge e in mathcal C, where mathcal C = mathcal E cup mathcal B. We break the discussion into sections. ","category":"page"},{"location":"tri_algs/constrained/#Segment-Location","page":"Constrained Triangulations","title":"Segment Location","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Similar to how in adding points into a triangulation the first step is point location, here the first step is segment location. Here, our aim is to find all triangles that intersect the edge e. This is easy to do if we simply remember that the jump-and-march algorithm walks through all triangles that  intersect an initial scan line until stopping: this is exactly what we want. So, what we have done is modify our jump-and-march code such that the history of triangles walked through is recorded. This information is recorded into a PointLocationHistory struct. With this, we also note that since the jump-and-march algorithm will require rotating around an initial point (one of the indices of e), we should want to minimise the number of triangles we may need to rate around. Thus, we rotate e such that its initial vertex is the one with the least degree, hence we have less triangles to rotate around initially, thus reducing the time spent searching. From here on, we let e be this rotated form. This segment location is handled via the following function:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"locate_intersecting_triangles","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.locate_intersecting_triangles","page":"Constrained Triangulations","title":"DelaunayTriangulation.locate_intersecting_triangles","text":"locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true);\n    check_existence::C=Val(has_multiple_segments(tri)),\n    rng::AbstractRNG=Random.default_rng()) where {C}\n\nReturns a list of triangles intersecting the segment e in tri. If is_true(rotate),  then e will be sorted such that initial(e) has the least degree in tri.\n\nMore precisely, the returned values are:\n\nintersecting_triangles: The triangles intersecting e.\ncollinear_segments: Any segments collinear with e, giving in order of appearance.\nleft_vertices: All vertices of intersecting_triangles appearing to the left of e.\nright_vertices: All vertices of intersecting_triangles appearing to the right of e.\n\n\n\n\n\nlocate_intersecting_triangles(\n    e,\n    pts,\n    adj,\n    adj2v,\n    graph::Graph{I},\n    boundary_index_ranges,\n    representative_point_list,\n    boundary_map,\n    TriangleType::Type{V},\n    check_existence::C=Val(has_multiple_segments(boundary_map)),\n    rng::AbstractRNG=Random.default_rng()) where {I,V,Vs,C}\n\nGiven an edge e, returns a set of  triangles whose interior intersects the edge. \n\nArguments\n\ne: The edge to find the intersection of.\npts: The points of the triangulation.\nadj: The Adjacent data structure.\nadj2v: The Adjacent2Vertex data structure.\ngraph: The Graph data structure.\nboundary_index_ranges: The boundary index ranges from construct_boundary_index_ranges.\nrepresentative_point_list: The representative point list.\nboundary_map: The boundary map from construct_boundary_map.\nTriangleType: The type of triangle to use.\ncheck_existence: Whether to check for the existence of the edge in the triangulation when using get_adjacent.\nrng: The random number generator to use.\n\nOutputs\n\nintersecting_triangles: The set of triangles that intersects e.\ncollinear_segments: The set of segments that are collinear with e.\nleft_vertices: The vertices of the intersecting_triangles that are to the left of e.\nright_vertices: The vertices of the intersecting_triangles that are to the right of e.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"This function also returns information about any segments that are collinear with e and all vertices of the intersecting triangles to the left and to the right of e. For the collinear segments, these are processed via the functions fix_segments!, connect_segments!, and extend_segments!, breaking e into a smaller set of segments so that no segments are collinear anymore. We will assume that there are no collinear segments for simplicity. For the vertices to the left and to the right of e, these are needed as they define the outline of points to be deleted on each side of e, thus giving a polygonal cavity (possibly self-intersecting, but this detail doesn't actually matter) that we can triangulate individually. For example, consider the triangulation:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"a = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]\ntri = triangulate(pts; delete_ghosts=false, randomise=false)\nfig, ax, sc = triplot(tri)\nlines!(ax, [get_point(tri, 2, 7)...], color=:blue, linewidth=2)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example.png', alt='An edge through a triangulation'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we perform segment location on this example on the highlighted segment (2, 7), we find:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> e = (2, 7)\n(2, 7)\n\njulia> intersecting_triangles, collinear_segments, left_vertices, right_vertices = DelaunayTriangulation.locate_intersecting_triangles(tri, e);\n\njulia> intersecting_triangles\n8-element Vector{Tuple{Int64, Int64, Int64}}:\n (4, 3, 2)\n (3, 4, 10)\n (10, 4, 9)\n (9, 4, 5)\n (9, 5, 10)\n (10, 5, 8)\n (8, 5, 6)\n (8, 6, 7)\n\njulia> collinear_segments\nTuple{Int64, Int64}[]\n\njulia> left_vertices\n7-element Vector{Int64}:\n  7\n  8\n 10\n  9\n 10\n  3\n  2\n\njulia> right_vertices\n5-element Vector{Int64}:\n 2\n 4\n 5\n 6\n 7","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The intersecting triangles gives the triangles intersected by e in order of occurrence. For left_vertices, these are given in counter-clockwise order, with the left- and right-most elements being the indices of e. See that the vertex 10 is repeated in left_vertices. This is because the point 9 creates a sort of dangling edge in the polygonal cavity that we have to delete, and we need to somehow know to insert this point back into the triangulation. What we do, then, is to imagine an ant walking around the polygonal cavity. The ant will walk from 10 to 9, but then it has to come back down to 10, so we include it twice to represent these two visits. To see the cavity, let us delete these triangles:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"DelaunayTriangulation.delete_intersected_triangles!(tri, intersecting_triangles)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example_deleted_triangles.png', alt='An edge through a triangulation with excavated cavities'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The polygonal cavities on each side of the blue segment are what we need to re-triangulate separately. Let us now describe this procedure.","category":"page"},{"location":"tri_algs/constrained/#Triangulating-the-Polygonal-Cavities","page":"Constrained Triangulations","title":"Triangulating the Polygonal Cavities","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now we need to triangulate each cavity. We will describe this only for the cavity above (2, 7) in the figure below, but the procedure is exactly the same for the other cavity. Let mathcal V = (v_1 ldots v_m) be the sequence of vertices in counter-clockwise order around the cavity when we insert the segment e=(v_1v_m). In this case, mathcal V = (7 8 10 9 10 3 2). First, just like in Chew's algorithm, we need to build up a linked-list representing the cavity. This is done via the function ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"prepare_vertex_linked_list","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.prepare_vertex_linked_list","page":"Constrained Triangulations","title":"DelaunayTriangulation.prepare_vertex_linked_list","text":"prepare_vertex_linked_list(V::AbstractArray{I}) where {I}\n\nGiven a list of polygon vertices V, defines a linked list (prev, next) of polygon vertices so that (prev[i], i, next[i]) define a trio of polygon vertices  in counter-clockwise order, and defines, and returns shuffled_indices which is currently  unshuffled.\n\nThe first and last entries of the returned values (prev, next, shuffled_indices) will  not be populated, instead being 0.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"(Note: The algorithm given by Shewchuk and Brown linked above also allocates a distance array storing orient determinants for this preparation of the linked list, giving values proportional to the distance from e. This is not exactly robust for us, since we need to compute the sign of a difference of two determinants. In particular, let o_1 and o_2 be two robust estimates for an orient determinant. To determine if o_1 < o_2 is the same as defining a predicate for the sign of o_1 - o_2, but this is problematic as, while the computation of o_1 and o_2 may be reliable, their difference is not. Instead, we recompute this predicate in a robust manner each time, trading performance for robustness. This predicate is defined by point_closest_to_line.)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Once we have prepared the linked list, we need to delete vertices from it in a random order, corresponding to deleting vertices from the polygon in a random order. Like in Chew's algorithm, this is done in such a way that we can reverse the process and automatically get point location without ever needing the jump-and-march algorithm. This deletion is handled via delete_polygon_vertices_in_random_order! which simply loops over each vertex, calling select_random_vertex and update_vertex_linked_list! at each iteration:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"delete_polygon_vertices_in_random_order!\nselect_random_vertex \nupdate_vertex_linked_list! ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.delete_polygon_vertices_in_random_order!","page":"Constrained Triangulations","title":"DelaunayTriangulation.delete_polygon_vertices_in_random_order!","text":"delete_polygon_vertices_in_random_order!(tri::Triangulation, V, shuffled_indices, prev, next, u, v, rng::AbstractRNG=Random.default_rng())\n\nGiven a triangulation tri, a vertex list V, a set of shuffled_indices, a linked list (prev, next) for the  poylgon vertices, and a segment (u, v) that was inserted in order to define the polygon V, deletes vertices of V, via their representation in (prev, next, shuffled_indices), in a random order.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.select_random_vertex","page":"Constrained Triangulations","title":"DelaunayTriangulation.select_random_vertex","text":"select_random_vertex(tri::Triangulation, V, shuffled_indices, prev, next, range, u, v, rng::AbstractRNG=Random.default_rng())\n\nGiven a triangulation tri, a line through points with indices u and v, a shuffled set of  indices shuffled_indices, and a doubly-linked list (prev, next) of vertex indices,  selects a random vertex j ∈ range that is not closer to the line than both of its  neighbours. V is the original vertex list.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.update_vertex_linked_list!","page":"Constrained Triangulations","title":"DelaunayTriangulation.update_vertex_linked_list!","text":"update_vertex_linked_list!(shuffled_indices, prev, next, i, j)\n\nLet π = shuffled_indices. This function replaces next[prev[π[j]]] with next[π[j]], prev[next[π[j]]] with prev[π[j]], and interchanges π[i] and π[j]. This has the act  of deleting V[π[j]] from the polygon, where V is the list of polygon vertices of the  polygon being evacuated during segment insertion for a constrained triangulation.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"An important note is that, while this insertion algorithm works even with dangling edges, self-intersections, etc., it does not work when a point has an interior angle exceeding 360 degrees. We can detect this case by finding a point in the polygon that is closer to e than its two neighbours, which is the only time such an interior angle is possible (see the paper for a proof). Thus, select_random_vertex actually keeps sampling vertices to delete in a random order until this is not the case, making use of vertex_is_closer_than_neighbours:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"vertex_is_closer_than_neighbours ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.vertex_is_closer_than_neighbours","page":"Constrained Triangulations","title":"DelaunayTriangulation.vertex_is_closer_than_neighbours","text":"vertex_is_closer_than_neighbours(tri::Triangulation, u, v, jᵢ, jᵢ₋₁, jᵢ₊₁)\nvertex_is_closer_than_neighbours(tri::Triangulation, V, u, v, j, shuffled_indices, prev, next)\n\nGiven a triangulation tri and a line through points with indices u and v, tests if the point with index jᵢ is closer to the line than those with index  jᵢ₋₁ and jᵢ₊₁, assuming all these points are to the left of the line. The second  method extracts these latter two indices using the linked list (prev, next) of vertices  and a shuffled set of indices shuffled_indices together with the original vertex list V.\n\nnote: Note\nThis function is useful for constrained triangulations since the algorithm  used will not work if a point being inserted on the cavity has interior angle  of 360° or greater. This is possible only if a vertex is closer to the line than  its neighbours on the polygon.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Once this is all done, we ready to start triangulating the cavity. After adding an initial triangle from the three remaining vertices, we add points in one at a time, making use of a function add_point_cavity_cdt!. This function is defined by:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"function add_point_cavity_cdt!(tri::Triangulation, u, v, w)\n    x = get_adjacent(tri, w, v)\n    if !edge_exists(x)\n        insert_flag = true\n    else\n        p, q, r, s = get_point(tri, w, v, x, u) \n        incircle_test = point_position_relative_to_circle(p, q, r, s)\n        orient_test = triangle_orientation(tri, u, v, w)\n        insert_flag = !is_inside(incircle_test) && is_positively_oriented(orient_test)\n    end\n    if insert_flag\n        add_triangle!(tri, u, v, w; protect_boundary=true, update_ghost_edges=false)\n    else\n        delete_triangle!(tri, w, v, x; protect_boundary=true, update_ghost_edges=false)\n        add_point_cavity_cdt!(tri, u, v, x)\n        add_point_cavity_cdt!(tri, u, x, w)\n    end\n    return nothing\nend","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"In particular, x = get_adjacent(tri, w, v) is used to find the triangle on the other side of the edge vw from u, the point being inserted. The only way that wv should not be deleted is if the triangle wvx does not exist, as detected via !edge_exists(x), or if u is not inside the circumcircle of wvx and u is on the correct side of the edge vw. This is detected by the computation of insert_flag. If insert_flag, just add the triangle. Otherwise, we need to delete the triangle wvx and uvw as they are no longer constrained Delaunay. This is done by flipping vw onto ux. Once we have done this for each point, we have successfuly triangulated the cavity. ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"This is all handled via the triangulate_cavity_cdt function:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"triangulate_cavity_cdt","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.triangulate_cavity_cdt","page":"Constrained Triangulations","title":"DelaunayTriangulation.triangulate_cavity_cdt","text":"triangulate_cavity_cdt(points, V;\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{Vs}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    rng::AbstractRNG=Random.default_rng()) where {I,E,Vs,Es,Ts}\ntriangulate_cavity_cdt(tri, V; rng::AbstractRNG=Random.default_rng())\n\nTriangulates the cavity, represented as a counter-clockwise list of  vertices V with indices corresponding to those in points,  left behind when deleting triangles intersected in a triangulation by an edge.  If a triangulation is provided, the points are used from that.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"For our example, what we find is (the triangulation tri was updated to put the missing triangles back in from the last piece of code, note):","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> add_edge!(tri, 2, 7) # calls triangulate_cavity_cdt on each cavity","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example_completed.png', alt='A constrained edge through a triangulation'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we used add_edge!(tri, 2, 7), which does all this pre-processing for us. Similarly, for adding many edges, the method ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"triangulate_constrained!","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.triangulate_constrained!","page":"Constrained Triangulations","title":"DelaunayTriangulation.triangulate_constrained!","text":"triangulate_constrained(tri::Triangulation; rng=Random.default_rng())\n\nInserts all constrained edges and boundary edges into tri.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"is useful (triangulate calls this internally).","category":"page"},{"location":"tri_algs/constrained/#Excavating-Exterior-Faces","page":"Constrained Triangulations","title":"Excavating Exterior Faces","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we define boundary curves, we typically want to delete any points and triangles exterior to them. The logic of the method we use for this is simple. Basically, we \"plant\" a seed in an exterior face, and use it to infect other points in this exterior face, continuing this spread until all exterior faces are found. The function that performs this is delete_holes!, with relevant docstrings below.","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"delete_holes!\nhas_interiors_within_interiors ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.delete_holes!","page":"Constrained Triangulations","title":"DelaunayTriangulation.delete_holes!","text":"delete_holes!(tri::Triangulation)\n\nDeletes all the exterior faces to the boundary nodes specified in the  triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.has_interiors_within_interiors","page":"Constrained Triangulations","title":"DelaunayTriangulation.has_interiors_within_interiors","text":"has_interiors_within_interiors(tri::Triangulation)\n\nReturns true if the triangulation has multiple curves and the first curve has a positive area and all other curves have negative areas, meaning there are some interior curves that are inside other interior curves. Returns false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The points that we find are then processed one at a time, checking all adjoining triangles to see if their centroid is in the interior or exterior. Special case is taken at the boundary nodes.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"We define some specific operations for acting on Triangulations directly. These are listed below.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"add_point!(::Triangulation, ::Any)\nadd_edge!(::Triangulation, ::Any)\ndelete_point!(::Triangulation, ::Any)\nadd_boundary_information!(::Triangulation)\ndelete_ghost_triangles!(::Triangulation)\nadd_ghost_triangles!(::Triangulation)\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}\nsplit_edge!\nlegalise_split_edge!\ncomplete_split_edge_and_legalise!\nsplit_triangle!\nlegalise_split_triangle!\ncomplete_split_triangle_and_legalise!\nflip_edge!\nlegalise_edge!\nclear_empty_features!\nlock_convex_hull! \nunlock_convex_hull!","category":"page"},{"location":"operations/#DelaunayTriangulation.add_point!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.add_point!","text":"addpoint!(tri::Triangulation, newpoint[, newpointy];     pointindices=getvertices(tri),     m=defaultnumsamples(length(pointindices)),     trypoints=(),     rng::AbstractRNG=Random.defaultrng(),     initialsearchpoint=integertype(tri)(selectinitialpoint(getpoints(tri),newpoint;pointindices,m,trypoints,rng)),     updaterepresentativepoint=false,     storeeventhistory = Val(false),     eventhistory = nothing,     exteriorcurveindex=1,     V=jumpandmarch(         tri,         newpoint isa Integer ? getpoint(tri, newpoint) : newpoint;         m=nothing,         pointindices=nothing,         trypoints=nothing,         k=initialsearchpoint,         rng,         checkexistence=Val(hasmultiplesegments(tri)),         exteriorcurveindex     )     )\n\nAdds the point new_point to the triangulation tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nnew_point[, new_point_y]: The point to add. This new_point can be an integer, in which case get_point(tri, new_point) is added. If new_point is just a set of coordinates, we add that into tri via push_point! and then add that index into tri. Lastly, if we provide (new_point, new_point_y), then the point is treated as this Tuple and inserted.\n\nKeyword Arguments\n\npoint_indices=each_solid_vertex(tri): The indices of the non-ghost points in the triangulation.\nm=default_num_samples(length(point_indices)): The number of points to sample from point_indices to use as the initial search point.\ntry_points=(): A list of points to try as the initial search point in addition to those sampled.\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\ninitial_search_point=integer_type(tri)(select_initial_point(get_points(tri),new_point;point_indices,m,try_points,rng)): The initial search point to use. If this is not provided, then we use select_initial_point to select one.\nupdate_representative_point=false: Whether to update the representative point list after adding the new point.\nstore_event_history = Val(false): Whether to store the event history. See InsertionEventHistory.\nevent_history = nothing: The event history to store the events in. See InsertionEventHistory. Only needed if is_true(store_event_history). This object is not returned, instead we just mutate it inplace.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nV=jump_and_march(tri, new_point isa Integer ? get_point(tri, new_point) : new_point; m=nothing, point_indices=nothing, try_points=nothing, k=initial_search_point, rng, check_existence=Val(has_multiple_segments(tri)), exterior_curve_index=exterior_curve_index): The triangle that q is in.\n\nOutputs\n\nThe triangulation is updated in-place with the new point, but we also return the triangle V containing new_point.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_edge!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(tri::Triangulation, segment; rng::AbstractRNG=Random.default_rng())\nadd_edge!(tri::Triangulation, i, j; rng::AbstractRNG=Random.default_rng())\n\nAdds the edge segment = (i, j) into the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_point!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.delete_point!","text":"delete_point!(tri::Triangulation, point; rng::AbstractRNG=Random.default_rng())\n\nDeletes point from the triangulation tri using Chew's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_boundary_information!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_boundary_information!","text":"add_boundary_information!(tri::Triangulation)\n\nGiven a triangulation tri, adds boundary information into tri. In particular,  the Adjacent, Adjacent2Vertex, and Graph fields are updated so that e.g. boundary edges  map to their corresponding boundary indices, boundary indices map to their boundary edges  via the Adjacent2Vertex map, and boundary indices are included in the Graph.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.delete_ghost_triangles!","text":"delete_ghost_triangles!(tri::Triangulation; boundary_indices = all_boundary_indices(tri), delete_neighbours=false)\n\nDeletes the ghost triangles from the triangulation tri.\n\nnote: Note\nA ghost triangle is a triangle of the form (i, j, k) where only one of the indices, say i,  satisfies is_boundary_index(i).\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_ghost_triangles!","text":"add_ghost_triangles!(tri::Triangulation; boundary_indices=all_boundary_indices(tri), add_neighbours=false\n\nGiven a Triangulation tri, adds the ghost triangles into tri. In particular,  the triangles, Adjacent, and Adjacent2Vertex fields are updated so that  ghost triangles are stored in them.\n\nnote: Note\nA ghost triangle is a triangle of the form (i, j, k) where only one of the indices, say i,  satisfies is_boundary_index(i).\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(tri::Triangulation, u, v, w; protect_boundary=false, update_ghost_edges=false)\nadd_triangle!(tri::Triangulation, T; protect_boundary=false, update_ghost_edges=false)\n\nGiven a triangle T = (u, v, w), adds the triangle into the triangulation tri. To update the ghost triangles directly,  set update_ghost_edges=true. The other parts of the boundary information will be handled, though, unless you set protect_boundary=true.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(tri::Triangulation, u, v, w; protect_boundary=false, update_ghost_edges=false)\ndelete_triangle!(tri::Triangulation, T; protect_boundary=false, update_ghost_edges=false)\n\nGiven a triangle T = (u, v, w), adds the triangle into the triangulation tri. To update the ghost triangles directly,  set update_ghost_edges=true. The other parts of the boundary information will be handled, though, unless you set protect_boundary=true.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.split_edge!","page":"Operations","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri and an edge (i, j), splits the edge at  the point r so that the edges (i, r) and (r, j) now appear in tri  (with the triangles updated accordingly). It is assumed that r is (at least  very close to) collinear with (i, j).\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_split_edge!","page":"Operations","title":"DelaunayTriangulation.legalise_split_edge!","text":"legalise_split_edge!(tri::Triangulation, i, j, k, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j) that has already  been split by split_edge! at the point r,  legalises the new edges using legalise_edge, letting  k be the vertex that was originally adjacent to (i, j).\n\nIf store_event_history is Val(true), then the event history is stored in  event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.complete_split_edge_and_legalise!","page":"Operations","title":"DelaunayTriangulation.complete_split_edge_and_legalise!","text":"complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j), and a point r, splits both (i, j) and (j, i) at r using split_edge! and then legalises the new edges using legalise_split_edge!.\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.split_triangle!","page":"Operations","title":"DelaunayTriangulation.split_triangle!","text":"split_triangle!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k), and a  point r inside the triangle, splits the triangle at r  so that (i, j, k) is replaced by the three triangles  (i, j, r), (j, k, r), and (k, i, r), respectively.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_split_triangle!","page":"Operations","title":"DelaunayTriangulation.legalise_split_triangle!","text":"legalise_split_triangle!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k) that has  already been split by split_triangle! at the point r, legalises the new edges using legalise_edge.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.complete_split_triangle_and_legalise!","page":"Operations","title":"DelaunayTriangulation.complete_split_triangle_and_legalise!","text":"complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k), and a point r, splits (i, j, k) at r using split_triangle! and then legalises the new edges using legalise_split_triangle!.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.flip_edge!","page":"Operations","title":"DelaunayTriangulation.flip_edge!","text":"flip_edge!(tri::Triangulation, i, j, store_event_history=Val(false), event_history=nothing)\nflip_edge!(tri::Triangulation, i, j, k, ℓ)\n\nGiven a triangulation tri and an edge (i, j) appearing in the triangulation,  flips the edge (i, j) so that it becomes (ℓ, k), where ℓ = get_adjacent(tri, i, j) and k = get_adjacent(tri, j, i). \n\nwarning: Warning\nIf (i, j, ℓ, k) is not a convex quadrilateral, than this edge flip makes the triangulation non-planar.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_edge!","page":"Operations","title":"DelaunayTriangulation.legalise_edge!","text":"legalise_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j), and a  point r that was added into a triangle that (i, j)  belongs to, legalises the edge (i, j) and other neighbouring  edges recursively.\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\nwarning: Warning\nEdge flipping can lead to final eventhistorys that have triangles both in addedtriangles and deleted_triangles\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.clear_empty_features!","page":"Operations","title":"DelaunayTriangulation.clear_empty_features!","text":"clear_empty_features!(tri::Triangulation)\n\nClears all empty features from the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.lock_convex_hull!","page":"Operations","title":"DelaunayTriangulation.lock_convex_hull!","text":"lock_convex_hull!(tri::Triangulation)\n\nLocks the convex hull of the triangulation tri by adding it to the constrained edges  of tri in place of boundary_nodes. If has_boundary_nodes(tri) is already true,  an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.unlock_convex_hull!","page":"Operations","title":"DelaunayTriangulation.unlock_convex_hull!","text":"unlock_convex_hull!(tri::Triangulation)\n\nUnlocks the convex hull of the triangulation tri by removing it from the constrained edges of tri. If has_boundary_nodes(tri) is already false or if get_boundary_nodes(tri) ≠ get_convex_hull_indices(tri),  an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/convex/#Convex-Polygons","page":"Convex Polygons","title":"Convex Polygons","text":"","category":"section"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"We have an algorithm available for computing the Delaunay triangulation of a convex polygon:","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"triangulate_convex ","category":"page"},{"location":"triangulations/convex/#DelaunayTriangulation.triangulate_convex","page":"Convex Polygons","title":"DelaunayTriangulation.triangulate_convex","text":"triangulate_convex(points, S;\n    IntegerType::Type{I}=Int64,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    rng::AbstractRNG=Random.default_rng(),\n    add_ghost_triangles=false,\n    add_convex_hull=false,\n    compute_centers=false,\n    delete_empty_features=false) where {I,E,V,Es,Ts}\n\nGiven some points and a counter-clockwise list of indices S for points in points  that define a convex polygon, triangulates it with Chew's algorithm.\n\nArguments\n\npoints::P: The set of points.\nS: A counter-clockwise list of vertices defining a convex polygon from the corresponding points in points.\n\nKeyword Arguments\n\nIntegerType::Type{I}=Int64: The integer type to use for indexing. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type to use for representing edges. \nTriangleType::Type{V}=NTuple{3,IntegerType}: The type to use for representing triangles. \nEdgesType::Type{Es}=Set{EdgeType}: The type to use for representing collections of edges. \nTrianglesType::Type{Ts}=Set{TriangleType}: The type to use for representing collections of triangles. \nrepresentative_point_list = get_empty_representative_points(IntegerType, number_type(points)): The representative point list to use.    \nrng::AbstractRNG=Random.default_rng(): The RNG to use.\nadd_ghost_triangles=true: Whether to add the ghost triangles at the end of the triangulation. \nadd_convex_hull=true: Whether to populate the convex hull field of tri with S at the end of the triangulation.\ncompute_centers=true: Whether to recompute the RepresentativePointList at the end of the triangulation.\ndelete_empty_features=true: Whether to delete any empty neighbourhoods and adjacencies at the end of the triangulation. \n\nOutputs\n\nReturns a Triangulation of the convex polygon.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"The function takes as input some set of points mathcal P and a corresponding sequence of indices v_1 ldots v_n, in counter-clockwise order, defining some convex polygon and returns the polygon's Delaunay triangulation. Note that the keyword arguments here differ from triangulate. Here is an example of triangulate_convex in action.","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"using DelaunayTriangulation \nusing CairoMakie\np1 = [10.0, 12.0]\np2 = [7.0, 11.0]\np3 = [8.0, 6.0]\np4 = [10.0, 3.0]\np5 = [14.0, 5.0]\np6 = [15.0, 10.0]\np7 = [13.0, 12.0]\npts = [p1, p2, p3, p4, p5, p6, p7]\nS = collect(1:7)\ntri = triangulate_convex(pts, S)\nfig, ax, sc = triplot(tri; plot_convex_hull=false)","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"<figure>\n    <img src='../figs/convex_triangulation_example.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"We represent convex hulls using a ConvexHull type, which is simply a type containing points and indices:","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"ConvexHull","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.ConvexHull","page":"Convex Hull","title":"DelaunayTriangulation.ConvexHull","text":"ConvexHull{P,I}\n\nStruct storing the results for a convex hull.\n\nFields\n\npoints::P\n\nThe complete set of points.\n\nindices::I\n\nIndices of points in points corresponding to the convex hull, in counter-clockwise order,  and indices[begin] == indices[end].\n\n\n\n\n\n","category":"type"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"For a triangulation, convex hulls are obtained from the unconstrained form, but if they need to be reconstructed then we can do so with a Graham scan.","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"convex_hull(::Any)","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.convex_hull-Tuple{Any}","page":"Convex Hull","title":"DelaunayTriangulation.convex_hull","text":"convex_hull(points; IntegerType::Type{I}=Int64) where {I}\n\nComputes the convex hull of points using Graham's scan. Returns a ConvexHull object.\n\nNote that if there are a trio of points on the convex hull that are collinear, they will  all be included, instead of only taking the endpoints of the collinear points.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/graph/#Graph","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"To make it possible to iterate over all points that share an edge with a given vertex, we have a Graph struct that we define as follows:","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"struct Graph{I}\n    graph::UndirectedGraph{I}\n    function Graph{I}() where {I}\n        G = UndirectedGraph{I}()\n        return new{I}(G)\n    end\n    Graph() = Graph{Int64}()\n    Graph(G::UndirectedGraph{I}) where {I} = new{I}(G)\nend","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Note that this graph is undirected. ","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Graph \nget_graph(::Graph)\nget_edges(::Graph)\nget_vertices(::Graph)\neach_vertex(::Graph)\nget_neighbours(::Graph)\nget_neighbours(::Graph, ::Any)\nnum_neighbours(::Graph, ::Any)\nnum_edges(::Graph)\nnum_vertices(::Graph)\nadd_vertex!(::Graph{I}, ::Vararg{I,N}) where {I,N}\nadd_neighbour!(::Graph{I}, ::I, ::I) where {I}\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\nadd_triangle!(::Graph, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\ndelete_triangle!(::Graph, ::Any)\ndelete_neighbour!(::Graph, ::Any, ::Any)\ndelete_vertex!(::Graph, ::Any)\ndelete_boundary_vertices_from_graph!(::Graph{I}) where {I}\nclear_empty_points!(::Graph)","category":"page"},{"location":"data_structures/graph/#DelaunayTriangulation.Graph","page":"Graph","title":"DelaunayTriangulation.Graph","text":"Graph{I}\n\nStruct for storing neighbourhood relationships that map vertices  to all other vertices that share an edge with that vertex.  The type I is the integer type.\n\nSee the docs for a description of how boundary edges  are handled.\n\nFields\n\ngraph::UndirectedGraph{I}\n\nThe UndirectedGraph that maps a vertex u to a list of edges, V, such that (u, v) is an edge of the triangulation for each  v in V. \n\nExtended help\n\nYou should not work with the graph field directly. We provide  the following functions for working with Graph, where G denotes  a Graph{I} type. (Type information in the function signatures  is omitted.)\n\nAccessors\n\nget_graph(G)\nget_vertices(G)\neach_vertex(G)\nget_edges(G)\nget_neighbours(G)\nget_neighbours(G, u)\n\nMutators\n\nadd_vertex!(G, u...)\nadd_neighbour!(G, u, v...)\nadd_triangle!(G, i, j, k) or add_triangle!(G, T)\nadd_triangle!(G, T...)\ndelete_triangle!(G, i, j, k) or delete_triangle!(G, T)\ndelete_triangle!(G, T...)\ndelete_neighbour!(G, u, v...)\ndelete_vertex!(G, u...)\ndelete_boundary_vertices_from_graph!(G)\nclear_empty_points!(G)\n\nMiscellaneous\n\nnum_edges(G)\nnum_neighbours(G, u)\nnum_vertices(G)\n\n\n\n\n\n","category":"type"},{"location":"data_structures/graph/#DelaunayTriangulation.get_graph-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_graph","text":"get_graph(G::Graph)\n\nReturns the field graph of G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_edges","text":"get_edges(G::Graph)\n\nReturns all the edges of the graph G. Edges  are unordered.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(G::Graph)\n\nGiven a graph, returns the current set of vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.each_vertex-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(G::Graph)\n\nGiven a graph, returns the current set of vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph)\n\nReturns the set of neighbourhoods of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph, u)\n\nReturns the neighbourhood of the points u of  the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(G::Graph, u)\n\nReturns the number of neighbours of the point u  of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.num_edges","text":"num_edges(G::Graph)\n\nReturns the number of edges G. The edges  (i, j) and (j, i) will only be counted once.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(G::Graph)\n\nReturns the number of vertices in the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_vertex!-Union{Tuple{N}, Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Vararg{I, N}}} where {I, N}","page":"Graph","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., adds these  vertices into G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, I, I}} where I","page":"Graph","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(G::Graph, u, v...)\n\nGiven a graph G, adds v... into the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, adds the triangle (i, j, k) into G. In particular, the  indices (i, j, k) are added into G, and the indices are all in each other's  neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, T...)\n\nAdds the triangles T... into the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, deletes the triangle (i, j, k) deletes G. In particular, the  indices (i, j, k) will no longer be neighbours of each other.\n\nnote: Note\nBe careful with using this function - you could have a triangle (j, i, ℓ), say,  which will also be affected since the graph is undirected. Note also  that the vertices (i, j, k) will not be removed - only the neighbourhoods  are affected.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, T...)\n\nDeletes the triangles T... from the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_neighbour!-Tuple{DelaunayTriangulation.Graph, Any, Any}","page":"Graph","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(G::Graph, u, v...)\n\nGiven a graph G and a vertex u, deletes the vertices v... from the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_vertex!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., deletes the vertices from G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Union{Tuple{DelaunayTriangulation.Graph{I}}, Tuple{I}} where I","page":"Graph","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(G::Graph{I}) where {I}\n\nGiven a graph G, deletes all the boundary indices from G, i.e.  all u such that u ≤ -1.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.clear_empty_points!-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.clear_empty_points!","text":"clear_empty_points!(G::Graph)\n\nGiven a graph, deletes any points that have empty neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"predicates/#Predicates","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The predicates that we use in this package are all built from ExactPredicates.jl, avoiding degeneracies from predicates owing to floating point arithmetic. The results from predicates are based on certificates, coming from a Certificate type defined with EnumX.jl. The definition of this is below.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Certificate","category":"page"},{"location":"predicates/#DelaunayTriangulation.Certificate","page":"Predicates","title":"DelaunayTriangulation.Certificate","text":"Certificate\n\nAn Enum type that represents results from a geometric predicate. Below we provide a list of available certificates,  along with the function that can be used for testing if a given Certificate matches that certificate.\n\nInside: is_inside\nDegenerate: is_degenerate\nOutside: is_outside\nOn: is_on\nLeft: is_left\nRight: is_right\nPositivelyOriented: is_positively_oriented\nNegativelyOriented: is_negatively_oriented\nCollinear: is_collinear\nNone: is_none or has_no_intersections\nSingle: is_single or has_one_intersection\nMultiple: is_multiple or has_multiple_intersections\nTouching: is_touching\nLegal: is_legal\nIllegal: is_illegal\nCloser: is_closer\nFurther: is_further\nEquidistant: is_equidistant\nObtuse: is_obtuse\nAcute: is_acute\nRight: is_right\nSuccessfulInsertion: is_successful_insertion\nFailedInsertion: is_failed_insertion\nPrecisionFailure: is_precision_failure\nEncroachmentFailure: is_encroachment_failure\n\n\n\n\n\n","category":"module"},{"location":"predicates/#General","page":"Predicates","title":"General","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some general predicates. The core ones that all other predicates are based on are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"orient_predicate\nincircle_predicate \nparallelorder_predicate","category":"page"},{"location":"predicates/#DelaunayTriangulation.orient_predicate","page":"Predicates","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate(p, q, r)\n\nReturns ExactPredicates.orient(p, q, r), in particular we return:\n\n1: (p, q, r) is positively oriented.\n0: (p, q, r) is collinear / degenerate. \n-1: (p, q, r) is negatively oriented.\n\nnote: Note\n\n\nThe orient predicate is defined by the determinant \n\ntextorient(p q r) = textsgn det beginvmatrix p_x  p_y  1  q_x  q_y  1  r_x  r_y  1 endvmatrix = textsgn det beginvmatrix p_x-r_x  p_y-r_y  q_x-r_x  q_y-r_y endvmatrix\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.incircle_predicate","page":"Predicates","title":"DelaunayTriangulation.incircle_predicate","text":"incircle_predicate(a, b, c, p)\n\nReturns ExactPredicates.incircle(a, b, c, p), in particular we return: \n\n1: If p is inside the circle defined by (a, b, c).\n0: If p is on the circle defined by (a, b, c).\n-1: If p is outside the circle defined by (a, b, c).\n\nnote: Note\nThe incircle predicate is defined by the determinant textincircle(a b c d) = textsgn det beginvmatrix a_x  a_y  a_x^2 + a_y^2  1  b_x  b_y  b_x62 + b_y^2  1  c_x  c_y  c_x^2 + c_y^2  1  d_x  d_y  d_x^2 + d_y^2  1 endvmatrix = textsgn det beginvmatrix a_x - d_x  a_y - d_y  (a_x - d_x)^2 + (a_y - d_y)^2  b_x - d_x  b_y - d_y  (b_x - d_x)^2 + (b_y - d_y)^2  c_x - d_x  c_y - d_y  (c_x - d_x)^2 + (c_y - d_y)^2 endvmatrix\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.parallelorder_predicate","page":"Predicates","title":"DelaunayTriangulation.parallelorder_predicate","text":"parallelorder_predicate(a, b, p, q)\n\nReturns ExactPredicates.parallelorder(a, b, p, q), in particular we return:\n\n1: q is closer to the line (a, b) than p.\n0: p and q are equidistant from the line (a, b).\n-1: p is closer to the line (a, b) than q.\n\nnote: Note\nThe parallelorder predicate is the same as orient_predicate(b-a, q-p, 0).\n\n\n\n\n\n","category":"function"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"In code, these predicates could be defined by (the actual definition with ExactPredicates.jl is much more involved):","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"_det(a, b, c, d) = a * d - b * c\n_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion \nfunction orient_predicate(a, b, c)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    o = _det(ax - cx, ay - cy, bx - cx, by - cy)\n    return Int(sign(o)) # need Int for xor\nend\nfunction incircle_predicate(a, b, c, d)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    dx, dy = getxy(d)\n    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,\n        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,\n        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)\n    return Int(sign(o)) # need Int for xor\nend\nfunction parallelorder_predicate(a, b, p, q)\n    return orient_predicate(b .- a, q .- p, (0.0, 0.0))\nend","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"You could use this as a reference if you want to disconnect from using ExactPredicates.jl (or e.g. use the predicates also defined in GeometricalPredicates.jl). This could be useful if you are not too worried about robustness (although you should typically care about this, so be careful - proceed at your own peril) and just want fast code.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The other predicates are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"sameside_predicate\nopposite_signs\nmeet_predicate \ntriangle_orientation(::Any, ::Any, ::Any)\npoint_position_relative_to_circle(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Any, ::Any, ::Any)\npoint_closest_to_line(::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Any, ::Any, ::Any)\nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_oriented_outer_halfplane(::Any, ::Any, ::Any)\nis_legal(::Any, ::Any, ::Any, ::Any)\ntriangle_line_segment_intersection(::Any, ::Any, ::Any, ::Any, ::Any)","category":"page"},{"location":"predicates/#DelaunayTriangulation.sameside_predicate","page":"Predicates","title":"DelaunayTriangulation.sameside_predicate","text":"sameside_predicate(a, b, p)\n\nReturns ExactPredicates.sameside(p, a, b) (but we redefine it here).\n\nnote: Note\nThe difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.opposite_signs","page":"Predicates","title":"DelaunayTriangulation.opposite_signs","text":"opposite_signs(x,y)\n\nFrom ExactPredicates.jl, returns true if x and y have opposite signs, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.meet_predicate","page":"Predicates","title":"DelaunayTriangulation.meet_predicate","text":"meet_predicate(p, q, a, b)\n\nReturns ExactPredicates.meet(p, q, a, b)  (but we redefine it here).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(p, q, r)\n\nGiven a triangle with coordinates (p, q, r), computes its orientation, returning:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circle","text":"point_position_relative_to_circle(a, b, c, p)\n\nGiven a circle through the coordinates (a, b, c), assumed to be positively oriented,  computes the position of p relative to the circle. In particular, returns:\n\nCertificate.Inside: p is inside the circle.\nCertificate.On: p is on the circle. \nCertificate.Outside: p is outside the triangle.\n\nSee also incircle_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(a, b, p)\n\nGiven a point p and the oriented line (a, b), computes the position  of p relative to the line, returning:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line. \n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_closest_to_line-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(a, b, p, q)\n\nGiven a line ℓ through a and b, tests if p is closer to ℓ than q is, returning:\n\nCertificate.Closer: p is closer to ℓ.\nCertificate:Further: q is closer to ℓ.\nCertificate.Equidistant: p and q are the same distance from ℓ.\n\nIt is assumed that p and q are to the left of ℓ.\n\nnote: Note\nNote that this function is same as computing numerical values for o₁ = orient(a, p, b) and o₂ = orient(a, q, b) (the determinants, not the signs) and seeing if o₁ < o₂. If indeed o₁ < o₂, then p is closer to ℓ then q. We cannot obtain values for  o₁ and o₂ such that the difference o₁ - o₂ is reliable, but notice that, letting  ∧ denote the exterior product, o₁ = (a - b) ∧ (p - b) and o₂ = (a - b) ∧ (q - b). Thus, o₁ - o₂ = (a - b) ∧ (p - q) = orient(b - a, p - q, 0). These differences b - a and p - q cannot be computed reliably, but we can use the relationship between orient  and parallelorder_predicate to write  orient(b - a, p - q, 0) = parallelorder(a, b, q, p). Thus, o₁ < o₂ if parallelorder(a, b, q, p) == -1.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(a, b, p)\n\nGiven a point p and the line segment (a, b), assuming p  to be collinear with a and b, computes the position of p relative to the line segment. In particular, returns:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\nSee also sameside_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(p, q, a, b)\n\nGiven the coordinates (p, q) and (a, b) defining two line segments,  tests the number of intersections between the two segments. In particular,  we return:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point. \nCertificate.Touching: One of the endpoints is on [a, b], but there are no other intersections.\n\nSee also meet_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(a, b, c, p)\n\nGiven a positively oriented triangle with coordinates (a, b, c), computes the  position of p relative to the triangle. In particular, returns: \n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","text":"point_position_relative_to_oriented_outer_halfplane(a, b, p)\n\nGiven an edge with coordinates (a, b) and a point p,  tests the position of p relative to the oriented outer halfplane defined  by (a, b). The returned values are:\n\nCert.Outside: p is outside of the oriented outer halfplane, meaning to the right of the line (a, b) or collinear with a and b but not on the line segment (a, b).\nCert.On: p is on the open line segment (a, b).\nCert.Inside: p is inside of the oriented outer halfplane, meaning to the left of the line (a, b).\n\nnote: Note\nThe oriented outer halfplane is the union of the open halfplane defined by the region to the left of the oriented line (a, b), and the open line segment (a, b). \n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_legal-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_legal","text":"is_legal(p, q, r, s)\n\nGiven an edge pq, incident to two triangles pqr and qps, tests  if the edge pq is legal, i.e. if s is not inside the triangle through  p, q, and r.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(p, q, r, a, b)\n\nGiven a triangle (p, q, r) and a line segment (a, b), tests if (a, b) intersects the triangle's interior. Returns:\n\nCert.Inside: (a, b) is entirely inside (p, q, r).\nCert.Single: (a, b) has one endpoint inside (p, q, r), and the other is outside.\nCert.Outside: (a, b) is entirely outside (p, q, r).\nCert.Touching: (a, b) is on (p, q, r)'s boundary, but not in its interior.\nCert.Multiple: (a, b) passes entirely through (p, q, r). This includes the case where a point is on the boundary of (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Boundaries-and-Ghosts","page":"Predicates","title":"Boundaries and Ghosts","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some predicates for working with boundaries and ghost triangles. ","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"is_boundary_index \nis_boundary_edge(::Any, ::Adjacent)\nis_boundary_triangle(::Any, ::Any, ::Any, ::Any)\nis_ghost_edge\nis_ghost_triangle \nis_interior_curve \nis_outer_boundary_index(::Any, ::Any)\nis_outer_ghost_triangle(::Any, ::Any, ::Any, ::Any)\nis_outer_ghost_edge(::Any, ::Any, ::Any)\nis_outer_boundary_node(::Any, ::Graph{I}, ::Any) where {I}\nis_boundary_node(::Any, ::Graph{I}, ::Any) where {I}\nedge_exists(::I) where {I}\nedge_exists(::Any, ::Adjacent{I, E}) where {I, E}\nhas_ghost_triangles(::Adjacent{I, E}, ::Any) where {I, E}","category":"page"},{"location":"predicates/#DelaunayTriangulation.is_boundary_index","page":"Predicates","title":"DelaunayTriangulation.is_boundary_index","text":"is_boundary_index(i::I) where {I}\n\nGiven an index i, returns i ≤ I(BoundaryIndex). \n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(ij, adj::Adjacent)\nis_boundary_edge(i, j, adj::Adjacent{I,E}) where {I,E}\n\nTests if the edge (i, j) is a boundary edge, meaning get_adjacent(adj, i, j)  is a boundary index.\n\nnote: Note\nThe orientation of (i, j) is important: even if (i, j) is an edge  on the boundary, if there is a triangle (i, j, k) in the triangulation then (i, j) is not a boundary edge but (j, i) would be.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(i, j, k, adj)\nis_boundary_triangle(T, adj)\n\nGiven a triangle T = (i, j, k) and an adjacent map adj, returns true if T is a boundary triangle. \n\nnote: Note\nA boundary triangle is still part of the triangulation, but it has at least one edge that forms part of the boundary (so that at least one of the edges (u, v) satisfies  is_boundary_edge(v, u, adj)). This is similar to, but not the same as, a ghost triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_ghost_edge","page":"Predicates","title":"DelaunayTriangulation.is_ghost_edge","text":"is_ghost_edge(i, j)\n\nGiven an edge (i, j), returns true if (i, j) is a ghost edge. \n\nnote: Note\nA ghost edge is an edge in which either is_boundary_index(i) or is_boundary_index(j) is true.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_ghost_triangle","page":"Predicates","title":"DelaunayTriangulation.is_ghost_triangle","text":"is_ghost_triangle(i, j, k)\nis_ghost_triangle(T)\n\nGiven a triangle T = (i, j, k), returns true if T is a  ghost triangle and false otherwise. \n\nnote: Note\nA ghost triangle is one in which any of the vertices (i, j, k) are a boundary index, as tested via is_boundary_index.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_interior_curve","page":"Predicates","title":"DelaunayTriangulation.is_interior_curve","text":"is_interior_curve(i)\nis_interior_curve(i, boundary_map)\n\nGiven an index i, tests if the curve is an interior curve, i.e. if i > 1. Alternatively,  if a boundary_map is provided from construct_boundary_map, i should be a boundary map so that is_interior_curve(j) is tested, where j = get_curve_index(boundary_map, i).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(i, boundary_map)\n\nGiven an index i and a boundary_map from construct_boundary_map, tests if the index is a boundary index referring to the outermost boundary.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_triangle","text":"is_outer_ghost_triangle(i, j, k, boundary_map)\n\nGiven a ghost triangle (i, j, k) and a boundary map boundary_map from construct_boundary_map, tests if the ghost triangle is on the outermost boundary (true) or on an interior boundary (false).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_edge-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_edge","text":"is_outer_ghost_edge(i, j, boundary_map)\n\nGiven a ghost edge (i, j) and a boundary map boundary_map from construct_boundary_map, tests if the ghost edge is attached to the outermost boundary (true) or on an interior boundary (false).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}\n\nTests if i is a node appearing on the outermost boundary. \n\nArguments\n\ni: The node to test. \ngraph::Graph: The graph. \nboundary_index_ranges: A dictionary from construct_boundary_index_ranges.\n\nOutputs\n\nis_outer_boundary_node: A Boolean indicating whether i is a node on the outermost boundary.\n\nSee also is_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I","page":"Predicates","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}\n\nTests if i is a node appearing on the boundary. \n\nArguments\n\ni: The node to test. \ngraph::Graph: The graph. \nboundary_index_ranges: A dictionary from construct_boundary_index_ranges.\n\nOutputs\n\nis_boundary_node: A Boolean indicating whether i is a node on the boundary.\nboundary_index: The boundary index of the boundary to which i belongs. If there is no such boundary, boundary_index = I(DefaultAdjacentValue).\n\nSee also is_outer_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Tuple{I} where I","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(i::I) where {I}\n\nReturns i ≠ I(DefaultAdjacentValue).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(i, j, adj::Adjacent{I,E}) where {I,E}\nedge_exists(ij, adj::Adjacent{I,E}) where {I,E}\n\nTests if the edge ij = (i, j) exists in the triangulation corresponding to the Adjacent map adj.\n\nSee also edge_exists(::I) where I.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(adj::Adjacent{I,E}, adj2v) where {I,E}\n\nTests if the triangle represented by the Adjacent map adj and the Adjacent2Vertex map adj2v contains ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Index-and-Ghost-Handling","page":"Predicates","title":"Index and Ghost Handling","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list methods for working with predicates that are used when we provide indices for points rather than points directly.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"triangle_orientation(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_circumcircle(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_closest_to_line(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Any, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::AbstractDict)\ntriangle_line_segment_intersection(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)","category":"page"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(i, j, k, pts, representative_point_list, boundary_map)\ntriangle_orientation(T, pts, representative_point_list, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices corresponding to points in pts, computes the orientation of the triangle, using boundary_map from construct_boundary_map to map boundary indices to their corresponding points in representative_point_list. We return:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nnote: Note\nA test is also made for the case that is_outer_ghost_triangle(T): If  T  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly. In case the boundary  index corresponds to an interior curve, this flip is not necessary.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{7, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(i, j, k, ℓ, pts, representative_point_list, boundary_map)\npoint_position_relative_to_circumcircle(T, ℓ, pts, representative_point_list, boundary_map)\n\nTests if the ℓth point of pts is inside the circumcircle of the triangle T = (i, j, k), using the boundary_map to map  boundary indices to their corresponding points in representative_point_list, returning:\n\nCertificate.Outside: pₗ is outside of the circumcircle.\nCertificate.On: pₗ is on the circumcircle.\nCertificate.Inside: pₗ is inside the circumcircle.\n\nnote: Note\nA test is also made for the case that is_ghost_triangle(T): When T is a ghost triangle, one of its indices is a boundary index, say i. Since this vertex  is treated as being out at infinity, the circumcircle degenerates into the line through the other two vertices and out to infinity in that direction.  Thus, we test that the ℓth point is inside this circumcircle by seeing if it is in the oriented outer halfplane defined by the other two vertices,  accomplished via point_position_relative_to_oriented_outer_halfplane.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(i, j, u, pts, representative_point_list, boundary_map)\n\nComputes the position of the uth point of pts relative to the line through the ith and jth points,  respectively, of pts. Boundary indices are mapped to their corresponding points in representative_point_list via  the boundary_map argument from construct_boundary_map. The returned values are:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line,\n\nwhere p is the uth point of pts.\n\nnote: Note\nIf is_outer_ghost_edge(i, j, boundary_map), the orientation of the line is flipped as the point corresponding to the boundary index will be a centroid which swaps the orientation.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_closest_to_line-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(i, j, u, v, pts)\n\nLet a, b, p, q be the points corresponding to the indices i, j, u, v, respectively, in pts, and let ℓ be the oriented line through a and b. This function tests if p is closer to ℓ than q is, returning:\n\nCertificate.Closer: p is closer to ℓ.\nCertificate:Further: q is closer to ℓ.\nCertificate.Equidistant: p and q are the same distance from ℓ.\n\nnote: Note\nIt is assumed that p and q are to the left of ℓ.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(i, j, u, pts)\n\nGiven indices i, j, and u corresponding to points a, b, and p in pts, respectively, computes the position  of p relative to the oriented line segment (a, b), assuming that the three points are collinear. The returned values are:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(u, v, i, j, pts)\n\nLet u, v, i, and j be indices corresponding to points p, q, a, and b, respectively, in pts. This  function tests the number of intersections between the two line segments (p, q) and (a, b), returning:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point.\nCertificate.On: One of the endpoints is on [a, b], but there are no other intersections.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, Any, AbstractDict}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(i, j, k, u, pts, representative_point_list, boundary_map)\npoint_position_relative_to_triangle(T, u, pts, representative_point_list, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices referring to points in pts, computes the position of u, corresponding to a point p, relative to T, with  any boundary indices mapped to their corresponding representative points in representative_point_list  via the boundary_map argument from construct_boundary_map. The returned values are:\n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(i, j, k, u, v, pts)\n\nGiven a triangle (i, j, k) and a line segment (u, v), with indices corresponding to points in pts, tests if (u, v)  intersects the triangle's interior. Letting (p, q, r) be the coordinates  corresponding to the triangle's vertices, and (a, b) those for the edge's  vertices, returns:\n\nCert.Inside: (a, b) is entirely inside (p, q, r).\nCert.Single: (a, b) has one endpoint inside (p, q, r), and the other is outside.\nCert.Outside: (a, b) is entirely outside (p, q, r).\nCert.Touching: (a, b) is on (p, q, r)'s boundary, but not in its interior.\nCert.Multiple: (a, b) passes entirely through (p, q, r). This includes the case where a point is on the boundary of (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/statistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"We provide an interface for computing statistics of a triangulation using statistics. (If it is important to you, note that the methods used for computing these statistics do not use adaptive floating point arithmetic unfortunately.)","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"IndividualTriangleStatistics \nTriangulationStatistics","category":"page"},{"location":"data_structures/statistics/#DelaunayTriangulation.IndividualTriangleStatistics","page":"Statistics","title":"DelaunayTriangulation.IndividualTriangleStatistics","text":"IndividualTriangleStatistics{T}\n\nStatistics for a single triangle.\n\nFields\n\narea: The area of the triangle.\nlengths: The sorted lengths of the edges of the triangle.\ncircumcenter: The circumcenter of the triangle.\ncircumradius: The circumradius of the triangle.\nangles: The sorted angles of the triangle.\nradius_edge_ratio: The radius-edge ratio of the triangle.\nedge_midpoints: The midpoints of the edges of the triangle.\naspect_ratio: The aspect ratio of the triangle.\ninradius: The inradius of the triangle.\nperimeter: The perimeter of the triangle.\ncentroid: The centroid of the triangle.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/statistics/#DelaunayTriangulation.TriangulationStatistics","page":"Statistics","title":"DelaunayTriangulation.TriangulationStatistics","text":"TriangulationStatistics{T,V,I}\n\nStatistics for a triangulation.\n\nThe constructor for this is statistics(tri::Triangulation).\n\nFields\n\nnum_vertices: The number of vertices in the triangulation.\nnum_solid_vertices: The number of solid vertices in the triangulation.\nnum_ghost_vertices: The number of ghost vertices in the triangulation.\nnum_edges: The number of edges in the triangulation.\nnum_solid_edges: The number of solid edges in the triangulation.\nnum_ghost_edges: The number of ghost edges in the triangulation.\nnum_triangles: The number of triangles in the triangulation.\nnum_solid_triangles: The number of solid triangles in the triangulation.\nnum_ghost_triangles: The number of ghost triangles in the triangulation.\nnum_constrained_boundary_edges: The number of constrained boundary edges in the triangulation.\nnum_constrained_interior_edges: The number of constrained interior edges in the triangulation.\nnum_constrained_edges: The number of constrained edges in the triangulation.\nnum_convex_hull_points: The number of points on the convex hull of the triangulation.\nsmallest_angle: The smallest angle in the triangulation.\nlargest_angle: The largest angle in the triangulation.\nsmallest_area: The smallest area in the triangulation.\nlargest_area: The largest area in the triangulation.\nsmallest_radius_edge_ratio: The smallest radius-edge ratio in the triangulation.\nlargest_radius_edge_ratio: The largest radius-edge ratio in the triangulation.\ntotal_area: The total area of the triangulation.\nindividual_statistics: A dictionary mapping triangles to their individual statistics.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"For example:","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"p1 = (0.0, 0.0)\np2 = (1.0, 0.0)\np3 = (1.0, 1.0)\np4 = (0.0, 1.0)\npts = [p1, p2, p3, p4]\ntri = triangulate(pts)","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"julia> stats = statistics(tri)\nDelaunay Triangulation Statistics.\n   Triangulation area: 1.0\n   Number of vertices: 5\n   Number of solid vertices: 4\n   Number of ghost vertices: 1\n   Number of edges: 9\n   Number of solid edges: 5\n   Number of ghost edges: 4\n   Number of triangles: 2\n   Number of solid triangles: 2\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 4\n   Smallest angle: 45.0°\n   Largest angle: 90.0°\n   Smallest area: 0.5\n   Largest area: 0.5\n   Smallest radius-edge ratio: 0.7071067811865476\n   Largest radius-edge ratio: 0.7071067811865476","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"stats = refine!(tri, max_area = 1e-2) # refine! computes and returns stats = statistics(tri) post-refinement","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"julia> stats\nDelaunay Triangulation Statistics.\n   Triangulation area: 0.9999999999999999\n   Number of vertices: 98\n   Number of solid vertices: 97\n   Number of ghost vertices: 1\n   Number of edges: 288\n   Number of solid edges: 256\n   Number of ghost edges: 32\n   Number of triangles: 160\n   Number of solid triangles: 160\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 32\n   Smallest angle: 30.231153476251915°\n   Largest angle: 113.40705209438516°\n   Smallest area: 0.0038884849847605116\n   Largest area: 0.0098765990101033\n   Smallest radius-edge ratio: 0.5799214659156856\n   Largest radius-edge ratio: 0.9930687672569417","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"All the relevant docstrings for working with these structs are below.","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"num_vertices(::TriangulationStatistics)\nnum_solid_vertices(::TriangulationStatistics)\nnum_ghost_vertices(::TriangulationStatistics)\nnum_edges(::TriangulationStatistics)\nnum_solid_edges(::TriangulationStatistics)\nnum_ghost_edges(::TriangulationStatistics)\nnum_triangles(::TriangulationStatistics)\nnum_solid_triangles(::TriangulationStatistics)\nnum_ghost_triangles(::TriangulationStatistics)\nnum_constrained_boundary_edges(::TriangulationStatistics)\nnum_constrained_interior_edges(::TriangulationStatistics)\nnum_constrained_edges(::TriangulationStatistics)\nnum_convex_hull_points(::TriangulationStatistics)\nget_smallest_angle(::TriangulationStatistics)\nget_largest_angle(::TriangulationStatistics)\nget_smallest_area(::TriangulationStatistics)\nget_largest_area(::TriangulationStatistics)\nget_smallest_radius_edge_ratio(::TriangulationStatistics)\nget_largest_radius_edge_ratio(::TriangulationStatistics)\nget_total_area(::TriangulationStatistics)\nget_individual_statistics(::TriangulationStatistics)\nget_minimum_angle(::TriangulationStatistics, ::Any)\nget_maximum_angle(::TriangulationStatistics, ::Any)\nget_median_angle(::TriangulationStatistics, ::Any)\nget_area(::TriangulationStatistics, ::Any)\nget_lengths(::TriangulationStatistics, ::Any)\nget_circumcenter(::TriangulationStatistics, ::Any)\nget_circumradius(::TriangulationStatistics, ::Any)\nget_angles(::TriangulationStatistics, ::Any)\nget_radius_edge_ratio(::TriangulationStatistics, ::Any)\nget_edge_midpoints(::TriangulationStatistics, ::Any)\nget_aspect_ratio(::TriangulationStatistics, ::Any)\nget_inradius(::TriangulationStatistics, ::Any)\nget_perimeter(::TriangulationStatistics, ::Any)\nget_centroid(::TriangulationStatistics, ::Any)","category":"page"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(stats::TriangulationStatistics)\n\nReturns the num_vertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_edges","text":"num_edges(stats::TriangulationStatistics)\n\nReturns the num_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(stats::TriangulationStatistics)\n\nReturns the numsolidedges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(stats::TriangulationStatistics)\n\nReturns the numghostedges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(stats::TriangulationStatistics)\n\nReturns the num_triangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(stats::TriangulationStatistics)\n\nReturns the numsolidtriangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(stats::TriangulationStatistics)\n\nReturns the numghosttriangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_boundary_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_boundary_edges","text":"num_constrained_boundary_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainedboundary_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_interior_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_interior_edges","text":"num_constrained_interior_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainedinterior_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_edges","text":"num_constrained_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainededges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_convex_hull_points-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_convex_hull_points","text":"num_convex_hull_points(stats::TriangulationStatistics)\n\nReturns the numconvexhull_points field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_angle-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_angle","text":"get_smallest_angle(stats::TriangulationStatistics)\n\nReturns the smallest_angle field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_angle-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_angle","text":"get_largest_angle(stats::TriangulationStatistics)\n\nReturns the largest_angle field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_area","text":"get_smallest_area(stats::TriangulationStatistics)\n\nReturns the smallest_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_area","text":"get_largest_area(stats::TriangulationStatistics)\n\nReturns the largest_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_radius_edge_ratio","text":"get_smallest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the smallestradiusedge_ratio field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_radius_edge_ratio","text":"get_largest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the largestradiusedge_ratio field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_total_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_total_area","text":"get_total_area(stats::TriangulationStatistics)\n\nReturns the total_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_individual_statistics-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_individual_statistics","text":"get_individual_statistics(stats::TriangulationStatistics)\n\nReturns the individual_statistics field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_minimum_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_minimum_angle","text":"get_minimum_angle(stats::TriangulationStatistics, T)\n\nReturns the smallest angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_maximum_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_maximum_angle","text":"get_maximum_angle(stats::TriangulationStatistics, T)\n\nReturns the largest angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_median_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_median_angle","text":"get_median_angle(stats::TriangulationStatistics, T)\n\nReturns the median angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_area-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_area","text":"get_area(stats::TriangulationStatistics, T)\n\nReturns the area field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_lengths-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_lengths","text":"get_lengths(stats::TriangulationStatistics, T)\n\nReturns the lengths field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_circumcenter-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_circumcenter","text":"get_circumcenter(stats::TriangulationStatistics, T)\n\nReturns the circumcenter field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_circumradius-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_circumradius","text":"get_circumradius(stats::TriangulationStatistics, T)\n\nReturns the circumradius field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_angles-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_angles","text":"get_angles(stats::TriangulationStatistics, T)\n\nReturns the angles field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_radius_edge_ratio","text":"get_radius_edge_ratio(stats::TriangulationStatistics, T)\n\nReturns the radiusedgeratio field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_edge_midpoints-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_edge_midpoints","text":"get_edge_midpoints(stats::TriangulationStatistics, T)\n\nReturns the edge_midpoints field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_aspect_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_aspect_ratio","text":"get_aspect_ratio(stats::TriangulationStatistics, T)\n\nReturns the aspect_ratio field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_inradius-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_inradius","text":"get_inradius(stats::TriangulationStatistics, T)\n\nReturns the inradius field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_perimeter-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_perimeter","text":"get_perimeter(stats::TriangulationStatistics, T)\n\nReturns the perimeter field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_centroid-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(stats::TriangulationStatistics, T)\n\nReturns the centroid field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/triangles/#Individual-Triangles","page":"Triangles","title":"Individual Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"Triangles are assumed to be of the form (i, j, k), with positive orientation, but we allow for customisation in the way these indices are represented. The following methods are used for working with triangles. First, we list the methods that must be defined, and then methods that extend these former methods. ","category":"page"},{"location":"interface/triangles/#Necessary-Methods","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"construct_triangle \ngeti \ngetj \ngetk \ninteger_type ","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.construct_triangle","page":"Triangles","title":"DelaunayTriangulation.construct_triangle","text":"construct_triangle(::Type{T}, i, j, k) where {T}\n\nConstructs a triangle with indices (i, j, k) with the  type T. The following methods are currently defined:\n\nconstruct_triangle(::Type{NTuple{3, I}}, i, j, k) where {I} \nconstruct_triangle(::Type{A}, i, j, k) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.geti","page":"Triangles","title":"DelaunayTriangulation.geti","text":"geti(T::F) where {F}\n\nFrom a triangle T, extract the ith index, i.e. the first.  The following methods are currently defined: \n\ngeti(T::NTuple{3, I})\ngeti(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getj","page":"Triangles","title":"DelaunayTriangulation.getj","text":"getj(T::F) where {F}\n\nFrom a triangle T, extract the jth index, i.e. the second.  The following methods are currently defined: \n\ngetj(T::NTuple{3, I})\ngetj(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getk","page":"Triangles","title":"DelaunayTriangulation.getk","text":"getk(T::F) where {F}\n\nFrom a triangle T, extract the kth index, i.e. the third.  The following methods are currently defined: \n\ngetk(T::NTuple{3, I})\ngetk(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.integer_type","page":"Triangles","title":"DelaunayTriangulation.integer_type","text":"integer_type(::Type{T}) where {T}\n\nReturns the integer type used for representnig a triangle with indices  (i, j, k) with the type T. The following methods are currently defined:\n\ninteger_type(::Type{NTuple{N, I}}) where {N, I} \ninteger_type(::Type{A}) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Generic-Methods","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"indices \ntriangle_edges\nrotate_triangle \nconstruct_positively_oriented_triangle(::Type{V}, ::Any, ::Any, ::Any, ::Any) where {V}\ncompare_triangles \nsort_triangle","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.indices","page":"Triangles","title":"DelaunayTriangulation.indices","text":"indices(T)\n\nReturns a tuple (i, j, k) containing the indices of the triangle T. The  indices are obtained using geti, getj, and getk.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_edges","page":"Triangles","title":"DelaunayTriangulation.triangle_edges","text":"triangle_edges(T)\ntriangle_edges(i, j, k)\n\nReturns an iterator over each edge of the triangle T. In particular,  returns ((geti(T), getj(T)), (getj(T), getk(T)), (getk(T), geti(T))). The latter method uses the indices directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.rotate_triangle","page":"Triangles","title":"DelaunayTriangulation.rotate_triangle","text":"rotate_triangle(T::V, i) where {V}\n\nGiven a triangle T, rotates the indices an amount i. In particular, if T = (i, j, k):\n\ni = 0: Returns (i, j, k).\ni = 1: Returns (j, k, i).\ni = 2: Returns (k, i, j).\nOtherwise, return rotate_triangle(T, i % 3).\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Any, Any, Any, Any}} where V","page":"Triangles","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(::Type{V}, i, j, k, points) where {V}\n\nGiven a triangle type V, indices (i, j, k) corresponding to points in points,  returns either construct_triangle(V, i, j, k) or construct_triangle(V, j, i, k), whichever is not negatively oriented.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangles","page":"Triangles","title":"DelaunayTriangulation.compare_triangles","text":"compare_triangles(T, V)\n\nTests if the triangle T is equal to the triangle V, with equality  defined on the indices. In particular, compare_triangles((i, j, k), (i, j, k)), compare_triangles((i, j, k), (j, k, i)), and compare_triangles((i, j, k), (k, i, j)) are all true.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangle","page":"Triangles","title":"DelaunayTriangulation.sort_triangle","text":"sort_triangle(T::V) where {V}\n\nGiven a triangle T = (i, j, k), sorts it so that the first index is the smallest, maintaining  the orientation of T.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Collection-of-Triangles","page":"Triangles","title":"Collection of Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"A collection of triangles simply stores many triangles, and the collection itself must be mutable so that triangles can be added and deleted. The following methods are used for working with collections of triangles. First, we list the methods that must be defined, and then methods that extend these former methods.","category":"page"},{"location":"interface/triangles/#Necessary-Methods-2","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"initialise_triangles \ntriangle_type \nnum_triangles \nadd_to_triangles! \ndelete_from_triangles!\neach_triangle \nremove_duplicate_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.initialise_triangles","page":"Triangles","title":"DelaunayTriangulation.initialise_triangles","text":"initialise_triangles(::Type{S})\n\nFor a given type S for some collection (e.g. a AbstractSet), returns an empty instance of that collection. The only method defined is\n\ninitialise_triangles(::Type{S}) where {T, S <: AbstractSet{T}}\ninitialise_triangles(::Type{V}) where {T,V<:AbstractVector{T}}\n\nwhich returns a Set{T}(). You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_type","page":"Triangles","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of triangles,  returns the type of triangle used inside S, e.g. NTuple{3, Int64} if S = AbstractSet{NTuple{3, Int64}}. The only methods defined are\n\ntriangle_type(::Type{S}) where {T, S <: AbstractSet{T}}\ntriangle_type(::Type{A}) where {T, A <: AbstractVector{E}}\n\nwhich returns T. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.num_triangles","page":"Triangles","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(T::S) where {S}\n\nGiven a collection of triangles T, returns the number of triangles  in T. The only method currently defined is \n\nnum_triangles(T::AbstractSet)\nnum_triangles(T::AbstractVector)\n\nwhich returns length(T). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_to_triangles!","page":"Triangles","title":"DelaunayTriangulation.add_to_triangles!","text":"add_to_triangles!(T::S, V) where {S}\n\nGiven a collection of triangles T, pushes V into it. The only  methods currently defined are\n\nadd_to_triangles!(T::AbstractSet{F}, V::F) where {F}\nadd_to_triangles!(T::AbstractSet{F}, V) where {F}\n\nwhich simply call push!(T, V). The latter method reconstructs V  using [indices] and construct_triangle. You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.delete_from_triangles!","page":"Triangles","title":"DelaunayTriangulation.delete_from_triangles!","text":"delete_from_triangles!(V::S, T::F) where {S}\n\nGiven a collection of triangles V of type S, containing  triangles of type F, deletes the triangle T from V.  The only method currently defined is \n\ndelete_from_triangles!(V::AbstractSet{F}, T::F) where {F}.\n\nwhich just calls delete! on V. The function already assumes that T  is already in V, and that T doesn't need to be rotated at all.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.each_triangle","page":"Triangles","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(V::F) where {F}\n\nFor a given collection of triangles V, returns an iterator that  goes over each triangle in the collection. The methods currently  defined are \n\neach_triangle(V::AbstractSet)\neach_triangle(V::AbstractMatrix)\neach_triangle(V::AbstractVector)\n\nwith the first method simply returning V, the second returning  eachcol(V), and the third returning V. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.remove_duplicate_triangles","page":"Triangles","title":"DelaunayTriangulation.remove_duplicate_triangles","text":"remove_duplicate_triangles(T::Ts) where {Ts}\n\nRemoves duplicate triangles from T. This procedure also sorts the triangles  so that the first index of each triangle is the smallest. Orientations are  preserved.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"You must also provide definitions for Base.in and Base.sizehint! for your type. You need Base.unique! to use remove_duplicate_triangles, unless your collection is a Set. Note also that Triangulations also define each_solid_triangle and each_ghost_triangle.","category":"page"},{"location":"interface/triangles/#Generic-Methods-2","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"contains_triangle \nadd_triangle!(::Any, ::Vararg{F, N}) where {F, N}\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ndelete_triangle!(::Any, ::Vararg{F, N}) where {F, N}\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ncompare_triangle_collections \nsort_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.contains_triangle","page":"Triangles","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(T::F, V::S) where {F, S}\n\nGiven a collection of triangles V of type S, containing triangles  of type F, checks if V includes the triangle T. In particular,  the returned value is \n\n(rotate_triangle(T, m), true)\n\nif V includes the triangle T, and m is the integer such that  rotate_triangle(T, m) is the form of T that V contains. If there  is no such m, the returned value is simply \n\n(T, false).\n\nTo use this function, your type needs to only have a definition for T ∈ V for  testing specific rotations of a triangle. This function then performs the checks  by checking T, then rotate_triangle(T, 1), then rotate_triangle(T, 2), and if none of those succeed just returns  (T, false). You can extend this function as you need. We also define\n\ncontains_triangle(i, j, k, V::Ts) where {Ts},\n\nand this method just calls the two-argument method after constructing  the triangle with construct_triangle.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T, V...)\n\nGiven a collection of triangles T, adds all the triangles V... into it.  To extend this method to other collections, see add_to_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, adds the triangle (i, j, k) into it.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(V, T...)\n\nGiven a collection of triangles V, deletes all the triangles T... from it.  Checks are made for rotated forms of T that V includes. For example, if  T = (i, j, k) but V contains (j, k, i), then (j, k, i) will be deleted. The function also checks to see if the triangle is in V at all prior to deleting it. To extend this method to other collections, see delete_from_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, deletes the triangle (i, j, k) from it.  Checks are made to see if T needs to be rotated, or if (i, j, k) is in T  at all.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangle_collections","page":"Triangles","title":"DelaunayTriangulation.compare_triangle_collections","text":"compare_triangle_collections(T, V)\n\nGiven two collections of triangles T and V, tests if they are equal, with  equality defined according to compare_triangles.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangles","page":"Triangles","title":"DelaunayTriangulation.sort_triangles","text":"sort_triangles(T::Ts) where {Ts}\n\nSorts the triangles in the collection T so that each triangle's first vertex  has the smallest value. The orientation of each triangle is preserved.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/triangulation/#Triangulation","page":"Triangulation","title":"Triangulation","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"The most important structure of the package is the Triangulation data structure. Its complete definition is given below, and then afterwards we give all the docstrings for methods that are useful for working with triangulations.","category":"page"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"Triangulation","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.Triangulation","page":"Triangulation","title":"DelaunayTriangulation.Triangulation","text":"Triangulation{P,Ts,I,E,Es,BN,BNM,B,BIR,BPL}\n\nStruct representing a Delaunay triangulation, as constructed via e.g. triangulate or generate_mesh.\n\nFields\n\npoints::P\n\nThe points used to construct the triangulation. Do note that this is  not necessarly the same as the set of points appearing in the triangulation, as could happen  e.g. if some points were deleted from the triangulation. If that is what you need,  then see each_vertex.\n\ntriangles::Ts\n\nThe triangles in the triangulation, all given with positive orientation. This field can include  ghost triangles. If you don't want ghost triangles, see each_solid_triangle.\n\nadjacent::Adjacent{I, E}\n\nThe Adjacent map.\n\nadjacent2vertex::Adjacent2Vertex{I,Es,E}\n\nThe Adjacent2Vertex map.\n\ngraph::Graph{I}\n\nThe Graph. \n\nboundary_nodes::BN\n\nThe boundary nodes in the triangulation that you provide, matching the specification given in the  documentation.\n\nboundary_edge_map::BNM\n\nThis is a Dict that maps all of the boundary edges to their position  in boundary_nodes. See also construct_boundary_edge_map.\n\nboundary_index_ranges::BIR\n\nThis is an OrderedDict that maps a boundary index to a range of all other boundary indices  that the corresponding boundary curve could correspond to. For example, for a curve with  four segments, there are four possible boundary indices that a segment could correspond to.  See also construct_boundary_index_ranges.\n\nconstrained_edges::Es\n\nThis is the set of extra edges added into the triangulation that you have provided. This will not include any of the other constrained edges from boundary_nodes.\n\nall_constrained_edges::Es\n\nThis is the set of all constrained edges appearing in the triangulation, essentially  given as the union of constrained_edges and boundary_nodes. This is different from  the constrained_edges field as it contains edges from both of these fields, e.g.  there might be an edge in constrained_edges that is not yet in the triangulation,  but it will definitely not appear in all_constrained_edges.\n\nconvex_hull::ConvexHull{P,Vector{I}}\n\nThe ConvexHull of points. See also convex_hull.\n\nrepresentative_point_list::RPL\n\nThe Dict of points giving representative points for each boundary curve, or for the  convex hull if boundary_nodes is empty. These representative points are used for interpreting  ghost vertices.\n\nConstructors\n\nThere are several ways to construct this struct directly, although in most cases  you should be using triangulate or generate_mesh.\n\nDefault Constructor\n\nThe default constructor is available, i.e. \n\nTriangulation(\n    points,\n    triangles,\n    adjacent,\n    adjacent2vertex,\n    graph,\n    boundary_nodes,\n    boundary_edge_map,\n    boundary_map,\n    boundary_index_ranges,\n    constrained_edges,\n    all_constrained_edges,\n    convex_hull,\n    representative_point_list\n)\n\nEmpty Triangulation\n\nAn empty triangulation can be initalised with the following method, \n\nTriangulation(points;\n    IntegerType=Int64,\n    EdgeType=NTuple{2,IntegerType},\n    TriangleType=NTuple{3,IntegerType},\n    EdgesType=Set{EdgeType},\n    TrianglesType=Set{TriangleType},\n    boundary_nodes=IntegerType[],\n    constrained_edges=initialise_edges(EdgesType),\n    representative_point_list=get_empty_representative_points(IntegerType, number_type(points))\n)\n\nTriangulation From an Existing Mesh\n\nA method is available from constructing a mesh from an existing set of points,  triangles, and boundary nodes, mainly existing for the purpose of generate_mesh:\n\nTriangulation(points, triangles, boundary_nodes;\n    IntegerType=Int64,\n    EdgeType=NTuple{2,IntegerType},\n    TriangleType=NTuple{3,IntegerType},\n    EdgesType=Set{EdgeType},\n    TrianglesType=Set{TriangleType},\n    add_ghost_triangles=false\n)\n\nwith add_ghost_triangles calling add_ghost_triangles! at the end of the constructor.\n\nWrapping a Triangulation with constrainededgepoints\n\nThis method is used in triangulate for wrapping a triangulation with a set of constraints:\n\nremake_triangulation_with_constraints(triangulation, edges, boundary_nodes)\n\nwhich returns (bn_map, bn_range, tri), where bn_map is the boundary_map that isn't yet added, bn_range is the boundary_index_range that isn't yet added either, and tri is the wrapped  triangulation that includes the constrained edges and the boundary_nodes. Note that  either edges or boundary_nodes can be nothing.\n\nThis can be used together with the method\n\nreplace_boundary_dict_information(triangulation, bn_map, bn_range)\n\nwhich returns a new triangulation with the boundary_map and boundary_index_range replaced, completing the wrapper.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"Each field has its own accessor: ","category":"page"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_points(::Triangulation) \nget_triangles(::Triangulation)\nget_adjacent(::Triangulation)\nget_adjacent2vertex(::Triangulation)\nget_graph(::Triangulation)\nget_boundary_nodes(::Triangulation)\nget_boundary_edge_map(::Triangulation)\nget_boundary_map(::Triangulation)\nget_boundary_index_ranges(::Triangulation)\nget_constrained_edges(::Triangulation)\nget_all_constrained_edges(::Triangulation)\nget_convex_hull(::Triangulation)\nget_representative_point_list(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_points","text":"get_points(tri::Triangulation)\n\nReturns the points field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_triangles","text":"get_triangles(tri::Triangulation)\n\nReturns the triangles field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation)\n\nReturns the adjacent field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation)\n\nReturns the adjacent2vertex field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_graph-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_graph","text":"get_graph(tri::Triangulation)\n\nReturns the graph field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri::Triangulation)\n\nReturns the boundary_nodes field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation)\n\nReturns the boundaryedgemap field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_map","text":"get_boundary_map(tri::Triangulation)\n\nReturns the boundary_map field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_index_ranges","text":"get_boundary_index_ranges(tri::Triangulation)\n\nReturns the boundaryindexranges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_constrained_edges","text":"get_constrained_edges(tri::Triangulation)\n\nReturns the constrained_edges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_all_constrained_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_all_constrained_edges","text":"get_all_constrained_edges(tri::Triangulation)\n\nReturns the allconstrainededges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull","text":"get_convex_hull(tri::Triangulation)\n\nReturns the convex_hull field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_representative_point_list-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_representative_point_list","text":"get_representative_point_list(tri::Triangulation)\n\nReturns the representativepointlist field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"There are several useful methods available for working with triangulations. We split these into several sections. ","category":"page"},{"location":"data_structures/triangulation/#Adjacent-Methods","page":"Triangulation","title":"Adjacent Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_adjacent(::Triangulation, ::Any)\nadd_adjacent!(::Triangulation, ::Any, ::Any)\ndelete_adjacent!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri, uv; check_existence=Val(has_multiple_segments(tri)))\nget_adjacent(tri, u, v; check_existence=Val(has_multiple_segments(tri)))\n\nReturns get_adjacent(tri, uv; check_existence) or get_adjacent(tri, u, v; check_existence).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(tri::Triangulation, uv, w)\nadd_adjacent!(tri::Triangulation, u, v, w)\n\nCalls add_adjacent!(get_adjacent(tri), uv, w) or add_adjacent!(get_adjacent(tri), u, v, w), adding the edge uv = (u, v) to the adjacent map of tri with corresponding vertex w.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(tri::Triangulation, uv)\ndelete_adjacent!(tri::Triangulation, u, v)\n\nCalls delete_adjacent!(get_adjacent(tri), uv) or delete_adjacent!(get_adjacent(tri), u, v), removing the edge uv = (u, v) from the adjacent map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Adjacent2Vertex-Methods","page":"Triangulation","title":"Adjacent2Vertex Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_adjacent2vertex(::Triangulation, ::Any)\nadd_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation, w)\n\nReturns get_adjacent2vertex(get_adjacent2vertex(tri), w), the edges (u, v) in tri  that are adjacent to w.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(tri::Triangulation, w, uv)\nadd_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nCalls add_adjacent2vertex!(get_adjacent2vertex(tri), w, uv) or add_adjacent2vertex!(get_adjacent2vertex(tri), w, u, v), pushing the edge uv = (u, v) into get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w, uv)\ndelete_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nCalls delete_adjacent2vertex!(get_adjacent2vertex(tri), w, uv) or delete_adjacent2vertex!(get_adjacent2vertex(tri), w, u, v), deleting the edge uv = (u, v) from get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w)\n\nCalls delete_adjacent2vertex!(get_adjacent2vertex(tri), w), deleting the vertex w from get_adjacent2vertex(tri).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Boundary-Nodes-Methods","page":"Triangulation","title":"Boundary Nodes Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"has_multiple_curves(::Triangulation)\nhas_multiple_segments(::Triangulation)\nnum_curves(::Triangulation)\nnum_segments(::Triangulation)\nget_boundary_nodes(::Triangulation, ::Any)\nmap_boundary_index(::Triangulation, ::Any)\nget_curve_index(::Triangulation, ::Any)\nget_segment_index(::Triangulation, ::Any)\nnum_outer_boundary_segments(::Triangulation)\nget_right_boundary_node(::Triangulation, ::Any, ::Any)\nget_left_boundary_node(::Triangulation, ::Any, ::Any)\nget_boundary_index_range(::Triangulation, ::Any)\nget_boundary_edge_map(::Triangulation, ::Any)\ninsert_boundary_node!(::Triangulation, ::Any, ::Any)\nsplit_boundary_edge!(::Triangulation, ::Any, ::Any)\nsplit_boundary_edge_at_collinear_segments!(::Triangulation, ::Any)\ncontains_boundary_edge(::Triangulation, ::Any)\nmerge_constrained_edges(::Any, ::Any, ::Es) where {Es}\nget_all_boundary_nodes(::Triangulation)\nall_boundary_indices(::Triangulation)\ndelete_boundary_node!(::Triangulation, ::Any)\nmerge_boundary_node!(::Triangulation, ::Any, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(tri::Triangulation)\n\nReturns has_multiple_curves(get_boundary_nodes(tri)), testing if tri's boundary is  comprised of multiple curves.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(tri::Triangulation)\n\nReturns has_multiple_segments(get_boundary_nodes(tri)), testing if tri's boundary is  comprised of multiple segments.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_curves","text":"num_curves(tri::Triangulation)\n\nReturns num_curves(get_boundary_nodes(tri)), the number of curves in tri's boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_segments","text":"num_segments(tri::Triangulation)\n\nReturns num_segments(get_boundary_nodes(tri)), the number of segments in tri's boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(bn, mnℓ...)\n\nGet the boundary nodes from bn corresponding to the specified indices.  See getboundarynodes.\n\n\n\n\n\nget_boundary_nodes(tri::Triangulation, mnℓ...)\n\nReturns get_boundary_nodes(get_boundary_nodes(tri), mnℓ...).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(tri::Triangulation, i)\n\nReturns map_boundary_index(get_boundary_map(tri), i), mapping the boundary index i to the corresponding index in the boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(tri::Triangulation, i)\n\nReturns get_curve_index(get_boundary_map(tri), i), the curve corresponding to the boundary index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_segment_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(tri::Triangulation, i)\n\nReturns get_segment_index(get_boundary_map(tri), i), the segment corresponding to the boundary  index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_outer_boundary_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_outer_boundary_segments","text":"num_outer_boundary_segments(tri::Triangulation)\n\nReturns num_outer_boundary_segments(get_boundary_nodes(tri)), returns the number of boundary segments on the  outermost boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(tri::Triangulation, k, boundary_index)\n\nReturns get_right_boundary_node(get_adjacent(tri), k, boundary_index, get_boundary_index_ranges(tri), Val(has_multiple_segments(tri))),  the node to the right of the boundary node k. It is assumed that k is on the part of the boundary of tri with index boundary_index.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(tri::Triangulation, k, boundary_index)\n\nReturns get_left_boundary_node(get_adjacent(tri), k, boundary_index, get_boundary_index_ranges(tri), Val(has_multiple_segments(tri))), the node to the left of the boundary node k. It is assumed that k is on the part of the boundary of tri with index boundary_index.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_index_range-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_index_range","text":"get_boundary_index_range(tri::Triangulation, i)\n\nReturns map_boundary_index(get_boundary_index_ranges(tri), i), the list of boundary indices belonging to the curve corresponding  to the boundary index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation, ij)\nget_boundary_edge_map(tri::Triangulation, i, j)\n\nReturns get_boundary_edge_map(get_boundary_nodes(tri), ij) or get_boundary_edge_map(get_boundary_nodes(tri), construct_edge(edge_type(tri), i, j)), returning a Tuple pos such that get_boundary_nodes(get_boundary_nodes(tri, pos[1]), pos[2]) is the edge ij = (i, j).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.insert_boundary_node!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(tri::Triangulation, pos, node)\n\nCalls insert_boundary_node!(get_boundary_nodes(tri), pos, node), splitting the boundary node at pos at node.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_boundary_edge!","text":"split_boundary_edge!(tri::Triangulation, edge, node)\nsplit_boundary_edge!(tri::Triangulation, i, j, node)\n\nGiven a triangulation tri, an edge = (i, j), and a node on edge, this function splits the boundary edge into two edges   edge = (i, node) and (node, j), updating tri.boundary_nodes and tri.boundary_edge_map accordingly.\n\nSee also split_boundary_edge_at_collinear_segments!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_boundary_edge_at_collinear_segments!","text":"split_boundary_edge_at_collinear_segments!(tri::Triangulation, collinear_segments)\n\nGiven a triangulation tri and a list of collinear segments collinear_segments, assumed to represent a  boundary edge (initial(first(collinear_segments)), terminal(last(collinear_segments))), splits  the edge at the collinear_segments and updates tri.boundary_nodes and tri.boundary_edge_map accordingly.\n\nSee also split_boundary_edge!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_boundary_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_boundary_edge","text":"contains_boundary_edge(tri::Triangulation, e)\ncontains_boundary_edge(tri::Triangulation, i, j)\n\nTests if the triangulation tri has the constrained boundary edge e = (i, j), returning e ∈ keys(get_boundary_edge_map(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.merge_constrained_edges-Union{Tuple{Es}, Tuple{Any, Any, Es}} where Es","page":"Triangulation","title":"DelaunayTriangulation.merge_constrained_edges","text":"merge_constrained_edges(bn_map, boundary_nodes, constrained_edges::Es)\nmerge_constrained_edges(tri::Triangulation, bn_map=get_boundary_map(tri))\n\nMerges the boundary edges, defined via boundary_nodes or get_boundary_nodes(tri), and the constrained_edges into a single collection. bn_map is used to iterate  over all the boundary edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_all_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_all_boundary_nodes","text":"get_all_boundary_nodes(tri::Triangulation)\n\nReturns a Set of all the boundary nodes in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.all_boundary_indices","text":"all_boundary_indices(tri::Triangulation)\n\nReturns all the boundary indices in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_boundary_node!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(tri::Triangulation, pos)\n\nCalls delete_boundary_node!(get_boundary_nodes(tri), pos), deleting the boundary node at pos.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Convex-Hull-Methods","page":"Triangulation","title":"Convex Hull Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_convex_hull_indices(::Triangulation)\nconvex_hull!(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull_indices","text":"get_convex_hull_indices(tri::Triangulation)\n\nCalls get_indices(get_convex_hull(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.convex_hull!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.convex_hull!","text":"convex_hull!(tri::Triangulation; reconstruct=is_constrained(tri))\n\nComputes the convex hull of the points included in the triangulation tri. If reconstruct,  then the method in convex_hull will be used, whereas if !reconstruct then the triangulation's  boundary is extracted to get the convex hull directly. Note that this latter method fails  if there are any constrained edges on the boundary of tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Edges-Methods","page":"Triangulation","title":"Edges Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"edge_type(::Triangulation{P,Ts,I,E}) where {P,Ts,I,E}\nnum_edges(::Triangulation)\neach_edge(::Triangulation)\neach_constrained_edge(::Triangulation)\ncontains_constrained_edge(::Triangulation, ::Any)\nnum_ghost_edges(::Triangulation)\nnum_solid_edges(::Triangulation)\neach_solid_edge\neach_ghost_edge \nsort_edge_by_degree(::Triangulation, ::Any)\nsplit_constrained_edge!(::Triangulation, ::Any, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_type-Union{Tuple{Triangulation{P, Ts, I, E}}, Tuple{E}, Tuple{I}, Tuple{Ts}, Tuple{P}} where {P, Ts, I, E}","page":"Triangulation","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation)\n\nReturns the type used for representing edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_edges","text":"num_edges(tri::Triangulation)\n\nReturns num_edges(get_graph(tri)), the number of edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_edge-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_edge","text":"each_edge(tri::Triangulation)\n\nReturns get_edges(get_graph(tri)). This iterator over the edges could include ghost edges.\n\nSee also each_solid_edge and each_ghost_edge\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_constrained_edge-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_constrained_edge","text":"each_constrained_edge(tri::Triangulation)\n\nReturns each_edge(get_all_constrained_edges(tri)), an iterator over all constrained_edges  (including all constrained boundary edges)`.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_constrained_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_constrained_edge","text":"contains_constrained_edge(tri::Triangulation, e)\ncontains_constrained_edge(tri::Triangulation, i, j)\n\nTests if tri contains the constrained edge e = (i, j) (or reverse_edge(e) = (j, i)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(tri::Triangulation)\n\nReturns the number of ghost edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(tri::Triangulation)\n\nReturns the number of solid edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_edge","page":"Triangulation","title":"DelaunayTriangulation.each_solid_edge","text":"each_solid_edge(tri)\n\nReturns an iterator over all solid edges of the triangulation tri, i.e.  over all edges that are not ghost edges.\n\nSee also each_edge and each_ghost_edge.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_edge","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_edge","text":"each_ghost_edge(tri)\n\nReturns an iterator over all ghost edges of the triangulation tri, i.e. over all edges that have a boundary index as one of its indices.\n\nSee also each_edge and each_solid_edge.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.sort_edge_by_degree-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.sort_edge_by_degree","text":"sort_edge_by_degree(tri::Triangulation, e)\n\nReturns sort_edge_by_degree(e, get_graph(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_constrained_edge!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_constrained_edge!","text":"split_constrained_edge!(tri::Triangulation, constrained_edge, collinear_segments)\n\nCalls split_constrained_edge!(get_constrained_edges(tri), constrained_edge, collinear_segments), splitting  the constrained_edge which is assumed to represent the union of the collinear_segments so that  we instead store those collinear_segments.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Graph-Methods","page":"Triangulation","title":"Graph Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_edges(::Triangulation)\nget_vertices(::Triangulation)\nget_neighbours(::Triangulation)\nget_neighbours(::Triangulation, ::Any)\nadd_vertex!(::Triangulation, ::Vararg{Any})\nnum_neighbours(::Triangulation, ::Any)\nadd_neighbour!(::Triangulation, ::Any, ::Vararg{Any})\ndelete_neighbour!(::Triangulation, ::Any, ::Vararg{Any})\ndelete_vertex!(::Triangulation, ::Vararg{Any})\ndelete_boundary_vertices_from_graph!(::Triangulation)\neach_vertex(::Triangulation)\nnum_vertices(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_edges","text":"get_graph(tri::Triangulation)\n\nReturns get_edges(get_graph(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_vertices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(tri::Triangulation)\n\nReturns get_vertices(get_graph(tri)), giving all vertices present in the triangulation.  This will include ghost vertices. \n\nSee also each_vertex, each_solid_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation)\n\nReturns get_neighbours(get_graph(tri)), the set of neighbourhoods in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation, u)\n\nReturns get_neighbours(get_graph(tri), u), the set of neighbours of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(tri::Triangulation, u...)\n\nCalls add_vertex!(get_graph(tri), u...), adding the vertex u into tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_neighbours-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(tri::Triangulation, u)\n\nReturns num_neighbours(get_graph(tri), u), the number of neighbours of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(tri::Triangulation, u, v...)\n\nCalls add_neighbour!(get_graph(tri), u, v...), adding each v into the neighbourhood of each u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(tri::Triangulation, u, v...)\n\nCalls delete_neighbour!(get_graph(tri), u, v...), deleting each v from the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(tri::Triangulation, u...)\n\nCalls delete_vertex!(get_graph(tri), u...), deleting each vertex u from tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(tri::Triangulation)\n\nCalls delete_boundary_vertices_from_graph!(get_graph(tri)), deleting all ghost vertices  from the graph.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_vertex-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(tri::Triangulation)\n\nReturns each_vertex(get_graph(tri)), an iterator over all vertices present  in the triangulation.\n\nwarning: Warning\nThis iterator will include ghost vertices. If you want to exclude these,  see each_solid_vertex. Alternatively, if you only want ghost vertices,  see each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_vertices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(tri::Triangulation)\n\nReturns num_vertices(get_graph(tri)), the number of vertices in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Points-Methods","page":"Triangulation","title":"Points Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_point(::Triangulation, ::Any)\neach_point_index(::Triangulation)\neach_point(::Triangulation)\nnum_points(::Triangulation)\npush_point!(::Triangulation, ::Any, ::Any)\neach_solid_vertex \neach_ghost_vertex\nnum_solid_vertices \nnum_ghost_vertices","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_point","text":"get_point(tri::Triangulation, i...)\n\nReturns the ith point of `tri. Boundary indices are automatically handled.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point_index-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(tri::Triangulation)\n\nReturns an iterator over the indices of the points of tri.\n\nSee also each_vertex, `eachsolidvertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point","text":"each_point(tri::Triangulation)\n\nReturns an iterator over the points of tri. \n\nSee also each_vertex, `eachsolidvertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_points","text":"num_points(tri::Triangulation)\n\nReturns the number of points of tri.\n\nnote: Note\nNote that this is just the size of get_points(tri), but if there are some missing points then this will not match the number in the triangulation itself.  Use num_vertices to get the number of vertices in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.push_point!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.push_point!","text":"push_point!(tri::Triangulation, x, y) = push_point!(get_points(tri), x, y)\npush_point!(tri::Triangulation, p) = push_point!(get_points(tri), p)\n\nPushes the point p = (x, y) into get_points(tri0.\n\nnote: Note\nThis does not add the point p into the triangulation itself. See add_point! for this.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_vertex","page":"Triangulation","title":"DelaunayTriangulation.each_solid_vertex","text":"each_solid_vertex(tri::Triangulation)\n\nReturns an iterator over the solid vertices in the triangulation tri, i.e.  those that are not ghost vertices.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_vertex","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_vertex","text":"each_ghost_vertex(tri::Triangulation)\n\nReturns an iterator over the ghost vertices in the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_vertices","page":"Triangulation","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(tri::Triangulation)\n\nReturns the number of solid vertices of tri.\n\n\n\n\n\nnum_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_vertices","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(tri::Trianngulation)\n\nReturns the number of ghost vertices of tri.\n\n\n\n\n\nnum_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#Triangles-Methods","page":"Triangulation","title":"Triangles Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"triangle_type(::Triangulation{P,Ts}) where {P,Ts}\nnum_triangles(::Triangulation)\neach_triangle(::Triangulation)\ncontains_triangle(::Triangulation, ::Any)\nconstruct_positively_oriented_triangle(::Triangulation, ::Any, ::Any, ::Any)\nnum_ghost_triangles(::Triangulation)\nnum_solid_triangles(::Triangulation)\neach_solid_triangle \neach_ghost_triangle","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_type-Union{Tuple{Triangulation{P, Ts}}, Tuple{Ts}, Tuple{P}} where {P, Ts}","page":"Triangulation","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation)\n\nReturns the type used for representing triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(tri::Triangulation) = num_triangles(get_triangles(tri))\n\nReturns the number of triangles in tri, including ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_triangle-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(tri::Triangulation)\n\nReturns an iterator over each triangle in tri. This iterator could include ghost triangles. \n\nSee also each_solid_triangle and each_ghost_triangle.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(tri::Triangulation, T)\ncontains_triangle(tri::Triangulation, i, j, k)\n\nTests if tri contains the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(tri::Triangulation, i, j, k)\n\nConstructs a triangle T with vertices (i, j, k) in tri such that T is  positively oriented.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(tri::Triangulation)\n\nReturns the number of ghost triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(tri::Triangulation)\n\nReturns the number of solid triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_triangle","page":"Triangulation","title":"DelaunayTriangulation.each_solid_triangle","text":"each_solid_triangle(tri)\n\nReturns an iterator over all triangles of tri that are not ghost triangles.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_triangle","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_triangle","text":"each_ghost_triangle(tri)\n\nReturns an iterator over all triangles of tri that are ghost triangles.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#Point-Location-Methods","page":"Triangulation","title":"Point Location Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"brute_force_search(::Triangulation, ::Any)\njump_and_march(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.brute_force_search-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q)\n\nReturns the triangle in tri containing q using brute force search.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.jump_and_march-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.jump_and_march","text":"jump_and_march(tri::Triangulation, q;\n    point_indices=each_point_index(tri),\n    m=default_num_samples(length(point_indices)),\n    try_points=(),\n    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),\n    check_existence::C=Val(has_multiple_segments(tri)),\n    store_history::F=Val(false),\n    history=nothing,\n    rng::AbstractRNG=Random.default_rng(),\n    exterior_curve_index=1) where {C,F}\n\nReturns the triangle containing q using the jump-and-march algorithm.\n\nArguments\n\ntri::Triangulation: The triangulation.\nq: The query point.\n\nKeyword Arguments\n\npoint_indices=each_point_index(tri): The indices of the points in the triangulation.\nm=default_num_samples(length(point_indices)): The number of samples to use when sampling the point to start the algorithm at.\ntry_points=(): Additional points to try when determining which point to start at.\nk=select_initial_point(get_points(tri), q; m, point_indices, try_points): The index of the point to start the algorithm at. \ncheck_existence::C=Val(has_multiple_segments(tri)): This is used when we want to check the existence of certain ghost triangles. See [get_adjacent}(@ref).\nstore_history::F=Val(false): Whether to record the history of the algorithm. See also PointLocationHistory.\nhistory=nothing: The object to store the history into, if is_true(store_history).\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nmaxiters = num_triangles(tri): Maximum number of iterations to perform before restarting the algorithm at a new initial point. \n\nnote: Note\nYou shouldn't ever need maxiters if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the maxiters keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, the value of m is doubled each time.\n\nOutputs\n\nReturns V, the triangle in tri containing q.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Predicates-Methods","page":"Triangulation","title":"Predicates Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"is_boundary_edge(::Triangulation, ::Any)\nis_boundary_triangle(::Triangulation, ::Any, ::Any, ::Any)\ntriangle_orientation(::Triangulation, ::Any, ::Any, ::Any)\npoint_position_relative_to_circumcircle(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Triangulation, ::Any, ::Any, ::Any)\npoint_closest_to_line(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Triangulation, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Triangulation, ::Any, ::Any, ::Any, ::Any)\ntriangle_line_segment_intersection(::Triangulation, ::Any, ::Any, ::Any, ::Any, ::Any)\nis_outer_boundary_index(::Triangulation, ::Any)\nis_outer_boundary_node(::Triangulation, ::Any)\nis_boundary_node(::Triangulation, ::Any)\nedge_exists(::Triangulation, ::Any, ::Any)\nhas_ghost_triangles(::Triangulation)\nhas_boundary_nodes(::Triangulation)\nis_legal(::Triangulation, ::Any, ::Any)\nfind_edge(::Triangulation, ::Any, ::Any)\nis_constrained(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(tri::Triangulation, ij)\nis_boundary_edge(tri::Triangulation, i, j)\n\nReturns is_boundary_edge(ij, get_adjacent(tri)) or is_boundary_edge(i, j, get_adjacent(tri)), respectively, testing if ij = (i, j) belongs to the boundary of the triangulation tri, i.e. (j, i) adjoins a ghost vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(tri::Triangulation, i, j, k)\nis_boundary_triangle(tri::Triangulation, T)\n\nReturns is_boundary_triangle(i, j, k, get_adjacent(tri)) or is_boundary_triangle(T, get_adjacent(tri)), testing if at least one of the edges (u, v) of T = (i, j, k) satisfies is_boundary_edge(tri, u, v).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(tri::Triangulation, i, j, k)\ntriangle_orientation(tri::Triangulation, T)\n\nComputes the orientation of the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(tri::Triangulation, i, j, k, ℓ)\npoint_position_relative_to_circumcircle(tri::Triangulation, T, ℓ)\n\nComputes the position of the ℓth point of tri relative to the circumcircle of the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(tri::Triangulation, i, j, u)\n\nComputes the position of the uth point of tri relative to the line segment with indices (i, j) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_closest_to_line-Tuple{Triangulation, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(tri::Triangulation, i, j, u, v)\n\nTests which of the points u or v is closest to the line segment with indices (i, j) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(tri::Triangulation, i, j, u)\n\nGiven vertices i, j, and u that are collinear, computes the position of u  on the line segment (i, j).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(tri::Triangulation, i, j, u, v)\n\nGiven two lines with indices (i, j) and (u, v), respectively, in tri, computes the number of  intersections.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(tri::Triangulation, i, j, k, u)\npoint_position_relative_to_triangle(tri::Triangulation, T, u)\n\nComputes the position of the uth point of tri relative to the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_line_segment_intersection-Tuple{Triangulation, Any, Any, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(tri::Triangulation, i, j, k, u, v)\ntriangle_line_segment_intersection(tri::Triangulation, T, e)\n\nComputes the type of the intersection of the triangle T = (i, j, k) in tri with the line segment e = (u, v).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(tri::Triangulation, i)\n\nReturns true if is_boundary_index(i) and this boundary index i corresponds to the outermost boundary of tri.  Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(tri::Triangulation, i)\n\nReturns true if i is a boundary node belonging to the outermost boundary of tri. Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_node-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(tri::Triangulation, i)\n\nReturns true if i is a node belonging to any boundary of tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(tri::Triangulation, i, j)\nedge_exists(tri::Triangulation, ij)\n\nReturns true if the edge (i, j) exists in tri, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(tri::Triangulation)\n\nReturns true if tri has ghost triangles, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_boundary_nodes","text":"has_boundary_nodes(tri::Triangulation)\n\nReturns true if tri has boundary nodes, and false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_legal-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_legal","text":"is_legal(tri::Triangulation, i, j)\n\nReturns true if the edge (i, j) is legal in tri, and false otherwise. We also define  constrained edges to be legal, as are ghost edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.find_edge","text":"find_edge(tri::Triangulation, T, ℓ)\n\nGiven a point ℓ that is on an edge of the triangle T in tri, returns the  edge that ℓ is on. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_constrained-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.is_constrained","text":"is_constrained(tri::Triangulation, i, j)\n\nReturns true if tri has any constrained edges, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Representative-Points-Methods","page":"Triangulation","title":"Representative Points Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"compute_representative_points!(::Triangulation)\nget_representative_point_coordinates(::Triangulation, ::Any)\nreset_representative_points!(::Triangulation)\nupdate_centroid_after_addition!(::Triangulation, ::Any, ::Any)\nupdate_centroid_after_deletion!(::Triangulation, ::Any, ::Any)\nnew_representative_point!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0)\n\nUpdates get_representative_point_list(tri) to match the current position of the boundaries. If there are no boundary nodes, use_convex_hull instead represents them using the indices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_representative_point_coordinates-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_representative_point_coordinates","text":"get_representative_point_coordinates(tri::Triangulation, i)\n\nReturns the coordinates of the ith representative point in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.reset_representative_points!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.reset_representative_points!","text":"reset_representative_points!(tri::Triangulation)\n\nResets get_representative_point_list(tri).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.update_centroid_after_addition!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.update_centroid_after_addition!","text":"update_centroid_after_addition!(tri::Triangulation, i, p)\n\nAfter the point p has been added into tri, this updates the ith representative point in  get_representative_point_list(tri), treating it as if it were a centroid.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.update_centroid_after_deletion!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.update_centroid_after_deletion!","text":"update_centroid_after_deletion!(tri::Triangulation, i, p)\n\nAfter the point p has been deleted from tri, this updates the ith representative point in get_representative_point_list(tri), treating it as if it were a centroid.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.new_representative_point!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.new_representative_point!","text":"new_representative_point!(tri::Triangulation, i)\n\nAdds a new representative point to get_representative_point_list(tri) with index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Segment-Location-Methods","page":"Triangulation","title":"Segment Location Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"locate_intersecting_triangles(::Triangulation, ::Any, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.locate_intersecting_triangles-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.locate_intersecting_triangles","text":"locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true);\n    check_existence::C=Val(has_multiple_segments(tri)),\n    rng::AbstractRNG=Random.default_rng()) where {C}\n\nReturns a list of triangles intersecting the segment e in tri. If is_true(rotate),  then e will be sorted such that initial(e) has the least degree in tri.\n\nMore precisely, the returned values are:\n\nintersecting_triangles: The triangles intersecting e.\ncollinear_segments: Any segments collinear with e, giving in order of appearance.\nleft_vertices: All vertices of intersecting_triangles appearing to the left of e.\nright_vertices: All vertices of intersecting_triangles appearing to the right of e.\n\n\n\n\n\n","category":"method"},{"location":"triangulations/plotting/","page":"Plotting","title":"Plotting","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"triangulations/plotting/","page":"Plotting","title":"Plotting","text":"triplot!","category":"page"},{"location":"triangulations/plotting/#DelaunayTriangulation.triplot!","page":"Plotting","title":"DelaunayTriangulation.triplot!","text":"triplot(!)(points, triangles, boundary_nodes, convex_hull, constrained_edges, representative_point_list; kwargs...)\ntriplot(!)(tri::Triangulation; kwargs...)\n\nPlots a triangulation. \n\nAttributes\n\nmarkersize=11\n\nSize of the points.\n\nshow_ghost_edges=false\n\nWhether to show ghost edges.\n\nrecompute_centers=false\n\nWhether to recompute tri.representative_point_list.\n\nshow_all_points=false\n\nWhether to show all points, regardless of whether they appear in the triangulation.\n\npoint_color=:red\n\nColour of the points.\n\nstrokecolor=:black\n\nColours of the triangle edges.\n\ntriangle_color=(:white, 0.0)\n\nColours of the triangles.\n\nghost_edge_color=:blue\n\nColours of the ghost edges.\n\nghost_edge_linewidth=1\n\nWidth of the ghost edges.\n\nstrokewidth=1\n\nWidth of the triangle edges.\n\nghost_edge_extension_factor=10.0\n\nFactor that scales the length of the ghost edges.\n\nshow_convex_hull=true\n\nWhether to show the convex hull.\n\nconvex_hull_color=:red\n\nColour of the convex hull.\n\nconvex_hull_linestyle=:dash\n\nLinestyle for the convex hull edges.\n\nconvex_hull_linewidth=2\n\nWidth of the convex hull.\n\nshow_constrained_edges=true\n\nWhether to show the constrained edges.\n\nconstrained_edge_color=:magenta\n\nColour of the constrained edges.\n\nconstrained_edge_linewidth=2\n\nWidth of the constrained edges.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent/#Adjacent","page":"Adjacent","title":"Adjacent","text":"","category":"section"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"The Adjacent map is used for mapping edges to vertices that together form a positively oriented triangle. The definition of the Adjacent map is below:","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"struct Adjacent{I,E}\n    adjacent::DefaultDict{E,I,I}\n    function Adjacent{I,E}() where {I,E}\n        A = DefaultDict{E,I,I}(I(DefaultAdjacentValue))\n        adj = new{I,E}(A)\n        return adj\n    end\n    Adjacent(adj::DefaultDict{E,I,I}) where {I,E} = new{I,E}(adj)\nend","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"We use a DefaultDict from DataStructures.jl for storing these relationships. We need to use a DefaultDict rather than a Dict so that we more efficiently check if an edge exists, simply seeing if get_adjacent(adj, u, v) returns a DefaultAdjacentValue (see the edge_exists function). We list the complete docstring for Adjacent below, along with individual docstrings for methods for working with Adjacent.","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"Adjacent\nget_adjacent(::Adjacent)\nget_adjacent(::Adjacent{I, E}, ::E) where {I, E, V}\nadd_adjacent!(::Adjacent, ::Any, ::Any)\ndelete_adjacent!(::Adjacent, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\nadd_triangle!(::Adjacent, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\ndelete_triangle!(::Adjacent, ::Any)\nclear_empty_keys!(::Adjacent)","category":"page"},{"location":"data_structures/adjacent/#DelaunayTriangulation.Adjacent","page":"Adjacent","title":"DelaunayTriangulation.Adjacent","text":"Adjacent{I,E}\n\nStruct for storing adjacency relationships for mapping edges to vertices that  together form a positively oriented triangle in an associated triangulation.  The type I is the integer type used, while E is the edge type.\n\nSee the docs for a description of how boundary edges are handled.\n\nSee also Adjacent2Vertex.\n\nFields\n\nadjacent::DefaultDict{E,I,I}\n\nThe Dict used for storing the edges (the keys) and the associated vertices  (the values). If (u, v) is not a valid edge, then w = adjacent[(u, v)] returns 0 (this value is defined in DefaultAdjacentValue). Otherwise, (u, v, w) is a positively oriented triangle.\n\nConstructors\n\nThe adjacent map can be constructed in two ways:\n\nAdjacent{I, E}() where {I, E}\n\nCreates an empty map.\n\nAdjacent(adj::DefaultDict{E,I,I}) where {E,I,I}\n\nCreates an adjacent map from an existing DefaultDict.\n\nExtended help\n\nYou should not work with the adjacent field directly. We provide the following  functions for working with Adjacent, where adj denotes an Adjacent{I, E} type. (Type information in the function signatures is omitted.)\n\nAccessors\n\nget_adjacent(adj)\nget_adjacent(adj, uv) or get_adjacent(adj, u, v)\n\nIn the latter methods, you can also use the keyword argument check_existence to  declare whether to check that the edge exists. This would be used if you need  to be careful about different boundary indices on the same boundary curve. The  default value is Val(false), meaning this isn't checked.\n\nMutators\n\nadd_adjacent!(adj, uv, w) or add_adjacent!(adj, u, v, w)\ndelete_adjacent!(adj, uv) or delete_adjacent!(adj, u, v)\nadd_triangle!(adj, i, j, k) or add_triangle!(adj, T)\nadd_triangle!(adj, T...)\ndelete_triangle!(adj, i, j, k) or delete_triangle!(adj, T)\ndelete_triangle!(adj, T...)\nclear_empty_keys!(adj)\n\nIteration\n\nYou can also iterate over Adjacent maps the same way as you would  with a Dict, e.g.\n\nfor (edge, vertex) in adj \n    get_adjacent(adj, edge) == vertex \nend\n\nwarning: Multiple boundary segments\nNote that in the case that you have multiple boundary indices, this iteration  may not be safe the iteration doesn't make use of get_adjacent, which  knows how to handle boundary indices properly (if you have just a single  boundary, do not worry).\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent)\n\nGiven the adjacent map adj, returns the adjacent field.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Union{Tuple{V}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E, V}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent{I,E}, uv::E; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\nget_adjacent(adj::Adjacent{I,E}, u, v; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\n\nGiven the adjacent map adj and an edge (u, v), returns the vertex w  such that (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\nIn the case of a ghost edge, check_existence = Val(true) may be useful in case the  boundary curve has multiple segments, meaning multiple boundary indices could correspond  to the same same curve. If this is the case, then boundary_index_ranges should also be a Dict from construct_boundary_index_ranges, so that all possible valid boundary indices can be checked.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(adj::Adjacent, uv, w)\nadd_adjacent!(adj::Adjacent{I,E}, u, v, w) where {I,E}\n\nGiven the adjacent map adj, an edge (u, v), and a vertex w, adds  the edge (u, v) with corresponding value w into the adjacent map  so that (u, v, w) is a positively oriented triangle in the  underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(adj::Adjacent, uv)\ndelete_adjacent!(adj::Adjacent{I,E}, u, v) where {I,E}\n\nGiven the adjacent map adj and an edge (u, v), deletes the  edge (u, v) from the adjacent map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  adds that triangle into the adjacent map. In particular, adds the edges (i, j), (j, k), and (k, i) into adj with corresponding values k, i, and j,  respectively.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., adds the  triangles into adj. See also add_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  deletes that triangle into the adjacent map. In particular, deletes the edges (i, j), (j, k), and (k, i) from adj.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., deletes the  triangles from adj. See also delete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent}","page":"Adjacent","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj::Adjacent)\n\nGiven an Adjacent map adj, removes any edges that  map to 0`.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent2vertex/#Adjacent2Vertex","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"","category":"section"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"The Adjacent2Vertex map is closely related to the Adjacent map. Instead of mapping edges to vertices that together form positively oriented triangles, we map vertices to all edges that will form a positively oriented triangle with that vertex. The definition is simply via a Dict:","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"struct Adjacent2Vertex{I,Es,E}\n    adjacent2vertex::Dict{I,Es}\n    function Adjacent2Vertex{I,Es,E}() where {I,Es,E}\n        D = Dict{I,Es}()\n        TA2V = new{I,Es,E}(D)\n        return TA2V\n    end\n    Adjacent2Vertex(adj2v::Dict{I,Es}) where {I,Es} = new{I,Es,edge_type(Es)}(adj2v)\nend","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"A complete list of methods used for working with this struct, along with the struct's docstring itself, is shown below.","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"Adjacent2Vertex \nget_adjacent2vertex(::Adjacent2Vertex)\nget_adjacent2vertex(::Adjacent2Vertex, ::Any)\nadd_adjacent2vertex!(::Adjacent2Vertex{I,Es,E}, ::Any, ::Any) where {I,Es,E}\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any, ::Any)\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\nadd_triangle!(::Adjacent2Vertex, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\ndelete_triangle!(::Adjacent2Vertex, ::Any)\nclear_empty_keys!(::Adjacent2Vertex)","category":"page"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex","page":"Adjacent2Vertex","title":"DelaunayTriangulation.Adjacent2Vertex","text":"Adjacent2Vertex{I, Es, E}\n\nStruct for storing adjacency relationships for mapping vertices to  all other edges that together form a positively oriented triangle  in an associated triangulation. The type I is the integer type  used, Es is the type used for representing a collection of edges,  and E is the type for a single edge.\n\nSee the docs for a description of how boundary edges  are handled.\n\nSee also Adjacent.\n\nFields\n\nadjacent2vertex::Dict{I, Es}\n\nThe Dict used for storing the vertices (the keys) and the associated  collection of edges (the values). In particular, if w is a vertex,  then (u, v, w) is a positively oriented triangle for each  (u, v) in adjacent2vertex[w].\n\nConstructors\n\nThe adjacent2vertex map can be constructed in two ways:\n\nAdjacent2Vertex{I,Es,E}()\n\nCreates an empty map.\n\nAdjacent2Vertex(adj2v::Dict{I,E}) where {I,Es}\n\nCreates an adjacent2vertex map from an existing Dict. The type E is obtained from  edge_type(Es).\n\nExtended help\n\nYou should not work with the adjacent2vertex field directory. We provide the  following functions for working with Adjacent2Vertex, where adj2v  denotes an Adjacent2Vertex{I,Es,E} type. (Type information in the  function signatures is omitted.)\n\nAccessors\n\nget_adjacent2vertex(adj2v)\nget_adjacent2vertex(adj2v, w)\n\nMutators\n\nadd_adjacent2vertex!(adj2v, w, uv) or add_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w, uv) or delete_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w)\nadd_triangle!(adj2v, i, j, k) or add_triangle!(adj2v, T)\nadd_triangle!(adj2v, T...)\ndelete_triangle!(adj2v, i, j, k) or delete_triangle!(adj2v, T)\ndelete_triangle!(adj2v, T...)\nclear_empty_keys!(adj2v)\n\nIteration\n\nYou can also iterate over Adjacent2Vertex maps the same way as you would  with a Dict, e.g. if adj is a corresponding Adjacent map,\n\nfor (vertex, edge_list) in adj2v \n    for edge in each_edge(edge_list)\n        get_adjacent(adj, edge) == vertex \n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex)\n\nReturns the adjacent2vertex field from the adjacent2vertex map adj2v.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, returns the set of  edges associated with the vertex w, i.e. the set of edges (u, v) such that  (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_adjacent2vertex!-Union{Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent2Vertex{I, Es, E}, Any, Any}} where {I, Es, E}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, uv) where {I,Es,E}\nadd_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), adds  the edge (u, v) into the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w, uv)\ndelete_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), deletes  the edge (u, v) from the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, deletes  the key w from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, adds that triangle from the  map. In particular, adds the edges (i, j), (j, k), and (k, i)  into the set of edges associated with the vertices k, i, and j, respectively, in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent map adj2v and triangles T..., adds the  triangles into adj2v. See also add_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, deletes that triangle from the  map. In particular, deletes the edges (i, j), (j, k), and (k, i)  from the set of edges associated with the vertices k, i, and j, respectively, from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent2vertex map adj2v and triangles T..., deletes the  triangles from adj2v. See also delete_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj2v::Adjacent2Vertex)\n\nGiven an Adjacent2Vertex map adj2v, removes  any keys that map to empty sets.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"#DelaunayTriangulation","page":"Home","title":"DelaunayTriangulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DelaunayTriangulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for computing Delaunay triangulations of planar point sets. We support both unconstrained and constrained Delaunay triangulations. An interface for computing  constrained Delaunay triangulations with Gmsh is also available if needed; see the Gmsh discussion in the sidebar. Unconstrained Delaunay triangulations are computed with the Bowyer-Watson algorithm, and constrained Delaunay triangulations are computed with the incremental algorithm given by https://doi.org/10.1016/j.comgeo.2015.04.006.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure that the triangulations are robust to degeneracies, we use ExactPredicates.jl for all geometrical predicates. The results from these predicates are handled through a Certificate module, as outlined in the predicates section in the sidebar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Much of the work in this package is derived from the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013).","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/bowyer/#Bowyer-Watson-Algorithm","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"","category":"section"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"Here we will give a description of the Bowyer-Watson algorithm. This algorithm is the algorithm used by triangulate.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"The main idea behind the algorithm is to insert points one at a time, deleting triangles at each step whose circumcircles contain the point to be inserted, then repairing the cavity. We give the procedure in steps below.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"First, using initialise_bowyer_watson, we need to define the initial triangle. This triangle will be the first three points in the provided point_order (which is, by default, just a random permutation of the point indices - see the point_order keyword argument in triangulate_bowyer_watson and the get_point_order function). If these first three points are collinear, we do a circular shift of the point order until we get a non-degenerate triangle. See get_initial_triangle. At this step, we also reset the representative points field of the triangulation and initialise it with DelaunayTriangulation.BoundaryIndex mapping to the centroid of this initial triangle.\nOnce the initial triangle is selected, we move into _triangulate_bowyer_watson, where we loop over each point and add it in one at a time. In this loop, we start by selecting the initial point to start the jump and march algorithm at, making use of select_initial_point. Since points are added in one at a time, and a user's insertion order may often have points that are close together both in the order and in space, the try_last_inserted_point keyword argument is useful here in case we can start right next to the new point. With this point selected, we move into actually adding the point via add_point_bowyer_watson!.\nThe add_point_bowyer_watson! starts by using jump_and_march to find a triangle containing the point. The idea is to then find all triangles whose circumcircles, i.e. the circle through the three points of the triangle, contain this new point. These points need to be deleted since, by definition, these triangles are no longer Delaunay. This is done via a depth-first search, where we take the triangle we are currently in and step over its three edges into three new triangles, done via the recursive function dig_cavity!. If the new triangle also contains the point in its circumcircle, we delete it also, and we keep stepping. We stop at any triangles that don't contain the point in its circumcircle. Once we have stopped, we take the edge we did not step over and connect it with the new point, giving us a new triangle. \nStill in add_point_bowyer_watson!, an important case to consider is when the point we find is directly on the triangle we found. This does not cause any problems with dig_cavity!, but it may cause issues with how we update the boundary, so not only do we check if the point is on the triangle, but we also check that the triangle is either a boundary triangle or a ghost triangle (meaning the edge is on the boundary). If this is the case, then we find the edge of the triangle that the point is on with find_edge, and split the edge in half at the point, placing the new point correctly on the boundary and giving two new triangles.\nLastly, still in add_point_bowyer_watson!, we use update_centroid_after_addition! to update the centroid of the points with the new point.\nSteps 2–5 are repeated for each new point, until we have finally added all points. Once this is done, we compute the convex hull of the points with convex_hull!, stepping over the boundary using the ghost triangles from the triangulation to get all the boundary nodes efficiently.\nNext, if the keyword argument recompute_representative_point is true, we can give a better representative point for the central part of the domain than the centroid by computing the pole of inaccessibility. This is done with compute_representative_points!.\nFinally, to clean up, we can delete all ghost triangles (if the keyword argument delete_ghosts is true) with delete_ghost_triangles!. Then, if the keyword argument delete_empty_features is true, we can delete all keys from the Adjacent map that map to empty values with clear_empty_features!, which would also clean up empty sets from the Adjacent2Vertex map and empty neighbourhoods from the Graph.","category":"page"},{"location":"tri_algs/bowyer/#Modifications-for-a-constrained-Delaunay-triangulation","page":"Bowyer-Watson Algorithm","title":"Modifications for a constrained Delaunay triangulation","text":"","category":"section"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"The Bowyer-Watson algorithm requires two modifications for adding points into a constrained Delaunay triangulation. The modifications are:","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"Avoid walking over any constrained edges when performing the depth-first search.\nIf a point is added onto a constrained segment, split the segment in two and perform the depth-first search on each side of the segment.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"With just these two modifications, the algorithm works.","category":"page"}]
}
