<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Edges · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/edges/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li class="is-active"><a class="tocitem" href>Edges</a><ul class="internal"><li><a class="tocitem" href="#Individual-Edges"><span>Individual Edges</span></a></li><li><a class="tocitem" href="#Collection-of-Edges"><span>Collection of Edges</span></a></li></ul></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Edges</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Edges</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/edges.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Individual-Edges"><a class="docs-heading-anchor" href="#Individual-Edges">Individual Edges</a><a id="Individual-Edges-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Edges" title="Permalink"></a></h2><p>Edges are assumed to take the form <code>(i, j)</code>, with customisation available for how we represent <code>(i, j)</code>. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods"><a class="docs-heading-anchor" href="#Necessary-Methods">Necessary Methods</a><a id="Necessary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_edge" href="#DelaunayTriangulation.construct_edge"><code>DelaunayTriangulation.construct_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_edge(::Type{E}, i, j) where {E}</code></pre><p>Constructs an edge with indices <code>(i, j)</code> with the type <code>E</code>. The  following methods are currently defined:</p><pre><code class="nohighlight hljs">construct_edge(::Type{NTuple{2, I}}, i, j) where {I}
construct_edge(::Type{A}, i, j) where {I,A&lt;:AbstractVector}</code></pre><p>You can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.initial" href="#DelaunayTriangulation.initial"><code>DelaunayTriangulation.initial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial(e::E)</code></pre><p>Given an edge <code>e</code>, returns the index for the initial point. The following  methods are currently defined:</p><pre><code class="nohighlight hljs">initial(e::NTuple{2,I}) where {I}
initial(e::A) where {I,A&lt;:AbstractVector{I}}</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.terminal" href="#DelaunayTriangulation.terminal"><code>DelaunayTriangulation.terminal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">terminal(e::E)</code></pre><p>Given an edge <code>e</code>, returns the index for the terminal point. The following  methods are currently defined:</p><pre><code class="nohighlight hljs">terminal(e::NTuple{2,I}) where {I}
terminal(e::A) where {I,A&lt;:AbstractVector{I}}</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L38-L48">source</a></section></article><h3 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_indices" href="#DelaunayTriangulation.edge_indices"><code>DelaunayTriangulation.edge_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_indices(e)</code></pre><p>Given an edge <code>e</code>, returns <code>(initial(e), terminal(e))</code>. </p><p>See also <a href="#DelaunayTriangulation.initial"><code>initial</code></a> and <a href="#DelaunayTriangulation.terminal"><code>terminal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.reverse_edge" href="#DelaunayTriangulation.reverse_edge"><code>DelaunayTriangulation.reverse_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse_edge(e)</code></pre><p>Given an edge <code>e</code>, returns <code>(terminal(e), initial(e))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L66-L70">source</a></section></article><h2 id="Collection-of-Edges"><a class="docs-heading-anchor" href="#Collection-of-Edges">Collection of Edges</a><a id="Collection-of-Edges-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-Edges" title="Permalink"></a></h2><p>A collection of edges simply stores many edges, and this collection must be mutable so that edges can be deleted added and deleted. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods-2"><a class="docs-heading-anchor" href="#Necessary-Methods-2">Necessary Methods</a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.initialise_edges" href="#DelaunayTriangulation.initialise_edges"><code>DelaunayTriangulation.initialise_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialise_edges(::Type{S})</code></pre><p>For a given type <code>S</code> for some collection (e.g. a <code>Set</code>), returns an empty instance of that collection. The only method defined is</p><pre><code class="nohighlight hljs">initialise_edges(::Type{S}) where {E, S &lt;: Set{E}}
initialise_edges(::Type{A}) where {E, A &lt;: AbstractVector{E}}</code></pre><p>which returns a <code>Set{E}()</code> or a <code>A()</code>, respectively. You can extend this  function as you need, making sure you extend it for the type rather than  for instances of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_type" href="#DelaunayTriangulation.edge_type"><code>DelaunayTriangulation.edge_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_type(::Type{S}) where {S}</code></pre><p>For a given type <code>S</code> representing a collection of edges,  returns the type of triangle used inside <code>S</code>, e.g. <code>NTuple{2, Int64}</code> if <code>S = Set{NTuple{2, Int64}}</code>. The only methods defined are </p><pre><code class="nohighlight hljs">edge_type(::Type{S}) where {E,S&lt;:Set{E}}
edge_type(::Type{A}) where {E,A&lt;:AbstractVector{E}}</code></pre><p>which return <code>E</code>. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_edges" href="#DelaunayTriangulation.num_edges"><code>DelaunayTriangulation.num_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_edges(E::S) where {S}</code></pre><p>Given a collection of edges <code>E</code>, returns the number of edges in <code>E</code>. The only method currently defined is </p><pre><code class="nohighlight hljs">num_edges(E::Set)
num_edges(E::AbstractVector)</code></pre><p>which returns <code>length(E)</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L117-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.contains_edge" href="#DelaunayTriangulation.contains_edge"><code>DelaunayTriangulation.contains_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains_edge(e::E, Es::S) where {E, S}</code></pre><p>Given a collection of edges <code>Es</code> of type <code>S</code>, containing edges of type <code>E</code>, checks if <code>Es</code> includes the edge <code>e</code>, returning <code>true</code>  if so. The methods currently defined are</p><pre><code class="nohighlight hljs">contains_edge(e::E, Es::Set{E}) where {E} 
contains_edge(e::E, Es::A) where {E,A&lt;:AbstractVector{E}}
contains_edge(i, j, Es::E)</code></pre><p>The first two methods simply return <code>e ∈ E</code>, while the latter constructs the edge <code>e = (i, j)</code> of type <code>edge_type(E)</code> and call the first two  methods. Only the method <code>contains_edge(::E, ::Es)</code> needs to be extended if you need,  the last method makes use of this definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L135-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_to_edges!" href="#DelaunayTriangulation.add_to_edges!"><code>DelaunayTriangulation.add_to_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_edges!(E::S, e) where {S}</code></pre><p>Given a collection of edges <code>E</code>, pushes <code>e</code> into it. The only  methods currently defined are</p><pre><code class="nohighlight hljs">add_to_edges!(E::Set, e)
add_to_edges!(E::Vector, e)</code></pre><p>which simply call <code>push!(E, e)</code>. You can extend this function   as you need. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L159-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_from_edges!" href="#DelaunayTriangulation.delete_from_edges!"><code>DelaunayTriangulation.delete_from_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_from_edges!(E::S, e::F) where {S}</code></pre><p>Given a collection of edges <code>E</code> of type <code>S</code>, containing  edges of type <code>F</code>, deletes the edge <code>e</code> from <code>E</code>.  The  methods currently defined are</p><pre><code class="nohighlight hljs">delete_from_edges!(E::Set{F}, T::F) where {F}
delete_from_edges!(Es::A, e::E) where {E, A&lt;:AbstractVector{E}}</code></pre><p>which just calls <code>delete!</code> on <code>E</code> in the first case, or <code>filter!</code>  in the second case. This is the form of the function that needs  to be extended. We also define </p><pre><code class="nohighlight hljs">delete_from_edges!(Es::E, i::Integer, j::Integer) where {E}</code></pre><p>which constructs the edge <code>(i, j)</code> and then deletes it from <code>Es</code>, calling  the methods above. You do not need to extend this last method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L191-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_edge" href="#DelaunayTriangulation.each_edge"><code>DelaunayTriangulation.each_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_edge(E::F) where {F}</code></pre><p>For a given collection of edges <code>E</code>, returns an iterator that  goes over each edge in the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_edge(E::Set)
each_edge(E::AbstractMatrix)
each_edge(E::AbstractVector)</code></pre><p>with the first and third methods simply returning <code>E</code>, and the second returning  <code>eachcol(E)</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L244-L257">source</a></section></article><h3 id="Generic-Methods-2"><a class="docs-heading-anchor" href="#Generic-Methods-2">Generic Methods</a><a class="docs-heading-anchor-permalink" href="#Generic-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_edge!" href="#DelaunayTriangulation.add_edge!"><code>DelaunayTriangulation.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_edge!(E, e...)</code></pre><p>Given a collection of edges <code>E</code>, adds all the triangles <code>e...</code> into it.  To extend this method to other collections, see <a href="#DelaunayTriangulation.add_to_edges!"><code>add_to_edges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L178-L183">source</a></section><section><div><pre><code class="language-julia hljs">add_edge!(tri::Triangulation, segment; rng::AbstractRNG=Random.default_rng())
add_edge!(tri::Triangulation, i, j; rng::AbstractRNG=Random.default_rng())</code></pre><p>Adds the edge <code>segment = (i, j)</code> into the triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/operations/add_edge.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_edge!" href="#DelaunayTriangulation.delete_edge!"><code>DelaunayTriangulation.delete_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_edge!(E, e...)</code></pre><p>Given a collection of edges <code>E</code>, deletes all the edges <code>e...</code> from it.  To extend this method to other collections, see <a href="#DelaunayTriangulation.delete_from_edges!"><code>delete_from_edges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.random_edge" href="#DelaunayTriangulation.random_edge"><code>DelaunayTriangulation.random_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_edge(E)</code></pre><p>Returns a random edge from edge set <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_empty" href="#DelaunayTriangulation.is_empty"><code>DelaunayTriangulation.is_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_empty(E)</code></pre><p>Tests if the edge set <code>E</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/interfaces/edges.jl#L274-L278">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../triangles/">« Triangles</a><a class="docs-footer-nextpage" href="../points/">Points »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 15 April 2023 08:22">Saturday 15 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
