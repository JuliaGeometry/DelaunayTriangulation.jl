<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Point Location · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/other_features/point_location/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li class="is-active"><a class="tocitem" href>Point Location</a><ul class="internal"><li><a class="tocitem" href="#The-Main-Method"><span>The Main Method</span></a></li><li><a class="tocitem" href="#History"><span>History</span></a></li><li><a class="tocitem" href="#Basic-Description-of-the-Algorithm"><span>Basic Description of the Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Other Features</a></li><li class="is-active"><a href>Point Location</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Point Location</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/other_features/point_location.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Point-Location"><a class="docs-heading-anchor" href="#Point-Location">Point Location</a><a id="Point-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Location" title="Permalink"></a></h1><p>The most expensive step for building a Delaunay triangulation is the point location step, wherein we need to find a triangle that contains a given point. The code for this turns out to be very complicated so that we can correctly handle points outside of the domain, inside interior holes, collinear with other points, on the corner, etc. The main function that handles all of this is <code>jump_and_march</code>, derived from the jump-and-march algorithm of Mücke, Saias, and Zhu (1999). We also provide a method that simply searches over all triangles, given below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search" href="#DelaunayTriangulation.brute_force_search"><code>DelaunayTriangulation.brute_force_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brute_force_search(tri::Triangulation, q)</code></pre><p>Returns the triangle in <code>tri</code> containing <code>q</code> using brute force search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/data_structures/triangulation/point_location.jl#L1-L5">source</a></section><section><div><pre><code class="nohighlight hljs">brute_force_search(T, r, pts, representative_point_list, boundary_map)</code></pre><p>Searches for the triangle in <code>T</code> containing the point <code>r</code> in <code>T</code> using brute force, simply  searching over all triangles. Ghost triangles are handled via the <code>representative_point_list</code> and <code>boundary_map</code> from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/brute_force.jl#L1-L7">source</a></section></article><h2 id="The-Main-Method"><a class="docs-heading-anchor" href="#The-Main-Method">The Main Method</a><a id="The-Main-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Main-Method" title="Permalink"></a></h2><p>Below we list docstrings for the main jump and march algorithm.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.jump_and_march" href="#DelaunayTriangulation.jump_and_march"><code>DelaunayTriangulation.jump_and_march</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jump_and_march(tri::Triangulation, q;
    point_indices=each_point_index(tri),
    m=default_num_samples(length(point_indices)),
    try_points=(),
    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),
    check_existence::C=Val(has_multiple_segments(tri)),
    store_history::F=Val(false),
    history=nothing,
    rng::AbstractRNG=Random.default_rng(),
    exterior_curve_index=1) where {C,F}</code></pre><p>Returns the triangle containing <code>q</code> using the jump-and-march algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The triangulation.</li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>point_indices=each_point_index(tri)</code>: The indices of the points in the triangulation.</li><li><code>m=default_num_samples(length(point_indices))</code>: The number of samples to use when sampling the point to start the algorithm at.</li><li><code>try_points=()</code>: Additional points to try when determining which point to start at.</li><li><code>k=select_initial_point(get_points(tri), q; m, point_indices, try_points)</code>: The index of the point to start the algorithm at. </li><li><code>check_existence::C=Val(has_multiple_segments(tri))</code>: This is used when we want to check the existence of certain ghost triangles. See [<code>get_adjacent</code>}(@ref).</li><li><code>store_history::F=Val(false)</code>: Whether to record the history of the algorithm. See also <a href="#DelaunayTriangulation.PointLocationHistory"><code>PointLocationHistory</code></a>.</li><li><code>history=nothing</code>: The object to store the history into, if <code>is_true(store_history)</code>.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li><li><code>exterior_curve_index=1</code>: The curve (or curves) corresponding to the outermost boundary.</li><li><code>maxiters = num_triangles(tri)</code>: Maximum number of iterations to perform before restarting the algorithm at a new initial point. </li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You shouldn&#39;t ever need <code>maxiters</code> if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the <code>maxiters</code> keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, the value of <code>m</code> is doubled each time.</p></div></div><p><strong>Outputs</strong></p><p>Returns <code>V</code>, the triangle in <code>tri</code> containing <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/data_structures/triangulation/point_location.jl#L14-L55">source</a></section><section><div><pre><code class="nohighlight hljs">jump_and_march(pts, adj, adj2v, graph, boundary_index_ranges, representative_point_list, boundary_map, q;
    m=default_num_samples(num_points(pts)),
    point_indices=each_point_index(pts),
    try_points=(),
    k=select_initial_point(pts, q; m, point_indices, try_points),
    TriangleType::Type{V}=NTuple{3,I},
    check_existence::C=Val(has_multiple_segments(boundary_map)),
    store_history::F=Val(false),
    history=nothing,
    rng::AbstractRNG = Random.default_rng(),
    exterior_curve_index=1,
    maxiters = 2 + length(exterior_curve_index) - num_vertices(graph) + num_edges(graph)) where {I,V,C,F}</code></pre><p>Using the jump and march algorithm, finds the triangle in the triangulation containing the  query point <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points.</li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>boundary_index_ranges</code>: The <code>Dict</code> mapping boundary indices to ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>representative_point_list</code>: The <code>Dict</code> mapping curve indices to representative points.</li><li><code>boundary_map</code>: The boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> handling the mapping of boundary indices. </li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m=default_num_samples(num_points(pts))</code>: The number of samples to use when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>point_indices</code>: The indices for the points. Only relevant if <code>k</code> is not specified. </li><li><code>try_points=()</code>: Extra points to try when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>k=select_initial_point(pts, q; m, point_indices, try_points)</code>: Where to start the algorithm.</li><li><code>TriangleType::Type{V}=NTuple{3,I}</code>: The type used for representing the triangles. </li><li><code>check_existence::C=Val(has_multiple_segments(boundary_map))</code>: Whether to check that the edge exists when using <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li><li><code>store_history::F=Val(false)</code>: Whether to store visited triangles. Exterior ghost triangles will not be stored.</li><li><code>history=nothing</code>: The history. This should be a <a href="#DelaunayTriangulation.PointLocationHistory"><code>PointLocationHistory</code></a> type if <code>store_history</code> is <code>true</code>.</li><li><code>rng::AbstractRNG</code>: The RNG to use.</li><li><code>exterior_curve_index=1</code>: The curve (or curves) corresponding to the outermost boundary.</li><li><code>maxiters = 2 + length(exterior_curve_index) - num_vertices(graph) + num_edges(graph)</code>: Maximum number of iterations to perform before restarting the algorithm at a new initial point. The default comes from Euler&#39;s formula, rearranged for the number of triangles.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You shouldn&#39;t ever need <code>maxiters</code> if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the <code>maxiters</code> keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, <code>m</code> is set to <code>num_vertices(graph)</code>.</p></div></div><p><strong>Output</strong></p><p>Returns the triangle <code>V</code> containing the query point <code>q</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If your triangulation does not have ghost triangles, and the point <code>q</code> is outside of the triangulation,  this function may fail to terminate. You may like to add ghost triangles in this case (using  <a href="../../operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}"><code>add_ghost_triangles!</code></a>), noting that there is no actual triangle that <code>q</code> is inside of when it is outside of the triangulation unless ghost triangles are present. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/jump_and_march.jl#L78-L135">source</a></section></article><p>The variant of the jump and march algorithm for points outside of the triangle is also accessed via the <code>jump_and_march</code>, calling into <code>exterior_jump_and_march</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.exterior_jump_and_march" href="#DelaunayTriangulation.exterior_jump_and_march"><code>DelaunayTriangulation.exterior_jump_and_march</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exterior_jump_and_march(
    pts, 
    adj, 
    boundary_index_ranges, 
    representative_point_list,
    boundary_map, 
    k, 
    q, 
    check_existence=Val(has_multiple_segments(boundary_map)),
    bnd_idx=I(BoundaryIndex))</code></pre><p>Given a point <code>q</code> outside of the triangulation, finds the ghost triangle containing it.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points.</li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>boundary_index_ranges</code>: A <code>Dict</code> mapping boundary indices to ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>representative_point_list</code>: A <code>Dict</code> mapping curve indices to representative points.</li><li><code>boundary_map</code>: A boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The vertex to start from.</li><li><code>q</code>: The point outside of the triangulation.</li><li><code>check_existence=Val(has_multiple_segments(boundary_map)))</code>: Used to check that the edge exists when using <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, in case there are multiple segments.</li><li><code>bnd_idx=I(BoundaryIndex)</code>: A boundary index corresponding to the boundary that <code>k</code> is on.</li></ul><p><strong>Ouptut</strong></p><ul><li>The edge <code>(i, j)</code> such that the ghost triangle <code>(i, j, g)</code> contains <code>q</code>, and <code>g = get_adjacent(adj, i, j)</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The result is meaningless if <code>q</code> is inside of the triangulation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/jump_and_march.jl#L1-L32">source</a></section></article><p>You should not need to call into this method directly.</p><p>The core complexity of the algorithm comes from having to find the direction of the point from an initial search point. The docstrings for some of these initialisers are given below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.default_num_samples" href="#DelaunayTriangulation.default_num_samples"><code>DelaunayTriangulation.default_num_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_num_samples(num_points)</code></pre><p>Returns <code>ceil(cbrt(num_points))</code>. This is the default number of samples  to use when sampling in the jump-and-march algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.select_initial_point" href="#DelaunayTriangulation.select_initial_point"><code>DelaunayTriangulation.select_initial_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_initial_point(pts, q;
    point_indices=each_point_index(pts),
    m=default_num_samples(length(point_indices)),
    try_points=(),
    rng::AbstractRNG=Random.default_rng())</code></pre><p>Given a collection of points and a point <code>q</code>, select <code>m</code> random points from <code>pts</code> and return  the one that is closet to <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The set of points.</li><li><code>q</code>: The coordinates of the query point, or its index in <code>pts</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>point_indices=each_point_index(pts)</code>: The indices of the points to consider.</li><li><code>m=default_num_samples(length(point_indices))</code>: The number of points to sample.</li><li><code>try_points=()</code>: The indices of points to try in addition to the sampled points.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: The random number generator to use.</li></ul><p><strong>Outputs</strong></p><ul><li><code>k</code>: The index of the point in <code>pts</code> that is closest to <code>q</code> out of the points sampled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L20-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.select_initial_triangle_interior_node" href="#DelaunayTriangulation.select_initial_triangle_interior_node"><code>DelaunayTriangulation.select_initial_triangle_interior_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_initial_triangle_interior_node(
    pts, 
    adj, 
    adj2v, 
    graph,
    representative_point_list, 
    boundary_map, 
    k, 
    q, 
    boundary_index_ranges, 
    check_existence=Val(has_multiple_segments(boundary_map)),
    store_history=Val(false),
    history=nothing,
    rng::AbstractRNG = Random.default_rng())</code></pre><p>Selects an initial triangle for the jump-and-march algorithm, starting from a point with index <code>k</code>  and finding the triangle such that the line from the <code>k</code>th point to <code>q</code> intersects it. It is assumed  that <code>k</code> is a point that is not on the boundary. </p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The set of points. </li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>adj2v</code>: The <a href="../../data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map.</li><li><code>graph</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a> of the triangulation.</li><li><code>representative_point_list</code>: The list of representative points, giving the coordinates of points corresponding to boundary indices.</li><li><code>boundary_map</code>: The map taking boundary indices to their corresponding segment in the boundary nodes. See <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The index of the point in <code>pts</code> that we are starting at.</li><li><code>q</code>: The point being searched for.</li><li><code>boundary_index_ranges</code>: The <code>Dict</code> handling the mapping of boundary indices to the range of boundary indices belonging to the same curve. See <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence=Val(has_multiple_segments(boundary_map))</code>: Checks for different possible boundary indices when there are multiple segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li><li><code>store_history=Val(false)</code>: Whether to store visited triangles. Exterior ghost triangles will not be stored.</li><li><code>history=nothing</code>: The history. This should be a <a href="#DelaunayTriangulation.PointLocationHistory"><code>PointLocationHistory</code></a> type if <code>store_history</code> is <code>true</code>.</li><li><code>rng::AbstractRNG = Random.default_rng()</code>: The random number generator.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The <code>k</code>th point in <code>pts</code>.</li><li><code>i, j</code>: These are indices defining the edge of a triangle including the point <code>p</code>, such that <code>i</code> is to the left of the line <code>pq</code> and <code>j</code> is to the right of <code>pq</code>.</li><li><code>pᵢ, pⱼ</code>: The points in <code>pts</code> corresponding to the indices in <code>i</code> and <code>j</code>, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L147-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges" href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_adjacent_boundary_edges(
    pts, 
    adj, 
    boundary_index_ranges, 
    boundary_map, 
    k, 
    q, 
    check_existence = Val(has_multiple_segments(boundary_map)),
    bnd_idx=I(BoundaryIndex))</code></pre><p>Assuming that <code>k</code> is on the outer boundary, this function searches down the boundary edges adjacent to <code>k</code> to try and locate a triangle  or edge containing <code>q</code>.</p><p>See also <a href="#DelaunayTriangulation.search_down_adjacent_boundary_edges"><code>search_down_adjacent_boundary_edges</code></a>, which uses this function to determine an initial direction to search along a  straight boundary in case <code>q</code> is collinear with it.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The set of points. </li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>boundary_index_ranges</code>: The list of boundary index ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, giving a range of boundary indices for a given boundary index all belonging to the same curve. </li><li><code>boundary_map</code>: The boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, which maps a boundary index to its corresponding segment. </li><li><code>k</code>: The outer boundary point <code>k</code> to start searching from.</li><li><code>q</code>: The query point <code>q</code>.</li><li><code>check_existence</code>: The same keyword argument from <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, and is needed when you use multiple segments in your boundary.</li><li><code>bnd_idx=I(BoundaryIndex)</code>: The boundary index for the boundary that <code>k</code> is on.</li></ul><p><strong>Outputs</strong></p><p>The output is a 5-tuple, with the first three elements having several possible forms:</p><ul><li><code>(Certificate.Outside, Certificate.Outside, k)</code>: The point <code>q</code> is not collinear with either of the adjacent boundary edges.</li><li><code>(Certificate.Right, C, r)</code>, where <code>C</code> is either <code>Certificate.On</code> or <code>Certificate.Right</code> and <code>r</code> is the vertex right of <code>k</code>: The point <code>q</code> is collinear with the edge to the right of <code>k</code>. If <code>C</code> is <code>Certificate.On</code>, then <code>q</code> is on the edge, whereas <code>C</code> being <code>Certificate.Right</code> means it is right of the edge. </li><li><code>(Certificate.Left, C, ℓ)</code>, where <code>C</code> is either <code>Certificate.On</code> or <code>Certificate.Left</code> and <code>ℓ</code> is the vertex left of <code>k</code>: The point <code>q</code> is collinear with the edge to the left of <code>k</code>. If <code>C</code> is <code>Certificate.On</code>, then <code>q</code> is on the edge, whereas <code>C</code> being <code>Certificate.Left</code> means it is left of the edge.</li></ul><p>In the latter two outputs above, <code>C</code> could also be <code>Certificate.Degenerate</code>, which means that <code>q</code> is <code>get_point(pts, r)</code> or <code>get_point(pts, ℓ)</code>, respectively.</p><p>The latter two elements of the tuple are: </p><ul><li><code>right_cert</code>: The position of <code>q</code> relative to the edge <code>(p, p_right)</code>, where <code>p_right</code> is the point on the boundary to the right of <code>p</code>.</li><li><code>left_cert</code>: The position of <code>q</code> relative to the edge <code>(p, p_left)</code>, where <code>p_left</code> is the point on the boundary to the left of <code>p</code>.</li></ul><p>These returned values are useful in case we need to go to <a href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node"><code>check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code></a>, since we can reuse these certificates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L263-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.search_down_adjacent_boundary_edges" href="#DelaunayTriangulation.search_down_adjacent_boundary_edges"><code>DelaunayTriangulation.search_down_adjacent_boundary_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_down_adjacent_boundary_edges(
    pts, 
    adj,
    boundary_index_ranges, 
    representative_point_list, 
    boundary_map, 
    k, 
    q,
    direction, 
    q_pos, 
    next_vertex,
    check_existence=Val(has_multiple_segments(boundary_map)),
    store_history=Val(false),
    history=nothing,
    bnd_idx=I(BoundaryIndex))</code></pre><p>Starting at the outer boundary node <code>k</code>, walks down the boundary in the direction of <code>q</code> until finding <code>q</code> or finding that it is outside of the triangulation. </p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points.</li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>boundary_index_ranges</code>: The list of boundary index ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>representative_point_list</code>: The list of representative points. </li><li><code>boundary_map</code>: The boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The outer boundary index.</li><li><code>q</code>: The point being searched for.</li><li><code>direction</code>: The direction of <code>q</code> from <code>get_point(pts, k)</code>.</li><li><code>q_pos</code>: The certificate for the position of <code>q</code> from this point <code>k</code>.</li><li><code>next_vertex</code>: The next vertex in the direction of <code>q</code> (this argument comes from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>).</li><li><code>check_existence=Val(has_multiple_segments(boundary_map))</code>: The same keyword argument from <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, and is needed when you use multiple segments in your boundary.</li><li><code>store_history=Val(false)</code>: Whether to store the history of the search.</li><li><code>history=nothing</code>: The history of the search.</li><li><code>bnd_idx=I(BoundaryIndex)</code>: The boundary index for the boundary that <code>k</code> is on.</li></ul><p><strong>Outputs</strong></p><p>The output takes the form <code>(cert, u, v, w)</code>, where: </p><ul><li><code>cert</code>: This is <code>Certificate.On</code> if <code>q</code> is on the edge <code>(u, v)</code>, and <code>Certificate.Outside</code> if <code>q</code> is outside of the triangulation.</li><li><code>(u, v, w)</code>: If <code>is_on(cert)</code>, then this is a positively oriented triangle with <code>q</code> on the edge <code>(u, v)</code>. Otherwise, <code>(u, v, w)</code> is a ghost triangle close to <code>q</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function relies on the assumption that the geometry is convex.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L343-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node" href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node"><code>DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_interior_edges_adjacent_to_boundary_node(
    pts,
    adj, 
    graph, 
    boundary_index_ranges, 
    representative_point_list,
    boundary_map, 
    k, 
    q, 
    right_cert, 
    left_cert, 
    check_existence=Val(has_multiple_segments(boundary_map)), 
    store_history=Val(false), 
    history=nothing,
    bnd_idx=I(BoundaryIndex))</code></pre><p>Checks if the line connecting the <code>k</code>th point of <code>pts</code> to <code>q</code> intersects any of the edges neighbouring the boundary node <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points. </li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>boundary_index_ranges</code>: The boundary index range mapping from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>representative_point_list</code>: The list of representative points.</li><li><code>boundary_map</code>: The map that handles the mapping of boundary indices to boundary segments. Sse <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The boundary node.</li><li><code>q</code>: The point we are searching for. </li><li><code>right_cert</code>: A certificate giving the position of <code>q</code> to the right of the <code>k</code>th point. This comes from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>left_cert</code>: A certificate giving the position of <code>q</code> to the left of the <code>k</code>th point. This comes from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>check_existence=Val(has_multiple_segments(boundary_nodes)))</code>: Checks for different possible boundary indices when there are multiple segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li><li><code>store_history=Val(false)</code>: Whether to store visited triangles. Exterior ghost triangles will not be stored.</li><li><code>history=nothing</code>: The history. This should be a <a href="#DelaunayTriangulation.PointLocationHistory"><code>PointLocationHistory</code></a> type if <code>store_history</code> is <code>true</code>.</li><li><code>bnd_idx=I(BoundaryIndex)</code>: The boundary index for the boundary that <code>k</code> is on.</li></ul><p><strong>Outputs</strong></p><p>There are several possible forms for the returned values. These are listed below, letting <code>p</code> be the <code>k</code>th point, <code>pᵢ</code> the point corresponding to  the index <code>i</code>, and <code>pⱼ</code> the point corresponding to the index <code>j</code>:</p><ul><li><code>(i, j, Certificate.Single, Certificate.Outside)</code></li></ul><p>The line <code>pq</code> intersects the edge <code>pᵢpⱼ</code>, and <code>(j, i, k)</code> is a positively oriented triangle. In particular, pᵢ is left of <code>pq</code> and <code>pⱼ</code> is right of <code>pq</code>.</p><ul><li><code>(i, j, Certificate.None, Certificate.Inside)</code></li></ul><p>The point <code>q</code> is inside the positively oriented triangle <code>(i, j, k)</code>.</p><ul><li><code>(zero(I), zero(I), Cert.None, Cert.Outside)</code></li></ul><p>The point <code>q</code> is outside of the triangulation. Note that <code>I</code> is the integer type.</p><ul><li><code>(i, j, Cert.On, Cert.Inside)</code></li></ul><p>The point <code>q</code> is on the edge <code>pᵢpⱼ</code>, and so is inside the positively oriented triangle <code>(i, j, k)</code>.</p><ul><li><code>(i, j, Cert.Right, Cert.Outside)</code></li></ul><p>The point <code>q</code> is collinear with the edge <code>pᵢpⱼ</code>, but is off of it and further into the triangulation. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function should only be used after <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>, and currently is only guaranteed to work on convex geometries. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/point_location/initialisers.jl#L458-L516">source</a></section></article><h2 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h2><p>If you need to, you can also store the history of the algorithm. This is primarily only used for (and only tested for) constrained triangulations, as it helps us locate which triangles to delete. The struct we use for storing history is given below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.PointLocationHistory" href="#DelaunayTriangulation.PointLocationHistory"><code>DelaunayTriangulation.PointLocationHistory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointLocationHistory{T,E,I}</code></pre><p>History from using <a href="#DelaunayTriangulation.jump_and_march"><code>jump_and_march</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>triangles::Vector{T}</code>: The visited triangles. </li><li><code>collinear_segments::Vector{E}</code>: Segments collinear with the original line <code>pq</code> using to jump.</li><li><code>collinear_point_indices::Vector{I}</code>: This field contains indices to segments in <code>collinear_segments</code> that refer to points that were on the original segment, but there is no valid segment for them. We use manually fix this after the fact. For example, we could add an edge <code>(1, 14)</code>, when really we mean something like <code>(7, 14)</code> which isn&#39;t a valid edge.</li><li><code>left_vertices::Vector{I}</code>: Vertices from the visited triangles to the left of <code>pq</code>.</li><li><code>right_verices::Vector{I}</code>: Vertices from the visited triangles to the right of <code>pq</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/b6b867c1f6c089b7ca3a6192a5abb21365cef33c/src/data_structures/point_location_history.jl#L1-L12">source</a></section></article><h2 id="Basic-Description-of-the-Algorithm"><a class="docs-heading-anchor" href="#Basic-Description-of-the-Algorithm">Basic Description of the Algorithm</a><a id="Basic-Description-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Description-of-the-Algorithm" title="Permalink"></a></h2><p>Let us give a basic description of what <code>jump_and_march</code> does.</p><p>First, using <code>select_initial_point</code>, an initial point to start the algorithm is selected. This function samples some number <span>$m$</span> of points, and then selects the point that is closest to the query point <span>$q$</span>.</p><p>Let the initially selected point be <span>$p_k$</span>. We break the discussion into two cases, where <span>$p_k$</span> is an interior point and <span>$p_k$</span> is a point on the boundary.</p><p>If <span>$p_k$</span> is not a point on the boundary, then it is possible to completely rotate around the point searching for a triangle such that line <span>$\overrightarrow{p_kq}$</span> intersects an edge of the triangle. This will give us an edge <span>$e_{ij}$</span> that <span>$\overrightarrow{p_kq}$</span> intersects, and we will put <span>$p_i$</span> to the left of <span>$\overrightarrow{p_kq}$</span> and <span>$p_j$</span> to the right. The function that handles this selection is <code>select_initial_triangle_interior_node</code>, which starts by handling the case of collinear edges and then rotates around. </p><p>Now suppose that <span>$p_k$</span> is a point on the outer boundary. There are several possibilities in this case. First, <span>$\overrightarrow{p_kq}$</span> might intersect a neighbouring boundary edge; secondly, <span>$\overrightarrow{p_kq}$</span> could intersect a neighbouring interior edge; thirdly, <span>$\overrightarrow{p_kq}$</span> could point away from the boundary, meaning <span>$q$</span> is outside of the boundary. The function starts by checking the neighbouring boundary edges, done via <code>check_for_intersections_with_adjacent_boundary_edges</code>, making use of <code>get_right_boundary_node</code> and <code>get_left_boundary_node</code> to obtain the neighbouring boundary nodes. If we find that <span>$\overrightarrow{p_kq}$</span> does intersect a neighbouring boundary edge, then we can search down adjacent boundary edges via <code>search_down_adjacent_boundary_edges</code> until we either find an edge that <span>$q$</span> is on, or until we identify that <span>$q$</span> is outside of the triangulation – this function assumes the domain is convex, as triangulations being built are. If <span>$q$</span> is outside of the triangulation, then we can use the exterior variant of the jump and march algorithm, <code>exterior_jump_and_march</code>, to find the ghost triangle containing <span>$q$</span>. This functon simply rotates around the boundary until we find two ghost edges enclosing the point <span>$q$</span>. Now let us assume we did not find a neighbouring boundary edge that intersects <span>$\overrightarrow{p_kq}$</span>. When this happens, we need to check the neighbouring interior edges, done via <code>check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code>, which just rotates around the edges until we find an intersection. If we have still not found any intersection then, again assuming convexity, <span>$q$</span> must be outside of the triangulation and so we use <code>exterior_jump_and_march</code>.</p><p>Now, if the algorithm is still going, then we need to start marching along the triangulation from <span>$p_k$</span> towards <span>$q$</span>. The idea is to keep marching, keeping <span>$p_i$</span> and <span>$p_j$</span> to the left and right of <span>$\overrightarrow{p_kq}$</span>, respectively, until we find a case where <span>$p_ip_jq$</span> is no longer a positively oriented triangle. When this happens, it must mean that we have passed <span>$q$</span>, and so we have found the triangle. </p><p>Let us describe how this marching is done in more detail. First, we need to be careful of boundary indices, first checking for an outer boundary index. If we have found an outer boundary index, then we have marched into the boundary, and so <span>$q$</span> will be outside of the domain, meaning we go into <code>exterior_jump_and_march</code>. If this is not the case, then we march using <code>get_adjacent</code> to step onto the next triangle from a given edge <span>$e_{ij}$</span>. Then, checking the positions of the new points relative to <span>$\overrightarrow{p_kq}$</span> and rearranging accordingly, we can step forward. We keep doing this until we get a negatively oriented triangle <span>$p_ip_jq$</span>. Unfortunately, this loop could terminate even if <span>$q$</span> is not in the found triangle, which can occasionally happen if <span>$p_ip_jq$</span> is a degenerate triangle. In this case, we just restart the jump and march algorithm. This latter worry is a very rare concern and does not alter the runtime in any significant manner.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../operations/">« Operations</a><a class="docs-footer-nextpage" href="../pole_of_inaccessibility/">Pole of Inaccessibility and Polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 15 April 2023 08:22">Saturday 15 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
