<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Nodes · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/boundary_nodes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li><a class="tocitem" href="../edges/">Edges</a></li><li><a class="tocitem" href="../points/">Points</a></li><li class="is-active"><a class="tocitem" href>Boundary Nodes</a><ul class="internal"><li><a class="tocitem" href="#Boundary-Nodes"><span>Boundary Nodes</span></a></li></ul></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Boundary Nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Nodes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/boundary_nodes.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Boundary-Nodes"><a class="docs-heading-anchor" href="#Boundary-Nodes">Boundary Nodes</a><a id="Boundary-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Nodes" title="Permalink"></a></h2><p>As mentioned at the start of this section, the interface for representing boundary nodes allows for support for a contiguous boundary, a segmented boundary, and multiple separate boundaries. (There is also support for more complex geometries, as described in the constrained triangulation section, although features like point location have limited support for e.g. non-convex domains and regions with holes inside holes.) This interface is customisable, and we define the following methods for this.</p><h3 id="Necessary-Methods"><a class="docs-heading-anchor" href="#Necessary-Methods">Necessary Methods</a><a id="Necessary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_curves" href="#DelaunayTriangulation.has_multiple_curves"><code>DelaunayTriangulation.has_multiple_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_multiple_curves(bn::A) where {A}</code></pre><p>Returns <code>true</code> if the given set of boundary nodes <code>bn</code> defines multiple curves,  meaning disjoint boundary curves. We currently define the methods </p><pre><code class="nohighlight hljs">has_multiple_curves(::AAA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A},AAA&lt;:AV{AA}} 
has_multiple_curves(::AA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A}} 
has_multiple_curves(::A) where {F&lt;:Number,A&lt;:AV{F}}</code></pre><p>with the first method returning <code>true</code>, while the last two methods return <code>false</code>, and <code>AV = AbstractVector</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_segments" href="#DelaunayTriangulation.has_multiple_segments"><code>DelaunayTriangulation.has_multiple_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_multiple_segments(bn::A) where {A}</code></pre><p>Returns <code>true</code> if the given set of boundary nodes <code>bn</code> contains multiple segments,  meaning disjoint boundary curves. We currently define the methods </p><pre><code class="nohighlight hljs">has_multiple_segments(::AAA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A},AAA&lt;:AV{AA}} 
has_multiple_segments(::AA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A}} 
has_multiple_segments(::A) where {F&lt;:Number,A&lt;:AV{F}}</code></pre><p>with the first and second methods returning <code>true</code>, while the last method returns <code>false</code>, and <code>AV = AbstractVector</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L27-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_curves" href="#DelaunayTriangulation.num_curves"><code>DelaunayTriangulation.num_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_curves(bn::A)</code></pre><p>Returns the number of <code>curves</code> defined by the boundary nodes <code>bn</code>. We currently  define the methods</p><pre><code class="nohighlight hljs">num_curves(bn::AAA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A},AAA&lt;:AV{AA}}</code></pre><p>which simply returns <code>bn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_segments" href="#DelaunayTriangulation.num_segments"><code>DelaunayTriangulation.num_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_segments(bn::A)</code></pre><p>Returns the number of <code>segments</code> defined by the boundary nodes <code>bn</code>. We currently  define the method</p><pre><code class="nohighlight hljs">num_segments(bn::AA) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A}}</code></pre><p>which simply returns <code>length(bn)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_boundary_edges" href="#DelaunayTriangulation.num_boundary_edges"><code>DelaunayTriangulation.num_boundary_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_boundary_edges(bn)</code></pre><p>Given a collection of boundary nodes <code>bn</code>, returns the number of edges. This only  needs to be defined for individual segments. We define the method </p><pre><code class="nohighlight hljs">num_boundary_edges(bn::A) where {A&lt;:AbstractVector}</code></pre><p>which returns <code>length(bn) - 1</code> (<code>-1</code> because it is assumed that <code>bn[begin] == bn[end]</code>).  This is the only method that needs to be extended.</p><p>See also <a href="#DelaunayTriangulation.getboundarynodes"><code>getboundarynodes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getboundarynodes" href="#DelaunayTriangulation.getboundarynodes"><code>DelaunayTriangulation.getboundarynodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getboundarynodes(bn::A, mnℓ...)</code></pre><p>Given a collection of boundary nodes <code>bn</code>, returns the specified component of the  collection. There are several forms for the methods. In these methods, it is assumed  that one-based indexing is used for accessing all the boundary nodes. If you want to  use offsets, for example, then define <code>getboundarynodes</code> appropriately (e.g. maybe  <code>getboundarynodes(bn, m)</code> could map <code>m</code> to <code>m-4</code> if <code>4</code> is your offset).</p><p>The methods that you need to define are those that go down a level, i.e. from a set of curves  to a curve, from a set of segments to a set of nodes, and from a set of nodes to a node. Of course,  if you only ever use e.g. a set of nodes, then you need only define that method. The methods that  we define for this are</p><pre><code class="nohighlight hljs">getboundarynodes(bn::AAA, m::Integer) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A},AAA&lt;:AV{AA}} 
getboundarynodes(bn::AA, n::Integer) where {F&lt;:Number,A&lt;:AV{F},AA&lt;:AV{A}} 
getboundarynodes(bn::A, ℓ::Integer) where {F&lt;:Number,A&lt;:AV{F}}</code></pre><p>The first method takes a set of curves to the <code>m</code>th curve, the second takes a set of segments to the  <code>n</code>th segment, and the third takes a set of nodes to the <code>ℓ</code>th node. These are the only methods  that need to be extended. For the set of curves case, we also define</p><pre><code class="nohighlight hljs">getboundarynodes(bn, m::Integer, n::Integer)
getboundarynodes(bn, (m, n)::NTuple{2,Integer})</code></pre><p>which calls <code>getboundarynodes(getboundarynodes(bn, m), n)</code>. This does not need to be extended. Lastly,  we also define </p><pre><code class="nohighlight hljs">getboundarynodes(bn::A, ::A) where {A}</code></pre><p>which simply returns <code>bn</code>. This is useful when using the result of <a href="#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L101-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_boundary_node" href="#DelaunayTriangulation.each_boundary_node"><code>DelaunayTriangulation.each_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_boundary_node(bn::A)</code></pre><p>Returns an iterator that goes over each node in <code>bn</code>. Only defined for  single segments so that <code>bn</code> acts like a vector of numbers. The only method  currently defined is </p><pre><code class="nohighlight hljs">each_boundary_node(bn::A) where {F&lt;:Number,A&lt;:AbstractVector{F}}</code></pre><p>which just returns <code>bn</code>. You can extend this function as you need. If you really  want to loop over every boundary node, you can make use of the result from  <a href="#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L152-L164">source</a></section></article><h3 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_nodes-Tuple{Any, Vararg{Any}}" href="#DelaunayTriangulation.get_boundary_nodes-Tuple{Any, Vararg{Any}}"><code>DelaunayTriangulation.get_boundary_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_nodes(bn, mnℓ...)</code></pre><p>Get the boundary nodes from <code>bn</code> corresponding to the specified indices.  See <a href="#DelaunayTriangulation.getboundarynodes"><code>getboundarynodes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_boundary_map" href="#DelaunayTriangulation.construct_boundary_map"><code>DelaunayTriangulation.construct_boundary_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_boundary_map(bn; IntegerType::Type{I} = Int) where {I}</code></pre><p>Given a set of boundary nodes <code>bn</code>, returns a <code>OrderedDict</code> that maps boundary indices  to their position in <code>bn</code>. In particular:</p><ul><li><code>has_multiple_curves(bn)</code></li></ul><p>In this case, the result is a <code>dict = OrderedDict{I, NTuple{2, I}}</code>. The results will be of the form  <code>dict[i] = (m, n)</code>, so that boundary indices with value <code>i</code> correspond to nodes at  <code>get_boundary_nodes(bn, m, n)</code>, i.e. the <code>n</code>th segment of the <code>m</code>th curve.</p><ul><li><code>has_multiple_segments(bn)</code></li></ul><p>In this case, the result is a <code>dict = OrderedDict{I, I}</code>. The results will be of the form <code>dict[i] = n</code>, so that boundary indices with value <code>i</code> correspond to nodes at <code>get_boundary_nodes(bn, n)</code>, i.e.  the <code>n</code>th segment.</p><ul><li><code>else</code></li></ul><p>Here, the result is a <code>dict = OrderedDict{I, F}</code>, mapping <code>-1</code> back to <code>bn</code> and <code>F = typeof(bn)</code>.</p><p><strong>Iteration Tips</strong></p><p>This dict can be useful for iterating over all boundary nodes. For example, you could do</p><pre><code class="language-julia hljs">bn_map = construct_boundary_map(bn)
for segment_index in values(bn_map)
    nodes = get_boundary_nodes(bn, segment_index)
    ## Do something with the nodes 
end </code></pre><p>The above will work for any form of <code>bn</code> also.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L171-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_boundary_index_ranges" href="#DelaunayTriangulation.construct_boundary_index_ranges"><code>DelaunayTriangulation.construct_boundary_index_ranges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_boundary_index_ranges(boundary_nodes; IntegerType::Type{I}=Int) where {I}</code></pre><p>Given a set of <code>boundary_nodes</code>, creates an <code>OrderedDict</code> that maps boundary indices  to the range of all boundary indices that the corresponding boundary curve could  correspond to. For example, suppose we have </p><pre><code class="language-julia-repl hljs">julia&gt; boundary_nodes = [
           [
               [1, 2, 3, 4], [4, 5, 6, 1]
           ],
           [
               [18, 19, 20, 25, 26, 30]
           ],
           [
               [50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]
           ]
       ]</code></pre><p>Then the first curve, <code>[[1, 2, 3, 4], [4, 5, 6, 1]]</code> has boundary indices <code>-1</code> and <code>-2</code>,  so the range would be <code>-2:-1</code>. The full <code>Dict</code> we obtain will be </p><pre><code class="language-julia-repl hljs">julia&gt; construct_boundary_index_ranges(boundary_nodes)
OrderedDict{Int, UnitRange{Int}} with 7 entries:
  -1 =&gt; -2:-1
  -2 =&gt; -2:-1
  -3 =&gt; -3:-3
  -4 =&gt; -7:-4
  -5 =&gt; -7:-4
  -6 =&gt; -7:-4
  -7 =&gt; -7:-4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L386-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.map_boundary_index-Tuple{Any, Any}" href="#DelaunayTriangulation.map_boundary_index-Tuple{Any, Any}"><code>DelaunayTriangulation.map_boundary_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_boundary_index(dict, i)</code></pre><p>Given a <code>dict</code> from <a href="#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, returns <code>dict[i]</code>. Also works  for a <code>dict</code> from <a href="#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L328-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_curve_index" href="#DelaunayTriangulation.get_curve_index"><code>DelaunayTriangulation.get_curve_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_curve_index(dict, i)
get_curve_index(i)</code></pre><p>Given a <code>dict</code> from <a href="#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> and a boundary index <code>i</code>,  returns the index of the curve corresponding to that boundary index. The  second method maps <code>i</code> to <code>1</code> if it is an integer, and <code>i[1]</code> if it is a <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_segment_index" href="#DelaunayTriangulation.get_segment_index"><code>DelaunayTriangulation.get_segment_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_segment_index(dict, i)
get_segment_index(i)</code></pre><p>Given a <code>dict</code> from <a href="#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> and a boundary index <code>i</code>,  returns the index of the segment corresponding to that boundary index. The  second method maps <code>i</code> to <code>i</code> if it is an integer, <code>1</code> if it is a vector,  and <code>i[2]</code> if it is a <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L349-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_outer_boundary_segments" href="#DelaunayTriangulation.num_outer_boundary_segments"><code>DelaunayTriangulation.num_outer_boundary_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_outer_boundary_segments(boundary_nodes)</code></pre><p>Given a set of <code>boundary_nodes</code>, returns the number of segments  that correspond to the outer boundary. Note that this also gives  the range of outer boundary indices, i.e.  <code>-1:-1:-num_outer_boundary_segments(boundary_nodes)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L364-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_boundary_edge_map" href="#DelaunayTriangulation.construct_boundary_edge_map"><code>DelaunayTriangulation.construct_boundary_edge_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_boundary_edge_map(bn::A; IntegerType::Type{I}=Int, EdgeType::Type{E}=NTuple{2,IntegerType}) where {A,I,E}</code></pre><p>Constructs a map that takes boundary edges <code>(i,j)</code> to a <code>Tuple</code> giving the edge&#39;s position in the corresponding  set of boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.insert_boundary_node!" href="#DelaunayTriangulation.insert_boundary_node!"><code>DelaunayTriangulation.insert_boundary_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_boundary_node!(bn, pos, node)</code></pre><p>Inserts a boundary node <code>node</code> into the set of boundary nodes <code>bn</code> at the position pos. The first element of <code>pos</code>  finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the  second element of <code>pos</code> gives the position of the array to insert <code>node</code> into. In particular, </p><pre><code class="nohighlight hljs">insert_boundary_node!(bn, pos, node)</code></pre><p>is the same as </p><pre><code class="nohighlight hljs">insert!(get_boundary_nodes(bn, pos[1]), pos[2], node)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L280-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_boundary_node!" href="#DelaunayTriangulation.delete_boundary_node!"><code>DelaunayTriangulation.delete_boundary_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_boundary_node!(bn, pos)</code></pre><p>Deletes a boundary node from the set of boundary nodes <code>bn</code> at the position pos. The first element of <code>pos</code> finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the second element of <code>pos</code> gives the position of the array to delete. In particular,</p><pre><code class="nohighlight hljs">delete_boundary_node!(bn, pos)</code></pre><p>is the same as</p><pre><code class="nohighlight hljs">deleteat!(get_boundary_nodes(bn, pos[1]), pos[2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/f9d12c5c41bcbf66fffd14a06953458e845feabc/src/interfaces/boundary_nodes.jl#L300-L312">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../points/">« Points</a><a class="docs-footer-nextpage" href="../example/">Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 August 2023 06:03">Tuesday 1 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
