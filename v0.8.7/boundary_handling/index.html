<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Handling · DelaunayTriangulation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/boundary_handling/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li class="is-active"><a class="tocitem" href>Boundary Handling</a><ul class="internal"><li><a class="tocitem" href="#Boundary-Indices"><span>Boundary Indices</span></a></li><li><a class="tocitem" href="#Ghost-Triangles"><span>Ghost Triangles</span></a></li><li><a class="tocitem" href="#Boundary-Specification"><span>Boundary Specification</span></a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../interface/edges/">Edges</a></li><li><a class="tocitem" href="../interface/points/">Points</a></li><li><a class="tocitem" href="../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../interface/example/">Example</a></li><li><a class="tocitem" href="../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li><a class="tocitem" href="../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Boundary Handling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Handling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/boundary_handling.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations"><a class="docs-heading-anchor" href="#Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations">Ghost Triangles, Boundary Handling, and Boundary Specifcations</a><a id="Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations-1"></a><a class="docs-heading-anchor-permalink" href="#Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations" title="Permalink"></a></h1><p>Here we will give a description about how we represent boundaries, and also how we use ghost triangles.</p><h2 id="Boundary-Indices"><a class="docs-heading-anchor" href="#Boundary-Indices">Boundary Indices</a><a id="Boundary-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Indices" title="Permalink"></a></h2><p>We use negative indices to denote vertices belonging to a boundary. For example, if <code>tri</code> is a triangulation and <code>get_adjacent(adj, u, v) == -1</code>, then this means that <code>(u, v)</code> is an edge on the boundary. We call this <code>-1</code> a ghost vertex or a boundary index (positive vertices could also be called solid vertices), with <code>-1</code> defined from <code>DelaunayTriangulation.BoundaryIndex</code>, which we discuss more in the next section.</p><p>In the case of a single contiguous outer boundary, having <code>-1</code> as the only boundary index is simple and works fine. If we have multiple segments or multiple boundaries, then we need to somehow have multiple boundary indices so that we can refer to each segment separately. We accomplish this by simply subtracting 1 from the current boundary index for each new segment. This is handled by <code>add_boundary_information!</code>. For example, if we had</p><pre><code class="language-julia hljs">bn = [
    [segment_1, segment_2, segment_3],
    [segment_4, segment_5],
    [segment_6],
    [segment_7, segment_8, segment_9, segment_10]
]</code></pre><p>then the <code>i</code>th segment will map to <code>-i</code>. Note that this always means that <code>-1</code> belongs to the outer-most boundary. There is a possible issue we can have with this when, for example, stepping around a boundary, since nodes will occur in two segments and hence nodes may not necessarily have a unique boundary index assigned to them. To handle this case, allowing us to check for all possible boundary indices when stepping around a boundary (or however else we might want to use <code>Adjacent</code> or similar), <code>get_adjacent</code> can call a safer version <code>_safe_get_adjacent</code>, which checks the boundary indices using <code>boundary_index_ranges</code>.</p><p>These issues are why the <code>Triangulation</code> data structure has the <code>boundary_map</code> and <code>boundary_index_ranges</code> fields. <code>boundary_map</code>, constructed with <code>construct_boundary_map</code>, is used to map a boundary index to its segment in the set of boundary nodes, so that <code>get_boundary_nodes(boundary_nodes, map_boundary_index(boundary_map, g))</code> gives the nodes corresponding to the segment which has boundary index <code>g</code>. To handle the issue with a curve having multiple boundary indices, we use <code>boundary_index_ranges</code>, constructed with <code>construct_boundary_index_ranges</code>, to map a boundary index <code>g</code> to all other indices that could be found on the associated curve. For example, in the <code>bn</code> example above, <code>-2</code> would map to <code>-3:-1</code>.</p><h2 id="Ghost-Triangles"><a class="docs-heading-anchor" href="#Ghost-Triangles">Ghost Triangles</a><a id="Ghost-Triangles-1"></a><a class="docs-heading-anchor-permalink" href="#Ghost-Triangles" title="Permalink"></a></h2><p>Ghost triangles are a special triangle that has a solid edge <code>(u, v)</code> and a vertex <code>g</code> associated with some boundary index. These ghost triangles are needed to make point location actually work properly when points are outside of the triangle, provided we associate the ghost vertex <code>g</code> with a physical point. For the outer-most boundary, this physical point just has to be somewhat in the center of the domain, which we define using a centroid when building the triangulation and the pole of inaccessibility once we have built the entire triangulation. With this physical point, ghost edges <code>(u, g)</code> are then interpreted to be of infinite extent, pointing from <code>u</code> out to infinity, but collinear with this central point. </p><p>In the case of an inner boundary, these ghost edges are of finite extent, simply connecting with the point <code>g</code> which is define via the pole of inaccessibility.</p><p>For the Bowyer-Watson algorithm, we need a definition for the circumcircle of a ghost triangle. For ghost triangles that belong to inner boundaries, we simply use the triangle that connects the points, since there is no issue with infinity here. For the outer ghost triangles, we need to be careful. Imagine taking a triangle and pulling away one of its vertices to infinity. The circumcircle would keep growing until it eventually covers the entire space on the side of the fixed edge that the point was on. In particular, the circle becomes the line through the fixed edge, dividing the plane into two half-planes. We then say that a point is in the circumcircle of an outer ghost triangle if it is in the open half-plane on the other side of the edge from the triangulation, or if it is on the edge itself (but is not one of the vertices). The union of the open half-plane and this open edge is called the outer half-plane of the edge.</p><h2 id="Boundary-Specification"><a class="docs-heading-anchor" href="#Boundary-Specification">Boundary Specification</a><a id="Boundary-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Specification" title="Permalink"></a></h2><p>When considering constrained triangulations, we allow for a set of boundary nodes to be provided. These nodes can be defined to represent three possible domains:</p><ol><li>A contiguous boundary with no holes. For example, a circle.</li><li>A single boundary with no holes, but the boundary is split into multiple segments that can be identified separately via boundary indices. For example, a square with a boundary index for each side.</li><li>A boundary comprising multiple disjoint curves, i.e. a multiply-connected domain. For example, a square with a circular hole inside. The most support is provided for the case where no interior hole contains another interior, but it is allowed (see the discussion in the constrained triangulation section).</li></ol><p>We do also provide support for much more complex geometries, such as disjoint regions, but the support is only for constructing the mesh. Limited support exists, for example, for point location in such regions. See the examples in the constrained triangulation section. There might also be issues with domains that are non-convex.</p><p>The way to represent boundaries can be customised as needed (see the Interfaces section), but by default we provide the following specifications; this specification is what we use in the <code>convert_boundary_points_to_indices</code> function. The specification that follows is also valid for <code>generate_mesh</code> where coordinates are used instead of indices. Let <code>bn</code> be the set of boundary nodes and <code>I</code> the integer type.</p><h3 id="Contiguous-boundary"><a class="docs-heading-anchor" href="#Contiguous-boundary">Contiguous boundary</a><a id="Contiguous-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Contiguous-boundary" title="Permalink"></a></h3><p>For a contiguous boundary, <code>bn</code> should be a single <code>Vector{I}</code> such that <code>bn[begin] == bn[end]</code>, defining a boundary in counter-clockwise order. </p><h3 id="Single-boundary-split-into-segments"><a class="docs-heading-anchor" href="#Single-boundary-split-into-segments">Single boundary split into segments</a><a id="Single-boundary-split-into-segments-1"></a><a class="docs-heading-anchor-permalink" href="#Single-boundary-split-into-segments" title="Permalink"></a></h3><p>Now consider a single boundary with no holes, but given by multiple segments, say into <code>ns</code> segments. Then <code>bn</code> should be a <code>Vector{Vector{I}}</code> with <code>length(bn) = ns</code>. The vectors should be defined such that the endpoints connect, meaning <code>bn[i][end] == bn[i+1][begin]</code> for <code>i &lt; ns</code> or <code>bn[end][end] == bn[begin][begin]</code>. Additionally, the nodes should be defined in counter-clockwise order. </p><h3 id="Multiply-connected-domain"><a class="docs-heading-anchor" href="#Multiply-connected-domain">Multiply-connected domain</a><a id="Multiply-connected-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Multiply-connected-domain" title="Permalink"></a></h3><p>Now suppose we have a boundary that is split into multiple curves, say into <code>nc</code> curves. In this case, <code>bn</code> is a <code>Vector{Vector{Vector{I}}}</code> where each individual curve <code>bn[i]</code> is assumed to represent a single boundary split into segments, with each <code>bn[i]</code> matching the previous specification. In this case, we provide the most support for the case where <code>bn[1]</code> is the outermost boundary curve, and all curves <code>bn[i]</code> for <code>i &gt; 1</code> are inside <code>bn[1]</code>. With this, <code>bn[1]</code> should be counter-clockwise, while <code>bn[i]</code> for <code>i &gt; 1</code> should be clockwise. While it is possible to place interior curves inside other interior curves, e.g. <code>bn[j]</code> could be inside <code>bn[i]</code> as long as <code>bn[j]</code> is counter-clockwise, less support for point location and other features is provided for this case. See the constrained triangulation section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tessellations/lloyd/">« Centroidal Voronoi Tessellation</a><a class="docs-footer-nextpage" href="../data_structures/adjacent/">Adjacent »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 15 August 2023 04:48">Tuesday 15 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
