var documenterSearchIndex = {"docs":
[{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/point_location/#Point-Location","page":"Point Location","title":"Point Location","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The most expensive step for building a Delaunay triangulation is the point location step, wherein we need to find a triangle that contains a given point. The code for this turns out to be very complicated so that we can correctly handle points outside of the domain, inside interior holes, collinear with other points, on the corner, etc. The main function that handles all of this is jump_and_march, derived from the jump-and-march algorithm of Mücke, Saias, and Zhu (1999). We also provide a method that simply searches over all triangles, given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"brute_force_search","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.brute_force_search","page":"Point Location","title":"DelaunayTriangulation.brute_force_search","text":"brute_force_search(tri::Triangulation, q; itr = each_triangle(tri)\n\nReturns the triangle in tri containing q using brute force search.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#The-Main-Method","page":"Point Location","title":"The Main Method","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Below we list docstrings for the main jump and march algorithm.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"jump_and_march ","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.jump_and_march","page":"Point Location","title":"DelaunayTriangulation.jump_and_march","text":"jump_and_march(tri::Triangulation, q;\n    point_indices=each_point_index(tri),\n    m=default_num_samples(length(point_indices)),\n    try_points=(),\n    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),\n    check_existence::C=Val(has_multiple_segments(tri)),\n    store_history::F=Val(false),\n    history=nothing,\n    rng::AbstractRNG=Random.default_rng(),\n    exterior_curve_index=1,\n    maxiters=2 + length(exterior_curve_index) - num_solid_vertices(tri) + num_solid_edges(tri)) where {C,F}\n\nReturns the triangle containing q using the jump-and-march algorithm.\n\nArguments\n\ntri::Triangulation: The triangulation.\nq: The query point.\n\nKeyword Arguments\n\npoint_indices=each_point_index(tri): The indices of the points in the triangulation.\nm=default_num_samples(length(point_indices)): The number of samples to use when sampling the point to start the algorithm at.\ntry_points=(): Additional points to try when determining which point to start at.\nk=select_initial_point(get_points(tri), q; m, point_indices, try_points): The index of the point to start the algorithm at. \nstore_history::F=Val(false): Whether to record the history of the algorithm. See also PointLocationHistory.\nhistory=nothing: The object to store the history into, if is_true(store_history).\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nmaxiters = num_triangles(tri): Maximum number of iterations to perform before restarting the algorithm at a new initial point. \nconcavity_protection=false: When your triangulation has concave boundaries, it is possible that a ghost triangle is incorrectly classified as containing the point. By setting this to true, this will be protected against.\n\nnote: Note\nYou shouldn't ever need maxiters if your triangulation is convex everywhere, as Delaunay triangulations  have no problems with jump-and-march, as the sequence of triangles visited is acyclic (H. Edelsbrunner, An acyclicity theorem for cell complexes in d dimensions, Combinatorica 10 (1990) 251– 260.) However, if the triangulation is not convex, e.g. if you have a constrained triangulation with boundaries  and excavations, then an infinite loop can be found where we just keep walking in circles. In this case,  you can use the maxiters keyword argument to specify the maximum number of iterations to perform before reinitialising the algorithm at a random vertex. When reinitialising, the value of m is doubled each time.\n\nOutputs\n\nReturns V, the triangle in tri containing q.\n\nwarning: Warning\nIf your triangulation does not have ghost triangles, and the point q is outside of the triangulation,  this function may fail to terminate. You may like to add ghost triangles in this case (using  add_ghost_triangles!), noting that there is no actual triangle that q is inside of when it is outside of the triangulation unless ghost triangles are present. \n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The variant of the jump and march algorithm for points outside of the triangle is also accessed via the jump_and_march, calling into exterior_jump_and_march:","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"exterior_jump_and_march","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.exterior_jump_and_march","page":"Point Location","title":"DelaunayTriangulation.exterior_jump_and_march","text":"exterior_jump_and_march(\n    pts, \n    adj, \n    boundary_index_ranges, \n    representative_point_list,\n    boundary_map, \n    k, \n    q, \n    check_existence=Val(has_multiple_segments(boundary_map)),\n    bnd_idx=I(BoundaryIndex))\n\nGiven a point q outside of the triangulation, finds the ghost triangle containing it.\n\nArguments\n\npts: The collection of points.\nadj: The Adjacent map.\nboundary_index_ranges: A Dict mapping boundary indices to ranges from construct_boundary_index_ranges.\nrepresentative_point_list: A Dict mapping curve indices to representative points.\nboundary_map: A boundary map from construct_boundary_map.\nk: The vertex to start from.\nq: The point outside of the triangulation.\ncheck_existence=Val(has_multiple_segments(boundary_map))): Used to check that the edge exists when using get_adjacent, in case there are multiple segments.\nbnd_idx=I(BoundaryIndex): A boundary index corresponding to the boundary that k is on.\n\nOuptut\n\nThe edge (i, j) such that the ghost triangle (i, j, g) contains q, and g = get_adjacent(adj, i, j).\n\nwarning: Warning\nThe result is meaningless if q is inside of the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"You should not need to call into this method directly.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"The core complexity of the algorithm comes from having to find the direction of the point from an initial search point. The docstrings for some of these initialisers are given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"default_num_samples\nselect_initial_point \nselect_initial_triangle_interior_node \ncheck_for_intersections_with_adjacent_boundary_edges\nsearch_down_adjacent_boundary_edges\ncheck_for_intersections_with_interior_edges_adjacent_to_boundary_node","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.default_num_samples","page":"Point Location","title":"DelaunayTriangulation.default_num_samples","text":"default_num_samples(num_points)\n\nReturns ceil(cbrt(num_points)). This is the default number of samples  to use when sampling in the jump-and-march algorithm.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_point","page":"Point Location","title":"DelaunayTriangulation.select_initial_point","text":"select_initial_point(tri::Triangulation{P,Ts,I}, q;\n    point_indices=each_solid_vertex(tri),\n    m=default_num_samples(num_vertices(point_indices)),\n    try_points=(),\n    rng::AbstractRNG=Random.default_rng()) where {P,Ts,I}\n\nGiven a triangulation tri and a point q, select m random points from tri and return  the one that is closet to q.\n\nArguments\n\ntri: The Triangulation.\nq: The coordinates of the query point, or its index in pts.\n\nKeyword Arguments\n\npoint_indices=each_point_index(pts): The indices of the points to consider.\nm=default_num_samples(length(point_indices)): The number of points to sample.\ntry_points=(): The indices of points to try in addition to the sampled points.\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\n\nOutputs\n\nk: The index of the point in pts that is closest to q out of the points sampled.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.select_initial_triangle_interior_node","page":"Point Location","title":"DelaunayTriangulation.select_initial_triangle_interior_node","text":"select_initial_triangle_interior_node(tri, k, q, store_history::F=Val(false), history=nothing, rng::AbstractRNG=Random.default_rng()) where {F}\n\nSelects an initial triangle for the jump-and-march algorithm, starting from a point with index k  and finding the triangle such that the line from the kth point to q intersects it. It is assumed  that k is a point that is not on the boundary. \n\nArguments\n\ntri: The Triangulation.\nk: The index of the point in pts that we are starting at.\nq: The point being searched for.\nboundary_index_ranges: The Dict handling the mapping of boundary indices to the range of boundary indices belonging to the same curve. See construct_boundary_index_ranges.\nstore_history=Val(false): Whether to store visited triangles. Exterior ghost triangles will not be stored.\nhistory=nothing: The history. This should be a PointLocationHistory type if store_history is true.\nrng::AbstractRNG = Random.default_rng(): The random number generator.\n\nOutputs\n\np: The kth point in tri.\ni, j: These are indices defining the edge of a triangle including the point p, such that i is to the left of the line pq and j is to the right of pq.\npᵢ, pⱼ: The points in tri corresponding to the indices in i and j, respectively.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges","text":"check_for_intersections_with_adjacent_boundary_edges(tri, k, q, bnd_idx=I(BoundaryIndex))\n\nAssuming that k is on the outer boundary, this function searches down the boundary edges adjacent to k to try and locate a triangle  or edge containing q.\n\nSee also search_down_adjacent_boundary_edges, which uses this function to determine an initial direction to search along a  straight boundary in case q is collinear with it.\n\nArguments\n\ntri: The Triangulation. \nk: The outer boundary point k to start searching from.\nq: The query point q.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThe output is a 5-tuple, with the first three elements having several possible forms:\n\n(Certificate.Outside, Certificate.Outside, k): The point q is not collinear with either of the adjacent boundary edges.\n(Certificate.Right, C, r), where C is either Certificate.On or Certificate.Right and r is the vertex right of k: The point q is collinear with the edge to the right of k. If C is Certificate.On, then q is on the edge, whereas C being Certificate.Right means it is right of the edge. \n(Certificate.Left, C, ℓ), where C is either Certificate.On or Certificate.Left and ℓ is the vertex left of k: The point q is collinear with the edge to the left of k. If C is Certificate.On, then q is on the edge, whereas C being Certificate.Left means it is left of the edge.\n\nIn the latter two outputs above, C could also be Certificate.Degenerate, which means that q is get_point(pts, r) or get_point(pts, ℓ), respectively.\n\nThe latter two elements of the tuple are: \n\nright_cert: The position of q relative to the edge (p, p_right), where p_right is the point on the boundary to the right of p.\nleft_cert: The position of q relative to the edge (p, p_left), where p_left is the point on the boundary to the left of p.\n\nThese returned values are useful in case we need to go to check_for_intersections_with_interior_edges_adjacent_to_boundary_node, since we can reuse these certificates.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.search_down_adjacent_boundary_edges","page":"Point Location","title":"DelaunayTriangulation.search_down_adjacent_boundary_edges","text":"search_down_adjacent_boundary_edges(\n    tri,\n    k, \n    q,\n    direction, \n    q_pos, \n    next_vertex,\n    store_history=Val(false),\n    history=nothing,\n    bnd_idx=I(BoundaryIndex))\n\nStarting at the outer boundary node k, walks down the boundary in the direction of q until finding q or finding that it is outside of the triangulation. \n\nArguments\n\ntri: The Triangulation.\nk: The outer boundary index.\nq: The point being searched for.\ndirection: The direction of q from get_point(pts, k).\nq_pos: The certificate for the position of q from this point k.\nnext_vertex: The next vertex in the direction of q (this argument comes from check_for_intersections_with_adjacent_boundary_edges).\nstore_history=Val(false): Whether to store the history of the search.\nhistory=nothing: The history of the search.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThe output takes the form (cert, u, v, w), where: \n\ncert: This is Certificate.On if q is on the edge (u, v), and Certificate.Outside if q is outside of the triangulation.\n(u, v, w): If is_on(cert), then this is a positively oriented triangle with q on the edge (u, v). Otherwise, (u, v, w) is a ghost triangle close to q.\n\nwarning: Warning\nThis function relies on the assumption that the geometry is convex.\n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","page":"Point Location","title":"DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node","text":"check_for_intersections_with_interior_edges_adjacent_to_boundary_node(\n    tri,\n    k, \n    q, \n    right_cert, \n    left_cert, \n    store_history=Val(false), \n    history=nothing,\n    bnd_idx=I(BoundaryIndex))\n\nChecks if the line connecting the kth point of pts to q intersects any of the edges neighbouring the boundary node k.\n\nArguments\n\ntri: The Triangulation.\nk: The boundary node.\nq: The point we are searching for. \nright_cert: A certificate giving the position of q to the right of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\nleft_cert: A certificate giving the position of q to the left of the kth point. This comes from check_for_intersections_with_adjacent_boundary_edges.\nstore_history=Val(false): Whether to store visited triangles. Exterior ghost triangles will not be stored.\nhistory=nothing: The history. This should be a PointLocationHistory type if store_history is true.\nbnd_idx=I(BoundaryIndex): The boundary index for the boundary that k is on.\n\nOutputs\n\nThere are several possible forms for the returned values. These are listed below, letting p be the kth point, pᵢ the point corresponding to  the index i, and pⱼ the point corresponding to the index j:\n\n(i, j, Certificate.Single, Certificate.Outside)\n\nThe line pq intersects the edge pᵢpⱼ, and (j, i, k) is a positively oriented triangle. In particular, pᵢ is left of pq and pⱼ is right of pq.\n\n(i, j, Certificate.None, Certificate.Inside)\n\nThe point q is inside the positively oriented triangle (i, j, k).\n\n(zero(I), zero(I), Cert.None, Cert.Outside)\n\nThe point q is outside of the triangulation. Note that I is the integer type.\n\n(i, j, Cert.On, Cert.Inside)\n\nThe point q is on the edge pᵢpⱼ, and so is inside the positively oriented triangle (i, j, k).\n\n(i, j, Cert.Right, Cert.Outside)\n\nThe point q is collinear with the edge pᵢpⱼ, but is off of it and further into the triangulation. \n\nwarning: Warning\nThis function should only be used after check_for_intersections_with_adjacent_boundary_edges, and currently is only guaranteed to work on convex geometries. \n\n\n\n\n\n","category":"function"},{"location":"other_features/point_location/#History","page":"Point Location","title":"History","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"If you need to, you can also store the history of the algorithm. This is primarily only used for (and only tested for) constrained triangulations, as it helps us locate which triangles to delete. The struct we use for storing history is given below.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"PointLocationHistory ","category":"page"},{"location":"other_features/point_location/#DelaunayTriangulation.PointLocationHistory","page":"Point Location","title":"DelaunayTriangulation.PointLocationHistory","text":"PointLocationHistory{T,E,I}\n\nHistory from using jump_and_march.\n\nFields\n\ntriangles::Vector{T}: The visited triangles. \ncollinear_segments::Vector{E}: Segments collinear with the original line pq using to jump.\ncollinear_point_indices::Vector{I}: This field contains indices to segments in collinear_segments that refer to points that were on the original segment, but there is no valid segment for them. We use manually fix this after the fact. For example, we could add an edge (1, 14), when really we mean something like (7, 14) which isn't a valid edge.\nleft_vertices::Vector{I}: Vertices from the visited triangles to the left of pq.\nright_verices::Vector{I}: Vertices from the visited triangles to the right of pq.\n\n\n\n\n\n","category":"type"},{"location":"other_features/point_location/#Basic-Description-of-the-Algorithm","page":"Point Location","title":"Basic Description of the Algorithm","text":"","category":"section"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us give a basic description of what jump_and_march does.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"First, using select_initial_point, an initial point to start the algorithm is selected. This function samples some number m of points, and then selects the point that is closest to the query point q.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let the initially selected point be p_k. We break the discussion into two cases, where p_k is an interior point and p_k is a point on the boundary.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"If p_k is not a point on the boundary, then it is possible to completely rotate around the point searching for a triangle such that line overrightarrowp_kq intersects an edge of the triangle. This will give us an edge e_ij that overrightarrowp_kq intersects, and we will put p_i to the left of overrightarrowp_kq and p_j to the right. The function that handles this selection is select_initial_triangle_interior_node, which starts by handling the case of collinear edges and then rotates around. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now suppose that p_k is a point on the outer boundary. There are several possibilities in this case. First, overrightarrowp_kq might intersect a neighbouring boundary edge; secondly, overrightarrowp_kq could intersect a neighbouring interior edge; thirdly, overrightarrowp_kq could point away from the boundary, meaning q is outside of the boundary. The function starts by checking the neighbouring boundary edges, done via check_for_intersections_with_adjacent_boundary_edges, making use of get_right_boundary_node and get_left_boundary_node to obtain the neighbouring boundary nodes. If we find that overrightarrowp_kq does intersect a neighbouring boundary edge, then we can search down adjacent boundary edges via search_down_adjacent_boundary_edges until we either find an edge that q is on, or until we identify that q is outside of the triangulation – this function assumes the domain is convex, as triangulations being built are. If q is outside of the triangulation, then we can use the exterior variant of the jump and march algorithm, exterior_jump_and_march, to find the ghost triangle containing q. This functon simply rotates around the boundary until we find two ghost edges enclosing the point q. Now let us assume we did not find a neighbouring boundary edge that intersects overrightarrowp_kq. When this happens, we need to check the neighbouring interior edges, done via check_for_intersections_with_interior_edges_adjacent_to_boundary_node, which just rotates around the edges until we find an intersection. If we have still not found any intersection then, again assuming convexity, q must be outside of the triangulation and so we use exterior_jump_and_march.","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Now, if the algorithm is still going, then we need to start marching along the triangulation from p_k towards q. The idea is to keep marching, keeping p_i and p_j to the left and right of overrightarrowp_kq, respectively, until we find a case where p_ip_jq is no longer a positively oriented triangle. When this happens, it must mean that we have passed q, and so we have found the triangle. ","category":"page"},{"location":"other_features/point_location/","page":"Point Location","title":"Point Location","text":"Let us describe how this marching is done in more detail. First, we need to be careful of boundary indices, first checking for an outer boundary index. If we have found an outer boundary index, then we have marched into the boundary, and so q will be outside of the domain, meaning we go into exterior_jump_and_march. If this is not the case, then we march using get_adjacent to step onto the next triangle from a given edge e_ij. Then, checking the positions of the new points relative to overrightarrowp_kq and rearranging accordingly, we can step forward. We keep doing this until we get a negatively oriented triangle p_ip_jq. Unfortunately, this loop could terminate even if q is not in the found triangle, which can occasionally happen if p_ip_jq is a degenerate triangle. In this case, we just restart the jump and march algorithm. This latter worry is a very rare concern and does not alter the runtime in any significant manner.","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tessellations/lloyd/#Centroidal-Voronoi-Tessellation","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"","category":"section"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"Now we show how to compute a centroidal Voronoi tessellation, i.e. a Voronoi tessellation where the generators are at the centroids of the polygons. This method only works on clipped tessellations, and generators on the boundary are fixed in place. The function that handles this computation is centroidal_smooth:","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"centroidal_smooth","category":"page"},{"location":"tessellations/lloyd/#DelaunayTriangulation.centroidal_smooth","page":"Centroidal Voronoi Tessellation","title":"DelaunayTriangulation.centroidal_smooth","text":"centroidal_smooth(vorn::VoronoiTessellation; maxiters=1000, tol=default_displacement_tolerance(vorn), rng=Random.default_rng(), kwargs...) -> VoronoiTessellation\n\nSmooth the Voronoi tessellation vorn by moving each generator to the centroid of its Voronoi polygon. Uses Lloyd's algorithm. The smoothing will stop when the maximum displacement of any generator is less than tol or when the maximum number of iterations maxiters is reached.\n\nThe refinement is not done in place, and instead the smoothed tessellation is returned with no modifications to vorn.\n\nThis function only works on clipped tessellations, and generators on the boundary of the underlying triangulation are fixed in-place.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"The algorithm for computing the tessellation is very simple, making use of Lloyd's algorithm:","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"First, compute the tessellation.\nCompute the centroids of each polygon and move the generator to the centroid.\nIf the maximum displacement of a generator is below some tolerance, or if the maximum number of iterations has been reached, exit. Otherwise, go back to step 1 with the new generators.","category":"page"},{"location":"tessellations/lloyd/#Example","page":"Centroidal Voronoi Tessellation","title":"Example","text":"","category":"section"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"Let's now give an example.","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"pts = 25randn(2, 500)\ntri = triangulate(pts)\nvorn = voronoi(tri, true)\nsmooth_vorn = centroidal_smooth(vorn)\n\nfig = Figure()\nax = Axis(fig[1, 1], aspect=1)\nvoronoiplot!(ax, vorn, strokecolor=:red, strokewidth=0.2, markersize=4, colormap=:jet)\nxlims!(ax, -100, 100)\nylims!(ax, -100, 100)\nax = Axis(fig[1, 2], aspect=1)\nvoronoiplot!(ax, smooth_vorn, strokecolor=:red, strokewidth=0.2, markersize=4, colormap=:jet)\nxlims!(ax, -100, 100)\nylims!(ax, -100, 100)","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"<figure>\n    <img src='../figs/lloyd.png', alt='Centroidal Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"See that we indeed have smoothed out the points significantly. Out of interest, here's the difference between the triangulations.","category":"page"},{"location":"tessellations/lloyd/","page":"Centroidal Voronoi Tessellation","title":"Centroidal Voronoi Tessellation","text":"<figure>\n    <img src='../figs/lloyd_tri.png', alt='Centroidal Voronoi Tessellation Underlying Triangulation'><br>\n</figure>","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/example/#Defining-a-Custom-Interface","page":"Example","title":"Defining a Custom Interface","text":"","category":"section"},{"location":"interface/example/","page":"Example","title":"Example","text":"In the code below, we given an example of how we can provide a fully customised interface for constructing an unconstrained triangulation. One important feature to note in this custom definition is that, rather than writing boundary nodes a sequence of integers defining the polygon vertices, we write them as a sequence of edges built up by individual polygons themselves built up of segments. ","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"using DelaunayTriangulation, CairoMakie, StableRNGs \nconst DT = DelaunayTriangulation\n\n## Struct definitions\nstruct CustomPoint\n    x::Float64\n    y::Float64\nend\nstruct CustomPoints\n    points::Vector{CustomPoint}\nend\nstruct CustomEdge\n    i::Int32\n    j::Int32\nend\nstruct CustomEdges\n    edges::Set{CustomEdge}\nend\nstruct CustomTriangle\n    i::Int32\n    j::Int32\n    k::Int32\nend\nstruct CustomTriangles\n    triangles::Vector{CustomTriangle}\nend\nstruct CustomPolygonSegment\n    edges::Vector{CustomEdge}\nend\nstruct CustomPolygon\n    segments::Vector{CustomPolygonSegment}\nend\nstruct CustomPolygons{N}\n    polygons::NTuple{N,CustomPolygon}\nend\n\n### Defining the methods\n## Definitions needed for unconstrained triangulations\n# Point\nDT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\nDT.number_type(::Type{CustomPoint}) = Float64\n\n# Points\nDT.each_point_index(pts::CustomPoints) = eachindex(pts.points)\nDT.num_points(pts::CustomPoints) = length(pts.points)\nDT.each_point(pts::CustomPoints) = pts.points\nDT.number_type(::Type{CustomPoints}) = DT.number_type(CustomPoint)\nDT.getpoint(pts::CustomPoints, i::Integer) = pts.points[i]\n\n# Edge\nDT.construct_edge(::Type{CustomEdge}, i, j) = CustomEdge(i, j)\nDT.initial(e::CustomEdge) = e.i\nDT.terminal(e::CustomEdge) = e.j\n\n# Edges\nDT.initialise_edges(::Type{CustomEdges}) = CustomEdges(Set{CustomEdge}())\nDT.add_to_edges!(edges::CustomEdges, edge::CustomEdge) = push!(edges.edges, edge)\nBase.iterate(edges::CustomEdges, state...) = Base.iterate(edges.edges, state...)\nDT.each_edge(edges::CustomEdges) = edges.edges\nDT.delete_from_edges!(edges::CustomEdges, edge::CustomEdge) = delete!(edges.edges, edge)\nDT.contains_edge(edge::CustomEdge, edges::CustomEdges) = edge ∈ edges.edges\nDT.num_edges(edges::CustomEdges) = length(edges.edges)\n\n# Triangle\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\nDT.geti(tri::CustomTriangle) = tri.i\nDT.getj(tri::CustomTriangle) = tri.j\nDT.getk(tri::CustomTriangle) = tri.k\nDT.integer_type(::Type{CustomTriangle}) = Int32\n\n# Triangles\nfunction DT.delete_from_triangles!(tri::CustomTriangles, triangle::CustomTriangle)\n    i = findfirst(==(triangle), tri.triangles)\n    deleteat!(tri.triangles, i)\n    return nothing\nend\nDT.initialise_triangles(::Type{CustomTriangles}) = CustomTriangles(Vector{CustomTriangle}())\nDT.sizehint!(tri::CustomTriangles, n) = sizehint!(tri.triangles, n)\nDT.triangle_type(::Type{CustomTriangles}) = CustomTriangle\nDT.add_to_triangles!(tri::CustomTriangles, triangle::CustomTriangle) = push!(tri.triangles, triangle)\nDT.num_triangles(tri::CustomTriangles) = length(tri.triangles)\nBase.iterate(tri::CustomTriangles, state...) = Base.iterate(tri.triangles, state...)\nBase.in(T, V::CustomTriangles) = T ∈ V.triangles\n\n## Definitions needed for constrained segments \n# Edge \nDT.integer_type(::Type{CustomEdge}) = Int32\n\n# Edges \nDT.edge_type(::Type{CustomEdges}) = CustomEdge\n\n## Definitions needed for boundary nodes \n# Triangles \nDT.each_triangle(tri::CustomTriangles) = tri.triangles\n\n# Boundary Nodes \nDT.has_multiple_curves(::CustomPolygons{N}) where {N} = N > 1\nDT.has_multiple_curves(::CustomPolygon) = false\nDT.has_multiple_curves(::CustomPolygonSegment) = false\nDT.has_multiple_segments(::CustomPolygons) = true\nDT.has_multiple_segments(poly::CustomPolygon) = true\nDT.has_multiple_segments(seg::CustomPolygonSegment) = false\nDT.num_curves(::CustomPolygons{N}) where {N} = N\nDT.getboundarynodes(poly::CustomPolygons, m) = poly.polygons[m] # go down to the mth polygon \nDT.getboundarynodes(poly::CustomPolygon, m) = poly.segments[m] # go down to the mth segment\nDT.getboundarynodes(seg::CustomPolygonSegment, m) = m > length(seg.edges) ? DT.terminal(seg.edges[m-1]) : DT.initial(seg.edges[m]) # go down to the mth edge and extract the left node\nDT.getboundarynodes(poly::CustomPolygons, (m, n)::NTuple{2,Int32}) = DT.getboundarynodes(DT.getboundarynodes(poly, m), n)\nDT.num_segments(poly::CustomPolygon) = length(poly.segments)\nDT.num_boundary_edges(seg::CustomPolygonSegment) = length(seg.edges)\n\n## Definitions needed for refinement \n# Points \nDT.push_point!(pts::CustomPoints, x, y) = push!(pts.points, CustomPoint(x, y))\nDT.pop_point!(pts::CustomPoints) = pop!(pts.points)\n\n# Edges \nDT.contains_edge(e::CustomEdge, Es::CustomEdges) = e ∈ Es.edges\n\n# Boundary Nodes \nfunction Base.insert!(seg::CustomPolygonSegment, index, node)\n    cur_edge = seg.edges[index-1]\n    u, v = DT.initial(cur_edge), DT.terminal(cur_edge)\n    seg.edges[index-1] = CustomEdge(u, node)\n    insert!(seg.edges, index, CustomEdge(node, v))\n    return nothing\nend\n\n### Example\n## Build the points \np1 = CustomPoint(0.0, 0.0)\np2 = CustomPoint(1.0, 0.0)\np3 = CustomPoint(1.0, 1.0)\np4 = CustomPoint(0.0, 1.0)\np5 = CustomPoint(0.5, 0.5)\np6 = CustomPoint(0.25, 0.25)\np7 = CustomPoint(0.75, 0.25)\np8 = CustomPoint(0.75, 0.75)\np9 = CustomPoint(0.25, 0.75)\np10 = CustomPoint(2.3, 5.5)\np11 = CustomPoint(-0.5, 2.3)\npoints = CustomPoints([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11])\n\n## The edges\nedges = CustomEdges(Set{CustomEdge}((CustomEdge(2, 7), CustomEdge(8, 3))))\n\n## The boundary nodes\nouter_polygon = CustomPolygon([\n    CustomPolygonSegment([CustomEdge(1, 2), CustomEdge(2, 3)]),\n    CustomPolygonSegment([CustomEdge(3, 4), CustomEdge(4, 1)]),\n])\ninner_polygon = CustomPolygon([\n    CustomPolygonSegment([CustomEdge(6, 9), CustomEdge(9, 8), CustomEdge(8, 7), CustomEdge(7, 6)]),\n])\npolygons = CustomPolygons((outer_polygon, inner_polygon))\n\n## Triangulate\nrng = StableRNG(982381238)\ntri = triangulate(points; edges=edges, boundary_nodes=polygons,\n    IntegerType=Int32,\n    EdgeType=CustomEdge,\n    TriangleType=CustomTriangle,\n    EdgesType=CustomEdges,\n    TrianglesType=CustomTriangles,\n    randomise=true,\n    delete_ghosts=false,\n    rng\n)\n\n## Refine \nA = get_total_area(tri)\nstats = refine!(tri; max_area=1e-3A, min_angle=27.3, rng)\nfig, ax, sc = triplot(tri; show_convex_hull=false)\nxlims!(ax, 0, 1)\nylims!(ax, 0, 1)","category":"page"},{"location":"interface/example/","page":"Example","title":"Example","text":"<figure>\n    <img src='../figs/interface_example.png', alt='Triangulation using a custom interface'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/gmsh/#Gmsh","page":"Gmsh","title":"Gmsh","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"We provide Gmsh support, making it possible to represent more complicated meshes. (This is less relevant now that we have constrained triangulations and mesh refinement without needing Gmsh.) The discussion that follows assume you have installed Gmsh, and defined a corresponding GMSH_PATH. I have used the default,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> GMSH_PATH = \"./gmsh-4.11.1-Windows64/gmsh.exe\"","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The methods for generating meshes with Gmsh are shown below.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"generate_mesh","category":"page"},{"location":"triangulations/gmsh/#DelaunayTriangulation.generate_mesh","page":"Gmsh","title":"DelaunayTriangulation.generate_mesh","text":"generate_mesh(x, y, ref;\n    mesh_algorithm = 6, \n    gmsh_path = \"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity = 0, \n    convert_result = true, \n    add_ghost_triangles = false, \n    check_args = true)\n\nUsing Gmsh, generates a mesh of the domain defined by (x, y).\n\nArguments\n\nx, y: These are the coordinates defining the curves that define the boundaries of the domain. All curves are to be positively oriented, meaning the outermost boundary should be counter-clockwise while the interior boundaries should be clockwise. The accepted forms of x, y are outlined in in the boundary handling section of the docs.\nref: The refinement parameter – smaller ref means more elements. \n\nKeyword Arguments\n\nmesh_algorithm = 6: The meshing algorithm to use. See the Gmsh documentation for more information. The default 6 means Frontal-Delaunay. \ngmsh_path = \"./gmsh-4.11.1-Windows64/gmsh.exe\": The path to the Gmsh executable.\nverbosity = 0: The verbosity of the Gmsh output.\nconvert_result = true: Whether to convert the Gmsh output to a Triangulation.\nadd_ghost_triangles = false: Whether to add ghost triangles to the triangulation.\ncheck_args = true: Whether to check the validity of the arguments.\n\nOutputs\n\nIf convert_result, then the final result is a Triangulation type for the mesh. Otherwise,  the following values are returned: \n\nelements: The triangular elements of the mesh. \nnodes: The nodes in the mesh. \nboundary_nodes: The bonudary nodes in the mesh.  All boundaries are positively oriented relative to the interior, meaning the outermost boundary is counter-clockwise while the interior boundaries are clockwise, and match the form of (x, y). \n\nExtended help\n\nThe function proceeds in four steps:\n\nMesh generation\n\nHere, we write a file \"meshgeometry.geo\" in the working directory. This file takes the form\n\nr = ref;\nMesh.Algorithm = mesh_algorithm; \nMesh.Format = 1;\nGeneral.Verbosity = 0;\nPoint(<point index>) = {<x>, <y>, 0, r}; # For each point\nLine(<line index>) = {<initial point>, <final point>}; # For each line \nCurve Loop(<boundary index>) = {<line 1>, <line 2>, ...}; # For each boundary \nPlane Surface(1) = {<curve 1>, <curve 2>, ...}; # <curve 1> = 1 and is the outermost boundary, while <curve i> = i, i > 1, are boundaries of interior holes \nPhysical Curve(<last line index + i>) = {<line 1>, <line 2>, ...}; # For i ranging over the number of segments, and the lines represent that segment \nPhysical Surface(1) = {1};\n\nMost importantly, every edge input into the function generate_mesh will be included in the mesh. An  older version of this function previously used cubic splines for defining boundary curves, but this  has the consequence that (1) not every edge put into the function is included, and (2) the boundary  is not exactly represented. \n\nThe function that handles this generation is write_gmsh.\n\nMesh writing \n\nThe \"meshgeometry.geo\" file is then used to mesh the domain, running the terminal command \n\ngmsh_path \"meshgeometry.geo\" -2 -format msh2\n\nThis creates a file \"meshgeometry.msh\" in the same working directory. \n\nThe function that handles this writing is run_gmsh.\n\nMesh reading \n\nOnce \"meshgeometry.msh\" is created, we need to read it. The format used (MeshFormat) is  2.2, but note that as of writing (13/01/2013), the most modern format is 4.1.\n\nThe \"meshgeometry.msh\" file is split into groups:\n\n3a. MeshFormat \n\nThis just reads off the format of the file used. This part of the file  is read using read_mesh_format!.\n\n3b. Nodes \n\nThis lists the node indices and all the coordinates of the nodes, with the  first line giving the number of nodes. A single line in this section,  after the first, takes the form \n\n<node index> <x> <y> 0\n\nand we read this using read_node_line. This entire part of the file  is read using read_nodes!.\n\n3c. Elements \n\nThe first line in this part of the file is the number of elements, though  here elements refer to both the lines and the triangles. The lines (edges)  are listed first, with each line taking the form \n\n<line index> 1 2 <boundary index> <> <left node> <right node>\n\nand will be in counter-clockwise order. After the lines are listed, all the triangles follow, with each line in this part taking the form\n\n<triangle index> 2 2 1 1 <node 1> <node 2> <node 3>\n\nwith each triangle positively oriented. These lines are read using  read_element_line. The entire part of the file is read using  read_elements!.\n\nConversion to Triangulation\n\nOnce the file \"meshgeometry.geo\" has been read, we have a list of  triangular elements, nodes, and boundary nodes. These need to all be  converted into a Triangulation type, and a constructor of  Triangulation is used to accomplish this.\n\n\n\n\n\ngenerate_mesh(a, b, c, d, ref; \n    mesh_algorithm=6,\n    gmsh_path=\"./gmsh-4.11.1-Windows64/gmsh.exe\",\n    verbosity=0,\n    single_boundary=true,\n    convert_result=true,\n    add_ghost_triangles=false)\n\nGenerates a mesh of a rectangle [a, b] × [c, d]. Use single_boundary=true if  each side of the rectangle should be treated the same, and single_boundary=false if  you want the boundary nodes to be segmented each side of the rectangle.\n\nSee the main function generate_mesh for a description of the other  arguments.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let's give some examples. ","category":"page"},{"location":"triangulations/gmsh/#Example-I:-Contiguous-boundary","page":"Gmsh","title":"Example I: Contiguous boundary","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us mesh a domain with a single non-segmented boundary curve. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\na = 4 / 5\nt = LinRange(0, 2π, 100)\nx = @. a * (2cos(t) + cos(2t))\ny = @. a * (2sin(t) - sin(2t))\ntri = generate_mesh(x, y, 0.1)\ntri2 = generate_mesh(x, y, 1.0)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $ Dense mesh\", titlealign=:left)\ntriplot!(ax, tri, show_convex_hull=true, show_constrained_edges=true)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(b):$ $  Coarse mesh\", titlealign=:left)\ntriplot!(ax, tri2, show_convex_hull=true, show_constrained_edges=true)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"In the figure, the red curve shows the convex hull. We note that we now have information in tri.boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n178-element Vector{Int}:\n  1\n  2\n  3\n  4\n  ⋮\n 97\n 98\n 99\n  1","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Similarly, tri.boundary_map is now populated:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int, Vector{Int}} with 1 entry:\n  -1 => [1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1]","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"We now also have tri.boundary_edge_map:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> tri.boundary_edge_map\nDict{Tuple{Int, Int}, Tuple{Vector{Int}, Int}} with 177 entries:\n  (116, 20)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 36)\n  (78, 158)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 136)\n  (11, 105)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 16)\n  (106, 13)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 19)\n  (103, 10)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 13)\n  (145, 56)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 101)\n  (169, 87)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 156)\n  (110, 111) => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 27)\n  (128, 42)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 70)\n  (43, 130)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 73)\n  (30, 31)   => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 56)\n  (156, 77)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 133)\n  (3, 4)     => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 3)\n  (112, 113) => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 30)\n  (41, 128)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 69)\n  (153, 74)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 127)\n  (133, 47)  => ([1, 2, 3, 4, 5, 6, 100, 7, 101, 8  …  93, 176, 94, 177, 95, 96, 97, 98, 99, 1], 80)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"In this case, each output of (i, j) is the Tuple (get_boundary_nodes(tri), k). For example,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> u, v = 133, 47;\n\njulia> pos = get_boundary_edge_map(tri, u, v);\n\njulia> segment_nodes = get_boundary_nodes(tri, pos[1]);\n\njulia> get_boundary_nodes(segment_nodes, pos[2]) == u # edges start at the left\ntrue\n\njulia> get_boundary_nodes(segment_nodes, pos[2]+1) == v\ntrue","category":"page"},{"location":"triangulations/gmsh/#Example-II:-Single-boundary-curve-with-multiple-segments","page":"Gmsh","title":"Example II: Single boundary curve with multiple segments","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Let us now give an example where we still have just a single boundary curve, but we split it into multiple segments. Importantly, each segment must be counter-clockwise and join with the previous segment.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\n# The first segment \nt = LinRange(0, 1 / 4, 25)\nx1 = cos.(2π * t)\ny1 = sin.(2π * t)\n# The second segment \nt = LinRange(0, -3, 25)\nx2 = collect(t)\ny2 = repeat([1.0], length(t))\n# The third segment \nt = LinRange(1, 0, 25)\nx3 = -3.0 .+ (1 .- t) .* sin.(t)\ny3 = collect(t)\n# The fourth segment \nt = LinRange(0, 1, 25)\nx4 = collect(-3.0(1 .- t))\ny4 = collect(0.98t)\n# The fifth segment \nx5 = [0.073914, 0.0797, 0.1522, 0.1522, 0.2, 0.28128, 0.3659, 0.4127, 0.3922, 0.4068, 0.497, 0.631, 0.728, 0.804, 0.888, 1.0]\ny5 = [0.8815, 0.8056, 0.80268, 0.73258, 0.6, 0.598, 0.5777, 0.525, 0.4346, 0.3645, 0.3032, 0.2886, 0.2623, 0.1367, 0.08127, 0.0]\n# Now combine the vectors \nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\n# Mesh \ntri = generate_mesh(x, y, 0.05)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=600, height=300)\ntriplot!(ax, tri, show_convex_hull=true)\ncolors = [:red, :blue, :orange, :purple, :darkgreen]\nbn_map = get_boundary_map(tri)\nfor (i, segment_index) in enumerate(values(bn_map))\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    lines!(ax, get_points(tri)[:, bn_nodes], color=colors[i], linewidth=4)\nend\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"An important feature to note for this case is that the index now used to refer to boundaries is no longer constant. In particular, the nth segment will map to -n, as we can verify using:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int, Int} with 5 entries:\n  -1 => 1\n  -2 => 2\n  -3 => 3\n  -4 => 4\n  -5 => 5","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This map makes it simple to iterate over all parts of a boundary, as we show in the above code when plotting. The tri.boundary_edge_map in this case is:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_edge_map(tri)\nDict{Tuple{Int, Int}, Tuple{Int, Int}} with 262 entries:\n  (118, 8)   => (1, 14)\n  (55, 56)   => (3, 10)\n  (34, 154)  => (2, 28)\n  (213, 214) => (4, 35)\n  (223, 224) => (4, 50)\n  (143, 29)  => (2, 12)\n  (24, 135)  => (1, 47)\n  (178, 179) => (2, 65)\n  (132, 22)  => (1, 42)\n  (46, 178)  => (2, 64)\n  (169, 42)  => (2, 51)\n  (154, 155) => (2, 29)\n  (115, 5)   => (1, 8)\n  (43, 172)  => (2, 55)\n  (261, 262) => (5, 38)\n  (146, 147) => (2, 17)\n  (49, 184)  => (3, 1)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"For example, ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> let pos = get_boundary_edge_map(tri, 115, 5)\n       segment_nodes = get_boundary_nodes(tri, pos[1])\n       u′ = get_boundary_nodes(segment_nodes, pos[2])\n       v′ = get_boundary_nodes(segment_nodes, pos[2]+1)\n       u′ == 115 && v′ == 5\n       end\ntrue","category":"page"},{"location":"triangulations/gmsh/#Example-III:-Multiple-boundaries","page":"Gmsh","title":"Example III: Multiple boundaries","text":"","category":"section"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Now let us give a more complicated example, meshing a multiply-connected domain. In this case, we provide the outer-most boundary in a counter-clockwise order, while all the inner boundaries are in a clockwise order.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"using DelaunayTriangulation, CairoMakie\nx1 = [collect(LinRange(0, 2, 4)),\n    collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 0, 4)),\n    collect(LinRange(0, 0, 4))]\ny1 = [collect(LinRange(0, 0, 4)),\n    collect(LinRange(0, 6, 4)),\n    collect(LinRange(6, 6, 4)),\n    collect(LinRange(6, 0, 4))]\nr = 0.5\nh = k = 0.6\nθ = LinRange(2π, 0, 50)\nx2 = [h .+ r .* cos.(θ)]\ny2 = [k .+ r .* sin.(θ)]\nr = 0.2\nh = 1.5\nk = 0.5\nx3 = [h .+ r .* cos.(θ)]\ny3 = [k .+ r .* sin.(θ)]\nx4 = reverse(reverse.([collect(LinRange(1, 1.5, 4)),\n    collect(LinRange(1.5, 1.5, 4)),\n    collect(LinRange(1.5, 1, 4)),\n    collect(LinRange(1, 1, 4))]))\ny4 = reverse(reverse.([collect(LinRange(2, 2, 4)),\n    collect(LinRange(2, 5, 4)),\n    collect(LinRange(5, 5, 4)),\n    collect(LinRange(5, 2, 4))]))\nx5 = [reverse([0.2, 0.5, 0.75, 0.75, 0.2, 0.2])]\ny5 = [reverse([2.0, 2.0, 3.0, 4.0, 5.0, 2.0])]\nx = [x1, x2, x3, x4, x5]\ny = [y1, y2, y3, y4, y5]\ntri = generate_mesh(x, y, 0.2)\nfig, ax, sc = triplot(tri; show_convex_hull=true, show_ghost_edges=true, show_constrained_edges=true, convex_hull_linestyle=:solid, convex_hull_linewidth=4)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"<figure>\n    <img src='../figs/gmsh_example_3.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The blue edges show the interpretation of the ghost edges (you can delete via delete_ghost_triangles! if you want). For the outer boundary, these edges are pointing away from the interior, collinear with a point in the center, as we can obtain via:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_representative_point_coordinates(tri, 1)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"or, alternatively,","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_representative_point_list(tri)\nDict{Int, DelaunayTriangulation.RepresentativeCoordinates{Int, Float64}} with 5 entries:\n  5 => RepresentativeCoordinates{Int, Float64}(0.475, 3.5, 0)\n  4 => RepresentativeCoordinates{Int, Float64}(1.25, 3.5, 0)\n  2 => RepresentativeCoordinates{Int, Float64}(0.6, 0.6, 0)\n  3 => RepresentativeCoordinates{Int, Float64}(1.5, 0.5, 0)\n  1 => RepresentativeCoordinates{Int, Float64}(1.5, 1.5, 0)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The keys are the indices for the boundary curve. These coordinates are visual centers, obtained via the pole of inaccessibility function; see the sidebar. For the inner boundaries, the ghost edges are no longer infinite and so they connect directly with these representative coordinates.","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"To access more of the boundary information, we could first consider boundary_nodes:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_nodes(tri)\n5-element Vector{Vector{Vector{Int}}}:\n [[1, 128, 129, 130, 2, 131, 132, 133, 3, 134, 135, 136, 4], [4, 137, 138, 139, 140, 141, 142, 143, 144, 145  …  155, 156, 157, 158, 159, 160, 161, 162, 163, 7], [7, 164, 165, 166, 8, 167, 168, 169, 9, 170, 171, 172, 10], [10, 173, 174, 175, 176, 177, 178, 179, 180, 181  …  191, 192, 193, 194, 195, 196, 197, 198, 199, 1]]\n [[13, 14, 15, 16, 17, 18, 19, 20, 21, 22  …  53, 54, 55, 56, 57, 58, 59, 60, 61, 13]]\n [[62, 63, 64, 65, 66, 67, 68, 69, 70, 71  …  102, 103, 104, 105, 106, 107, 108, 109, 110, 62]]\n [[111, 200, 201, 202, 203, 112, 204, 205, 206, 207, 113, 208, 209, 210, 211, 114], [114, 115, 116, 117], [117, 212, 213, 214, 215, 118, 216, 217, 218, 219, 119, 220, 221, 222, 223, 120], [120, 121, 122, 111]]  \n [[123, 224, 225, 226, 227, 228, 229, 230, 231, 232  …  246, 126, 247, 248, 249, 250, 251, 127, 252, 123]]","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"This is simply a vector of curves, with each curve storing its segments. This vector itself does not tell us what boundary index corresponds to what segment of what curve, and this could be obtained from the boundary map:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_map(tri)\nOrderedDict{Int, Tuple{Int, Int}} with 11 entries:\n  -1  => (1, 1)\n  -2  => (1, 2)\n  -3  => (1, 3)\n  -4  => (1, 4)\n  -5  => (2, 1)\n  -6  => (3, 1)\n  -7  => (4, 1)\n  -8  => (4, 2)\n  -9  => (4, 3)\n  -10 => (4, 4)\n  -11 => (5, 1)","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, the boundary index -8 comes from the second segment of the fourth curve. As before, this boundary map makes it simple to iterate over each segment as follows:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    nedges = num_boundary_edges(bn_nodes) # Note that nedges = length(bn_nodes) - 1\n    for edge_idx in 1:nedges \n        node = get_boundary_node(bn_nodes, edge_idx)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The form above is generic, and ignores the last part of each segment (since it is duplicated for the next segment). Of course, a version like","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"bn_map = get_boundary_map(tri)\nfor segment_index in values(bn_map)\n    bn_nodes = get_boundary_nodes(tri, segment_index)\n    for i in bn_nodes\n        node = get_boundary_node(bn_nodes, i)\n        ...\n    end\nend","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"(which includes the last part of each segment) could be used. It is up to you based on your interface how you prefer to write this. Notice also that in the previous example we used a similar style, using get_boundary_nodes(tri, segment_index) also. The function get_boundary_nodes can be used with either single integers or Tuples, making it simple to iterate with this exact pattern whether we have a contiguous boundary curve, a segmented boundary curve, or multiple boundaries. ","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"Another feature to note is tri.boundary_index_ranges, which will tell us what other boundary indices belong to a curve given a known boundary index for that curve. This can be useful if we want to rotate around a boundary curve based on a given boundary index (see e.g. how it is used in the get_left_boundary_node and get_right_boundary_node functions). This field is a major part of making point location work in these inner boundaries, making get_adjacent work properly in this case (see e.g. the code in _safe_get_adjacent).","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_index_ranges(tri)\nOrderedDict{Int, UnitRange{Int}} with 11 entries:\n  -1  => -4:-1\n  -2  => -4:-1\n  -3  => -4:-1\n  -4  => -4:-1\n  -5  => -5:-5\n  -6  => -6:-6\n  -7  => -10:-7\n  -8  => -10:-7\n  -9  => -10:-7\n  -10 => -10:-7\n  -11 => -11:-11","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"So, for example, we see tha the boundary index -3 belongs to a curve that also has boundary indices -1, -2, and -4. If we wanted to go from a boundary index to the index for the curve, this is what the boundary map is also for:","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> DelaunayTriangulation.get_curve_index(tri, -3)\n1","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"The last feature to show is the new tri.boundary_edge_map for this case, given by","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"julia> get_boundary_edge_map(tri)\nDict{Tuple{Int, Int}, Tuple{Tuple{Int, Int}, Int}} with 252 entries:\n  (55, 56)   => ((2, 1), 43)\n  (130, 2)   => ((1, 1), 4)\n  (92, 93)   => ((3, 1), 31)\n  (213, 214) => ((4, 3), 3)\n  (14, 15)   => ((2, 1), 2)\n  (172, 10)  => ((1, 3), 12)\n  (203, 112) => ((4, 1), 5)\n  (178, 179) => ((1, 4), 7)\n  (121, 122) => ((4, 4), 2)\n  (151, 152) => ((1, 2), 17)\n  (26, 27)   => ((2, 1), 14)\n  (171, 172) => ((1, 3), 11)\n  (88, 89)   => ((3, 1), 27)\n  (132, 133) => ((1, 1), 7)\n  (133, 3)   => ((1, 1), 8)\n  (146, 147) => ((1, 2), 12)\n  (46, 47)   => ((2, 1), 34)\n  ⋮          => ⋮","category":"page"},{"location":"triangulations/gmsh/","page":"Gmsh","title":"Gmsh","text":"As before, (u, v) = (get_boundary_nodes(segment_nodes, pos[2]), get_boundary_nodes(segment_nodes, pos[2]+1), where segment_nodes = get_boundary_nodes(tri, pos[1]) and pos = get_boundary_edge_map(tri, u, v). This pattern is true for any form of boundary nodes, in fact.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/refinement/#Mesh-Refinement","page":"Mesh Refinement","title":"Mesh Refinement","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Here we show how we can use mesh refinement to improve the quality of a triangulation. In this package, the algorithm used is Ruppert's algorithm, and we permit constraints on the minimum angle and maximum area of a triangle in a triangulation. This algorithm works on any type of geometry. The function used for refinement is refine!. Some of the relevant docstrings are:","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"refine!\nRefinementTargets \nRefinementQueue ","category":"page"},{"location":"triangulations/refinement/#DelaunayTriangulation.refine!","page":"Mesh Refinement","title":"DelaunayTriangulation.refine!","text":"refine!(tri::Triangulation;\n    min_area=1e-9get_total_area(tri),\n    max_area=typemax(number_type(tri)),\n    max_radius_edge_ratio=nothing,\n    max_points=typemax(Int),\n    min_angle=nothing,\n    rng::AbstractRNG=Random.default_rng(),\n    maxiters=100,\n    lock_convex_hull=!has_boundary_nodes(tri),\n    exterior_curve_index=1\n    )\n\nRefine the triangulation tri according to the given refinement targets.\n\nArguments\n\ntri::Triangulation: The triangulation to refine.\n\nKeyword Arguments\n\nmin_area=1e-9get_total_area(tri)\n\nThe minimum permissible area of a triangle. Any circumcenter insertion attempts into a triangle with area below this minimum will be prevented, and the triangle will never be queued for refinement. This is useful for preventing the mesh from becoming too fine in certain regions and preventing convergence.\n\nmax_area=typemax(number_type(tri))\n\nThe maximum permissible area of a triangle.\n\nmax_radius_edge_ratio=nothing\n\nThe maximum allowed radius-edge ratio (the ratio of the circumradius to the shortest edge length) of a triangle.  This ratio is related to a min_angle constraint by the formula min_angle = asin(0.5 / max_radius_edge_ratio). If max_radius_edge_ratio=nothing, then it is computed from the provided min_angle if it is not nothing,  or we set max_radius_edge_ratio = 1. This can also be a function of the form f(T, p, q, r, ρ), where T is the triangle's indices, p, q, r its coordinates, and ρ is the triangle's radius-edge  ratio. This function should return true if it should be refined, and false otherwise.\n\nThe maximum radius-edge ratio cannot be less than 1/√3. If it is, it is replaced with 1/√3.\n\nmin_angle=nothing\n\nThe minimum allowed angle of a triangle, given in degrees. If max_radius_edge_ratio is not nothing, then this is ignored. Otheriwse,  we set max_radius_edge_ratio = 1 / (2sind(min_angle)).\n\nIf min_angle > 33.9°, a warning is given as convergence of the algorithm may struggle to converge in this case. Additionally, ifminangle < 0.0orminangle > 60.00005, thenminangleis replaced with30°(maxradiusedgeratio = 1`). You should also be cautious that, for some domains (e.g. ones with many small angles), an even smaller angle might be needed to accommodate floating point arithmetic.\n\nnote: Note\nA minimum angle constraint of θₘᵢₙ° corresponds to a maximum angle constraint of 180° - 2θₘᵢₙ, e.g. θₘᵢₙ° = 30° gives θₘₐₓ° = 120°.\n\nmax_points=typemax(Int)\n\nHow many points are allowed to be in the triangulation before terminating.\n\nrng::AbstractRNG=Random.default_rng()\n\nThe random number generator to use.\n\nmaxiters=5000\n\nThe maximum number of iterations to perform.\n\nlock_convex_hull=!has_boundary_nodes(tri)\n\nWhether to lock the convex hull of the triangulation. If true, then the convex hull edges are put into the constrained edges of the triangulation. This  is only relevant if the triangulation has no boundary nodes.\n\ndanger: Danger\nNot enabling this option can lead to the triangulation being refined in a way that  continually adds points that go out to infinity. Do so at your own peril.\n\nexterior_curve_index=1\n\nThe curve (or curves) corresponding to the outermost boundary. Only seems to be needed  in rare cases, even with multiple exterior curves (disjoint domains). If you are having issues with the triangulation not being refined correctly, try setting this to be the  correct values.\n\nOutputs\n\nThe TriangulationStatistics of tri are returned. The triangulation is refined in-place.\n\nSee also RefinementTargets.\n\nnote: Note\nIt is not strictly guaranteed that the refinement targets will be met. For example, precision  issues may cause small angles from near-degenerate triangles. Despite this, the algorithm will still typically give no angle larger than 180° - 2θ°, where θ° = asind[1 / (2max_radius_edge_ratio)] is the minimum angle constraint associated with max_radius_edge_ratio. Moreover, domains with  small angles (between constrained segments) will cause issues, forcing small angles to be  introduced into the triangulation to accommodate them, but only between the constrained  segments with small angles. If you are finding issues with small angles, try increasing the max_radius_edge_ratio (or reduce min_angle). Basically, be aware that arithmetic is not perfected and floating point arithmetic  only has so much precision to offer.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/refinement/#DelaunayTriangulation.RefinementTargets","page":"Mesh Refinement","title":"DelaunayTriangulation.RefinementTargets","text":"RefinementTargets{A,M,R,P}\n\nA struct containing the user-specified refinement targets. \n\nFields\n\nmax_area::A\n\nThe maximum area of a triangle. This can also be a function of the form f(T, p, q, r, A), where T is the trianglewith areaAand coordinatesp,q,r, returningtrue` if the triangle should be refined.\n\nmin_area::M\n\nThe minimum area of a triangle. This is used to test for the presence of small triangles, which can be a sign of poor quality / convergence. For example, if a circumcenter is attempted to be added into a triangle with area below min_area, it is prevented. Defaults to 0.0.\n\nmax_radius_edge_ratio::R\n\nThe maximum permitted radius-edge ratio. This can also be a function of the form f(T, p, q, r, ρ), where T is the trianglewith ratioρand coordinatesp,q,r, returningtrue` if the triangle should be refined. Defaults to 1.0, corresponding to a minimum angle of 30°.\n\nmax_points::P\n\nThe maximum number of points in the mesh. Defaults to Inf.\n\nConstructors\n\nThe constructor is \n\nRefinementTargets(;\n        max_area=typemax(Float64),\n        max_radius_edge_ratio=nothing,\n        max_points=typemax(Int),\n        min_angle = nothing\n        )\n\nwhich allows for a user to specify either the maximum radius-edge ratio ρ or the minimum angle min_angle in degrees, using the relationship min_angle = asin[1/(2ρ)]. If both are provided, the minimum angle is ignored. If neither are provided, the default value of ρ = 1.0 is used, corresponding to a minimum angle of 30°.\n\nNote that you cannot use min_angle as a function, unlike max_radius_edge_ratio. If you want to use a function, use max_radius_edge_ratio instead.\n\n\n\n\n\n","category":"type"},{"location":"triangulations/refinement/#DelaunayTriangulation.RefinementQueue","page":"Mesh Refinement","title":"DelaunayTriangulation.RefinementQueue","text":"RefinementQueue{T,E,F}\n\nA queue for storing encroachment and triangle refinement priority queues. \n\nFields\n\nencroachment_queue::PriorityQueue{T,E,F,Base.Order.ReverseOrdering}\n\nA priority queue for storing encroached segments to be split. The keys are the squared edge lengths.\n\ntriangle_queue::PriorityQueue{T,E,F,Base.Order.ReverseOrdering}\n\nA priority queue for storing triangles to be refined. The keys are radius-edge ratio.\n\n\n\n\n\n","category":"type"},{"location":"triangulations/refinement/#Unconstrained-triangulations","page":"Mesh Refinement","title":"Unconstrained triangulations","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Although rarely needed, let us start with an unconstrained triangulation example. To prevent points from being inserted into the triangulation outside of the convex hull (and typically out to infinity), the convex hull of the triangulation's points (i.e. the triangulation's boundary) are locked in place and treated as constrained segments. Once the refinement is done, they are unlocked.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"First, let us take some point cloud and build its triangulation.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"using DelaunayTriangulation, CairoMakie\npts = [(rand(), rand()) for _ in 1:50]\ntri = triangulate(pts)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We now refine it. We will use a minimum angle constraint of 30 degrees, and a maximum area constraint of 1% of the total area.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = get_total_area(tri)\nstats = refine!(tri; min_angle=30.0, max_area=0.01A)\nDelaunay Triangulation Statistics.\n   Triangulation area: 0.8744517117708429\n   Number of vertices: 283\n   Number of solid vertices: 282\n   Number of ghost vertices: 1\n   Number of edges: 843\n   Number of solid edges: 771\n   Number of ghost edges: 72\n   Number of triangles: 490\n   Number of solid triangles: 490\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 72\n   Smallest angle: 30.04506696762518°\n   Largest angle: 116.57834703069716°\n   Smallest area: 1.8915322852892662e-5\n   Largest area: 0.008731595421089517\n   Smallest radius-edge ratio: 0.5784601192132447\n   Largest radius-edge ratio: 0.9986397882266155","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"As we can tell from the output, indeed each angle is above 30 degrees. Below we show a comparison of the original triangulation, its refinement, and a histogram of the minimum angle and (relative) areas of each triangle.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"fig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.001:0.01)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=20:2:60)\nvlines!(ax, [30.0], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/unconstrained_refinement.png', alt='Unconstrained refinement'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"The triangulation is now quite uniform, and the angles are all satisfactory. If we wanted to refine further, just call refine! again with your new quality targets.","category":"page"},{"location":"triangulations/refinement/#Constrained-triangulations","page":"Mesh Refinement","title":"Constrained triangulations","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"From now, we focus on examples that have constrained segments or boundaries. ","category":"page"},{"location":"triangulations/refinement/#A-rectangle","page":"Mesh Refinement","title":"A rectangle","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A typical scenario in meshing is to start with a boundary, and then insert the vertices. Below we show how we can create a rectangle with a constrained diagonal, and then mesh it. We use a minimum angle of 33 degrees.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"p1 = (0.0, 0.0)\np2 = (1.0, 0.0)\np3 = (1.0, 0.5)\np4 = (0.0, 0.5)\npts = [p1, p2, p3, p4, p1]\nboundary_nodes, points = convert_boundary_points_to_indices(pts)\nC = Set(((2, 4),))\ntri = triangulate(points; boundary_nodes, edges=C)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; min_angle=33.0, max_area=0.001A)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.0001:0.001)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:2:60)\nvlines!(ax, [30.0], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/square_constrained_refinement.png', alt='Refined rectangle'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"In this case, there are some angles below the minimum angle because the input domain has small angles. Typically, there will only be very few triangles that are forced to have a minimum angle. Moreover, from this paper, the maximum angle will still satisfy theta_max leq maxpi - 2kappa pi - 2arcsin(sqrt 3 - 1)2, where kappa is our minimum angle constraint. In our case, this gives theta_max to be bounded by about 137 degrees, which is true for this example (the maximum is about 112 degrees).","category":"page"},{"location":"triangulations/refinement/#Multiply-connected-domain","page":"Mesh Refinement","title":"Multiply-connected domain","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"We can refine triangulations that are multiply-connected. Here is an example that shows that, even if the triangulation is quite complicated, we can still get a reasonably fine mesh.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"A = (0.0, 0.0)\nB = (0.0, 25.0)\nC = (5.0, 25.0)\nD = (5.0, 5.0)\nE = (10.0, 5.0)\nF = (10.0, 10.0)\nG = (25.0, 10.0)\nH = (25.0, 15.0)\nI = (10.0, 15.0)\nJ = (10.0, 25.0)\nK = (45.0, 25.0)\nL = (45.0, 20.0)\nM = (40.0, 20.0)\nN = (40.0, 5.0)\nO = (45.0, 5.0)\nP = (45.0, 0.0)\nQ = (10.0, 0.0)\nR = (10.0, -5.0)\nS = (15.0, -5.0)\nT = (15.0, -10.0)\nU = (10.0, -10.0)\nV = (5.0, -10.0)\nW = (5.0, -5.0)\nZ = (5.0, 0.0)\nA1 = (5.0, 2.5)\nB1 = (10.0, 2.5)\nC1 = (38.0, 2.5)\nD1 = (38.0, 20.0)\nE1 = (27.0, 20.0)\nF1 = (27.0, 11.0)\nG1 = (27.0, 4.0)\nH1 = (2.0, 4.0)\nI1 = (2.0, 0.0)\npts = [A, I1, H1, G1, F1, E1, D1, C1, B1, A1, Z, W, V, U, T, S, R, Q, P, O, N, M, L, K, J, I, H, G, F, E, D, C, B, A]\nJ1 = (17.0603265896789, 7.623652007194)\nK1 = (14.8552854162067, 6.5423337394336)\nL1 = (16.6998871670921, 6.9875824379232)\nM1 = (16.0, 6.0)\nN1 = (16.9755173137761, 6.6483453343121)\nO1 = (17.0391242707032, 4.8885528593294)\nP1 = (17.4207660122657, 6.4575244635308)\nQ1 = (17.6327892020226, 4.9945644542079)\nR1 = (22.6789411182379, 6.1818943168468)\nS1 = (21.8096460402344, 6.4787267825065)\nT1 = (26.0, 8.0)\nU1 = (15.0673086059636, 9.086612016517)\nW1 = (15.0, 8.5)\nZ1 = (17.7913089332764, 8.3603005983396)\ninner_pts = [Z1, W1, U1, T1, S1, R1, Q1, P1, O1, N1, M1, L1, K1, J1, Z1]\nboundary_pts = [[pts], [inner_pts]]\nnodes, points = convert_boundary_points_to_indices(boundary_pts)\npush!(points, (20.0, 20.0))\nC = Set{NTuple{2,Int}}()\nfor i in 1:50\n    θ = 2π * rand()\n    r = 4sqrt(rand())\n    x = 20 + r * cos(θ)\n    y = 20 + r * sin(θ)\n    push!(points, (x, y))\n    push!(C, (48, 48 + i))\nend\ntri = triangulate(points; boundary_nodes=nodes, edges=C)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; max_area=0.001A, min_angle = 27.3)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri)\nareas = get_all_stat(stats, :area) ./ A\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.0000001:0.000001)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:0.5:40)\nvlines!(ax, [27.3], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/mc_constrained_refinement.png', alt='Refined rectangle'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Most of the triangles are the same size as we see in (c). Moreover, most angles are above the minimum, except for between segments that subtend a small angle (those coming from all the spokes in the upper part of the domain).","category":"page"},{"location":"triangulations/refinement/#Multipolygons","page":"Mesh Refinement","title":"Multipolygons","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Refinement even works on multipolygons. Here's an example using the Julia logo example.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"C = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\n\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\ntri = triangulate(points; boundary_nodes=nodes, check_arguments=false)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; min_angle=26.45, max_area=0.005A / 9)\n\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", title=L\"(a):$ $ Original\", width=400, height=400, titlealign=:left)\ntriplot!(ax, orig_tri, show_convex_hull=false) # orig_tri was deepcopy(triangulate(pts)) from before \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", title=L\"(b):$ $ Refined\", width=400, height=400, titlealign=:left)\ntriplot!(ax, tri, show_convex_hull=false)\nareas = get_all_stat(stats, :area) ./ (0.005A)\nangles = getindex.(get_all_stat(stats, :angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\", ylabel=L\"$ $Count\", title=L\"(c):$ $ Area histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, areas, bins=0:0.001:0.1)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\", ylabel=L\"$ $Count\", title=L\"(d):$ $ Angle histogram\", width=400, height=400, titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:0.2:40)\nvlines!(ax, [26.45], color=:red)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/julia_constrained_refinement.png', alt='Refined Julia logo'><br>\n</figure>","category":"page"},{"location":"triangulations/refinement/#Tasmania","page":"Mesh Refinement","title":"Tasmania","text":"","category":"section"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"Just to show that we can even triangulate really complicated boundaries with many small angles, here's Tasmania. The file tassy.txt came from an image of Tasmania that was then traced using ImageJ.","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"tassy = readdlm(\"./test/tassy.txt\")\nymax = @views maximum(tassy[:, 2])\ntassy = [(x, ymax - y) for (x, y) in eachro(tassy)]\nreverse!(tassy)\nunique!(tassy)\npush!(tassy, tassy[begin])\nboundary_nodes, points =convert_boundary_points_to_indices(tassy)\ntri = triangulate(points;boundary_nodes=boundary_nodes)\norig_tri = deepcopy(tri)\nA = get_total_area(tri)\nstats = refine!(tri; max_area=1e-3A)\nfig = Figure(fontsize=33)\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\",title=L\"(a):$ $ Original\", width=400,height=400, titlealign=:left)\ntriplot!(ax, orig_tri, show_convex_hull=false)# orig_tri was deepcopy(triangulate(pts)) frombefore \nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\",title=L\"(b):$ $ Refined\", width=400,height=400, titlealign=:left)\ntriplot!(ax, tri, show_convex_hull=false)\nareas = get_all_stat(stats, :area) ./ (1e-3A)\nangles = getindex.(get_all_stat(stats,:angles), 1) # 1 is the smallest\nax = Axis(fig[2, 1], xlabel=L\"A/A(\\Omega)\",ylabel=L\"$ $Count\", title=L\"(c):$ $ Areahistogram\", width=400, height=400,titlealign=:left)\nhist!(ax, areas, bins=0:0.01:1)\nylims!(ax, 0, 1000)\nax = Axis(fig[2, 2], xlabel=L\"\\theta_{\\min}\",ylabel=L\"$ $Count\", title=L\"(d):$ $ Anglehistogram\", width=400, height=400,titlealign=:left)\nhist!(ax, rad2deg.(angles), bins=0:0.2:60)\nvlines!(ax, [30.0], color=:red)\nresize_to_layout!(fig)\nylims!(ax, 0, 1000)","category":"page"},{"location":"triangulations/refinement/","page":"Mesh Refinement","title":"Mesh Refinement","text":"<figure>\n    <img src='../figs/tassy_constrained_refinement.png', alt='Tasmania'><br>\n</figure>","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"boundary_handling/#Ghost-Triangles,-Boundary-Handling,-and-Boundary-Specifcations","page":"Boundary Handling","title":"Ghost Triangles, Boundary Handling, and Boundary Specifcations","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Here we will give a description about how we represent boundaries, and also how we use ghost triangles.","category":"page"},{"location":"boundary_handling/#Boundary-Indices","page":"Boundary Handling","title":"Boundary Indices","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"We use negative indices to denote vertices belonging to a boundary. For example, if tri is a triangulation and get_adjacent(adj, u, v) == -1, then this means that (u, v) is an edge on the boundary. We call this -1 a ghost vertex or a boundary index (positive vertices could also be called solid vertices), with -1 defined from DelaunayTriangulation.BoundaryIndex, which we discuss more in the next section.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"In the case of a single contiguous outer boundary, having -1 as the only boundary index is simple and works fine. If we have multiple segments or multiple boundaries, then we need to somehow have multiple boundary indices so that we can refer to each segment separately. We accomplish this by simply subtracting 1 from the current boundary index for each new segment. This is handled by add_boundary_information!. For example, if we had","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"bn = [\n    [segment_1, segment_2, segment_3],\n    [segment_4, segment_5],\n    [segment_6],\n    [segment_7, segment_8, segment_9, segment_10]\n]","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"then the ith segment will map to -i. Note that this always means that -1 belongs to the outer-most boundary. There is a possible issue we can have with this when, for example, stepping around a boundary, since nodes will occur in two segments and hence nodes may not necessarily have a unique boundary index assigned to them. To handle this case, allowing us to check for all possible boundary indices when stepping around a boundary (or however else we might want to use Adjacent or similar), get_adjacent can call a safer version _safe_get_adjacent, which checks the boundary indices using boundary_index_ranges.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"These issues are why the Triangulation data structure has the boundary_map and boundary_index_ranges fields. boundary_map, constructed with construct_boundary_map, is used to map a boundary index to its segment in the set of boundary nodes, so that get_boundary_nodes(boundary_nodes, map_boundary_index(boundary_map, g)) gives the nodes corresponding to the segment which has boundary index g. To handle the issue with a curve having multiple boundary indices, we use boundary_index_ranges, constructed with construct_boundary_index_ranges, to map a boundary index g to all other indices that could be found on the associated curve. For example, in the bn example above, -2 would map to -3:-1.","category":"page"},{"location":"boundary_handling/#Ghost-Triangles","page":"Boundary Handling","title":"Ghost Triangles","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Ghost triangles are a special triangle that has a solid edge (u, v) and a vertex g associated with some boundary index. These ghost triangles are needed to make point location actually work properly when points are outside of the triangle, provided we associate the ghost vertex g with a physical point. For the outer-most boundary, this physical point just has to be somewhat in the center of the domain, which we define using a centroid when building the triangulation and the pole of inaccessibility once we have built the entire triangulation. With this physical point, ghost edges (u, g) are then interpreted to be of infinite extent, pointing from u out to infinity, but collinear with this central point. ","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"In the case of an inner boundary, these ghost edges are of finite extent, simply connecting with the point g which is define via the pole of inaccessibility.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"For the Bowyer-Watson algorithm, we need a definition for the circumcircle of a ghost triangle. For ghost triangles that belong to inner boundaries, we simply use the triangle that connects the points, since there is no issue with infinity here. For the outer ghost triangles, we need to be careful. Imagine taking a triangle and pulling away one of its vertices to infinity. The circumcircle would keep growing until it eventually covers the entire space on the side of the fixed edge that the point was on. In particular, the circle becomes the line through the fixed edge, dividing the plane into two half-planes. We then say that a point is in the circumcircle of an outer ghost triangle if it is in the open half-plane on the other side of the edge from the triangulation, or if it is on the edge itself (but is not one of the vertices). The union of the open half-plane and this open edge is called the outer half-plane of the edge.","category":"page"},{"location":"boundary_handling/#Boundary-Specification","page":"Boundary Handling","title":"Boundary Specification","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"When considering constrained triangulations, we allow for a set of boundary nodes to be provided. These nodes can be defined to represent three possible domains:","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"A contiguous boundary with no holes. For example, a circle.\nA single boundary with no holes, but the boundary is split into multiple segments that can be identified separately via boundary indices. For example, a square with a boundary index for each side.\nA boundary comprising multiple disjoint curves, i.e. a multiply-connected domain. For example, a square with a circular hole inside. The most support is provided for the case where no interior hole contains another interior, but it is allowed (see the discussion in the constrained triangulation section).","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"We do also provide support for much more complex geometries, such as disjoint regions, but the support is only for constructing the mesh. Limited support exists, for example, for point location in such regions. See the examples in the constrained triangulation section. There might also be issues with domains that are non-convex.","category":"page"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"The way to represent boundaries can be customised as needed (see the Interfaces section), but by default we provide the following specifications; this specification is what we use in the convert_boundary_points_to_indices function. The specification that follows is also valid for generate_mesh where coordinates are used instead of indices. Let bn be the set of boundary nodes and I the integer type.","category":"page"},{"location":"boundary_handling/#Contiguous-boundary","page":"Boundary Handling","title":"Contiguous boundary","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"For a contiguous boundary, bn should be a single Vector{I} such that bn[begin] == bn[end], defining a boundary in counter-clockwise order. ","category":"page"},{"location":"boundary_handling/#Single-boundary-split-into-segments","page":"Boundary Handling","title":"Single boundary split into segments","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Now consider a single boundary with no holes, but given by multiple segments, say into ns segments. Then bn should be a Vector{Vector{I}} with length(bn) = ns. The vectors should be defined such that the endpoints connect, meaning bn[i][end] == bn[i+1][begin] for i < ns or bn[end][end] == bn[begin][begin]. Additionally, the nodes should be defined in counter-clockwise order. ","category":"page"},{"location":"boundary_handling/#Multiply-connected-domain","page":"Boundary Handling","title":"Multiply-connected domain","text":"","category":"section"},{"location":"boundary_handling/","page":"Boundary Handling","title":"Boundary Handling","text":"Now suppose we have a boundary that is split into multiple curves, say into nc curves. In this case, bn is a Vector{Vector{Vector{I}}} where each individual curve bn[i] is assumed to represent a single boundary split into segments, with each bn[i] matching the previous specification. In this case, we provide the most support for the case where bn[1] is the outermost boundary curve, and all curves bn[i] for i > 1 are inside bn[1]. With this, bn[1] should be counter-clockwise, while bn[i] for i > 1 should be clockwise. While it is possible to place interior curves inside other interior curves, e.g. bn[j] could be inside bn[i] as long as bn[j] is counter-clockwise, less support for point location and other features is provided for this case. See the constrained triangulation section.","category":"page"},{"location":"interface/points/","page":"Points","title":"Points","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/points/#Individual-Points","page":"Points","title":"Individual Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"Points are assumed to take the form (x, y), but we allow for customisation in how we represent these points. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getx \ngety ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getx","page":"Points","title":"DelaunayTriangulation.getx","text":"getx(p::P) where {P}\n\nGiven a point p, returns the x-coordinate. The  only methods currently defined are\n\ngetx(p::NTuple{N,T}) where {N,T}\ngetx(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.gety","page":"Points","title":"DelaunayTriangulation.gety","text":"gety(p::P) where {P}\n\nGiven a point p, returns the y-coordinate. The  only methods currently defined are\n\ngety(p::NTuple{N,T}) where {N,T}\ngety(p::AbstractVector)\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getxy ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getxy","page":"Points","title":"DelaunayTriangulation.getxy","text":"getxy(p)\n\nGiven a point p, returns (getx(p), gety(p)).\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Collection-of-Points","page":"Points","title":"Collection of Points","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"A collection of points simply store many points. It does not need to be mutable (unless you want to add points into the triangulation not already in tri.points, or if you want mesh refinement). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/points/#Necessary-Methods-2","page":"Points","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"getpoint \neach_point_index \neach_point\nnum_points \nnumber_type \npush_point!\npop_point!\nset_point!","category":"page"},{"location":"interface/points/#DelaunayTriangulation.getpoint","page":"Points","title":"DelaunayTriangulation.getpoint","text":"getpoint(pts::P, i)\n\nGiven a collection of points pts, returns a Tuple  of the x and y coordinates of the ith point in  the collection. The methods currently defined are \n\ngetpoint(pts::AbstractVecOrTuple, i)\ngetpoint(pts::AbstractMatrix, i)\n\nYou can extend this function as you need. \n\nIt is assumed that whenever i is not an integer, i is meant to be  a point, so (getx(i), gety(i)) would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point_index","page":"Points","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(pts::P) where {P}\n\nGiven a collection of points pts, returns an iterator  over the indices of the collection. The methods currently  defined are \n\neach_point_index(pts::AbstractVecOrTuple)\neach_point_index(pts::AbstractMatrix)\n\nwith the first returning eachindex(pts) and the second  returning axes(pts, 2). You can extend this function  as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.each_point","page":"Points","title":"DelaunayTriangulation.each_point","text":"each_point(pts::P) where {p}\n\nFor a given collection of points p, returns an iterator that  goes over each point in the collection. The methods currently  defined are \n\neach_point(pts::AbstractVecOrTuple)\neach_point(pts::AbstractMatrix)\n\nwith the first method simply returning pts, and the second returning  eachcol(pts). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.num_points","page":"Points","title":"DelaunayTriangulation.num_points","text":"num_points(pts)\n\nReturns the number of points in pts. The methods currently defined are \n\nnum_points(pts::AbstractVecOrTuple)\nnum_points(pts::AbstractMatrix)\n\nwith the first returning length(pts) and the second returning size(pts, 2). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.number_type","page":"Points","title":"DelaunayTriangulation.number_type","text":"number_type(vor::VoronoiTessellation)\n\nReturns the type of the numbers used in the Voronoi tessellation vor.\n\n\n\n\n\nnumber_type(x)\n\nGiven a container x, returns the number type used for storing coordinates.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.push_point!","page":"Points","title":"DelaunayTriangulation.push_point!","text":"push_point!(pts, x, y)\n\nPushes the point (x, y) into pts. The only methods currently  defined are  \n\npush_point!(pts::AbstractVector{T}, x, y) where {F,T<:NTuple{2,F}} = push!(pts, (F(x), F(y)))\npush_point!(pts::AbstractVector{T}, x, y) where {F<:Number,T<:AbstractVector{F}} = push!(pts, F[x, y])\n\nYou can extend this function as needed. We also provide the method \n\npush_point!(pts, p) = push_point!(pts, getx(p), gety(p))\n\nwhich you can extend if you have a point type p that has getx and gety.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.pop_point!","page":"Points","title":"DelaunayTriangulation.pop_point!","text":"pop_point!(pts)\n\nPops the last point from pts. The only method currently defined is\n\npop_point!(pts::AbstractVector) = pop!(pts)\n\nYou can extend this function as needed.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.set_point!","page":"Points","title":"DelaunayTriangulation.set_point!","text":"set_point!(points, i, x, y)\n\nSets the point at index i in points to (x, y). The only methods currently defined are \n\nset_point!(points::AbstractVector{T}, i, x, y) = (points[i] = (x, y))\nset_point!(points::AbstractMatrix{T}, i, x, y) where {T} = (points[1, i] = x; points[2, i] = y)\n\nYou can extend this function as needed. We also define \n\nset_point!(points, i, p) = set_point!(points, i, getx(p), gety(p))\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#Generic-Methods-2","page":"Points","title":"Generic Methods","text":"","category":"section"},{"location":"interface/points/","page":"Points","title":"Points","text":"get_point \npoints_are_unique \nlexicographic_order\nmean_points ","category":"page"},{"location":"interface/points/#DelaunayTriangulation.get_point","page":"Points","title":"DelaunayTriangulation.get_point","text":"get_point(pts::P, i...)\n\nGiven a collection of points pts, returns the points  corresponding to the indices in i.... This simply  calls getpoint - you do not need to  extend this method. \n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.points_are_unique","page":"Points","title":"DelaunayTriangulation.points_are_unique","text":"points_are_unique(pts)\n\nReturns true if pts has no duplicate points, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.lexicographic_order","page":"Points","title":"DelaunayTriangulation.lexicographic_order","text":"lexicographic_order(pts)\n\nReturns a set of indices idx that gives the lexicographic ordering  of the set of points pts, i.e. sorting by x and then sorting points  with duplicate x-coordinates by y. The implementation is simply \n\nlexicographic_order(pts) = (sortperm ∘ collect ∘ each_point)(pts)\n\nwhich you might want to specialise for an easier representation of your  points pts.\n\n\n\n\n\n","category":"function"},{"location":"interface/points/#DelaunayTriangulation.mean_points","page":"Points","title":"DelaunayTriangulation.mean_points","text":"mean_points(points, vertices = each_point_index(points))\n\nReturns the mean of the points in points indexed by vertices, given as a Tuple of the form (mean_x, mean_y).\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/convex/#Chew's-Algorithm-for-Triangulating-Convex-Polygons","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"","category":"section"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"Our algorithm for triangulating convex polygons comes from L. Paul Chew's \"Building Voronoi diagrams for convex polygons in linear expected time\" back in 1990, following the presentation of it in the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013). The idea is that we can utilise the neighbour information already provided by the definition of a polygon to avoid the point location step, which turns out to be the most expensive step when computing triangulations normally. This algorithm is mainly used so that we can delete vertices from a Delaunay triangulation - see the referenced book for more detail.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"A basic overview of the algorithm is as follows: Let us suppose that S is a sequence that lists the k vertices of some convex polygon in counterclockwise order, say S = v_1 ldots v_k, as obtained via get_surrounding_polygon:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"get_surrounding_polygon","category":"page"},{"location":"tri_algs/convex/#DelaunayTriangulation.get_surrounding_polygon","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(vor::VoronoiTessellation, i)\n\nGets the polygon surrounding the generator with index i in vor. You shouldn't need  to use this, see get_polygon instead.\n\n\n\n\n\nget_surronding_polygon(tri, u; skip_boundary_indices=false)\n\nReturns the set of neighbours of u in counter-clockwise order. If skip_boundary_indices is true, then boundary indices are not included in the set.\n\n\n\n\n\nget_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}\n\nGiven a point u, returns a vector S which gives a counter-clockwise sequence of the neighbours of u. \n\nArguments\n\nadj::Adjacent{I,E}: The Adjacent map.\ngraph::Graph: The Graph.\nu: The vertex.\nboundary_index_ranges: The output of construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nKeyword Arguments\n\nskip_boundary_indices=false: Whether to remove all boundary indices from the result at the end.\n\nOutputs\n\nS: The surrounding polygon.\n\nnote: Note\nWhen u is an outer boundary index, the returned polygon is clockwise.\nWhen u is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"To improve the complexity of our algorithm, we should randomise the insertion order for the polygon vertices to reduce the work needed, noting that the average degree of a vertex in a triangulation should typically be around six. So, we construct some permutation pi of 1 ldots k that will define how we insert the points, taking the first three vertices pi_1 pi_2 pi_3 as our initial triangle. Then, using the Bowyer-Watson algorithm, we can add in points one at a time, simply walking along the polygon to find triangles rather than the jump and march algorithm used in our main Bowyer-Watson algorithm. Note that when we add some vertex u, only one edge can separate it from the triangulation's interior, else the polygon wouldn't be convex. Hence, when u is inserted, we just take the union of this disk with all other triangles whose open circumdisks contain u. This will give us our triangulation.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"Let us now describe the algorithm in more detail. The main complexity in the algorithm comes in from devising a smart way for avoiding point location. This is done with backward analysis, where instead of imagining points in one at a time, we think about what happens if we delete vertices one at a time. Suppose we have a vertex u with neighbours v and w. When we delete u, the only way to reform the poylgon and keep it convex is to join v and w, i.e. a deletion of a vertex also implies a new edge from its neighbours. This edge is exactly what we need for point location: the edge we need is simply the edge from a point's neighbours, thus allowing us to skip the jump and march algorithm. With this knowledge, we construct a circularly-, doubly-linked list of our polygon vertices, called mathcal N (next) and mathcal P (previous) for the two neighbours of each vertex, and then we imagine deleting vertices one at a time by simply editing this linked list. The steps are as follows:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"First, take S = v_1 ldots v_k and a permutation pi of 1ldotsk.\nNext, compute mathcal N = 2 3 ldots 1 and mathcal P = k 1 ldots k-1.\nThen, from i=k down to i=4:  a. To delete v_pi_i from the polygon, we can set mathcal Nmathcal P(pi_i) mapsfrom mathcal N(pi_i) and mathcal Pmathcal N(pi_i) = mathcal P(pi_i), i.e. just connect the two neighbours together.\nNow, start the triangulation with the initial triangle through (v_pi_1, v_mathcal N(pi_1), v_mathcal P(pi_1). If this triangle is degenerate, just repeat the above steps until you find a non-degenerate triangular.\nNow that we have our initial triangle, we can start adding points in. So, for i = 4 up to i = k:  a. Call the routine mathcal C(v_pi_i v_mathcal N(pi_i) v_mathcal P(pi_i)) to insert v_pi_i, defined below.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"This routine mathcal C(u v w) is defined as follows:","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"First, take x = mathcal A(w v) where mathcal A is the adjacent map. With this definition, the triangle wvx is opposite the ede vw from u.\nIt is possible that x is not on the polygon, i.e. x might be emptyset or, if this algorithm is being used for deleting a vertex so that the polygon is embedded inside a larger triangulation, x could be a vertex away from the polygon, so we must check that x in S. Moreover, we must check that x is actually inside the triangle through u, v, and w. If these two conditions hold, then the triangles uvw and wvx must not be Delaunay, so delete the triangle wvx, and continue stepping through the triangulation by calling mathcal C(u v x) and mathcal C(u x w) so that more non-Delaunay triangles can be identified and deleted.\nIf the two conditions in the last step did not hold, we start this third step (otherwise, return in step 2 above). These two conditions holding mean that vw is still a Delaunay edge, so we can edge the triangle uvw into the triangle.","category":"page"},{"location":"tri_algs/convex/","page":"Chew's Algorithm for Triangulating Convex Polygons","title":"Chew's Algorithm for Triangulating Convex Polygons","text":"With this routine and the steps for the original algorithm, we can triangulate convex polygons.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tessellations/clipped/#Clipped-Voronoi-Tessellations","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"","category":"section"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Often, it is useful to chop off the unbounded polygons in a tessellation, truncating them to some boundary. Usually this is just a box. We currently provide support for chopping to a convex hull, but the aim is to eventually support chopping to any boundary (the same algorithm we use should apply here, but there are some special cases that are really quite difficult). ","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The same function voronoi is used for this, just setting the second argument to be true. The algorithm is described at the end of this section.","category":"page"},{"location":"tessellations/clipped/#Example","page":"Clipped Voronoi Tessellations","title":"Example","text":"","category":"section"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Let us give an example.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"using DelaunayTriangulation, CairoMakie\npts = randn(2, 250)\ntri = triangulate(pts)\nvorn = voronoi(tri)\nvorn_clip = voronoi(tri, true)\n\nfig = Figure()\nax = Axis(fig[1, 1], aspect=1)\nvoronoiplot!(ax, vorn, strokecolor=:red, strokewidth=0.2, show_generators=false)\ntriplot!(ax, tri, strokewidth=0.0, strokecolor=(:black, 0.4), show_convex_hull=true)\nxlims!(ax, -5, 5)\nylims!(ax, -5, 5)\nax = Axis(fig[1, 2], aspect=1)\nvoronoiplot!(ax, vorn_clip, strokecolor=:red, strokewidth=0.2, show_generators=false)\ntriplot!(ax, tri, strokewidth=0.0, strokecolor=(:black, 0.4), show_convex_hull=true)\nxlims!(ax, -5, 5)\nylims!(ax, -5, 5)","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"<figure>\n    <img src='../figs/bounded.png', alt='Clipped Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"As we can see, all the polygons have now been chopped so that the entire tessellation fits into the original boundary of the dual triangulation. Also, the unbounded_polygons and boundary_polygons fields have been updated:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_unbounded_polygons(vorn_clip)\nSet{Int}()\n\njulia> DelaunayTriangulation.get_boundary_polygons(vorn_clip)\nSet{Int} with 31 elements:\n  169\n  56\n  200\n  195\n  72\n  180\n  221\n  8\n  37\n  187\n  32\n  6\n  171\n  190\n  69\n  219\n  73\n  ⋮","category":"page"},{"location":"tessellations/clipped/#Algorithm","page":"Clipped Voronoi Tessellations","title":"Algorithm","text":"","category":"section"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Since the code for clipping is quite involved, most likely more involved than it should be, it is probably worthwhile describing the actual implementation here. I want to one day refine this approach, and allow it to work on any domain. The approach is mostly based on the ideas in the paper \"Efficient Computation of Clipped Voronoi Diagram for Mesh Generation\" by Yan, Wang, Lévy, and Liu. I imagine if I had access to their code, everything would be a lot nicer (that seems to be true in many computational geometry papers).","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The function that performs the clipping is clip_voronoi_tessellation!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"clip_voronoi_tessellation!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.clip_voronoi_tessellation!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.clip_voronoi_tessellation!","text":"clip_voronoi_tessellation!(vorn::VoronoiTessellation)\n\nClip the Voronoi tessellation vorn to the convex hull of the points in vorn. \n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"This function starts off by finding all the intersections and then adding them into the point set, then using these new points to clip the polygons. We describe these steps below.","category":"page"},{"location":"tessellations/clipped/#Finding-all-intersections","page":"Clipped Voronoi Tessellations","title":"Finding all intersections","text":"","category":"section"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The function find_all_intersections finds the intersections of the polygons with the boundary.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"find_all_intersections\ninitialise_clipping_arrays","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.find_all_intersections","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.find_all_intersections","text":"find_all_intersections(vorn::VoronoiTessellation)\n\nFind all intersections between the edges of the Voronoi tessellation and the boundary of the polygon.\n\nOutputs\n\nboundary_sites: A dictionary of boundary sites.\nsegment_intersections: The intersection points. \nexterior_circumcenters: The circumcenters that are outside of the domain.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.initialise_clipping_arrays","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.initialise_clipping_arrays","text":"initialise_clipping_arrays(vorn::VoronoiTessellation)\n\nInitialise the arrays used in the clipping algorithm.\n\nOutputs\n\nedges_to_process: The set of edges that are to be processed.\npolygon_edge_queue: The queue of edges that are to be processed.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nsegment_intersections: The list of segment intersections.\nprocessed_pairs: The set of pairs of edges and polygons that have been processed.\nintersected_edge_cache: The list of intersected edges currently being considered.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nleft_edge_intersectors: The set of sites that intersect the edge to the left of an edge currently being considered.\nright_edge_intersectors: The set of sites that intersect the edge to the right of an edge currently being considered.\ncurrent_edge_intersectors: The set of sites that intersect the current edge being considered.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The idea is to use a first-in first-out (FIFO) queue to prioritise the edges and polygons to consider. In particular, we pick some random edge and then use its midpoint to find what polygon that midpoint is in (via jump_and_march). This edge and the polygon are then added into the queue to be processed. Starting with this edge-polygon pair, we keep looking for intersections until we have processed all boundary edges and there are no more pairs in the queue. The function that does this processing of queued pairs is dequeue_and_process!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"dequeue_and_process!\nenqueue_new_edge!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.dequeue_and_process!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.dequeue_and_process!","text":"dequeue_and_process!(vorn, polygon_edge_queue, edges_to_process, intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, processed_pairs, boundary_sites, segment_intersections, exterior_circumcenters, equal_circumcenter_mapping)\n\nDequeue an edge from polygon_edge_queue and process it. If polygon_edge_queue is empty, then we process the first edge in edges_to_process.\n\nArguments\n\nvorn: The Voronoi tessellation.\npolygon_edge_queue: The queue of edges that need to be processed.\nedges_to_process: The edges that need to be processed.\nintersected_edge_cache: A cache of intersected edges.\nleft_edge_intersectors: The intersection points of left_edge with other edges.\nright_edge_intersectors: The intersection points of right_edge with other edges.\ncurrent_edge_intersectors: The intersection points of current_edge with other edges.\nprocessed_pairs: A set of pairs of edges and polygons that have already been processed.\nboundary_sites: A dictionary of boundary sites.\nsegment_intersections: A dictionary of segment intersections.\nexterior_circumcenters: A dictionary of exterior circumcenters.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.enqueue_new_edge!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.enqueue_new_edge!","text":"enqueue_new_edge!(polygon_edge_queue, vorn::VoronoiTessellation, e)\n\nEnqueue the edge e of the boundary to be processed.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Essentially, this function first checks if the pair has already been processed and, if so, returns. Otherwise, the first step is to go into process_polygon! to find the intersections of the polygons with the nearby boundary:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"process_polygon!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.process_polygon!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.process_polygon!","text":"process_polygon!(vorn::VoronoiTessellation, e, incident_polygon, boundary_sites, segment_intersections, intersected_edge_cache, exterior_circumcenters, equal_circumcenter_mapping)\n\nProcess the polygon incident_polygon for all of its intersections based on the boundary edge e, updating the caches in-place and returning (left_edge, right_edge, e), where  left_edge is the edge to the left of e on the boundary and right_edge is the edge to the right of e on the boundary.\n\nArguments\n\nvorn::VoronoiTessellation: The Voronoi tessellation.\ne: The edge on the boundary being considered.\nincident_polygon: The index of the polygon being considered.\nboundary_sites: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.\nsegment_intersections: The list of segment intersections.\nintersected_edge_cache: A cache of the edges that have been intersected by the ray from u to v.\nexterior_circumcenters: A list of the circumcenters of the sites that are outside the convex hull of the sites on the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The goal of process_polygon! is to iterate over the edges of the current polygon to look for intersections, searching (1) the current edge, (2) the edge to the left of the current edge, and (3) the edge to the right of the current edge. Suppose we have an edge e_uv of the polygon being considered. There are four possibilities:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"First, both u and v could correspond to ghost vertices, meaning no intersection with the boundary is possible.\nAlternatively, e_uv could be a ray going inwards, meaning u is a ghost vertex while v corresponds to an actual circumcenter. In this case, process_ray_intersection! is used to look for an intersection of e_uv with the edge of the ghost triangle corresponding to u. If an intersection is found, we do need to be careful of rays that intersect multiple boundary edges (as is common when we have very few triangles in the underlying triangulation). This check is done with process_ray_intersection_with_other_edges!, which simply looks at the left and right edges along with the current edge. \nSame as the above, except e_uv could be a ray going inwards, meaning u now corresponds to an actual cicrcumcenter while v is a ghost vertex.\nLastly, e_uv could be a fniite segment, in which case we can use simple intersection formula to test for intersections with the left and right edges along with the current edge. This check is done via process_segment_intersection!.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"In these steps, when there are no intersections we also check if it was because a segment lies entirely outside of the domain. We keep track of these points as these will need to be deleted later.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Some of the relevant docstrings for working with process_polygon! are below.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"is_segment_between_two_ghosts\nis_ray_going_in\nis_ray_going_out\nis_finite_segment\nprocess_segment_intersection!\nprocess_ray_intersection!\nadd_to_intersected_edge_cache!\nadd_segment_intersection!\nsegment_intersection_coordinates\nintersection_of_edge_and_bisector_ray\nclassify_and_compute_segment_intersection\nprocess_ray_intersection_with_other_edges!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.is_segment_between_two_ghosts","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.is_segment_between_two_ghosts","text":"is_segment_between_two_ghosts(u, v)\n\nCheck if the segment between the sites u and v is between two ghost sites.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.is_ray_going_in","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.is_ray_going_in","text":"is_ray_going_in(u, v)\n\nCheck if the ray from the site u to the site v is going in.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.is_ray_going_out","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.is_ray_going_out","text":"is_ray_going_out(u, v)\n\nCheck if the ray from the site u to the site v is going out.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.is_finite_segment","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.is_finite_segment","text":"is_finite_segment(u, v)\n\nCheck if the segment between the sites u and v is finite.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.process_segment_intersection!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.process_segment_intersection!","text":"process_segment_intersection!(\n    vorn::VoronoiTessellation,\n    u,\n    v,\n    e,\n    incident_polygon,\n    intersected_edge_cache,\n    segment_intersections,\n    boundary_sites,\n    exterior_circumcenters,\n    equal_circumcenter_mapping)\n\nProcess the intersection of the Voronoi polygon's edge (u, v) with the edge e of the boundary, returning the coordinates of the intersection and updating via add_segment_intersection.\n\nArguments\n\nvorn: The Voronoi tessellation.\nu: The index of the site u.\nv: The index of the site v.\ne: The edge e of the boundary.\nincident_polygon: The index of the Voronoi polygon currently being considered (u, v).\nintersected_edge_cache: The list of intersected edges currently being considered.\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.process_ray_intersection!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.process_ray_intersection!","text":"process_ray_intersection!(\n    vorn::VoronoiTessellation,\n    u,\n    v,\n    incident_polygon,\n    intersected_edge_cache,\n    segment_intersections,\n    boundary_sites,\n    exterior_circumcenters,\n    equal_circumcenter_mapping)\n\nProcess the intersection of the Voronoi polygon of the site u with the ray emanating from the circumcenter of the site v, returning the coordinates of the intersection and updating via add_segment_intersection.\n\nArguments\n\nvorn: The Voronoi tessellation.\nu: The index of the site u, given as a boundary index for the associated ghost triangle.\nv: The index of the site v.\nincident_polygon: The index of the Voronoi polygon of the site u that is incident to the ray emanating from the circumcenter of the site v.\nintersected_edge_cache: The list of intersected edges currently being considered.\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nexterior_circumcenters: The list of circumcenters of sites that are outside the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.add_to_intersected_edge_cache!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.add_to_intersected_edge_cache!","text":"add_to_intersected_edge_cache!(intersected_edge_cache, u, v, a, b)\n\nAdd the edge uv to the list of intersected edges, where uv is the edge of the Voronoi polygon intersecting the edge of the boundary ab.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.add_segment_intersection!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.add_segment_intersection!","text":"add_segment_intersection!(segment_intersections, boundary_sites, intersection_point, incident_polygon::I) where {I}\n\nAdd the intersection point to the list of segment intersections and return the index of the intersection point in the list.  If the intersection point already exists in the list, then the index of the existing point is returned and used instead.\n\nArguments\n\nsegment_intersections: The list of segment intersections.\nboundary_sites: A mapping from boundary sites to the indices of the segment intersections that are incident to the boundary site.\nintersection_point: The intersection point to add.\nincident_polygon: The index of the polygon that is incident to the intersection point.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.segment_intersection_coordinates","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.segment_intersection_coordinates","text":"segment_intersection_coordinates(a, b, c, d)\n\nFinds the coordinates of the intersection of the line segment from a to b  with the line segment from c to d.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.intersection_of_edge_and_bisector_ray","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.intersection_of_edge_and_bisector_ray","text":"intersection_of_edge_and_bisector_ray(a, b, c)\n\nGiven an edge (a, b) and a ray emanating from c perpendicular   with the edge and collinear with its midpoint, tests if c intersects  the edge, and if so, returns the (cert, p), where p is the intersection point (which is the midpoint) and c is the position of c relative to (a, b). If there is no intersection, p = (NaN, NaN) is returned (together with cert). The ray should be directed to the left of the edge.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.classify_and_compute_segment_intersection","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.classify_and_compute_segment_intersection","text":"classify_and_compute_segment_intersection(a, b, c, d)\n\nGiven two line segments (a, b) and (c, d), classifies the intersection of the two segments, returning (cert, cert_c, cert_d, p), where p is the intersection point or (NaN, NaN) if there is no intersection. The certificate cert determines the intersection  type, giving \n\nCert.None: No intersections.\nCert.Single: There is an intersection point.\nCert.Touching: There is an intersection point, and one of c and d is the intersection point.\nCert.Multiple: The closed segments meet in one or several points.\n\nThe certificates cert_c and cert_d similarly return the positions of c and d relative to (a, b), respectively.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#DelaunayTriangulation.process_ray_intersection_with_other_edges!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.process_ray_intersection_with_other_edges!","text":"process_ray_intersection_with_other_edges!(vorn::VoronoiTessellation, u, v, e, left_edge, right_edge, r, segment_intersections,\nboundary_sites, incident_polygon, equal_circumcenter_mapping, intersected_edge_cache)\n\nProcess the intersection of the ray from the ghost site u to the site v with the edges e, left_edge and right_edge.\n\nArguments\n\nvorn::VoronoiTessellation: The Voronoi tessellation.\nu: The index of the ghost site.\nv: The index of the site u is going to.\ne: The edge on the boundary being considered.\nleft_edge: The edge to the left of e on the boundary.\nright_edge: The edge to the right of e on the boundary.\nr: The coordinates of the intersection of the ray from u to v with some edge. If any(isnan, r), then the ray does not intersect any edge and we skip. \nsegment_intersections: The list of segment intersections.\nboundary_sites: The mapping from the indices of the sites on the boundary to the indices of the edges on the boundary that they intersect.\nincident_polygon: The index of the polygon that contains the intersection of the ray from u to v with the boundary.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\nintersected_edge_cache: A cache of the edges that have been intersected by the ray from u to v.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Once we have gone through process_polygon!, we need to assign the identified intersections to the current edge, the left edge, or to the right edge. This is done with classify_intersections!.","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"classify_intersections!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.classify_intersections!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.classify_intersections!","text":"classify_intersections!(intersected_edge_cache, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge)\n\nClassify the intersections in intersected_edge_cache into left_edge_intersectors, right_edge_intersectors, and current_edge_intersectors based on whether they intersect left_edge, right_edge, or current_edge, respectively.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Once this is done, we need to actually consider the intersection points. The two goals here are: (1) Check if a corner point inside the polygon has to be added, and (2) look for other incident polygons to process. This processing is done via process_intersection_points!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"process_intersection_points!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.process_intersection_points!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.process_intersection_points!","text":"process_intersection_points!(polygon_edge_queue, vorn, current_incident_polygon, left_edge_intersectors, right_edge_intersectors, current_edge_intersectors, left_edge, right_edge, current_edge, processed_pairs, segment_intersections, boundary_sites)\n\nProcess the intersection points in left_edge_intersectors, right_edge_intersectors, and current_edge_intersectors and add the new edges to polygon_edge_queue if necessary. Special  care is taken to not miss any corner points. \n\nThe rules are based on the paper \"Efficient Computation of Clipped Voronoi Diagram for Mesh Generation\" by Yan, Wang, Levy, and Liu. Namely,  an edge that intersects a boundary edge and one to it has its shared vertex added to the queue together with the current polygon (current_incident_polygon) being  considered, and any intersections have the adjacent polygon added to the queue together with the intersecting edge. These are not strictly  the rules in the paper, but they are the rules that I was able to implement since they do not share their code.\n\nArguments\n\npolygon_edge_queue: The queue of edges that need to be processed.\nvorn: The Voronoi tessellation.\ncurrent_incident_polygon: The index of the current polygon being processed.\nleft_edge_intersectors: The intersection points of left_edge with other edges.\nright_edge_intersectors: The intersection points of right_edge with other edges.\ncurrent_edge_intersectors: The intersection points of current_edge with other edges.\nleft_edge: The left edge of the current polygon.\nright_edge: The right edge of the current polygon.\ncurrent_edge: The current edge of the current polygon.\nprocessed_pairs: A set of pairs of edges and polygons that have already been processed.\nsegment_intersections: A dictionary of segment intersections.\nboundary_sites: A dictionary of boundary sites.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Basically, this function first looks at the left and right intersections. If we have intersections on the left and on the current edge, then we will also have the vertex shared by the two edges included as a point we need to chop to, unless the current polygon being considered corresponds to a generator not on a boundary. We check this for each intersection and update the intersections with add_segment_intersection! accordingly. In such a case, we add the current edge, together with the indices of the left edge (corresponding to polygons) to the queue, ready for the next iteration. The same is done for the right edge. After handling this case, we check all the intersections without worry for corner points. For each intersection, we take the polygon on the other side of the intersecting segment and add it to the queue together with the boundary ede that was intersected. ","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"We do all the above steps until we run out of edges to process and the queue is empty, adding all the intersection points into the point list using add_intersection_points!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"add_intersection_points!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.add_intersection_points!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.add_intersection_points!","text":"add_intersection_points!(vorn::VoronoiTessellation, segment_intersections)\n\nAdd the intersection points to the polygon vertices.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/#Clipping-the-polygons","page":"Clipped Voronoi Tessellations","title":"Clipping the polygons","text":"","category":"section"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"The next step is to clip the polygons to the boundary using the computed intersections. This is handled via clip_all_polygons!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"clip_all_polygons!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.clip_all_polygons!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.clip_all_polygons!","text":"clip_all_polygons!(vorn::VoronoiTessellation, n, boundary_sites, exterior_circumcenters, equal_circumcenter_mapping, is_convex)\n\nClip all of the polygons in the Voronoi tessellation.\n\nArguments\n\nvorn: The Voronoi tessellation.\nn: The number of vertices in the tessellation before clipping.\nboundary_sites: A dictionary of boundary sites.\nexterior_circumcenters: Any exterior circumcenters to be filtered out.\nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\nis_convex: Whether the polygon is convex or not. Not currently used.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"This function iterates over all the identified boundary polygons and calls clip_polygon! on each:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"clip_polygon!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.clip_polygon!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.clip_polygon!","text":"clip_polygon!(vorn::VoronoiTessellation, n, points, polygon, new_verts, exterior_circumcenters, equal_circumcenter_mapping, is_convex)\n\nClip the polygon polygon by removing the vertices that are outside of the domain and adding the new vertices new_verts to the polygon.\n\nArguments\n\nvorn: The Voronoi tessellation.\nn: The number of vertices in the tessellation before clipping.\npoints: The points of the tessellation. \npolygon: The index of the polygon to be clipped.\nnew_verts: The indices of the new vertices that are added to the polygon.\nexterior_circumcenters: Any exterior circumcenters to be filtered out. \nequal_circumcenter_mapping: A mapping from the indices of the segment intersections that are equal to the circumcenter of a site to the index of the site.\nis_convex: Whether the polygon is convex or not. Not currently used.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"Consider a single polygon. The clip_polygon! function starts by deleting the adjacencies for this polygon, ready for updating later. We then remove all ghost vertices from the vertex list, and all circumcenters identified from the previous step that lie outside of the domain. We then add all the vertices. With this processing, the vertex list is no longer sorted, so sort_convex_polygon! is called to get a counter-clockwise representation. Adding in the adjacencies via add_polygon_adjacent!, this completes the clipping of this polygon. ","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"With all polygons processed, we add in all that we processed into the boundary_polygons field via add_all_boundary_polygons!:","category":"page"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"add_all_boundary_polygons!","category":"page"},{"location":"tessellations/clipped/#DelaunayTriangulation.add_all_boundary_polygons!","page":"Clipped Voronoi Tessellations","title":"DelaunayTriangulation.add_all_boundary_polygons!","text":"add_all_boundary_polygons!(vorn::VoronoiTessellation, boundary_sites)\n\nAdd all of the boundary polygons to the Voronoi tessellation.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/clipped/","page":"Clipped Voronoi Tessellations","title":"Clipped Voronoi Tessellations","text":"With this last step, the clipping is complete.","category":"page"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/boundary_nodes/#Boundary-Nodes","page":"Boundary Nodes","title":"Boundary Nodes","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"As mentioned at the start of this section, the interface for representing boundary nodes allows for support for a contiguous boundary, a segmented boundary, and multiple separate boundaries. (There is also support for more complex geometries, as described in the constrained triangulation section, although features like point location have limited support for e.g. non-convex domains and regions with holes inside holes.) This interface is customisable, and we define the following methods for this.","category":"page"},{"location":"interface/boundary_nodes/#Necessary-Methods","page":"Boundary Nodes","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"has_multiple_curves \nhas_multiple_segments \nnum_curves \nnum_segments \nnum_boundary_edges \ngetboundarynodes \neach_boundary_node ","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn defines multiple curves,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_curves(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_curves(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_curves(::A) where {F<:Number,A<:AV{F}}\n\nwith the first method returning true, while the last two methods return false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.has_multiple_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(bn::A) where {A}\n\nReturns true if the given set of boundary nodes bn contains multiple segments,  meaning disjoint boundary curves. We currently define the methods \n\nhas_multiple_segments(::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \nhas_multiple_segments(::AA) where {F<:Number,A<:AV{F},AA<:AV{A}} \nhas_multiple_segments(::A) where {F<:Number,A<:AV{F}}\n\nwith the first and second methods returning true, while the last method returns false, and AV = AbstractVector. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_curves","page":"Boundary Nodes","title":"DelaunayTriangulation.num_curves","text":"num_curves(bn::A)\n\nReturns the number of curves defined by the boundary nodes bn. We currently  define the methods\n\nnum_curves(bn::AAA) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}}\n\nwhich simply returns bn.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_segments","text":"num_segments(bn::A)\n\nReturns the number of segments defined by the boundary nodes bn. We currently  define the method\n\nnum_segments(bn::AA) where {F<:Number,A<:AV{F},AA<:AV{A}}\n\nwhich simply returns length(bn).\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_boundary_edges","page":"Boundary Nodes","title":"DelaunayTriangulation.num_boundary_edges","text":"num_boundary_edges(bn)\n\nGiven a collection of boundary nodes bn, returns the number of edges. This only  needs to be defined for individual segments. We define the method \n\nnum_boundary_edges(bn::A) where {A<:AbstractVector}\n\nwhich returns length(bn) - 1 (-1 because it is assumed that bn[begin] == bn[end]).  This is the only method that needs to be extended.\n\nSee also getboundarynodes.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.getboundarynodes","page":"Boundary Nodes","title":"DelaunayTriangulation.getboundarynodes","text":"getboundarynodes(bn::A, mnℓ...)\n\nGiven a collection of boundary nodes bn, returns the specified component of the  collection. There are several forms for the methods. In these methods, it is assumed  that one-based indexing is used for accessing all the boundary nodes. If you want to  use offsets, for example, then define getboundarynodes appropriately (e.g. maybe  getboundarynodes(bn, m) could map m to m-4 if 4 is your offset).\n\nThe methods that you need to define are those that go down a level, i.e. from a set of curves  to a curve, from a set of segments to a set of nodes, and from a set of nodes to a node. Of course,  if you only ever use e.g. a set of nodes, then you need only define that method. The methods that  we define for this are\n\ngetboundarynodes(bn::AAA, m::Integer) where {F<:Number,A<:AV{F},AA<:AV{A},AAA<:AV{AA}} \ngetboundarynodes(bn::AA, n::Integer) where {F<:Number,A<:AV{F},AA<:AV{A}} \ngetboundarynodes(bn::A, ℓ::Integer) where {F<:Number,A<:AV{F}}\n\nThe first method takes a set of curves to the mth curve, the second takes a set of segments to the  nth segment, and the third takes a set of nodes to the ℓth node. These are the only methods  that need to be extended. For the set of curves case, we also define\n\ngetboundarynodes(bn, m::Integer, n::Integer)\ngetboundarynodes(bn, (m, n)::NTuple{2,Integer})\n\nwhich calls getboundarynodes(getboundarynodes(bn, m), n). This does not need to be extended. Lastly,  we also define \n\ngetboundarynodes(bn::A, ::A) where {A}\n\nwhich simply returns bn. This is useful when using the result of construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.each_boundary_node","page":"Boundary Nodes","title":"DelaunayTriangulation.each_boundary_node","text":"each_boundary_node(bn::A)\n\nReturns an iterator that goes over each node in bn. Only defined for  single segments so that bn acts like a vector of numbers. The only method  currently defined is \n\neach_boundary_node(bn::A) where {F<:Number,A<:AbstractVector{F}}\n\nwhich just returns bn. You can extend this function as you need. If you really  want to loop over every boundary node, you can make use of the result from  construct_boundary_map.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#Generic-Methods","page":"Boundary Nodes","title":"Generic Methods","text":"","category":"section"},{"location":"interface/boundary_nodes/","page":"Boundary Nodes","title":"Boundary Nodes","text":"get_boundary_nodes(::Any, ::Vararg{Any})\nconstruct_boundary_map \nconstruct_boundary_index_ranges \nmap_boundary_index(::Any, ::Any) \nget_curve_index \nget_segment_index \nnum_outer_boundary_segments \nconstruct_boundary_edge_map\ninsert_boundary_node!\ndelete_boundary_node!","category":"page"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_boundary_nodes-Tuple{Any, Vararg{Any}}","page":"Boundary Nodes","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(bn, mnℓ...)\n\nGet the boundary nodes from bn corresponding to the specified indices.  See getboundarynodes.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_map","text":"construct_boundary_map(bn; IntegerType::Type{I} = Int) where {I}\n\nGiven a set of boundary nodes bn, returns a OrderedDict that maps boundary indices  to their position in bn. In particular:\n\nhas_multiple_curves(bn)\n\nIn this case, the result is a dict = OrderedDict{I, NTuple{2, I}}. The results will be of the form  dict[i] = (m, n), so that boundary indices with value i correspond to nodes at  get_boundary_nodes(bn, m, n), i.e. the nth segment of the mth curve.\n\nhas_multiple_segments(bn)\n\nIn this case, the result is a dict = OrderedDict{I, I}. The results will be of the form dict[i] = n, so that boundary indices with value i correspond to nodes at get_boundary_nodes(bn, n), i.e.  the nth segment.\n\nelse\n\nHere, the result is a dict = OrderedDict{I, F}, mapping -1 back to bn and F = typeof(bn).\n\nIteration Tips\n\nThis dict can be useful for iterating over all boundary nodes. For example, you could do\n\nbn_map = construct_boundary_map(bn)\nfor segment_index in values(bn_map)\n    nodes = get_boundary_nodes(bn, segment_index)\n    ## Do something with the nodes \nend \n\nThe above will work for any form of bn also.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_index_ranges","text":"construct_boundary_index_ranges(boundary_nodes; IntegerType::Type{I}=Int) where {I}\n\nGiven a set of boundary_nodes, creates an OrderedDict that maps boundary indices  to the range of all boundary indices that the corresponding boundary curve could  correspond to. For example, suppose we have \n\njulia> boundary_nodes = [\n           [\n               [1, 2, 3, 4], [4, 5, 6, 1]\n           ],\n           [\n               [18, 19, 20, 25, 26, 30]\n           ],\n           [\n               [50, 51, 52, 53, 54, 55], [55, 56, 57, 58], [58, 101, 103, 105, 107, 120], [120, 121, 122, 50]\n           ]\n       ]\n\nThen the first curve, [[1, 2, 3, 4], [4, 5, 6, 1]] has boundary indices -1 and -2,  so the range would be -2:-1. The full Dict we obtain will be \n\njulia> construct_boundary_index_ranges(boundary_nodes)\nOrderedDict{Int, UnitRange{Int}} with 7 entries:\n  -1 => -2:-1\n  -2 => -2:-1\n  -3 => -3:-3\n  -4 => -7:-4\n  -5 => -7:-4\n  -6 => -7:-4\n  -7 => -7:-4\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.map_boundary_index-Tuple{Any, Any}","page":"Boundary Nodes","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(dict, i)\n\nGiven a dict from construct_boundary_map, returns dict[i]. Also works  for a dict from construct_boundary_index_ranges.\n\n\n\n\n\n","category":"method"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_curve_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(dict, i)\nget_curve_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the curve corresponding to that boundary index. The  second method maps i to 1 if it is an integer, and i[1] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.get_segment_index","page":"Boundary Nodes","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(dict, i)\nget_segment_index(i)\n\nGiven a dict from construct_boundary_map and a boundary index i,  returns the index of the segment corresponding to that boundary index. The  second method maps i to i if it is an integer, 1 if it is a vector,  and i[2] if it is a Tuple.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.num_outer_boundary_segments","page":"Boundary Nodes","title":"DelaunayTriangulation.num_outer_boundary_segments","text":"num_outer_boundary_segments(boundary_nodes)\n\nGiven a set of boundary_nodes, returns the number of segments  that correspond to the outer boundary. Note that this also gives  the range of outer boundary indices, i.e.  -1:-1:-num_outer_boundary_segments(boundary_nodes).\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_edge_map","page":"Boundary Nodes","title":"DelaunayTriangulation.construct_boundary_edge_map","text":"construct_boundary_edge_map(bn::A; IntegerType::Type{I}=Int, EdgeType::Type{E}=NTuple{2,IntegerType}) where {A,I,E}\n\nConstructs a map that takes boundary edges (i,j) to a Tuple giving the edge's position in the corresponding  set of boundary nodes.\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.insert_boundary_node!","page":"Boundary Nodes","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(bn, pos, node)\n\nInserts a boundary node node into the set of boundary nodes bn at the position pos. The first element of pos  finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the  second element of pos gives the position of the array to insert node into. In particular, \n\ninsert_boundary_node!(bn, pos, node)\n\nis the same as \n\ninsert!(get_boundary_nodes(bn, pos[1]), pos[2], node)\n\n\n\n\n\n","category":"function"},{"location":"interface/boundary_nodes/#DelaunayTriangulation.delete_boundary_node!","page":"Boundary Nodes","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(bn, pos)\n\nDeletes a boundary node from the set of boundary nodes bn at the position pos. The first element of pos finds the set of boundary nodes that lie on the segment corresponding to this first element, and then the second element of pos gives the position of the array to delete. In particular,\n\ndelete_boundary_node!(bn, pos)\n\nis the same as\n\ndeleteat!(get_boundary_nodes(bn, pos[1]), pos[2])\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"utils/#Other-Utilities","page":"Other Utilities","title":"Other Utilities","text":"","category":"section"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"Here are some docstrings for other utility functions.","category":"page"},{"location":"utils/","page":"Other Utilities","title":"Other Utilities","text":"is_true\nget_boundary_index\nrotate_ghost_triangle_to_standard_form \nget_right_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nget_left_boundary_node(::Adjacent{I, E}, ::Any, ::Any, ::Any, ::C) where {I,E,C}\nfind_edge(::Any, ::Any, ::Any)\nchoose_uvw \nis_circular \ncircular_equality \nget_surrounding_polygon(::Adjacent{I,E}, ::Graph, ::Any, ::Any, ::C) where {I,E,C}\nsort_edge_by_degree(::E, ::Graph) where {E}\nsplit_constrained_edge!(::Any, ::E, ::Any) where {E}\nfix_segments!(::AbstractVector{E}, bad_indices) where {E}\nconnect_segments!(::AbstractVector{E}) where {E}\nextend_segments!(::AbstractVector{E}, ::Any) where {E}\nconvert_boundary_points_to_indices(::AAA, ::AAA) where {F<:Number,A<:AbstractVector{F},AA<:AbstractVector{A},AAA<:AbstractVector{AA}}\nget_ordinal_suffix \ncheck_args\nmin_max \nmin_med_max \nbalanced_power_of_two_ternary_split\nbalanced_power_of_two_quarternary_split \nsegment_vertices_adjoin_other_segments\nedge_lies_on_two_distinct_segments\nget_shared_vertex\nconvert_to_boundary_index \nget_neighbouring_boundary_edges \nis_last_boundary_index \nis_first_boundary_index \nprevindex_circular\nnextindex_circular\nis_first_boundary_index\nis_last_boundary_index \nget_neighbouring_boundary_edges\nconvert_to_boundary_edge\nget_shared_vertex\nreplace_boundary_triangle_with_ghost_triangle\niterated_neighbourhood","category":"page"},{"location":"utils/#DelaunayTriangulation.is_true","page":"Other Utilities","title":"DelaunayTriangulation.is_true","text":"is_true(b)\n\nReturns true if b is true, Val{true}, or Val(true). Returns false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_boundary_index","page":"Other Utilities","title":"DelaunayTriangulation.get_boundary_index","text":"get_boundary_index(i, j, k)\nget_boundary_index(i, j)\n\nGiven three indices i, j, and k, returns the index corresponding to a boundary index. If no boundary index is provided, an ArgumentError is thrown. Similarly for the second method, which takes two indices.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.rotate_ghost_triangle_to_standard_form","page":"Other Utilities","title":"DelaunayTriangulation.rotate_ghost_triangle_to_standard_form","text":"rotate_ghost_triangle_to_standard_form(i, j, k)\nrotate_ghost_triangle_to_standard_form(T::V) where {V}\n\nGiven a triangle T = (i, j, k), rotates it to a new triangle T′ = (u, v, w) such that w is a boundary index.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_right_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nReturns the node on the boundary that is to the right of k.\n\nArguments\n\nadj::Adjacent: The Adjacent map.\nk: The boundary node index.\nboundary_index: The boundary index corresponding to the curve.\nboundary_index_ranges: The boundary index ranges from construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nOutputs\n\ni: The node on the boundary to the right of k.\n\nSee also get_left_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.get_left_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}\n\nReturns the node on the boundary that is to the left of k.\n\nArguments\n\nadj::Adjacent: The Adjacent map.\nk: The boundary node index.\nboundary_index: The boundary index corresponding to the curve.\nboundary_index_ranges: The boundary index ranges from construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nOutputs\n\ni: The node on the boundary to the left of k.\n\nSee also get_right_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.find_edge-Tuple{Any, Any, Any}","page":"Other Utilities","title":"DelaunayTriangulation.find_edge","text":"find_edge(T, points, ℓ)\n\nGiven a triangle T with indices corresponding to points, returns the edge of T that contains the point ℓ. It is assumed that the point ℓ is on an edge of T. If this is not the case, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.choose_uvw","page":"Other Utilities","title":"DelaunayTriangulation.choose_uvw","text":"choose_uvw(e1, e2, e3, u, v, w)\n\nChoose values for (u, v, w) based on the Booleans (e1, e2, e3),  assuming only one is true. The three cases are: \n\nIf e1, returns (u, v, w).\nIf e2, returns (v, w, u).\nIf e3, returns (w, u, v).\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.is_circular","page":"Other Utilities","title":"DelaunayTriangulation.is_circular","text":"is_circular(A)\n\nTests if A[begin] == A[end]. Also returns true if A is empty.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.circular_equality","page":"Other Utilities","title":"DelaunayTriangulation.circular_equality","text":"circular_equality(A, B, by = isequal)\n\nTests if the arrays A and B are equal up to a circular shift, assuming A  and B are circular. The function by is used to test equality of elements.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_surrounding_polygon-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, DelaunayTriangulation.Graph, Any, Any, C}} where {I, E, C}","page":"Other Utilities","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}\n\nGiven a point u, returns a vector S which gives a counter-clockwise sequence of the neighbours of u. \n\nArguments\n\nadj::Adjacent{I,E}: The Adjacent map.\ngraph::Graph: The Graph.\nu: The vertex.\nboundary_index_ranges: The output of construct_boundary_index_ranges.\ncheck_existence::C: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.\n\nKeyword Arguments\n\nskip_boundary_indices=false: Whether to remove all boundary indices from the result at the end.\n\nOutputs\n\nS: The surrounding polygon.\n\nnote: Note\nWhen u is an outer boundary index, the returned polygon is clockwise.\nWhen u is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.sort_edge_by_degree-Union{Tuple{E}, Tuple{E, DelaunayTriangulation.Graph}} where E","page":"Other Utilities","title":"DelaunayTriangulation.sort_edge_by_degree","text":"sort_edge_by_degree(e::E, graph::Graph)\n\nGiven an edge e of a graph, say e = (u, v), returns:\n\nIf deg(u) ≤ deg(v), returns e;\nIf deg(u) > deg(v), returns (v, u).\n\nIn particular, e is sorted so that initial(e) is the vertex of e  with the smallest degree.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.split_constrained_edge!-Union{Tuple{E}, Tuple{Any, E, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.split_constrained_edge!","text":"split_constrained_edge!(constrained_edges, constrained_edge::E, collinear_segments) where {E}\n\nSplits the constrained_edge at the segments in collinear_segments, updating constrained_edges accordingly.\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.fix_segments!","text":"fix_segments!(segments::AbstractVector{E}, bad_indices) where {E}\n\nFixes the overlapping segments in segments, referred to via bad_indices.\n\nExample\n\nFor example, if we had \n\njulia> c = [(2, 15), (2, 28), (2, 41)]\n\nthen these edges come from connecting the start of a constrained segment with a point that  it goes through, but they are not actual segments in the triangulation (because they  all start with 2). So, using bad_indices = [1, 2, 3], the function mutates c  to give \n\njulia> bad_indices = [1, 2, 3]\njulia> fix_segments!(c, bad_indices)\njulia> c\n3-element Vector{Tuple{Int, Int}}:\n (2, 15)\n (15, 28)\n (28, 41)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E","page":"Other Utilities","title":"DelaunayTriangulation.connect_segments!","text":"connect_segments!(segments::AbstractVector{E}) where {E}\n\nGiven an ordered vector of segments, mutates so that the endpoints connect, preserving order.\n\nExample\n\njulia> C = [(7, 12), (12, 17), (17, 22), (32, 37), (37, 42), (42, 47)];\n\njulia> DelaunayTriangulation.connect_segments!(C);\n\njulia> C\n7-element Vector{Tuple{Int, Int}}:\n (7, 12)\n (12, 17)\n (17, 22)\n (32, 37)\n (37, 42)\n (42, 47)\n (22, 32)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E","page":"Other Utilities","title":"DelaunayTriangulation.extend_segments!","text":"extend_segments!(segments::AbstractVector{E}, constrained_edge) where {E}\n\nGiven an ordered vector of segments, ensures that they also represent the  replacement of constrained_edge.\n\nExample\n\njulia> segments = [(2, 7), (7, 12), (12, 49)];\njulia> constrained_edge = (1, 68);\njulia> extend_segments!(segments, constrained_edge);\njulia> segments\n5-element Vector{Tuple{Int, Int}}:\n (1, 2)\n (2, 7)\n (7, 12)\n (12, 49)\n (49, 68)\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.convert_boundary_points_to_indices-Union{Tuple{AAA}, Tuple{AA}, Tuple{A}, Tuple{F}, Tuple{AAA, AAA}} where {F<:Number, A<:AbstractVector{F}, AA<:AbstractVector{A}, AAA<:AbstractVector{AA}}","page":"Other Utilities","title":"DelaunayTriangulation.convert_boundary_points_to_indices","text":"convert_boundary_points_to_indices(x, y; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)\nconvert_boundary_points_to_indices(xy; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)\n\nGiven some points (x, y) representing a boundary, or xy giving the points combined rather than separated, converts their representation into a set of  indices corresponding to each boundary. The points should match the specification of a boundary  defined in the documentation. These points also get appended onto the set of points given by the  existing_points keyword argument, which should be used if you have a pre-existing set of points.\n\nThe returned value is (nodes, points), with nodes the indices and points the modified  existing_points (which are mutated in-place also).\n\n\n\n\n\n","category":"method"},{"location":"utils/#DelaunayTriangulation.get_ordinal_suffix","page":"Other Utilities","title":"DelaunayTriangulation.get_ordinal_suffix","text":"get_ordinal_suffix(i)\n\nReturns the ordinal suffix for the given integer i. \n\nExample\n\njulia> get_ordinal_suffix(1)\n\"st\"\njulia> get_ordinal_suffix(2)\n\"nd\"\njulia> get_ordinal_suffix(3)\n\"rd\"    \njulia> get_ordinal_suffix(4)\n\"th\"\njulia> get_ordinal_suffix(11)\n\"th\"\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.check_args","page":"Other Utilities","title":"DelaunayTriangulation.check_args","text":"check_args(points, boundary_nodes)\n\nChecks the arguments points and boundary_nodes to make sure that they are valid. If they are not, an error is thrown. This function is called by triangulate if the check_args keyword argument is set to true. If you are sure that your arguments are valid, you can set this keyword argument to false to speed up the triangulation process.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.min_max","page":"Other Utilities","title":"DelaunayTriangulation.min_max","text":"min_max(a, b)\n\nReturns (min(a, b), max(a, b)).\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.min_med_max","page":"Other Utilities","title":"DelaunayTriangulation.min_med_max","text":"min_med_max(a, b, c)\n\nReturns (min(a, b, c), med(a, b, c), max(a, b, c)), wheremed(a, b, c)is the value that is neithermin(a, b, c)ormax(a, b, c)`.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.balanced_power_of_two_ternary_split","page":"Other Utilities","title":"DelaunayTriangulation.balanced_power_of_two_ternary_split","text":"balanced_power_of_two_ternary_split(ℓ)\n\nCompute the the power of two that is closest  to ℓ/3 or to ℓ/1.5.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.balanced_power_of_two_quarternary_split","page":"Other Utilities","title":"DelaunayTriangulation.balanced_power_of_two_quarternary_split","text":"balanced_power_of_two_quarternary_split(ℓ)\n\nCompute the the power of two that is closest to ℓ/4 or to ℓ/0.5.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.segment_vertices_adjoin_other_segments","page":"Other Utilities","title":"DelaunayTriangulation.segment_vertices_adjoin_other_segments","text":"segment_vertices_adjoin_other_segments(tri::Triangulation, e)\n\nTest if the segment e's vertices adjoin other segments. Returns:\n\n0: No vertex adjoins another segment.\n1: One vertex adjoins another segment.\n2: Both vertices adjoin another segment.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.edge_lies_on_two_distinct_segments","page":"Other Utilities","title":"DelaunayTriangulation.edge_lies_on_two_distinct_segments","text":"edge_lies_on_two_distinct_segments(tri::Triangulation, e)\n\nTests if the edge (i, j) lies on two distinct segments. The returned value is:\n\n(true, common_vertex): If e lies on two distinct segments, and the common vertex is common_vertex.\n(false, 0): Otherwise.\n\nIf there are multiple common vertices. In this case, the function returns the vertex that is closest to e.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.get_shared_vertex","page":"Other Utilities","title":"DelaunayTriangulation.get_shared_vertex","text":"get_shared_vertex(e, f)\n\nGiven two edges e and f, returns the vertex that they share, or DefaultAdjacentValue if they do not share a vertex.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.is_last_boundary_index","page":"Other Utilities","title":"DelaunayTriangulation.is_last_boundary_index","text":"is_last_boundary_index(cell, i)\n\nReturns true if the index cell[i] is the last boundary index in the cell cell, assuming they come as a chain.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.is_first_boundary_index","page":"Other Utilities","title":"DelaunayTriangulation.is_first_boundary_index","text":"is_first_boundary_index(cell, i)\n\nReturns true if the index cell[i] is the first boundary index in the cell cell, assuming they come as a chain.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.previndex_circular","page":"Other Utilities","title":"DelaunayTriangulation.previndex_circular","text":"previndex_circular(C, i)\n\nReturns the previous index in the collection C before i, wrapping around to the second-last index if i is the first  index, assuming that is_circular(C) so that C[begin] == C[end].\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.nextindex_circular","page":"Other Utilities","title":"DelaunayTriangulation.nextindex_circular","text":"nextindex_circular(C, i)\n\nReturns the next index in the collection C after i, wrapping around to the first index if i is the last index.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.convert_to_boundary_edge","page":"Other Utilities","title":"DelaunayTriangulation.convert_to_boundary_edge","text":"convert_to_boundary_edge(vorn::VoronoiTessellation, e)\n\nConverts the edge e in the triangulation of vorn to a boundary edge so that get_adjacent(vorn, e) is a boundary index.\n\n\n\n\n\nconvert_to_boundary_edge(tri::Triangulation, e)\n\nGiven an edge e, returns the edge that is on the boundary, oriented so that get_adjacent(tri, v) is a boundary index, where v is the edge returned.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle","page":"Other Utilities","title":"DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle","text":"replace_boundary_triangle_with_ghost_triangle(tri, V)\n\nGiven a triangulation tri and a boundary triangle V, returns the ghost triangle associated with the boundary edge.\n\n\n\n\n\n","category":"function"},{"location":"utils/#DelaunayTriangulation.iterated_neighbourhood","page":"Other Utilities","title":"DelaunayTriangulation.iterated_neighbourhood","text":"iterated_neighbourhood(tri, i, d)\n\nComputes the d-times iterated neighbourhood of i in the triangulation tri. In particular, this returns all indices that are within d edges of i, excluding i itself.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/constrained/#Constrained-Triangulations","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we show to compute constrained triangulations. The interface for this is via triangulate just as it was with unconstrained triangulations, or  you can do it manually with add_edge!. We will go through several examples.","category":"page"},{"location":"triangulations/constrained/#Constrained-edges-only","page":"Constrained Triangulations","title":"Constrained edges only","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Let us start with an example that shows the computation of a constrained triangulation, with constrained edges only rather than handling boundary nodes. Here, any edges can be used as long as they do not intersect (they can run into each other if they are collinear, in which case they are split automatically).","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\na = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]\nC = Set([(2,1),(2,11),(2, 7), (2, 5)])\nuncons_tri = triangulate(pts)\ncons_tri=triangulate(pts;edges=C)\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(a):$ $ Unconstrained\", titlealign=:left)\ntriplot!(ax, uncons_tri)\nax = Axis(fig[1, 2], xlabel=L\"x\", ylabel=L\"y\", width=300, height=300,\n    title=L\"(b):$ $  Constrained\", titlealign=:left)\ntriplot!(ax, cons_tri)\nresize_to_layout!(fig)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/simple_constrained.png', alt='Constrained triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#With-an-outer-boundary","page":"Constrained Triangulations","title":"With an outer boundary","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let us define an outer boundary also. For this, the convert_boundary_points_to_indices function will be useful to convert a set of boundary coordinates to indices correctly. Note also that the boundary points we specify must connect, matching the specification defined in the boundary handling section of the sidebar.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\npts = [\n    (-7.36, 12.55), (-9.32, 8.59), (-9.0, 3.0), (-6.32, -0.27),\n    (-4.78, -1.53), (2.78, -1.41), (-5.42, 1.45), (7.86, 0.67),\n    (10.92, 0.23), (9.9, 7.39), (8.14, 4.77), (13.4, 8.61),\n    (7.4, 12.27), (2.2, 13.85), (-3.48, 10.21), (-4.56, 7.35),\n    (3.44, 8.99), (3.74, 5.87), (-2.0, 8.0), (-2.52, 4.81),\n    (1.34, 6.77), (1.24, 4.15)\n]\nboundary_points = [\n    (0.0, 0.0), (2.0, 1.0), (3.98, 2.85), (6.0, 5.0),\n    (7.0, 7.0), (7.0, 9.0), (6.0, 11.0), (4.0, 12.0),\n    (2.0, 12.0), (1.0, 11.0), (0.0, 9.13), (-1.0, 11.0),\n    (-2.0, 12.0), (-4.0, 12.0), (-6.0, 11.0), (-7.0, 9.0),\n    (-6.94, 7.13), (-6.0, 5.0), (-4.0, 3.0), (-2.0, 1.0), (0.0, 0.0)\n]\nboundary_nodes, pts = convert_boundary_points_to_indices(boundary_points; existing_points=pts)\nuncons_tri = triangulate(pts, delete_ghosts = false)\ncons_tri = triangulate(pts; boundary_nodes, delete_ghosts = false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/heart_constrained.png', alt='Constrained triangulation with a boundary'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"If we wanted to, we could add an edge in after the construction or a point. We would need to add back in the ghost triangles, though, or use delete_ghosts=false in triangulate (as we did above).","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"add_point!(cons_tri, 0.0, 5.0)\nadd_edge!(cons_tri, 40, 26)\nadd_edge!(cons_tri, 39, 27)\nadd_edge!(cons_tri, 38, 28)\nadd_point!(cons_tri, -3.0, 12.0) # can add points onto segments ","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/heart_add_constrained.png', alt='Constrained triangulation with a boundary and additions'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"You do need to be careful not to add segments that intersect each other at an angle, though.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Since we have used just a single boundary, there is just a single boundary index:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> DelaunayTriangulation.all_boundary_indices(cons_tri)\nKeySet for a OrderedCollections.OrderedDict{Int, UnitRange{Int}} with 1 entry. Keys:\n  -1\n\njulia> get_adjacent2vertex(cons_tri, -1)\nSet{Tuple{Int, Int}} with 21 elements:\n  (37, 36)\n  (44, 35)\n  (35, 34)\n  (33, 32)\n  (27, 26)\n  (36, 44)\n  (31, 30)\n  (39, 38)\n  (24, 23)\n  (23, 42)\n  (30, 29)\n  (42, 41)\n  ⋮\n\njulia> get_neighbours(cons_tri, -1)\nSet{Int} with 21 elements:\n  35\n  30\n  28\n  24\n  37\n  23\n  32\n  41\n  44\n  36\n  31\n  39\n  ⋮","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"If needed, you can get all the constrained edges using the all_constrained_edges field:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> each_constrained_edge(cons_tri)\nSet{Tuple{Int, Int}} with 25 elements:\n  (23, 24)\n  (40, 43)\n  (40, 41)\n  (26, 43)\n  (25, 26)\n  (39, 27)\n  (30, 31)\n  (29, 30)\n  (44, 35)\n  (42, 23)\n  (33, 34)\n  (38, 39)\n  ⋮","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"which includes all constrained edges, i.e. the boundary edges and the constrained edges we just added. If you just want to iterate over each boundary edge, you could use the boundary_edge_map:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> get_boundary_edge_map(cons_tri)\nDict{Tuple{Int, Int}, Tuple{Vector{Int}, Int}} with 21 entries:\n  (23, 24) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 1)\n  (40, 41) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 19)\n  (25, 26) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 3)\n  (35, 44) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 13)\n  (30, 31) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 8)\n  (29, 30) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 7)\n  (42, 23) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 21)\n  (33, 34) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 11)\n  (38, 39) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 17)\n  (27, 28) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 5)\n  (26, 27) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 4)\n  (39, 40) => ([23, 24, 25, 26, 27, 28, 29, 30, 31, 32  …  35, 44, 36, 37, 38, 39, 40, 41, 42, 23], 18)\n  ⋮        => ⋮","category":"page"},{"location":"triangulations/constrained/#Segmented-outer-boundary","page":"Constrained Triangulations","title":"Segmented outer boundary","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now we give an example where we split the boundary into segments, allowing each part of the boundary to be identified separately. For this, we define the boundary nodes on each segment, but making sure the segments connect at the endpoints.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\npoints = [\n    (2.0, 8.0), (6.0, 4.0), (2.0, 6.0),\n    (2.0, 4.0), (8.0, 2.0)\n]\nsegment_1 = [(0.0, 0.0), (14.0, 0.0)]\nsegment_2 = [(14.0, 0.0), (10.0, 4.0), (4.0, 6.0), (2.0, 12.0), (0.0, 14.0)]\nsegment_3 = [(0.0, 14.0), (0.0, 0.0)]\nboundary_points = [segment_1, segment_2, segment_3]\nboundary_nodes, points = convert_boundary_points_to_indices(boundary_points; existing_points=points)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/triangle_triangulation.png', alt='Constrained triangulation of a dented triangle'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"In this case, we can now identify the bottom, diagonal, and left sides:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> get_adjacent2vertex(cons_tri, -1) # bottom\nSet{Tuple{Int, Int}} with 1 element:\n  (7, 6)\n\njulia> get_adjacent2vertex(cons_tri, -2) # diagonal\nSet{Tuple{Int, Int}} with 4 elements:\n  (10, 9)\n  (8, 7)\n  (11, 10)\n  (9, 8)\n\njulia> get_adjacent2vertex(cons_tri, -3) # left\nSet{Tuple{Int, Int}} with 1 element:\n  (6, 11)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The triangulation we've built has few triangles around the boundaries, since we've defined the boundary using few points. We can add more points onto the boundary if we want, being careful not to add points on top of other points, and noting that we need to have ghost triangles to do this. Note also that floating point arithmetic isn't perfect, so some points aren't detected as being on the boundary unfortunately:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"add_ghost_triangles!(cons_tri)\nadd_ghost_triangles!(uncons_tri)\nfor x in LinRange(0.1, 13.9, 10) # bottom side\n    add_point!(uncons_tri, x, 0.0)\n    add_point!(cons_tri, x, 0.0)\nend\nfor x in LinRange(13.9, 10.1, 10) # first part of diagonal\n    add_point!(uncons_tri, x, 14 - x)\n    add_point!(cons_tri, x, 14 - x)\nend\nfor x in LinRange(9.9, 4.1, 10) # second part of diagonal \n    add_point!(uncons_tri, x, 22 // 3 - x / 3)\n    add_point!(cons_tri, x, 22 // 3 - x / 3)\nend\nfor x in LinRange(3.9, 2.1, 10) # third part of diagonal \n    add_point!(uncons_tri, x, 18 - 3x)\n    add_point!(cons_tri, x, 18 - 3x)\nend\nfor x in LinRange(1.9, 0.1, 10) # last part of diagonal\n    add_point!(uncons_tri, x, 14 - x)\n    add_point!(cons_tri, x, 14 - x)\nend\nfor y in LinRange(13.9, 0.1, 10) # left \n    add_point!(uncons_tri, 0.0, y)\n    add_point!(cons_tri, 0.0, y)\nend\ndelete_ghost_triangles!(cons_tri)\ndelete_ghost_triangles!(uncons_tri)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/triangle_triangulation_refined.png', alt='Constrained triangulation of a dented triangle with refinements'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"A better way could be to use e.g. the split_edge! operation. This would be better handled by the mesh refinement methods.","category":"page"},{"location":"triangulations/constrained/#Domain-with-interior-holes","page":"Constrained Triangulations","title":"Domain with interior holes","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let us consider a domain with interior holes. In this case, the outer boundary should be given counter-clockwise, while the interiors should be clockwise. Additionally, each curve should be given as if it were split into segments, even if there is only a single segment.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"using DelaunayTriangulation, CairoMakie\ncurve_1 = [[\n    (0.0, 0.0), (4.0, 0.0), (8.0, 0.0), (12.0, 0.0), (12.0, 4.0),\n    (12.0, 8.0), (14.0, 10.0), (16.0, 12.0), (16.0, 16.0),\n    (14.0, 18.0), (12.0, 20.0), (12.0, 24.0), (12.0, 28.0),\n    (8.0, 28.0), (4.0, 28.0), (0.0, 28.0), (-2.0, 26.0), (0.0, 22.0),\n    (0.0, 18.0), (0.0, 10.0), (0.0, 8.0), (0.0, 4.0), (-4.0, 4.0),\n    (-4.0, 0.0), (0.0, 0.0),\n]]\ncurve_2 = [[\n    (4.0, 26.0), (8.0, 26.0), (10.0, 26.0), (10.0, 24.0),\n    (10.0, 22.0), (10.0, 20.0), (8.0, 20.0), (6.0, 20.0),\n    (4.0, 20.0), (4.0, 22.0), (4.0, 24.0), (4.0, 26.0)\n]]\ncurve_3 = [[(4.0, 16.0), (12.0, 16.0), (12.0, 14.0), (4.0, 14.0), (4.0, 16.0)]]\ncurve_4 = [[(4.0, 8.0), (10.0, 8.0), (8.0, 6.0), (6.0, 6.0), (4.0, 8.0)]]\ncurves = [curve_1, curve_2, curve_3, curve_4]\npoints = [\n    (2.0, 26.0), (2.0, 24.0), (6.0, 24.0), (6.0, 22.0), (8.0, 24.0), (8.0, 22.0),\n    (2.0, 22.0), (0.0, 26.0), (10.0, 18.0), (8.0, 18.0), (4.0, 18.0), (2.0, 16.0),\n    (2.0, 12.0), (6.0, 12.0), (2.0, 8.0), (2.0, 4.0), (4.0, 2.0),\n    (-2.0, 2.0), (4.0, 6.0), (10.0, 2.0), (10.0, 6.0), (8.0, 10.0), (4.0, 10.0),\n    (10.0, 12.0), (12.0, 12.0), (14.0, 26.0), (16.0, 24.0), (18.0, 28.0),\n    (16.0, 20.0), (18.0, 12.0), (16.0, 8.0), (14.0, 4.0), (14.0, -2.0),\n    (6.0, -2.0), (2.0, -4.0), (-4.0, -2.0), (-2.0, 8.0), (-2.0, 16.0),\n    (-4.0, 22.0), (-4.0, 26.0), (-2.0, 28.0), (6.0, 15.0), (7.0, 15.0),\n    (8.0, 15.0), (9.0, 15.0), (10.0, 15.0), (6.2, 7.8),\n    (5.6, 7.8), (5.6, 7.6), (5.6, 7.4), (6.2, 7.4), (6.0, 7.6),\n    (7.0, 7.8), (7.0, 7.4)]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points=points)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/multiply_connected.png', alt='Constrained triangulation of a multiply-connected domain'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#More-complex-geometries","page":"Constrained Triangulations","title":"More complex geometries","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"It is possible to represent more complex geometries than those above. While the package assumes that boundaries are continguous boundaries, segmented contiguous boundaries, or an outer boundary with interior holes that themselves have no interior holes, e.g. for point location, we can still construct them. If you are only going to use the mesh without worrying about adding points or further edges, this works great.","category":"page"},{"location":"triangulations/constrained/#Interior-holes-within-interiors","page":"Constrained Triangulations","title":"Interior holes within interiors","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Let us give an example which has interiors within interiors. This can be represented by swapping the orientation of an interior to be counter-clockwise.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"curve_1 = [\n    [(0.0, 0.0), (5.0, 0.0), (10.0, 0.0), (15.0, 0.0), (20.0, 0.0), (25.0, 0.0)],\n    [(25.0, 0.0), (25.0, 5.0), (25.0, 10.0), (25.0, 15.0), (25.0, 20.0), (25.0, 25.0)],\n    [(25.0, 25.0), (20.0, 25.0), (15.0, 25.0), (10.0, 25.0), (5.0, 25.0), (0.0, 25.0)],\n    [(0.0, 25.0), (0.0, 20.0), (0.0, 15.0), (0.0, 10.0), (0.0, 5.0), (0.0, 0.0)]\n] # outer-most boundary: counter-clockwise  \ncurve_2 = [\n    [(4.0, 6.0), (4.0, 14.0), (4.0, 20.0), (18.0, 20.0), (20.0, 20.0)],\n    [(20.0, 20.0), (20.0, 16.0), (20.0, 12.0), (20.0, 8.0), (20.0, 4.0)],\n    [(20.0, 4.0), (16.0, 4.0), (12.0, 4.0), (8.0, 4.0), (4.0, 4.0), (4.0, 6.0)]\n] # inner boundary: clockwise \ncurve_3 = [\n    [(12.906, 10.912), (16.0, 12.0), (16.16, 14.46), (16.29, 17.06),\n    (13.13, 16.86), (8.92, 16.4), (8.8, 10.9), (12.906, 10.912)]\n] # this is inside curve_2, so it's counter-clockwise \ncurves = [curve_1, curve_2, curve_3]\npoints = [\n    (3.0, 23.0), (9.0, 24.0), (9.2, 22.0), (14.8, 22.8), (16.0, 22.0),\n    (23.0, 23.0), (22.6, 19.0), (23.8, 17.8), (22.0, 14.0), (22.0, 11.0),\n    (24.0, 6.0), (23.0, 2.0), (19.0, 1.0), (16.0, 3.0), (10.0, 1.0), (11.0, 3.0),\n    (6.0, 2.0), (6.2, 3.0), (2.0, 3.0), (2.6, 6.2), (2.0, 8.0), (2.0, 11.0),\n    (5.0, 12.0), (2.0, 17.0), (3.0, 19.0), (6.0, 18.0), (6.5, 14.5),\n    (13.0, 19.0), (13.0, 12.0), (16.0, 8.0), (9.8, 8.0), (7.5, 6.0),\n    (12.0, 13.0), (19.0, 15.0)\n]\nboundary_nodes, points = convert_boundary_points_to_indices(curves; existing_points=points)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we try and triangulate this, we get an error:","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"cons_tri = triangulate(points; boundary_nodes=boundary_nodes)\nERROR: AssertionError: The 3rd boundary curve is counter-clockwise when it should be clockwise. If this is a mistake, e.g. if this curve is inside of another one in which case it should be counter-clockwise, recall triangulate with check_arguments = false.\nStacktrace:\n [1] check_args(points::Vector{Tuple{Float64, Float64}}, boundary_nodes::Vector{Vector{Vector{Int}}})\n   @ DelaunayTriangulation c:\\Users\\User\\.julia\\dev\\DelaunayTriangulation\\src\\utils.jl:515\n [2] triangulate(points::Vector{Tuple{Float64, Float64}}; edges::Nothing, boundary_nodes::Vector{Vector{Vector{Int}}}, IntegerType::Type{Int}, EdgeType::Type{Tuple{Int, Int}}, TriangleType::Type{Tuple{Int, Int, Int}}, EdgesType::Type{Set{Tuple{Int, Int}}}, TrianglesType::Type{Set{Tuple{Int, Int, Int}}}, randomise::Bool, delete_ghosts::Bool, delete_empty_features::Bool, try_last_inserted_point::Bool, skip_points::Set{Int}, num_sample_rule::typeof(DelaunayTriangulation.default_num_samples), rng::TaskLocalRNG, point_order::Vector{Int}, recompute_representative_point::Bool, delete_holes::Bool, check_arguments::Bool)\n   @ DelaunayTriangulation c:\\Users\\User\\.julia\\dev\\DelaunayTriangulation\\src\\triangulation\\triangulate.jl:69\n [3] top-level scope\n   @ Untitled-1:198","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"We have this as a default to try and make the process a bit simpler for the most common geometries. A workaround though, as suggested, is to no longer check the arguments.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"uncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes, check_arguments=false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/multiply_connected_interior_interior.png', alt='Constrained triangulation of a multiply-connected domain with holes inside holes'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/#Disjoint-domains","page":"Constrained Triangulations","title":"Disjoint domains","text":"","category":"section"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now let's give a more complex example, where we consider multiple disjoint domains. This is the domain that is furthest from being supported, and I'm not sure whether proper support for it is planned. (Perhaps the best way to represent it is via something like a UnionTriangulation type, storing the triangulation information for each domain? Maybe.) The way to do it is to simply treat each domain as you would a standard domain, with the outer boundary being counter-clockwise, interiors clockwise (and other interiors inside interiors counter-clockwise, if you so please). The delete_holes! function will handle everything.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"First, a simple example.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"θ = LinRange(0, 2π, 20) |> collect\nθ[end] = 0 # need to make sure that 2π gives the exact same coordinates as 0\nxy = Vector{Vector{Vector{NTuple{2,Float64}}}}()\ncx = 0.0\nfor i in 1:2\n    # Make the exterior circle\n    push!(xy, [[(cx + cos(θ), sin(θ)) for θ in θ]])\n    # Now the interior circle - clockwise\n    push!(xy, [[(cx + 0.5cos(θ), 0.5sin(θ)) for θ in reverse(θ)]])\n    cx += 3.0\nend\nboundary_nodes, points = convert_boundary_points_to_indices(xy)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes=boundary_nodes, check_arguments=false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/simple_disjoint.png', alt='Simple example with two separated circles'><br>\n</figure>","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here's a more cheeky example.","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"C = (15.7109521325776, 33.244486807457)\nD = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\n\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nuncons_tri = triangulate(points)\ncons_tri = triangulate(points; boundary_nodes = nodes, check_arguments = false)","category":"page"},{"location":"triangulations/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/julia.png', alt='Julia logo'><br>\n</figure>","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tessellations/voronoi/#Voronoi-Tessellations","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"","category":"section"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"We provide support for constructing Voronoi tessellations, the dual graph to a Delaunay triangulation (strictly true only for unconstrained triangulations). The main function for this is voronoi:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"voronoi","category":"page"},{"location":"tessellations/voronoi/#DelaunayTriangulation.voronoi","page":"Voronoi Tessellations","title":"DelaunayTriangulation.voronoi","text":"voronoi(tri::Triangulation, clip=false) -> VoronoiTessellation\n\nConstruct the Voronoi tessellation of the points in tri. If clip is true then the Voronoi tessellation will be clipped to the convex hull of the points in tri. \n\nnote: Accessing polygon coordinates and rectangle clipping\nIf you are interested instead in clipping the tessellation to a rectangular bounding box, see  get_polygon_coordinates which allows for a bounding box to be applied to an  unclipped tessellation, returning a vector of the coordinates of polygons, clipping  to the bounding box where applicable. polygon_bounds can be used to obtain good  default bounding boxes. Note that if you are not worried about this clipping,  and you know that your polygon is not unbounded (which would mean it is not in the  unbounded_polygons field of the VoronoiTessellation output), then you should instead use  get_polygon(vorn, i) to get the indices of the points in vorn that define the polygon,  and then use get_polygon_point to get the coordinates. \n\nwarning: Warning\nExact predicates are used only for classifying intersections, but no special methods  are used for computing the intersections themselves. \n\nwarning: Warning\nClipping is not yet guaranteed to work for constrained triangulations. \n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The algorithm is really quite simple:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Construct the Delaunay triangulation.\nFor each point in the triangulation, connect the circumcenters of all triangles with that point as a vertex.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"(Omitting, of course, some details like duplicate circumcenters from cocircular susets – as with many things in computational geometry, anything is \"simple\" until you think about reality.) Note that extra care is taken for the unbounded edges, which we simply represent using negative indices. The negative indices we use have no real meaning, but they are unique so that we can uniquely identify for any unbounded ray the associated ghost triangle (shown by example later).","category":"page"},{"location":"tessellations/voronoi/#Example","page":"Voronoi Tessellations","title":"Example","text":"","category":"section"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Let us give an example. The first step in any tessellation is the construction of the triangulation.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"using DelaunayTriangulation, CairoMakie\npts = rand(2, 25)\ntri = triangulate(pts)","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"To now construct the tessellation, use voronoi.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"vorn = voronoi(tri)","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"We can visualise the diagram using voronoiplot. This function uses get_polygon_coordinates to get a finite representation of the unbounded edges, clipping the polygons to some bounding box determined by DelaunayTriangulation.polygon_bounds.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"fig, ax, sc = voronoiplot(vorn, strokecolor=:red, markersize=9)\ntriplot!(ax, tri, strokewidth=1, strokecolor=(:black, 0.4))","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"<figure>\n    <img src='../figs/unbounded.png', alt='Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"You can set the bounding box using the bounding_box keyword if you want it determined manually rather than programatically. The function that handles chopping to a box is get_polygon_coordinates, which primarily relies on intersection_of_ray_with_bounding_box:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"intersection_of_ray_with_bounding_box","category":"page"},{"location":"tessellations/voronoi/#DelaunayTriangulation.intersection_of_ray_with_bounding_box","page":"Voronoi Tessellations","title":"DelaunayTriangulation.intersection_of_ray_with_bounding_box","text":"intersection_of_ray_with_bounding_box(p, q, a, b, c, d)\n\nGiven a ray starting at p and in the direction of q, finds the intersection  of the ray with the bounding box [a, b] × [c, d]. It is assumed that p is inside  the bounding box, but q can be inside or outside.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"We will see later how to clip these polygons to the convex hull show in the red dashed line.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Let us now actually show the data structure. There are several fields:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> vorn.\nadjacent                  circumcenter_to_triangle  generators                polygons                  triangulation\nboundary_polygons         cocircular_circumcenters  polygon_points            triangle_to_circumcenter  unbounded_polygon","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The adjacent field is similar to the one we deal with for triangulations, except edges now map to their associated polygon. For example, we have","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> get_polygon(vorn, 1)\n7-element Vector{Int}:\n 23\n 17\n -8\n -6\n 32\n 34\n 23\n\njulia> get_adjacent(vorn, 23, 17) == get_adjacent(vorn, 17, -8) == 1\ntrue","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The circumcenter_to_triangle field allows us to go from the index of a circumcenter to its associated triangle. For instance, if we look at the vertices of the first polygon above, we may want to know where this vertex 34 came from:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_circumcenter_to_triangle(vorn, 34)\n(10, 4, 1)","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Thus, it came from the triangle (10, 4, 1). Note that the triangles used in this structure are always sorted so that the minimum index is last (while preserving the counter-clockwise orientation).","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The generators field is a repackaged version of tri.points:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_generators(vorn)\nDict{Int, Tuple{Float64, Float64}} with 25 entries:\n  5  => (0.684537, 0.618674)\n  16 => (0.585988, 0.554157)\n  20 => (0.43467, 0.161223)\n  12 => (0.00191717, 0.70299)\n  24 => (0.562014, 0.246805)\n  8  => (0.446736, 0.717801)\n  17 => (0.00141105, 0.639474)\n  23 => (0.953932, 0.352213)\n  1  => (0.234991, 0.0601079)\n  22 => (0.559084, 0.538079)\n  19 => (0.650726, 0.439868)\n  6  => (0.966998, 0.627038)\n  11 => (0.464044, 0.594492)\n  9  => (0.512324, 0.0257408)\n  14 => (0.559852, 0.55035)\n  3  => (0.139261, 0.472539)\n  7  => (0.560707, 0.767171)\n  25 => (0.0731719, 0.791413)\n  4  => (0.389615, 0.253273)\n  15 => (0.597794, 0.761001)\n  ⋮  => ","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Here, we need to use a Dict to represent the points since the original triangulation may not include all points. With this, we always know that get_generator(vorn, i) == get_point(tri, i). If we want the coordinates of the ith generator, we could use ","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> get_generator(vorn, 16)\n(0.5859881889826812, 0.5541565595408635)\n\njulia> get_generator(vorn, 7, 22, 1)\n((0.560707474714347, 0.7671706685373769), (0.5590841028546631, 0.5380792727814472), (0.2349910552466512, 0.060107935323076456))","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The polygons field is a Dict that maps the indices of the generators to their polygon:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_polygons(vorn)\nDict{Int, Vector{Int}} with 25 entries:\n  5  => [24, 29, 15, 8, 24]\n  16 => [24, 37, 26, 20, 16, 29, 24]\n  20 => [30, 38, 14, 6, 30]\n  12 => [3, -3, -9, 39, 3]\n  24 => [33, 6, 14, 9, 18, 2, 33]\n  8  => [35, 12, 5, 21, 31, 10, 35]\n  17 => [39, -9, -8, 17, 22, 39]\n  23 => [11, 18, 9, -2, -5, 11]\n  1  => [23, 17, -8, -6, 32, 34, 23]\n  22 => [33, 2, 16, 20, 1, 4, 33]\n  19 => [29, 16, 2, 18, 11, 15, 29]\n  6  => [15, 11, -5, -7, 8, 15]\n  11 => [1, 7, 10, 31, 36, 19, 4, 1]\n  9  => [38, 32, -6, -2, 9, 14, 38]\n  14 => [20, 26, 7, 1, 20]\n  3  => [19, 36, 22, 17, 23, 19]\n  7  => [13, 25, 12, 35, 13]\n  25 => [27, 28, -1, -3, 3, 27]\n  4  => [4, 19, 23, 34, 30, 6, 33, 4]\n  15 => [8, -7, -4, 25, 13, 37, 24, 8]\n  ⋮  => ⋮","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"So, if we wanted the polygon for the fifth generator, we would use:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> get_polygon(vorn, 5)\n5-element Vector{Int}:\n 24\n 29\n 15\n  8\n 24","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"These polygons are always sorted to be counter-clockwise, with the first element equalling the last also.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The triangulation field is simply tri. The boundary_polygons field is essentially the same as unbounded_polygons in most cases, and is only relevant later on when we consider clipped tessellations (for unbounded tessellations, this field is always empty). The cocircular_circumcenters field is just for keeping track of cocircular circumcenters to avoid adding duplicate points into the tessellation; it is an implementation detail, you shouldn't need to use it.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The polygon_points field stores the coordinates of the points used for the polygons:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_polygon_points(vorn)\n39-element Vector{Tuple{Float64, Float64}}:\n (0.5006477732564246, 0.5478946133538716)\n (0.5008095733914651, 0.3918411792218543)\n (0.10565601252653685, 0.692314380288574)\n (0.4270143529620006, 0.4238420900557963)\n (0.33079352748966667, 0.7624750560470457)\n (0.4753703522300822, 0.23819561748527615)\n (0.5226957825549574, 0.5957485305429776)\n (0.8205472522054272, 0.799163351762504)\n (0.8189082811407147, 0.07294487509120647)\n (0.4026965184932325, 0.6487501595269026)\n ⋮\n (0.330822898041236, 0.16744471621902937)\n (0.3146257041841115, 0.6363882426877013)\n (0.34474111887983666, -0.1904242188538559)\n (0.4811272594567467, 0.391643188260307)\n (0.2982325567607496, 0.16795358951510841)\n (0.5199378327863162, 0.7050503627303082)\n (0.2840418508918076, 0.5804155201166311)\n (0.5862985419779859, 0.657897964228626)\n (0.4650876739497739, 0.08866174194893103)\n (0.10972835538971261, 0.6703707990569139)","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"If we wanted the coordinates for the sixth vertex, we would do:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> get_polygon_point(vorn, 6)\n(0.4753703522300822, 0.23819561748527615)","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"The triangle_to_circumcenter field is similar to circumcenter_to_triangle, except this takes triangles to the index of their associated circumcenter:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_triangle_to_circumcenter(vorn)\nDict{Tuple{Int, Int, Int}, Int} with 48 entries:\n  (22, 14, 11) => 1\n  (8, 13, 7)   => 35\n  (22, 19, 16) => 16\n  (25, 18, -1) => -1\n  (3, 17, 1)   => 17\n  (17, 21, 12) => 39\n  (14, 13, 11) => 7\n  (23, 9, -1)  => -2\n  (6, 15, 5)   => 8\n  (23, 24, 9)  => 9\n  (19, 23, 6)  => 11\n  (12, 25, -1) => -3\n  (18, 15, -1) => -4\n  (16, 19, 5)  => 29\n  (13, 15, 7)  => 13\n  (4, 3, 1)    => 23\n  (19, 6, 5)   => 15\n  (21, 11, 8)  => 31\n  (6, 23, -1)  => -5\n  (18, 25, 2)  => 28\n  ⋮            => ⋮","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Lastly, the unbounded_polygons field stores the indices of all generators whose associated polygon is unbounded:","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"julia> DelaunayTriangulation.get_unbounded_polygons(vorn)\nSet{Int} with 9 elements:\n  6\n  15\n  25\n  18\n  9\n  12\n  17\n  23\n  1","category":"page"},{"location":"tessellations/voronoi/#Relevant-Docstrings","page":"Voronoi Tessellations","title":"Relevant Docstrings","text":"","category":"section"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"Here are some relevant docstrings for the construction of the tessellation.","category":"page"},{"location":"tessellations/voronoi/","page":"Voronoi Tessellations","title":"Voronoi Tessellations","text":"initialise_voronoi_tessellation \nprepare_add_voronoi_polygon \nget_next_triangle_for_voronoi_polygon\nconnect_circumcenters!\nadd_edge_to_voronoi_polygon!\nclose_voronoi_polygon!\nadd_voronoi_polygon!","category":"page"},{"location":"tessellations/voronoi/#DelaunayTriangulation.initialise_voronoi_tessellation","page":"Voronoi Tessellations","title":"DelaunayTriangulation.initialise_voronoi_tessellation","text":"initialise_voronoi_tessellation(tri::Triangulation)\n\nInitialise a VoronoiTessellation from the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.prepare_add_voronoi_polygon","page":"Voronoi Tessellations","title":"DelaunayTriangulation.prepare_add_voronoi_polygon","text":"prepare_add_voronoi_polygon(vorn::VoronoiTessellation, i)\n\nPrepare the arrays for adding the Voronoi polygon for the point i to the VoronoiTessellation vorn, returning:\n\nS: The vertices surrounding the generator i.\nB: An empty array for storing vertices.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.get_next_triangle_for_voronoi_polygon","page":"Voronoi Tessellations","title":"DelaunayTriangulation.get_next_triangle_for_voronoi_polygon","text":"get_next_triangle_for_voronoi_polygon(vorn::VoronoiTessellation, i, k, S, m)\n\nGet the next triangle for the Voronoi polygon for the point i in the VoronoiTessellation vorn, returning:\n\nci: The index for the circumcenter of the next triangle.\nk: The index of the next vertex in S.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.connect_circumcenters!","page":"Voronoi Tessellations","title":"DelaunayTriangulation.connect_circumcenters!","text":"connect_circumcenters!(B, ci)\n\nAdd the circumcenter ci to the array B.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.add_edge_to_voronoi_polygon!","page":"Voronoi Tessellations","title":"DelaunayTriangulation.add_edge_to_voronoi_polygon!","text":"add_edge_to_voronoi_polygon!(B, vorn::VoronoiTessellation, i, k, S, m, encountered_duplicate_circumcenter)\n\nAdd the next edge to the Voronoi polygon for the point i in the VoronoiTessellation vorn, returning:\n\nci: The index for the circumcenter of the triangle considered.\nencountered_duplicate_circumcenter: Whether or not a duplicate circumcenter has been encountered.\nk: The index of the latest vertex in S.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.close_voronoi_polygon!","page":"Voronoi Tessellations","title":"DelaunayTriangulation.close_voronoi_polygon!","text":"close_voronoi_polygon!(vorn::VoronoiTessellation, B, i, encountered_duplicate_circumcenter, prev_ci)\n\nClose the Voronoi polygon for the point i in the VoronoiTessellation vorn.\n\n\n\n\n\n","category":"function"},{"location":"tessellations/voronoi/#DelaunayTriangulation.add_voronoi_polygon!","page":"Voronoi Tessellations","title":"DelaunayTriangulation.add_voronoi_polygon!","text":"add_voronoi_polygon!(vorn::VoronoiTessellation, i)\n\nAdd the Voronoi polygon for the point i to the VoronoiTessellation vorn.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/lattice/#Lattice-Triangulations","page":"Lattice","title":"Lattice Triangulations","text":"","category":"section"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"We provide a method for triangulation a lattice on some grid a b times c d with n_x times n_y points. The docstring for this method is given below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"triangulate_rectangle","category":"page"},{"location":"triangulations/lattice/#DelaunayTriangulation.triangulate_rectangle","page":"Lattice","title":"DelaunayTriangulation.triangulate_rectangle","text":"triangulate_rectangle(a, b, c, d, nx, ny;\n    single_boundary=false,\n    add_ghost_triangles=true,\n    IntegerType::Type{I}=Int,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType}) where {I,E,V,Es,Ts}\n\nComputes a triangulation of the rectangular grid [a, b] × [c, d] with points (xᵢ, yⱼ),  i = 1, …, nx, j = 1, …, ny, where xᵢ = a + (i-1)(b-a)/(nx-1) and yⱼ = b + (j-1)(d-c)/(ny-1). If  the boundary of the rectangle should be considered as one single boundary, use single_boundary = false, and if  you want the four sides of the boundary to be separated use single_boundary = true. \n\nReturns a Triangulation representing the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The single_boundary argument is useful if you want to, for example, have a boundary condition for the entire boundary or for each side of the boundary separately. ","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the four boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"a, b, c, d = 2.0, 10.0, -5.0, 7.5\nnx = 20\nny = 10\ntri = DT.triangulate_rectangle(a, b, c, d, nx, ny)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)\nlines!(ax, tri.points[get_boundary_nodes(tri, 1)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 2)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 3)]; linewidth=4)\nlines!(ax, tri.points[get_boundary_nodes(tri, 4)]; linewidth=4)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"The blue edges show the interpretation of the ghost edges.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"An example of the single boundary case is below.","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"tri = DT.triangulate_rectangle(a, b, c, d, nx, ny; single_boundary=true)\nfig, ax, sc = triplot(tri; show_ghost_edges=true)","category":"page"},{"location":"triangulations/lattice/","page":"Lattice","title":"Lattice","text":"<figure>\n    <img src='../figs/rectangular_triangulation_2.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"As defined in the data structures section, we have the ability for computing convex hulls. These can be computed outside of the triangulation process, using our implementation of Graham's scan. ","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"Here is an example.","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"pts = [Tuple(25randn(2)) for _ in 1:500]\nch = convex_hull(pts)\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, pts)\nlines!(ax, pts[ch.indices])","category":"page"},{"location":"other_features/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"<figure>\n    <img src='../figs/convex_hull_1.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"other_features/pole_of_inaccessibility/#Pole-of-Inaccessibility-and-Polygons","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We provide a function for computing the pole of inaccessibility of a given polygon, namely the point inside the polygon that is furthest from the boundary. Our method is primarily based on this blogpost, recursively subdividing the polygon using quadtree partitioning. The function for this is pole_of_inaccessibility:","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pole_of_inaccessibility","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.pole_of_inaccessibility","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.pole_of_inaccessibility","text":"pole_of_inaccessibility(pts, boundary_nodes; precision = one(number_type(pts)))\n\nGiven a collection of points pts and a set of boundary_nodes defining the polygon connections, finds the pole of inaccessibility. This works for multiply-connected polygons,  provided boundary_nodes matches the specification given in the documentation. You can  control the tolerance of the returned pole using precision.\n\nThis function is also commonly called polylabel.\n\nnote: Note\nThe pole of inaccessibility is a point within a polygon that is furthest from an  edge. It is useful for our purposes since it is a representative point that is  guaranteed to be inside the polygon, in contrast to for example a centroid which  is not always inside the polygon.For more information about this, see e.g. this blog post or the original repo. This implementation was partially based  on the python implementation and this other Julia implementation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"We needed this method since the point we need to associate ghost vertices with must be inside the domain, and so other representative points like centroids or arithmetic averages would not be sufficient if the domain is non-convex.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below we also list some other relevant docstrings.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Cell \nCellQueue \npolygon_features(::Any, ::Any)\nsquared_distance_to_segment \ndistance_to_polygon \npolygon_bounds(::Any, ::Any)\nsort_convex_polygon!","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.Cell","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.Cell","text":"Cell{T}\n\nA cell in a grid. The cell is a square with side length 2half_width. The cell is centered at (x, y). The cell is  assumed to live in a polygon.\n\nFields\n\nx::T\n\nThe x-coordinate of the center of the cell.\n\ny::T\n\nThe y-coordinate of the center of the cell.\n\nhalf_width::T\n\nThe half-width of the cell.\n\ndist::T\n\nThe distance from the center of the cell to the polygon.\n\nmax_dist::T\n\nThe maximum distance from the center of the cell to the polygon. This is dist + half_width * sqrt(2).\n\nConstructors\n\n`Cell(x::T, y::T, half_width::T, pts, boundary_nodes)`\n\nConstructs a cell with center (x, y) and half-width half_width. The cell is assumed to live in the polygon defined by pts and boundary_nodes.\n\n\n\n\n\n","category":"type"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.CellQueue","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.CellQueue","text":"CellQueue{T}\n\nA struct representing the priority queue of Cells, used for sorting the cells in a grid according to their maximum distance.\n\nFields\n\nqueue::PriorityQueue{Cell{T},T,typeof(Base.Order.Reverse)}\n\nThe priority queue of cells.\n\nConstructors\n\nCellQueue{T}()\n\nConstructs a new CellQueue with elements of type Cell{T}.\n\n\n\n\n\n","category":"type"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_features-Tuple{Any, Any}","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(pts, boundary_nodes)\n\nReturns features of the polygon represented by the points pts with boundary_nodes defining the polygon  connections. The features returned are (a, c), where a is the area of the polygon and  c = (cx, cy) is the centroid. \n\nnote: Note\nThe polygon is assumed to be simple, i.e. no self-intersections.\nThe function works with holes, provided boundary_nodes represents these as described in the documentation.\nThe polygon is assumed to have a consistent orientation for each boundary. If the orientation is positive, a > 0, and a < 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.squared_distance_to_segment","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.squared_distance_to_segment","text":"squared_distance_to_segment(x₁, y₁, x₂, y₂, x, y)\n\nGiven a line segment (x₁, y₁) → (x₂, y₂) and a query point (x, y), returns the  squared distance from (x, y) to the line segment.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.distance_to_polygon","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.distance_to_polygon","text":"distance_to_polygon(q, pts, boundary_nodes)\n\nGiven a polygon represented by the points pts with boundary_nodes defining the polygon  connections, and a query point q, returns the signed distance from q to the polygon. If  q is outside of the polygon, then the returned distance is negative, and if it is inside  then the distance is positive. Works with holes, provided boundary_nodes matches the  specification of a boundary given in the documentation.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.polygon_bounds-Tuple{Any, Any}","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(pts, boundary_nodes, check_all_curves = Val(false))\n\nGiven a polygon represented by the points pts with boundary_nodes defining the polygon  connections, returns a bounding box of the polygon. The bounding box is returned  in the order (xmin, xmax, ymin, ymax). If your polygon is not a multiple polygon,  check_all_curves = Val(false) is sufficient, otherwise you might want to use Val(true).\n\n\n\n\n\n","category":"method"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.sort_convex_polygon!","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.sort_convex_polygon!","text":"sort_convex_polygon!(vertices, points)\n\nSorts the vertices of a convex polygon in counter-clockwise order. The polygon is defined by the points points and the vertices vertices. The vertices are sorted in place. It is  assumed that the vertices are not circular, i.e. vertices[begin] ≠ vertices[end].\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"distance_to_polygon is also useful for point location, as shown in the examples below.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"If you need to compute this for multiple boundaries, meaning multiple poles, use compute_representative_points!.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"compute_representative_points!","category":"page"},{"location":"other_features/pole_of_inaccessibility/#DelaunayTriangulation.compute_representative_points!","page":"Pole of Inaccessibility and Polygons","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0)\n\nUpdates get_representative_point_list(tri) to match the current position of the boundaries. If there are no boundary nodes, use_convex_hull instead represents them using the indices of the convex hull.\n\n\n\n\n\n","category":"function"},{"location":"other_features/pole_of_inaccessibility/#Example:-Pole-of-inaccessibility","page":"Pole of Inaccessibility and Polygons","title":"Example: Pole of inaccessibility","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Below is a simple example of computing this pole of inaccessibility.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"pts = [0.0 8.0\n      2.0 5.0\n      3.0 7.0\n      1.81907 8.13422\n      3.22963 8.865\n      4.24931 7.74335\n      4.50423 5.87393\n      3.67149 4.3784\n      2.73678 2.62795\n      5.50691 1.38734\n      8.43 2.74691\n      9.7046 5.53404\n      8.56595 7.79433\n      6.71353 9.03494\n      4.13034 9.66375\n      2.75378 10.3775\n      1.0883 10.4965\n      -1.138 9.83369\n      -2.25965 8.45712\n      -2.78649 5.94191\n      -1.39292 3.64763\n      0.323538 4.97322\n      -0.900078 6.6217\n      0.98633 9.68074\n      0.153591 9.54478\n      0.272554 8.66106\n      2.90673 8.18521\n      2.12497 9.42582\n      7.27436 2.7979\n      3.0 4.0\n      5.33697 1.88019]'\nboundary_nodes = [\n      [[1, 4, 3, 2], [2, 9, 10, 11, 8, 7, 12], [12, 6, 13, 5, 14, 15, 16, 17, 16], [16, 17, 18, 19, 20, 21, 22, 23, 1]],\n      [[26, 25, 24], [24, 28, 27, 26]],\n      [[29, 30, 31, 29]]\n]\nx, y = DT.pole_of_inaccessibility(pts, boundary_nodes)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=L\"x\", ylabel=L\"y\")\nbn1 = pts[:, unique(reduce(vcat, boundary_nodes[1]))] |> x -> hcat(x, x[:, begin])\nbn2 = pts[:, unique(reduce(vcat, boundary_nodes[2]))] |> x -> hcat(x, x[:, begin])\nbn3 = pts[:, unique(reduce(vcat, boundary_nodes[3]))] |> x -> hcat(x, x[:, begin])\nlines!(ax, bn1, color=:red, linewidth=4)\nlines!(ax, bn2, color=:red, linewidth=4)\nlines!(ax, bn3, color=:red, linewidth=4)\nscatter!(ax, [x], [y], color=:blue, markersize=23)","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/pole_of_inaccessibility.png', alt='Pole of inaccessibility'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/#Example:-Querying-if-points-are-in-a-polygon","page":"Pole of Inaccessibility and Polygons","title":"Example: Querying if points are in a polygon","text":"","category":"section"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"If we need to, distance_to_polygon is a nice way for querying whether a point is inside or outside of a given polygon. Let's use the Julia example. Let us start by defining the polygon (this is a multiple polygon, it works for even simpler polygons obviously) and placing random points inside its bounding box:","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"D = (14.2705719699703, 32.8530791545746)\nE = (14.3, 27.2)\nF = (14.1, 27.0)\nG = (13.7, 27.2)\nH = (13.4, 27.5)\nI = (13.1, 27.6)\nJ = (12.7, 27.4)\nK = (12.5, 27.1)\nL = (12.7, 26.7)\nM = (13.1, 26.5)\nN = (13.6, 26.4)\nO = (14.0, 26.4)\nP = (14.6, 26.5)\nQ = (15.1983491346581, 26.8128534095401)\nR = (15.6, 27.6)\nS = (15.6952958264624, 28.2344688505621)\nT = (17.8088971520274, 33.1192363585346)\nU = (16.3058917649589, 33.0722674401887)\nV = (16.3215480710742, 29.7374742376305)\nW = (16.3841732955354, 29.393035503094)\nZ = (16.6190178872649, 28.9233463196351)\nA1 = (17.0417381523779, 28.5319386667527)\nB1 = (17.5114273358368, 28.3753756055997)\nC1 = (18.1376795804487, 28.3597192994844)\nD1 = (18.7169629067146, 28.5632512789833)\nE1 = (19.2805899268653, 28.8920337074045)\nF1 = (19.26493362075, 28.4536571361762)\nG1 = (20.6426885588962, 28.4223445239456)\nH1 = (20.689657477242, 33.1035800524193)\nI1 = (19.2805899268653, 33.0722674401887)\nJ1 = (19.2962462329806, 29.7531305437458)\nK1 = (19.0614016412512, 29.393035503094)\nL1 = (18.7482755189452, 29.236472441941)\nM1 = (18.4508057027546, 29.1425346052493)\nN1 = (18.1689921926793, 29.3147539725175)\nO1 = (17.7932408459121, 29.6278800948235)\nP1 = (22.6466957416542, 35.4207133574833)\nQ1 = (21.2219718851621, 34.9979930923702)\nR1 = (21.2376281912774, 28.4693134422915)\nS1 = (22.6780083538847, 28.4380008300609)\nT1 = (24.5724213938357, 33.1975178891111)\nU1 = (23.3512295168425, 32.8530791545746)\nV1 = (23.3199169046119, 28.4380008300609)\nW1 = (24.6663592305274, 28.3753756055997)\nZ1 = (15.1942940307729, 35.4363696635986)\nA2 = (14.7246048473139, 35.3737444391374)\nB2 = (14.3645098066621, 35.1858687657538)\nC2 = (14.1766341332786, 34.8570863373326)\nD2 = (14.1140089088174, 34.3247719294125)\nE2 = (14.2705719699703, 33.8394264398383)\nF2 = (14.7246048473139, 33.6202381542241)\nG2 = (15.4604512347329, 33.6045818481088)\nH2 = (16.0, 34.0)\nI2 = (15.9771093365377, 34.6848669700643)\nJ2 = (15.6170142958859, 35.2328376840997)\nK2 = (24.1653574348379, 35.4520259697138)\nL2 = (23.7739497819555, 35.4363696635986)\nM2 = (23.4608236596496, 35.2641502963303)\nN2 = (23.272947986266, 34.9040552556785)\nO2 = (23.1320412312284, 34.5909291333725)\nP2 = (23.1163849251131, 34.2151777866054)\nQ2 = (23.2886042923813, 33.8081138276077)\nR2 = (23.8209187003014, 33.6045818481088)\nS2 = (24.3062641898756, 33.5576129297629)\nT2 = (24.7602970672192, 33.8550827459536)\nU2 = (25.010797965064, 34.4656786844502)\nV2 = (24.8385785977957, 34.9666804801397)\nW2 = (24.5254524754898, 35.2641502963303)\nZ2 = (25.3708930057158, 37.4716894585871)\nA3 = (24.7916096794498, 37.3464390096648)\nB3 = (24.4471709449133, 36.9550313567823)\nC3 = (24.3062641898756, 36.5636237038999)\nD3 = (24.4941398632592, 35.9999966837492)\nE3 = (25.0264542711793, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nF3 = (25.5587686790994, 35.5929327247515)\nG3 = (26.0, 36.0)\nH3 = (26.1380520053653, 36.5792800100152)\nI3 = (26.0, 37.0)\nJ3 = (25.7466443524829, 37.2838137852036)\nK3 = (26.3885529032101, 35.4676822758291)\nL3 = (25.9814889442124, 35.3580881330221)\nM3 = (25.6840191280217, 35.1858687657538)\nN3 = (25.5274560668688, 34.9040552556785)\nO3 = (25.4961434546382, 34.5596165211419)\nP3 = (25.5274560668688, 34.246490398836)\nQ3 = (25.6683628219064, 33.8394264398383)\nR3 = (26.0284578625583, 33.6358944603394)\nS3 = (26.5451159643631, 33.6202381542241)\nT3 = (27.0, 34.0)\nU3 = (27.280962351782, 34.5596165211419)\nV3 = (27.0304614539373, 35.2171813779844)\nW3 = (26.1693646175959, 33.087923746304)\nZ3 = (26.0, 33.0)\nA4 = (25.5274560668688, 32.7278287056522)\nB4 = (25.2612988629087, 32.4147025833463)\nC4 = (25.1830173323322, 32.0702638488098)\nD4 = (25.2299862506781, 31.7727940326191)\nE4 = (25.6527065157911, 31.5222931347744)\nF4 = (26.2946150665183, 31.7258251142732)\nG4 = (26.5607722704784, 32.5086404200381)\nH4 = (27.1557119028596, 32.7434850117675)\nI4 = (27.6097447802033, 32.4929841139228)\nJ4 = (27.6410573924338, 32.1015764610403)\nK4 = (27.7193389230103, 31.6005746653509)\nL4 = (27.437525412935, 31.4283552980826)\nM4 = (26.9834925355914, 31.2561359308143)\nN4 = (26.5764285765937, 31.0995728696614)\nO4 = (26.0441141686736, 30.7864467473554)\nP4 = (25.6527065157911, 30.5672584617413)\nQ4 = (25.3239240873699, 30.1915071149741)\nR4 = (25.1673610262169, 29.8783809926682)\nS4 = (25.1047358017558, 29.6122237887082)\nT4 = (25.0890794956405, 29.1895035235952)\nU4 = (25.2926114751393, 28.8294084829433)\nV4 = (25.6840191280217, 28.5632512789833)\nW4 = (26.1537083114806, 28.3753756055997)\nZ4 = (26.8269294744384, 28.391031911715)\nA5 = (27.4844943312809, 28.6102201973292)\nB5 = (27.7342002330051, 28.7239579596219)\nC5 = (27.7264126450755, 28.4202565942047)\nD5 = (29.1825559185446, 28.3922538389457)\nE5 = (29.1545531632856, 32.2146299318021)\nF5 = (29.000538009361, 32.5786657501693)\nG5 = (28.6785063238822, 32.9006974356481)\nH5 = (28.3144705055149, 33.0827153448317)\nI5 = (27.9084305542591, 33.2367304987563)\nJ5 = (27.3343740714492, 33.3207387645334)\nK5 = (26.8303244767868, 33.2367304987563)\nL5 = (27.6564057569279, 30.786489413592)\nM5 = (27.6984098898165, 30.3944508399657)\nN5 = (27.6984098898165, 29.7363860913787)\nO5 = (27.5863988687804, 29.4143544059)\nP5 = (27.2643671833016, 29.2043337414573)\nQ5 = (26.9843396307114, 29.1763309861983)\nR5 = (26.6903107004917, 29.3163447624934)\nS5 = (26.5782996794556, 29.7503874690082)\nT5 = (26.7603175886393, 30.3384453294476)\nU5 = (27.3203726938197, 30.7024811478149)\nJ_curve = [[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, C]]\nU_curve = [[T, U, V, W, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, T]]\nL_curve = [[P1, Q1, R1, S1, P1]]\nI_curve = [[T1, U1, V1, W1, T1]]\nA_curve_outline = [[\n    K5, W3, Z3, A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4,\n    O4, P4, Q4, R4, S4, T4, U4, V4, W4, Z4, A5, B5, C5, D5, E5, F5, G5,\n    H5, I5, J5, K5]]\nA_curve_hole = [[L5, M5, N5, O5, P5, Q5, R5, S5, T5, U5, L5]]\ndot_1 = [[Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, Z1]]\ndot_2 = [[Z2, A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, Z2]]\ndot_3 = [[K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2, U2, V2, W2, K2]]\ndot_4 = [[K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3, U3, V3, K3]]\ncurves = [J_curve, U_curve, L_curve, I_curve, A_curve_outline, A_curve_hole, dot_1, dot_2, dot_3, dot_4]\nnodes, points = convert_boundary_points_to_indices(curves)\nxmin, xmax, ymin, ymax = DelaunayTriangulation.polygon_bounds(points, nodes, Val(true)) # Val(true) => check all parts of the polygon\nquery_points = [((xmax - xmin) * rand() + xmin, (ymax - ymin) * rand() + ymin) for _ in 1:1000]\n\nfig = Figure()\nax = Axis(fig[1, 1])\nscatter!(ax, query_points)\nfor nodes in nodes\n    lines!(ax, points[reduce(vcat, nodes)], color=:magenta, linewidth=3)\nend","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/scattered_julia.png', alt='Scattered Julia'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Now let's use distance_to_polygon to test if points are inside or outside of the logo. We colour points inside in blue, and points outside in red.","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"is_inside = [DelaunayTriangulation.distance_to_polygon(q, points, nodes) > 0 for q in query_points]\nscatter!(ax, query_points[is_inside], color=:blue)\nscatter!(ax, query_points[.!is_inside], color=:red)","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"<figure>\n    <img src='../figs/point_in_polygon.png', alt='Point-in-polygon'><br>\n</figure>","category":"page"},{"location":"other_features/pole_of_inaccessibility/","page":"Pole of Inaccessibility and Polygons","title":"Pole of Inaccessibility and Polygons","text":"Works perfectly! ","category":"page"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/edges/#Individual-Edges","page":"Edges","title":"Individual Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"Edges are assumed to take the form (i, j), with customisation available for how we represent (i, j). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"construct_edge \ninitial\nterminal","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.construct_edge","page":"Edges","title":"DelaunayTriangulation.construct_edge","text":"construct_edge(::Type{E}, i, j) where {E}\n\nConstructs an edge with indices (i, j) with the type E. The  following methods are currently defined:\n\nconstruct_edge(::Type{NTuple{2, I}}, i, j) where {I}\nconstruct_edge(::Type{A}, i, j) where {I,A<:AbstractVector}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.initial","page":"Edges","title":"DelaunayTriangulation.initial","text":"initial(e::E)\n\nGiven an edge e, returns the index for the initial point. The following  methods are currently defined:\n\ninitial(e::NTuple{2,I}) where {I}\ninitial(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.terminal","page":"Edges","title":"DelaunayTriangulation.terminal","text":"terminal(e::E)\n\nGiven an edge e, returns the index for the terminal point. The following  methods are currently defined:\n\nterminal(e::NTuple{2,I}) where {I}\nterminal(e::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"edge_indices \nreverse_edge\ncompare_unoriented_edge","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.edge_indices","page":"Edges","title":"DelaunayTriangulation.edge_indices","text":"edge_indices(e)\n\nGiven an edge e, returns (initial(e), terminal(e)). \n\nSee also initial and terminal.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.reverse_edge","page":"Edges","title":"DelaunayTriangulation.reverse_edge","text":"reverse_edge(e)\n\nGiven an edge e, returns (terminal(e), initial(e)).\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.compare_unoriented_edge","page":"Edges","title":"DelaunayTriangulation.compare_unoriented_edge","text":"compare_unoriented_edge(u, v)\n\nCompares two edges u and v to see if they are the same edge, regardless of the orientation. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Collection-of-Edges","page":"Edges","title":"Collection of Edges","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"A collection of edges simply stores many edges, and this collection must be mutable so that edges can be deleted added and deleted. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. ","category":"page"},{"location":"interface/edges/#Necessary-Methods-2","page":"Edges","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"initialise_edges \nedge_type \nnum_edges \ncontains_edge \nadd_to_edges! \ndelete_from_edges! \neach_edge ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.initialise_edges","page":"Edges","title":"DelaunayTriangulation.initialise_edges","text":"initialise_edges(::Type{S})\n\nFor a given type S for some collection (e.g. a Set), returns an empty instance of that collection. The only method defined is\n\ninitialise_edges(::Type{S}) where {E, S <: Set{E}}\ninitialise_edges(::Type{A}) where {E, A <: AbstractVector{E}}\n\nwhich returns a Set{E}() or a A(), respectively. You can extend this  function as you need, making sure you extend it for the type rather than  for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.edge_type","page":"Edges","title":"DelaunayTriangulation.edge_type","text":"edge_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of edges,  returns the type of triangle used inside S, e.g. NTuple{2, Int} if S = Set{NTuple{2, Int}}. The only methods defined are \n\nedge_type(::Type{S}) where {E,S<:Set{E}}\nedge_type(::Type{A}) where {E,A<:AbstractVector{E}}\n\nwhich return E. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.num_edges","page":"Edges","title":"DelaunayTriangulation.num_edges","text":"num_edges(E::S) where {S}\n\nGiven a collection of edges E, returns the number of edges in E. The only method currently defined is \n\nnum_edges(E::Set)\nnum_edges(E::AbstractVector)\n\nwhich returns length(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.contains_edge","page":"Edges","title":"DelaunayTriangulation.contains_edge","text":"contains_edge(e::E, Es::S) where {E, S}\n\nGiven a collection of edges Es of type S, containing edges of type E, checks if Es includes the edge e, returning true  if so. The methods currently defined are\n\ncontains_edge(e::E, Es::Set{E}) where {E} \ncontains_edge(e::E, Es::A) where {E,A<:AbstractVector{E}}\ncontains_edge(i, j, Es::E)\n\nThe first two methods simply return e ∈ E, while the latter constructs the edge e = (i, j) of type edge_type(E) and call the first two  methods. Only the method contains_edge(::E, ::Es) needs to be extended if you need,  the last method makes use of this definition.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.add_to_edges!","page":"Edges","title":"DelaunayTriangulation.add_to_edges!","text":"add_to_edges!(E::S, e) where {S}\n\nGiven a collection of edges E, pushes e into it. The only  methods currently defined are\n\nadd_to_edges!(E::Set, e)\nadd_to_edges!(E::Vector, e)\n\nwhich simply call push!(E, e). You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_from_edges!","page":"Edges","title":"DelaunayTriangulation.delete_from_edges!","text":"delete_from_edges!(E::S, e::F) where {S}\n\nGiven a collection of edges E of type S, containing  edges of type F, deletes the edge e from E.  The  methods currently defined are\n\ndelete_from_edges!(E::Set{F}, T::F) where {F}\ndelete_from_edges!(Es::A, e::E) where {E, A<:AbstractVector{E}}\n\nwhich just calls delete! on E in the first case, or filter!  in the second case. This is the form of the function that needs  to be extended. We also define \n\ndelete_from_edges!(Es::E, i::Integer, j::Integer) where {E}\n\nwhich constructs the edge (i, j) and then deletes it from Es, calling  the methods above. You do not need to extend this last method.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.each_edge","page":"Edges","title":"DelaunayTriangulation.each_edge","text":"each_edge(E::F) where {F}\n\nFor a given collection of edges E, returns an iterator that  goes over each edge in the collection. The methods currently  defined are \n\neach_edge(E::Set)\neach_edge(E::AbstractMatrix)\neach_edge(E::AbstractVector)\n\nwith the first and third methods simply returning E, and the second returning  eachcol(E). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#Generic-Methods-2","page":"Edges","title":"Generic Methods","text":"","category":"section"},{"location":"interface/edges/","page":"Edges","title":"Edges","text":"add_edge!\ndelete_edge!\nrandom_edge \nis_empty ","category":"page"},{"location":"interface/edges/#DelaunayTriangulation.add_edge!","page":"Edges","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(E, e...)\n\nGiven a collection of edges E, adds all the triangles e... into it.  To extend this method to other collections, see add_to_edges!.\n\n\n\n\n\nadd_edge!(tri::Triangulation, segment; rng::AbstractRNG=Random.default_rng())\nadd_edge!(tri::Triangulation, i, j; rng::AbstractRNG=Random.default_rng())\n\nAdds the edge segment = (i, j) into the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.delete_edge!","page":"Edges","title":"DelaunayTriangulation.delete_edge!","text":"delete_edge!(E, e...)\n\nGiven a collection of edges E, deletes all the edges e... from it.  To extend this method to other collections, see delete_from_edges!.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.random_edge","page":"Edges","title":"DelaunayTriangulation.random_edge","text":"random_edge(E)\n\nReturns a random edge from edge set E.\n\n\n\n\n\n","category":"function"},{"location":"interface/edges/#DelaunayTriangulation.is_empty","page":"Edges","title":"DelaunayTriangulation.is_empty","text":"is_empty(E)\n\nTests if the edge set E is empty.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/voronoi/#Voronoi-Tessellation","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"The data structure for a Voronoi tessellation is reasonably simple. The data structure here is probably not as exhaustive as it could be, but it is sufficient.","category":"page"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"VoronoiTessellation ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.VoronoiTessellation","page":"Voronoi Tessellation","title":"DelaunayTriangulation.VoronoiTessellation","text":"VoronoiTessellation{Tr<:Triangulation,P,I,T,S,E}\n\nStruct for a Voronoi tessellation. \n\nFields\n\ntriangulation::Tr\n\nThe underlying triangulation, dual to the tessellation (unless there are constraints, in which case the tessellation is  no longer dual, but it's still used).\n\ngenerators::Dict{I, P}\n\nThe generators for each polygon. These are simply the points present in the triangulation. The keys are the vertices,  while the values are the coordinates; we need to use a Dict in case the triangulation is missing points.\n\npolygon_points::Vector{P}\n\nThe points defining the vertices of the polygons. The points are not guaranteed to be unique if a circumcenter  appears on the boundary and you are considering a clipped tessellation.\n\nSee also get_polygon_coordinates.\n\npolygons::Dict{I, Vector{I}}\n\nA Dict mapping a polygon index (same as a generator index) to the vertices of the polygon. The polygons are given in counter-clockwise order, and their first and last vertices are equal.\n\ncircumcenter_to_triangle::Dict{I, T}\n\nA Dict mapping a circumcenter index to the triangle that contains it. The triangles are sorted such that the minimum index is last.\n\ntriangle_to_circumcenter::Dict{T, I}\n\nA Dict mapping a triangle to its circumcenter index. The triangles are sorted such that the minimum index is last.\n\nunbounded_polygons::Set{I}\n\nA Set of the indices of the unbounded polygons.\n\ncocircular_circumcenters::S\n\nA Set of the indices of the circumcenters that come from triangles that are cocircular with another triangle's vertices, and adjoin said triangles. \n\nadjacent::Adjacent{I, E}\n\nAn Adjacent struct that stores the adjacency information for the polygons, mapping an oriented edge to the polygon to which it belongs. \n\nboundary_polygons::Set{I}\n\nA Set of the indices of the polygons that are on the boundary of the tessellation. Only relevant for clipped tessellations, otherwise see  unbounded_polygons.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Each field has its own accessor:","category":"page"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"get_triangulation(::VoronoiTessellation) \nget_generators(::VoronoiTessellation) \nget_polygon_points(::VoronoiTessellation)\nget_polygons(::VoronoiTessellation) \nget_circumcenter_to_triangle(::VoronoiTessellation)\nget_triangle_to_circumcenter(::VoronoiTessellation) \nget_unbounded_polygons(::VoronoiTessellation) \nget_cocircular_circumcenters(::VoronoiTessellation) \nget_adjacent(::VoronoiTessellation) \nget_boundary_polygons(::VoronoiTessellation) ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_triangulation-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_triangulation","text":"get_triangulation(vor::VoronoiTessellation)\n\nReturns the triangulation field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_generators-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_generators","text":"get_generators(vor::VoronoiTessellation)\n\nReturns the generators field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_polygon_points-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_polygon_points","text":"get_polygon_points(vor::VoronoiTessellation)\n\nReturns the polygon_points field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_polygons-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_polygons","text":"get_polygons(vor::VoronoiTessellation)\n\nReturns the polygons field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_circumcenter_to_triangle-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_circumcenter_to_triangle","text":"get_circumcenter_to_triangle(vor::VoronoiTessellation)\n\nReturns the circumcentertotriangle field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_triangle_to_circumcenter-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_triangle_to_circumcenter","text":"get_triangle_to_circumcenter(vor::VoronoiTessellation)\n\nReturns the triangletocircumcenter field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_unbounded_polygons-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_unbounded_polygons","text":"get_unbounded_polygons(vor::VoronoiTessellation)\n\nReturns the unbounded_polygons field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_cocircular_circumcenters-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_cocircular_circumcenters","text":"get_cocircular_circumcenters(vor::VoronoiTessellation)\n\nReturns the cocircular_circumcenters field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_adjacent-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(vor::VoronoiTessellation)\n\nReturns the adjacent field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_boundary_polygons-Tuple{VoronoiTessellation}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_boundary_polygons","text":"get_boundary_polygons(vor::VoronoiTessellation)\n\nReturns the boundary_polygons field from the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"There are several useful methods available for working with this data structure. We list some of these below; for functions that actually construct the tessellation, see the dedicated tessellation section in the sidebar.","category":"page"},{"location":"data_structures/voronoi/#Type-queries","page":"Voronoi Tessellation","title":"Type queries","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"edge_type(::VoronoiTessellation{Tr,P,I,T,S,E}) where {Tr,P,I,T,S,E}\nnumber_type(::VoronoiTessellation{Tr,P}) where {Tr,P}\ninteger_type(::VoronoiTessellation{Tr,P,I}) where {Tr,P,I}\ntriangle_type(::VoronoiTessellation{Tr,P,I,T}) where {Tr,P,I,T}","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.edge_type-Union{Tuple{VoronoiTessellation{Tr, P, I, T, S, E}}, Tuple{E}, Tuple{S}, Tuple{T}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I, T, S, E}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation)\n\nReturns the type used for representing edges in tri.\n\n\n\n\n\nedge_type(vor::VoronoiTessellation)\n\nReturns the type of the edges in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.number_type-Union{Tuple{VoronoiTessellation{Tr, P}}, Tuple{P}, Tuple{Tr}} where {Tr, P}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.number_type","text":"number_type(vor::VoronoiTessellation)\n\nReturns the type of the numbers used in the Voronoi tessellation vor.\n\n\n\n\n\nnumber_type(x)\n\nGiven a container x, returns the number type used for storing coordinates.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.integer_type-Union{Tuple{VoronoiTessellation{Tr, P, I}}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.integer_type","text":"integer_type(vor::VoronoiTessellation)\n\nReturns the type of the integers used in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.triangle_type-Union{Tuple{VoronoiTessellation{Tr, P, I, T}}, Tuple{T}, Tuple{I}, Tuple{P}, Tuple{Tr}} where {Tr, P, I, T}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation)\n\nReturns the type used for representing triangles in tri.\n\n\n\n\n\ntriangle_type(vor::VoronoiTessellation)\n\nReturns the type of the triangles used in the triangulation underlying the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#Getters","page":"Voronoi Tessellation","title":"Getters","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"get_generator(::VoronoiTessellation, ::Any)\nget_polygon_point(::VoronoiTessellation, ::Any)\nget_polygon(::VoronoiTessellation, ::Any)\nget_circumcenter_to_triangle(::VoronoiTessellation, ::Any)\nget_triangle_to_circumcenter(::VoronoiTessellation, ::Any)\nget_polygon_coordinates \nget_neighbouring_boundary_edges ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_generator-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_generator","text":"get_generators(vor::VoronoiTessellation, i...)\n\nGets the coordinates for the ith generator(s) of vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_polygon_point-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_polygon_point","text":"get_polygon_points(vor::VoronoiTessellation, i...)\n\nGets the coordinates for the ith polygon vertex(vertices) of vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_polygon-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_polygon","text":"get_polygons(vor::VoronoiTessellation, i)\n\nGets the vertices of the ith polygon of vor. The vertices are given in counter-clockwise order, and the first and last vertices are equal.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_circumcenter_to_triangle-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_circumcenter_to_triangle","text":"get_circumcenter_to_triangle(vor::VoronoiTessellation, i)\n\nGets the triangle that contains the ith circumcenter of vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_triangle_to_circumcenter-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_triangle_to_circumcenter","text":"get_triangle_to_circumcenter(vor::VoronoiTessellation, T)\n\nGets the index of the circumcenter of the triangle T in vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_polygon_coordinates","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_polygon_coordinates","text":"get_polygon_coordinates(vorn::VoronoiTessellation, i, bounding_box = nothing)\n\nReturns a vector for the coordinates of the ith polygon in vorn. If bounding_box  is provided, the polygon will be clipped to the bounding box, assuming that it takes  the form (xmin, xmax, ymin, ymax). Some specific cases:\n\nIf the polygon is unbounded but bounding_box is nothing, then an error will be thrown. \nIf the polygon is bounded and bounding_box is nothing, then the polygon coordinates will be returned as if without any clipping.\nIf the polygon is outside of the bounding box entirely, then an empty vector will be returned.\n\nIf you do need to consider clipping your polygon to an arbitrary polygon, see the  polygon_clip function; this function (get_polygon_coordinates) uses  polygon_clip for rectangular clipping when bounding_box is considered.\n\nSee also polygon_bounds for a good default for bounding_box.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_neighbouring_boundary_edges","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_neighbouring_boundary_edges","text":"get_neighbouring_boundary_edges(vor::VoronoiTessellation, e)\n\nGets the boundary edges that are adjacent to the boundary edge e in vor.\n\n\n\n\n\nget_neighbouring_boundary_edges(tri::Triangulation, e)\n\nGiven an edge e on the boundary, returns the edges to the left  and to the right of e, oriented so that get_adjacent(tri, v)  is a boundary index, where v are the edges returned.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#Nums","page":"Voronoi Tessellation","title":"Nums","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"num_polygons \nnum_polygon_vertices \nnum_generators ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.num_polygons","page":"Voronoi Tessellation","title":"DelaunayTriangulation.num_polygons","text":"num_polygons(vor::VoronoiTessellation)\n\nGets the number of polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.num_polygon_vertices","page":"Voronoi Tessellation","title":"DelaunayTriangulation.num_polygon_vertices","text":"num_polygon_vertices(vor::VoronoiTessellation)\n\nGets the number of vertices in all the polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.num_generators","page":"Voronoi Tessellation","title":"DelaunayTriangulation.num_generators","text":"num_generators(vor::VoronoiTessellation)\n\nGets the number of generators in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#Adders","page":"Voronoi Tessellation","title":"Adders","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"add_polygon! \npush_polygon_point! \nadd_unbounded_polygon! \ndelete_unbounded_polygon! \nadd_boundary_polygon! ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.add_polygon!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.add_polygon!","text":"add_polygon!(vor::VoronoiTessellation, B, i)\n\nAdds the polygon B to vor at index i.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.push_polygon_point!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.push_polygon_point!","text":"push_polygon_point!(vor::VoronoiTessellation, p)\npush_polygon_point!(vor::VoronoiTessellation, x, y)\n\nPushes the point p = (x, y)to the list of polygon points invor`.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.add_unbounded_polygon!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.add_unbounded_polygon!","text":"add_unbounded_polygon!(vor::VoronoiTessellation, i)\n\nAdds the index i to the list of unbounded polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.delete_unbounded_polygon!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.delete_unbounded_polygon!","text":"delete_unbounded_polygon!(vor::VoronoiTessellation, i)\n\nDeletes the index i from the list of unbounded polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.add_boundary_polygon!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.add_boundary_polygon!","text":"add_boundary_polygon!(vorn::VoronoiTessellation, i)\n\nAdds the index i to the list of boundary polygons in vorn.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#Iterators","page":"Voronoi Tessellation","title":"Iterators","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"each_generator \neach_polygon_vertex \neach_unbounded_polygon \neach_polygon \neach_polygon_index ","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.each_generator","page":"Voronoi Tessellation","title":"DelaunayTriangulation.each_generator","text":"each_generator(vor::VoronoiTessellation)\n\nGets an iterator over the indices of the generators in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.each_polygon_vertex","page":"Voronoi Tessellation","title":"DelaunayTriangulation.each_polygon_vertex","text":"each_polygon_vertex(vor::VoronoiTessellation)\n\nGets an iterator over the indices of the polygon points in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.each_unbounded_polygon","page":"Voronoi Tessellation","title":"DelaunayTriangulation.each_unbounded_polygon","text":"each_unbounded_polygon(vor::VoronoiTessellation)\n\nGets an iterator over the indices of the unbounded polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.each_polygon","page":"Voronoi Tessellation","title":"DelaunayTriangulation.each_polygon","text":"each_polygon(vor::VoronoiTessellation)\n\nGets an iterator over the polygons in vor, giving their vertices.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.each_polygon_index","page":"Voronoi Tessellation","title":"DelaunayTriangulation.each_polygon_index","text":"each_polygon_index(vor::VoronoiTessellation)\n\nGets an iterator over the indices of the polygons in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#Adjacent","page":"Voronoi Tessellation","title":"Adjacent","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"get_adjacent(::VoronoiTessellation, ::Any)\nadd_adjacent!(::VoronoiTessellation, ::Any, ::Any)\ndelete_adjacent!(::VoronoiTessellation, ::Any, ::Any)\ndelete_polygon_adjacent!\nadd_polygon_adjacent!","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_adjacent-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(vor::VoronoiTessellation, e)\nget_adjacent(vor::VoronoiTessellation, i, j)\n\nGets the adjacent polygon to the edge e or the edge (i, j).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.add_adjacent!-Tuple{VoronoiTessellation, Any, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(vor::VoronoiTessellation, e, i)\nadd_adjacent!(vor::VoronoiTessellation, i, j, k)\n\nAdds the adjacent polygon i to the edge e or the edge (i, j) to the polygon k.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.delete_adjacent!-Tuple{VoronoiTessellation, Any, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(vor::VoronoiTessellation, e, i)\ndelete_adjacent!(vor::VoronoiTessellation, i, j, k)\n\nDeletes the adjacent polygon i from the edge e or the edge (i, j) from the polygon k.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.delete_polygon_adjacent!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.delete_polygon_adjacent!","text":"delete_polygon_adjacent!(vorn::VoronoiTessellation, polygon)\n\nDeletes the adjacent polygons of the boundary edges of the polygon polygon from the adjacency list.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.add_polygon_adjacent!","page":"Voronoi Tessellation","title":"DelaunayTriangulation.add_polygon_adjacent!","text":"add_polygon_adjacent!(vorn::VoronoiTessellation, polygon)\n\nAdds the adjacent polygons of the boundary edges of the polygon polygon to the adjacency list.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#Features","page":"Voronoi Tessellation","title":"Features","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"polygon_features(::VoronoiTessellation, ::Any)\nget_area\nget_centroid \npolygon_bounds(::VoronoiTessellation, ::Any)\njump_and_march(::VoronoiTessellation, ::Any)","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.polygon_features-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.polygon_features","text":"polygon_features(vor::VoronoiTessellation, i)\n\nGets the area and centroid of the polygon with index i in vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_area","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_area","text":"get_area(stats::TriangulationStatistics, T)\n\nReturns the area field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\nget_area(vor::VoronoiTessellation, i)\n\nGets the area of the polygon with index i in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_centroid","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(stats::TriangulationStatistics, T)\n\nReturns the centroid field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\nget_centroid(vor::VoronoiTessellation, i)\n\nGets the centroid of the polygon with index i in vor.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/voronoi/#DelaunayTriangulation.polygon_bounds-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.polygon_bounds","text":"polygon_bounds(vorn::VoronoiTessellation, unbounded_extension_factor=0.0; include_polygon_vertices=true)\n\nGets the bounding box of the polygons in vorn. If unbounded_extension_factor is positive, the bounding box is extended by this factor in each direction, proportional to the width of each axis.\n\nIf include_polygon_vertices=true, then the bounds both the generators and the polygons. Otherwise, only the generators  will be considered.\n\n\n\n\n\npolygon_bounds(pts, boundary_nodes, check_all_curves = Val(false))\n\nGiven a polygon represented by the points pts with boundary_nodes defining the polygon  connections, returns a bounding box of the polygon. The bounding box is returned  in the order (xmin, xmax, ymin, ymax). If your polygon is not a multiple polygon,  check_all_curves = Val(false) is sufficient, otherwise you might want to use Val(true).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#Utilities","page":"Voronoi Tessellation","title":"Utilities","text":"","category":"section"},{"location":"data_structures/voronoi/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"get_surrounding_polygon(::VoronoiTessellation, ::Any)\nconvert_to_boundary_edge(::VoronoiTessellation, :Any)","category":"page"},{"location":"data_structures/voronoi/#DelaunayTriangulation.get_surrounding_polygon-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.get_surrounding_polygon","text":"get_surrounding_polygon(vor::VoronoiTessellation, i)\n\nGets the polygon surrounding the generator with index i in vor. You shouldn't need  to use this, see get_polygon instead.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/voronoi/#DelaunayTriangulation.convert_to_boundary_edge-Tuple{VoronoiTessellation, Any}","page":"Voronoi Tessellation","title":"DelaunayTriangulation.convert_to_boundary_edge","text":"convert_to_boundary_edge(vorn::VoronoiTessellation, e)\n\nConverts the edge e in the triangulation of vorn to a boundary edge so that get_adjacent(vorn, e) is a boundary index.\n\n\n\n\n\n","category":"method"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/unconstrained/#Unconstrained-Triangulations","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"","category":"section"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"It is simple to construct unconstrained triangulations. The method for this is through the triangulate function, shown below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangulate ","category":"page"},{"location":"triangulations/unconstrained/#DelaunayTriangulation.triangulate","page":"Unconstrained Triangulations","title":"DelaunayTriangulation.triangulate","text":"triangulate(points::P; edges=nothing, boundary_nodes=nothing,\n    IntegerType::Type{I}=Int,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    randomise=true,\n    delete_ghosts=true,\n    delete_empty_features=true,\n    try_last_inserted_point=true,\n    skip_points=Set{IntegerType}(),\n    num_sample_rule::M=default_num_samples,\n    rng::AbstractRNG=Random.default_rng(),\n    point_order=get_point_order(points, randomise, skip_points, IntegerType, rng),\n    recompute_representative_point=true,\n    delete_holes=true,\n    check_arguments=true\n) where {P,I,E,V,Es,Ts,M}\n\nComputes the unconstrained Delaunay triangulation of a set of points. If edges is provided,  they will be inserted. If boundary_nodes is provided, a boundary will also be made from these  nodes, with all triangles inside the boundaries deleted.\n\nArguments\n\npoints::P: The set of points to compute the triangulation of. \n\nKeyword Arguments\n\nedges=nothing: Any constrained edges to insert. If nothing, an unconstrained triangulation is built. The constrained edges should not intersect each other, and they should not cross over boundary edges.\nboundary_nodes=nothing: Any boundaries to define. The specification of these boundary nodes is outlined in the boundary handling section of the documentation. All triangles away from a defined boundary are deleted if delete_holes.\nIntegerType::Type{I}=Int: The integer type to use for indexing. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type to use for representing edges. \nTriangleType::Type{V}=NTuple{3,IntegerType}: The type to use for representing triangles. \nEdgesType::Type{Es}=Set{EdgeType}: The type to use for representing collections of edges. \nTrianglesType::Type{Ts}=Set{TriangleType}: The type to use for representing collections of triangles. \nrandomise=true: Whether to randomise the insertion order. \ndelete_ghosts=true: Whether to remove the ghost triangles at the end of the triangulation. \ndelete_empty_features=true: Whether to delete any empty neighbourhoods and adjacencies at the end of the triangulation. \ntry_last_inserted_point=true: When finding the next point, this decides if the previously inserted point should also be attempted. \nskip_points=Set{IntegerType}(): Points to skip over when triangulationg, i.e. points to not include in the triangulation. \nnum_sample_rule::M=default_num_samples: A function of the form n -> Number, with n the number of points currently in the triangulation, that returns the number of points to sample during the point location steps. \nrng::AbstractRNG=Random.default_rng(): The RNG to use.\npoint_order=get_point_order(points, randomise, skip_points, IntegerType, rng): The insertion order. \nrecompute_representative_point=true: At the end of the triangulation, will recompute the RepresentativePointList if true.\ndelete_holes=true: Whether to delete the exterior faces of all boundaries. There may be issues if you have boundary nodes but have this set to false - this kwarg is mostly for debugging.\ncheck_arguments=true: Whether to check the arguments for validity.\n\nOutputs\n\nReturns a Triangulation.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"In the code below, we give an example, and show how we can plot the result.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"using DelaunayTriangulation, CairoMakie \na = [1.5, 4.0]\nb = [0.0, 3.5]\nc = [2.0, 1.5]\nd = [3.0, 2.5]\ne = [2.5, 3.5]\nf = [0.5, 3.0]\ng = [2.5, -2.0]\nh = [0.5, 1.5]\ni = [0.0, 0.5]\nj = [1.5, 3.0]\npts = [a, b, c, d, e, f, g, h, i, j]\ntri = triangulate(pts)\nfig, ax, sc = triplot(tri)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"<figure>\n    <img src='../figs/small_example.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object tri is a Triangulation.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> tri\nDelaunay Triangulation.\n    Constrained: false\n    Has ghost triangles: false\n    Number of points: 10\n    Number of triangles: 12\n    Number of edges: 27","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"As we describe in more detail in the data structures section in the sidebar, tri has several fields:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> propertynames(tri)\n(:points, :triangles, :adjacent, :adjacent2vertex, :graph, :boundary_nodes, :boundary_edge_map, :boundary_map, :boundary_index_ranges, :constrained_edges, :all_constrained_edges, :convex_hull, :representative_point_list)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"We explain each field below.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.points: This stores pts.\ntri.triangles: This stores all the triangles. In this case,","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_triangles(tri)\nSet{Tuple{Int, Int, Int}} with 12 elements:\n  (10, 5, 1)\n  (9, 7, 3)\n  (2, 6, 1)\n  (3, 10, 8)\n  (10, 4, 5)\n  (9, 3, 8)\n  (3, 4, 10)\n  (8, 6, 2)\n  (9, 8, 2)\n  (10, 1, 6)\n  (8, 10, 6)\n  (3, 7, 4)","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"More generally, you can iterate over these triangles via each_triangle(tri). For example, the area of the triangulation could be computed as follows:","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"triangle_area(p, q, r) = 0.5 * (p[1] * q[2] + q[1] * r[2] + r[1] * p[2] - p[1] * r[2] - r[1] * q[2] - q[1] * p[2])\nA = 0.0\nfor T in each_triangle(tri)\n    i, j, k = indices(T)\n    p, q, r = get_point(tri, i, j, k)\n    A += triangle_area(p, q, r)\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent: This stores the adjacency relationships of the triangulation, mapping edges (u, v) to a vertex w so that (u, v, w) is a positively oriented triangle in tri. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent(tri)\nAdjacent{Int, Tuple{Int, Int}}, with map:\nDataStructures.DefaultDict{Tuple{Int, Int}, Int, Int} with 43 entries:\n  (9, 3)  => 8\n  (8, 9)  => 3\n  (4, 7)  => -1\n  (2, 1)  => -1\n  (10, 1) => 6\n  (2, 8)  => 6\n  (10, 8) => 3\n  (3, 9)  => 7\n  (4, 5)  => 10\n  (8, 3)  => 10\n  (9, 8)  => 2\n  ⋮       => ⋮","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (uv, w) in get_adjacent(tri)\n    u = initial(uv)\n    v = terminal(uv)\n    ...\nend","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.adjacent2vertex: This is a map that returns, given an index i, all other edges (j, k) such that (i, j, k) is a positively oriented triangle in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_adjacent2vertex(tri)\nAdjacent{Int, Set{Tuple{Int, Int}}, Tuple{Int, Int}}, with map:\nDict{Int, Set{Tuple{Int, Int}}} with 11 entries:\n  5  => Set([(10, 4), (1, 10)])\n  8  => Set([(9, 3), (2, 9), (6, 2), (3, 10), (10, 6)])\n  1  => Set([(6, 10), (10, 5), (2, 6)])\n  6  => Set([(1, 2), (2, 8), (10, 1), (8, 10)])\n  -1 => Set([(7, 9), (4, 7), (2, 1), (9, 2), (5, 4), (1, 5)])\n  9  => Set([(7, 3), (3, 8), (8, 2)])\n  3  => Set([(7, 4), (4, 10), (10, 8), (8, 9), (9, 7)])\n  7  => Set([(3, 9), (4, 3)])\n  4  => Set([(5, 10), (3, 7), (10, 3)])\n  2  => Set([(8, 6), (9, 8), (6, 1)])\n  10 => Set([(4, 5), (6, 8), (8, 3), (5, 1), (1, 6), (3, 4)])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This object is iterable, allowing for you to do e.g. ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"for (w, S) in get_adjacent2vertex(w)\n    for (u, v) in S \n        ...\n    end\nend ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.graph: This is a graph that returns, given an index i, all other indices j such that (i, j) is an edge in the triangulation. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_graph(tri)\nGraph\n    Number of edges: 27\n    Number of vertices: 11\n\njulia> get_edges(tri)\nSet{Tuple{Int, Int}} with 27 elements:\n  (2, 9)\n  (4, 5)\n  (1, 2)\n  (6, 8)\n  (6, 10)\n  (3, 7)\n  (-1, 2)\n  (4, 7)\n  (3, 4)\n  (1, 5)\n  (-1, 9)\n  (4, 10)\n  (2, 8)\n  (-1, 5)\n  (1, 6)\n  (3, 9)\n  (7, 9)\n  ⋮\n\njulia> get_neighbours(tri)\nDict{Int, Set{Int}} with 11 entries:\n  5  => Set([4, -1, 10, 1])\n  8  => Set([6, 2, 10, 9, 3])\n  1  => Set([5, 6, 2, 10, -1])\n  6  => Set([2, 10, 8, 1])\n  -1 => Set([5, 4, 7, 2, 9, 1])\n  9  => Set([7, 2, -1, 8, 3])\n  3  => Set([4, 7, 10, 9, 8])\n  7  => Set([4, -1, 9, 3])\n  4  => Set([5, 7, -1, 10, 3])\n  2  => Set([6, -1, 9, 8, 1])\n  10 => Set([5, 4, 6, 8, 3, 1])","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.boundary_nodes: This is a list of all fixed boundary nodes in the triangulation. In our case, we have none. See the Gmsh section for an example. The actual nodes on the boundary in this case can be obtained via tri.convex_hull.\ntri.boundary_edge_map: This is a Dict that maps all boundary edges to their position in tri.boundary_nodes. See the Gmsh section for an example.\ntri.boundary_map: This would be a list mapping boundary indices to all the fixed boundary nodes in tri.boundary_nodes corresponding to that index. This map is empty in this case as we have no fixed boundary nodes,, but see the Gmsh section for an example.\ntri.boundary_index_ranges: This is be a list mapping indices of boundary curves to all boundary indices belonging to that curve. In this case, we have ","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_boundary_index_ranges(tri)\nOrderedCollections.OrderedDict{Int, UnitRange{Int}} with 1 entry:\n  -1 => -1:-1","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"This tells us that whenever we see a -1 as a vertex, we have a ghost vertex corresponding to the outer curve, so e.g. if get_adjacent(tri, u, v) == -1, then (u, v) is an edge on the boundary. A better example is in the Gmsh section.","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.constrained_edges: This would be the collection of constrained edges if we had any. See the constrained trangulation section.\ntri.all_constrained_edges: This is a collection of all constrained edges currently in the triangulation, including the boundary edges. We have none here, but see the constrained triangulation section.\ntri.convex_hull: This is the ConvexHull of tri.points. In this case, we have","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> get_convex_hull(tri)\nConvex hull.\n    Indices:\n7-element Vector{Int}:\n 7\n 4\n 5\n 1\n 2\n 9\n 7","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"tri.representative_point_list: This is the Dict that maps curve indices to the coordinate used for representing corresponding boundary indices. Typically, these points are near the centroid of the curve; see the pole_of_inaccessibility function. In our case,","category":"page"},{"location":"triangulations/unconstrained/","page":"Unconstrained Triangulations","title":"Unconstrained Triangulations","text":"julia> tri.representative_point_list\nDict{Int, DelaunayTriangulation.RepresentativeCoordinates{Int, Float64}} with 1 entry:\n  1 => RepresentativeCoordinates{Int, Float64}(1.51155, 1.43234, 0)","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/interface/#Interface","page":"General and Defaults","title":"Interface","text":"","category":"section"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"The package makes its simple for customing the interface used for defining points, edges, and triangles, as described in the docstring for Interfaces (see the end of this section). Without any customisation, the default forms are:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Edges: NTuple{2, Int}.\nCollections of edges: Set{NTuple{2, Int}}.\nTriangles: NTuple{3, Int}.\nCollections of triangles: Set{NTuple{3, Int}}","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also give support for customing how points are represented, and by default we support collections of points given as matrices (with each point its own column), or vectors of vectors. The number type used for representing coordinates has to be Float64 to support ExactPredicates.jl, although if you like you could customise orient_predicate and incircle_predicate, even circumventing ExactPredicates.jl if you like. See the predicates section in the sidebar for a further discussion of changing these predicate definitions.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"We also provide a customisable interface for representing boundary nodes, although for unconstrained triangulations this is relevant. By default, we support boundary nodes represented according to the following, where we let BN refer to the collection of boundary nodes:","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"Vector{Int}: In this case, there is only one fixed boundary and it is represented as a contiguous set of nodes. We must have BN[begin] == BN[end], and the nodes must be listed in counter-clockwise order.\nVector{Vector{Int}}: In this case, there is only one fixed boundary, but it is made up of separate segments, with BN[n] the nodes for the nth segment. This makes it possible to more easily support, for example, a domain with different boundary conditions on separate parts of the boundary. We must have BN[n][end] == BN[n+1][begin] and BN[end][end] == BN[begin][begin], and each segment must be listed in counter-clockwise order.\nVector{Vector{Vector{Int}}}: In this case, there are multiple fixed boundaries, each of which are assumed to be made up of separate segments. This makes it possible to support multiply-connected domains, e.g. an annulus with each circle split into its lower and upper halves. Here, BN[m][n] is the set of nodes for the nth segment of the mth boundary curve, and BN[begin] the outer-most boundary curve and BN[m], m > 1, nodes for curves contained within BN[begin]. As in the previous case, BN[m][n][end] == BN[m][n+1][end] and BN[m][end][end] == BN[m][begin][begin] for each m. Moreover, BN[begin] should be a counter-clockwise list of nodes while BN[m] is a clockwise list of nodes for m > 1.","category":"page"},{"location":"interface/interface/","page":"General and Defaults","title":"General and Defaults","text":"For more information about how we handle boundaries, and how they are handled in our data structures, see the boundary handling section in the sidebar. ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/constrained/#Constrained-Triangulations","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we describe the algorithm used for computing a constrained triangulation. We assume that we have some point set mathcal P, a set of edges mathcal E to be inserted, and some boundary edges mathcal B. The algorithm we implement is given here and is built upon the basic idea of Chew's algorithm for triangulating convex polygons, namely solving the point location problem by deleting an associated cavity in a clever way.","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"First, suppose we have computed the unconstrained Delaunay triangulation mathcal Dmathcal T(mathcal P) of our point set. The algorithm for then computing the constrained Delaunay triangulation mathcal Dmathcal T(mathcal P mathcal E mathcal B) then works incrementally, inserting edges one at a time. Let us, then, describe the procedure for inserting some edge e in mathcal C, where mathcal C = mathcal E cup mathcal B. We break the discussion into sections. ","category":"page"},{"location":"tri_algs/constrained/#Segment-Location","page":"Constrained Triangulations","title":"Segment Location","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Similar to how in adding points into a triangulation the first step is point location, here the first step is segment location. Here, our aim is to find all triangles that intersect the edge e. This is easy to do if we simply remember that the jump-and-march algorithm walks through all triangles that  intersect an initial scan line until stopping: this is exactly what we want. So, what we have done is modify our jump-and-march code such that the history of triangles walked through is recorded. This information is recorded into a PointLocationHistory struct. With this, we also note that since the jump-and-march algorithm will require rotating around an initial point (one of the indices of e), we should want to minimise the number of triangles we may need to rate around. Thus, we rotate e such that its initial vertex is the one with the least degree, hence we have less triangles to rotate around initially, thus reducing the time spent searching. From here on, we let e be this rotated form. This segment location is handled via the following function:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"locate_intersecting_triangles","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.locate_intersecting_triangles","page":"Constrained Triangulations","title":"DelaunayTriangulation.locate_intersecting_triangles","text":"locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true); rng::AbstractRNG=Random.default_rng()) where {C}\n\nReturns a list of triangles intersecting the segment e in tri. If is_true(rotate),  then e will be sorted such that initial(e) has smaller degree in tri than terminal(e).\n\nMore precisely, the returned values are:\n\nintersecting_triangles: The triangles intersecting e.\ncollinear_segments: Any segments collinear with e, giving in order of appearance.\nleft_vertices: All vertices of intersecting_triangles appearing to the left of e.\nright_vertices: All vertices of intersecting_triangles appearing to the right of e.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"This function also returns information about any segments that are collinear with e and all vertices of the intersecting triangles to the left and to the right of e. For the collinear segments, these are processed via the functions fix_segments!, connect_segments!, and extend_segments!, breaking e into a smaller set of segments so that no segments are collinear anymore. We will assume that there are no collinear segments for simplicity. For the vertices to the left and to the right of e, these are needed as they define the outline of points to be deleted on each side of e, thus giving a polygonal cavity (possibly self-intersecting, but this detail doesn't actually matter) that we can triangulate individually. For example, consider the triangulation:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"a = (0.0, 0.0)\nb = (0.0, 1.0)\nc = (0.0, 2.5)\nd = (2.0, 0.0)\ne = (6.0, 0.0)\nf = (8.0, 0.0)\ng = (8.0, 0.5)\nh = (7.5, 1.0)\ni = (4.0, 1.0)\nj = (4.0, 2.5)\nk = (8.0, 2.5)\npts = [a, b, c, d, e, f, g, h, i, j, k]\ntri = triangulate(pts; delete_ghosts=false, randomise=false)\nfig, ax, sc = triplot(tri)\nlines!(ax, [get_point(tri, 2, 7)...], color=:blue, linewidth=2)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example.png', alt='An edge through a triangulation'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we perform segment location on this example on the highlighted segment (2, 7), we find:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> e = (2, 7)\n(2, 7)\n\njulia> intersecting_triangles, collinear_segments, left_vertices, right_vertices = DelaunayTriangulation.locate_intersecting_triangles(tri, e);\n\njulia> intersecting_triangles\n8-element Vector{Tuple{Int, Int, Int}}:\n (4, 3, 2)\n (3, 4, 10)\n (10, 4, 9)\n (9, 4, 5)\n (9, 5, 10)\n (10, 5, 8)\n (8, 5, 6)\n (8, 6, 7)\n\njulia> collinear_segments\nTuple{Int, Int}[]\n\njulia> left_vertices\n7-element Vector{Int}:\n  7\n  8\n 10\n  9\n 10\n  3\n  2\n\njulia> right_vertices\n5-element Vector{Int}:\n 2\n 4\n 5\n 6\n 7","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The intersecting triangles gives the triangles intersected by e in order of occurrence. For left_vertices, these are given in counter-clockwise order, with the left- and right-most elements being the indices of e. See that the vertex 10 is repeated in left_vertices. This is because the point 9 creates a sort of dangling edge in the polygonal cavity that we have to delete, and we need to somehow know to insert this point back into the triangulation. What we do, then, is to imagine an ant walking around the polygonal cavity. The ant will walk from 10 to 9, but then it has to come back down to 10, so we include it twice to represent these two visits. To see the cavity, let us delete these triangles:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"DelaunayTriangulation.delete_intersected_triangles!(tri, intersecting_triangles)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example_deleted_triangles.png', alt='An edge through a triangulation with excavated cavities'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The polygonal cavities on each side of the blue segment are what we need to re-triangulate separately. Let us now describe this procedure.","category":"page"},{"location":"tri_algs/constrained/#Triangulating-the-Polygonal-Cavities","page":"Constrained Triangulations","title":"Triangulating the Polygonal Cavities","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Now we need to triangulate each cavity. We will describe this only for the cavity above (2, 7) in the figure below, but the procedure is exactly the same for the other cavity. Let mathcal V = (v_1 ldots v_m) be the sequence of vertices in counter-clockwise order around the cavity when we insert the segment e=(v_1v_m). In this case, mathcal V = (7 8 10 9 10 3 2). First, just like in Chew's algorithm, we need to build up a linked-list representing the cavity. This is done via the function ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"prepare_vertex_linked_list","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.prepare_vertex_linked_list","page":"Constrained Triangulations","title":"DelaunayTriangulation.prepare_vertex_linked_list","text":"prepare_vertex_linked_list(V::AbstractArray{I}) where {I}\n\nGiven a list of polygon vertices V, defines a linked list (prev, next) of polygon vertices so that (prev[i], i, next[i]) define a trio of polygon vertices  in counter-clockwise order, and defines, and returns shuffled_indices which is currently  unshuffled.\n\nThe first and last entries of the returned values (prev, next, shuffled_indices) will  not be populated, instead being 0.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"(Note: The algorithm given by Shewchuk and Brown linked above also allocates a distance array storing orient determinants for this preparation of the linked list, giving values proportional to the distance from e. This is not exactly robust for us, since we need to compute the sign of a difference of two determinants. In particular, let o_1 and o_2 be two robust estimates for an orient determinant. To determine if o_1 < o_2 is the same as defining a predicate for the sign of o_1 - o_2, but this is problematic as, while the computation of o_1 and o_2 may be reliable, their difference is not. Instead, we recompute this predicate in a robust manner each time, trading performance for robustness. This predicate is defined by point_closest_to_line.)","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Once we have prepared the linked list, we need to delete vertices from it in a random order, corresponding to deleting vertices from the polygon in a random order. Like in Chew's algorithm, this is done in such a way that we can reverse the process and automatically get point location without ever needing the jump-and-march algorithm. This deletion is handled via delete_polygon_vertices_in_random_order! which simply loops over each vertex, calling select_random_vertex and update_vertex_linked_list! at each iteration:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"delete_polygon_vertices_in_random_order!\nselect_random_vertex \nupdate_vertex_linked_list! ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.delete_polygon_vertices_in_random_order!","page":"Constrained Triangulations","title":"DelaunayTriangulation.delete_polygon_vertices_in_random_order!","text":"delete_polygon_vertices_in_random_order!(tri::Triangulation, V, shuffled_indices, prev, next, u, v, rng::AbstractRNG=Random.default_rng())\n\nGiven a triangulation tri, a vertex list V, a set of shuffled_indices, a linked list (prev, next) for the  poylgon vertices, and a segment (u, v) that was inserted in order to define the polygon V, deletes vertices of V, via their representation in (prev, next, shuffled_indices), in a random order.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.select_random_vertex","page":"Constrained Triangulations","title":"DelaunayTriangulation.select_random_vertex","text":"select_random_vertex(tri::Triangulation, V, shuffled_indices, prev, next, range, u, v, rng::AbstractRNG=Random.default_rng())\n\nGiven a triangulation tri, a line through points with indices u and v, a shuffled set of  indices shuffled_indices, and a doubly-linked list (prev, next) of vertex indices,  selects a random vertex j ∈ range that is not closer to the line than both of its  neighbours. V is the original vertex list.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.update_vertex_linked_list!","page":"Constrained Triangulations","title":"DelaunayTriangulation.update_vertex_linked_list!","text":"update_vertex_linked_list!(shuffled_indices, prev, next, i, j)\n\nLet π = shuffled_indices. This function replaces next[prev[π[j]]] with next[π[j]], prev[next[π[j]]] with prev[π[j]], and interchanges π[i] and π[j]. This has the act  of deleting V[π[j]] from the polygon, where V is the list of polygon vertices of the  polygon being evacuated during segment insertion for a constrained triangulation.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"An important note is that, while this insertion algorithm works even with dangling edges, self-intersections, etc., it does not work when a point has an interior angle exceeding 360 degrees. We can detect this case by finding a point in the polygon that is closer to e than its two neighbours, which is the only time such an interior angle is possible (see the paper for a proof). Thus, select_random_vertex actually keeps sampling vertices to delete in a random order until this is not the case, making use of vertex_is_closer_than_neighbours:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"vertex_is_closer_than_neighbours ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.vertex_is_closer_than_neighbours","page":"Constrained Triangulations","title":"DelaunayTriangulation.vertex_is_closer_than_neighbours","text":"vertex_is_closer_than_neighbours(tri::Triangulation, u, v, jᵢ, jᵢ₋₁, jᵢ₊₁)\nvertex_is_closer_than_neighbours(tri::Triangulation, V, u, v, j, shuffled_indices, prev, next)\n\nGiven a triangulation tri and a line through points with indices u and v, tests if the point with index jᵢ is closer to the line than those with index  jᵢ₋₁ and jᵢ₊₁, assuming all these points are to the left of the line. The second  method extracts these latter two indices using the linked list (prev, next) of vertices  and a shuffled set of indices shuffled_indices together with the original vertex list V.\n\nnote: Note\nThis function is useful for constrained triangulations since the algorithm  used will not work if a point being inserted on the cavity has interior angle  of 360° or greater. This is possible only if a vertex is closer to the line than  its neighbours on the polygon.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Once this is all done, we ready to start triangulating the cavity. After adding an initial triangle from the three remaining vertices, we add points in one at a time, making use of a function add_point_cavity_cdt!. This function is defined by:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"function add_point_cavity_cdt!(tri::Triangulation, u, v, w)\n    x = get_adjacent(tri, w, v)\n    if !edge_exists(x)\n        insert_flag = true\n    else\n        p, q, r, s = get_point(tri, w, v, x, u) \n        incircle_test = point_position_relative_to_circle(p, q, r, s)\n        orient_test = triangle_orientation(tri, u, v, w)\n        insert_flag = !is_inside(incircle_test) && is_positively_oriented(orient_test)\n    end\n    if insert_flag\n        add_triangle!(tri, u, v, w; protect_boundary=true, update_ghost_edges=false)\n    else\n        delete_triangle!(tri, w, v, x; protect_boundary=true, update_ghost_edges=false)\n        add_point_cavity_cdt!(tri, u, v, x)\n        add_point_cavity_cdt!(tri, u, x, w)\n    end\n    return nothing\nend","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"In particular, x = get_adjacent(tri, w, v) is used to find the triangle on the other side of the edge vw from u, the point being inserted. The only way that wv should not be deleted is if the triangle wvx does not exist, as detected via !edge_exists(x), or if u is not inside the circumcircle of wvx and u is on the correct side of the edge vw. This is detected by the computation of insert_flag. If insert_flag, just add the triangle. Otherwise, we need to delete the triangle wvx and uvw as they are no longer constrained Delaunay. This is done by flipping vw onto ux. Once we have done this for each point, we have successfuly triangulated the cavity. ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"This is all handled via the triangulate_cavity_cdt function:","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"triangulate_cavity_cdt","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.triangulate_cavity_cdt","page":"Constrained Triangulations","title":"DelaunayTriangulation.triangulate_cavity_cdt","text":"triangulate_cavity_cdt(points, V;\n    IntegerType::Type{I}=Int,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{Vs}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    rng::AbstractRNG=Random.default_rng()) where {I,E,Vs,Es,Ts}\ntriangulate_cavity_cdt(tri, V; rng::AbstractRNG=Random.default_rng())\n\nTriangulates the cavity, represented as a counter-clockwise list of  vertices V with indices corresponding to those in points,  left behind when deleting triangles intersected in a triangulation by an edge.  If a triangulation is provided, the points are used from that.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"For our example, what we find is (the triangulation tri was updated to put the missing triangles back in from the last piece of code, note):","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"julia> add_edge!(tri, 2, 7) # calls triangulate_cavity_cdt on each cavity","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"<figure>\n    <img src='../figs/segment_example_completed.png', alt='A constrained edge through a triangulation'><br>\n</figure>","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"Here we used add_edge!(tri, 2, 7), which does all this pre-processing for us. Similarly, for adding many edges, the method ","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"triangulate_constrained!","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.triangulate_constrained!","page":"Constrained Triangulations","title":"DelaunayTriangulation.triangulate_constrained!","text":"triangulate_constrained(tri::Triangulation; rng=Random.default_rng())\n\nInserts all constrained edges and boundary edges into tri.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"is useful (triangulate calls this internally).","category":"page"},{"location":"tri_algs/constrained/#Excavating-Exterior-Faces","page":"Constrained Triangulations","title":"Excavating Exterior Faces","text":"","category":"section"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"When we define boundary curves, we typically want to delete any points and triangles exterior to them. The logic of the method we use for this is simple. Basically, we \"plant\" a seed in an exterior face, and use it to infect other points in this exterior face, continuing this spread until all exterior faces are found. The function that performs this is delete_holes!, with relevant docstrings below.","category":"page"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"delete_holes!\nhas_interiors_within_interiors ","category":"page"},{"location":"tri_algs/constrained/#DelaunayTriangulation.delete_holes!","page":"Constrained Triangulations","title":"DelaunayTriangulation.delete_holes!","text":"delete_holes!(tri::Triangulation)\n\nDeletes all the exterior faces to the boundary nodes specified in the  triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/#DelaunayTriangulation.has_interiors_within_interiors","page":"Constrained Triangulations","title":"DelaunayTriangulation.has_interiors_within_interiors","text":"has_interiors_within_interiors(tri::Triangulation)\n\nReturns true if the triangulation has multiple curves and the first curve has a positive area and all other curves have negative areas, meaning there are some interior curves that are inside other interior curves. Returns false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tri_algs/constrained/","page":"Constrained Triangulations","title":"Constrained Triangulations","text":"The points that we find are then processed one at a time, checking all adjoining triangles to see if their centroid is in the interior or exterior. Special case is taken at the boundary nodes.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"We define some specific operations for acting on Triangulations directly. These are listed below.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"add_point!(::Triangulation, ::Any)\nadd_edge!(::Triangulation, ::Any)\ndelete_point!(::Triangulation, ::Any)\nadd_boundary_information!(::Triangulation)\ndelete_ghost_triangles!(::Triangulation)\nadd_ghost_triangles!(::Triangulation)\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts<:Triangulation}\nsplit_edge!\nlegalise_split_edge!\ncomplete_split_edge_and_legalise!\nsplit_triangle!\nlegalise_split_triangle!\ncomplete_split_triangle_and_legalise!\nflip_edge!\nlegalise_edge!\nclear_empty_features!\nlock_convex_hull! \nunlock_convex_hull!","category":"page"},{"location":"operations/#DelaunayTriangulation.add_point!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.add_point!","text":"add_point!(tri::Triangulation, new_point[, new_point_y];\n    point_indices=get_vertices(tri),\n    m=default_num_samples(length(point_indices)),\n    try_points=(),\n    rng::AbstractRNG=Random.default_rng(),\n    initial_search_point=integer_type(tri)(select_initial_point(get_points(tri),new_point;point_indices,m,try_points,rng)),\n    update_representative_point=false,\n    store_event_history = Val(false),\n    event_history = nothing,\n    exterior_curve_index=1,\n    V=jump_and_march(\n        tri,\n        new_point isa Integer ? get_point(tri, new_point) : new_point;\n        m=nothing,\n        point_indices=nothing,\n        try_points=nothing,\n        k=initial_search_point,\n        rng,\n        check_existence=Val(has_multiple_segments(tri)),\n        exterior_curve_index\n    ),\n    peek = Val(false),\n    )\n\nAdds the point new_point to the triangulation tri.\n\nArguments\n\ntri::Triangulation: The Triangulation.\nnew_point[, new_point_y]: The point to add. This new_point can be an integer, in which case get_point(tri, new_point) is added. If new_point is just a set of coordinates, we add that into tri via push_point! and then add that index into tri. Lastly, if we provide (new_point, new_point_y), then the point is treated as this Tuple and inserted.\n\nKeyword Arguments\n\npoint_indices=each_solid_vertex(tri): The indices of the non-ghost points in the triangulation.\nm=default_num_samples(length(point_indices)): The number of points to sample from point_indices to use as the initial search point.\ntry_points=(): A list of points to try as the initial search point in addition to those sampled.\nrng::AbstractRNG=Random.default_rng(): The random number generator to use.\ninitial_search_point=integer_type(tri)(select_initial_point(tri,new_point;point_indices,m,try_points,rng)): The initial search point to use. If this is not provided, then we use select_initial_point to select one.\nupdate_representative_point=false: Whether to update the representative point list after adding the new point.\nstore_event_history = Val(false): Whether to store the event history. See InsertionEventHistory.\nevent_history = nothing: The event history to store the events in. See InsertionEventHistory. Only needed if is_true(store_event_history). This object is not returned, instead we just mutate it inplace.\nexterior_curve_index=1: The curve (or curves) corresponding to the outermost boundary.\nV=jump_and_march(tri, new_point isa Integer ? get_point(tri, new_point) : new_point; m=nothing, point_indices=nothing, try_points=nothing, k=initial_search_point, rng, check_existence=Val(has_multiple_segments(tri)), exterior_curve_index=exterior_curve_index): The triangle that q is in.\npeek=Val(false): If is_true(peek), then we don't actually add the point, but all operations that update the history will be run. (So you should only really want this if you are using event_history.)\n\nOutputs\n\nThe triangulation is updated in-place with the new point, but we also return the triangle V containing new_point.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_edge!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.add_edge!","text":"add_edge!(tri::Triangulation, segment; rng::AbstractRNG=Random.default_rng())\nadd_edge!(tri::Triangulation, i, j; rng::AbstractRNG=Random.default_rng())\n\nAdds the edge segment = (i, j) into the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_point!-Tuple{Triangulation, Any}","page":"Operations","title":"DelaunayTriangulation.delete_point!","text":"delete_point!(tri::Triangulation, point; rng::AbstractRNG=Random.default_rng())\n\nDeletes point from the triangulation tri using Chew's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_boundary_information!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_boundary_information!","text":"add_boundary_information!(tri::Triangulation)\n\nGiven a triangulation tri, adds boundary information into tri. In particular,  the Adjacent, Adjacent2Vertex, and Graph fields are updated so that e.g. boundary edges  map to their corresponding boundary indices, boundary indices map to their boundary edges  via the Adjacent2Vertex map, and boundary indices are included in the Graph.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.delete_ghost_triangles!","text":"delete_ghost_triangles!(tri::Triangulation; boundary_indices = all_boundary_indices(tri), delete_neighbours=false)\n\nDeletes the ghost triangles from the triangulation tri.\n\nnote: Note\nA ghost triangle is a triangle of the form (i, j, k) where only one of the indices, say i,  satisfies is_boundary_index(i).\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}","page":"Operations","title":"DelaunayTriangulation.add_ghost_triangles!","text":"add_ghost_triangles!(tri::Triangulation; boundary_indices=all_boundary_indices(tri), add_neighbours=false\n\nGiven a Triangulation tri, adds the ghost triangles into tri. In particular,  the triangles, Adjacent, and Adjacent2Vertex fields are updated so that  ghost triangles are stored in them.\n\nnote: Note\nA ghost triangle is a triangle of the form (i, j, k) where only one of the indices, say i,  satisfies is_boundary_index(i).\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(tri::Triangulation, u, v, w; protect_boundary=false, update_ghost_edges=false)\nadd_triangle!(tri::Triangulation, T; protect_boundary=false, update_ghost_edges=false)\n\nGiven a triangle T = (u, v, w), adds the triangle into the triangulation tri. To update the ghost triangles directly,  set update_ghost_edges=true. The other parts of the boundary information will be handled, though, unless you set protect_boundary=true.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts<:Triangulation","page":"Operations","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(tri::Triangulation, u, v, w; protect_boundary=false, update_ghost_edges=false)\ndelete_triangle!(tri::Triangulation, T; protect_boundary=false, update_ghost_edges=false)\n\nGiven a triangle T = (u, v, w), adds the triangle into the triangulation tri. To update the ghost triangles directly,  set update_ghost_edges=true. The other parts of the boundary information will be handled, though, unless you set protect_boundary=true.\n\n\n\n\n\n","category":"method"},{"location":"operations/#DelaunayTriangulation.split_edge!","page":"Operations","title":"DelaunayTriangulation.split_edge!","text":"split_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri and an edge (i, j), splits the edge at  the point r so that the edges (i, r) and (r, j) now appear in tri  (with the triangles updated accordingly). It is assumed that r is (at least  very close to) collinear with (i, j).\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_split_edge!","page":"Operations","title":"DelaunayTriangulation.legalise_split_edge!","text":"legalise_split_edge!(tri::Triangulation, i, j, k, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j) that has already  been split by split_edge! at the point r,  legalises the new edges using legalise_edge, letting  k be the vertex that was originally adjacent to (i, j).\n\nIf store_event_history is Val(true), then the event history is stored in  event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.complete_split_edge_and_legalise!","page":"Operations","title":"DelaunayTriangulation.complete_split_edge_and_legalise!","text":"complete_split_edge_and_legalise!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j), and a point r, splits both (i, j) and (j, i) at r using split_edge! and then legalises the new edges using legalise_split_edge!.\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.split_triangle!","page":"Operations","title":"DelaunayTriangulation.split_triangle!","text":"split_triangle!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k), and a  point r inside the triangle, splits the triangle at r  so that (i, j, k) is replaced by the three triangles  (i, j, r), (j, k, r), and (k, i, r), respectively.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_split_triangle!","page":"Operations","title":"DelaunayTriangulation.legalise_split_triangle!","text":"legalise_split_triangle!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k) that has  already been split by split_triangle! at the point r, legalises the new edges using legalise_edge.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.complete_split_triangle_and_legalise!","page":"Operations","title":"DelaunayTriangulation.complete_split_triangle_and_legalise!","text":"complete_split_triangle_and_legalise!(tri::Triangulation, i, j, k, r)\n\nGiven a triangulation tri, a triangle (i, j, k), and a point r, splits (i, j, k) at r using split_triangle! and then legalises the new edges using legalise_split_triangle!.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.flip_edge!","page":"Operations","title":"DelaunayTriangulation.flip_edge!","text":"flip_edge!(tri::Triangulation, i, j, store_event_history=Val(false), event_history=nothing)\nflip_edge!(tri::Triangulation, i, j, k, ℓ)\n\nGiven a triangulation tri and an edge (i, j) appearing in the triangulation,  flips the edge (i, j) so that it becomes (ℓ, k), where ℓ = get_adjacent(tri, i, j) and k = get_adjacent(tri, j, i). \n\nwarning: Warning\nIf (i, j, ℓ, k) is not a convex quadrilateral, than this edge flip makes the triangulation non-planar.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.legalise_edge!","page":"Operations","title":"DelaunayTriangulation.legalise_edge!","text":"legalise_edge!(tri::Triangulation, i, j, r, store_event_history=Val(false), event_history=nothing)\n\nGiven a triangulation tri, an edge (i, j), and a  point r that was added into a triangle that (i, j)  belongs to, legalises the edge (i, j) and other neighbouring  edges recursively.\n\nIf store_event_history is Val(true), then the event history is stored in event_history.\n\nwarning: Warning\nEdge flipping can lead to final eventhistorys that have triangles both in addedtriangles and deleted_triangles\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.clear_empty_features!","page":"Operations","title":"DelaunayTriangulation.clear_empty_features!","text":"clear_empty_features!(tri::Triangulation)\n\nClears all empty features from the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.lock_convex_hull!","page":"Operations","title":"DelaunayTriangulation.lock_convex_hull!","text":"lock_convex_hull!(tri::Triangulation)\n\nLocks the convex hull of the triangulation tri by adding it to the constrained edges  of tri in place of boundary_nodes. If has_boundary_nodes(tri) is already true,  an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"operations/#DelaunayTriangulation.unlock_convex_hull!","page":"Operations","title":"DelaunayTriangulation.unlock_convex_hull!","text":"unlock_convex_hull!(tri::Triangulation)\n\nUnlocks the convex hull of the triangulation tri by removing it from the constrained edges of tri. If has_boundary_nodes(tri) is already false or if get_boundary_nodes(tri) ≠ get_convex_hull_indices(tri),  an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/counting/#Application:-Counting-Function-Calls","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"","category":"section"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"The ability to customise the primitive interfaces completely has many advantages. In the previous section we gave a complete example for how to setup and define all the functions required. Here, we will show an actual example where customisation can be really useful.","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"The application in mind is to study how many times a function is being called during the construction of a triangulation. By defining custom definitions for points and triangles, we can estimate how many times we compute predicates and how many times we add and remove triangles. ","category":"page"},{"location":"interface/counting/#Setting-Up","page":"Application: Counting Function Calls","title":"Setting Up","text":"","category":"section"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"To start the application, we first load in the packages.","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"using DelaunayTriangulation\nusing CairoMakie\nusing StatsBase\nconst DT = DelaunayTriangulation","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"We then need to define the custom primitves and the required definitions. First, the structs and basic definitions:","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"struct CustomPoint\n    x::Float64\n    y::Float64\nend\nstruct CustomTriangle\n    i::Int\n    j::Int\n    k::Int\nend\nDT.getx(p::CustomPoint) = p.x\nDT.gety(p::CustomPoint) = p.y\nDT.number_type(::Type{CustomPoint}) = Float64\nDT.construct_triangle(::Type{CustomTriangle}, i, j, k) = CustomTriangle(i, j, k)\nDT.geti(tri::CustomTriangle) = tri.i\nDT.getj(tri::CustomTriangle) = tri.j\nDT.getk(tri::CustomTriangle) = tri.k\nDT.integer_type(::Type{CustomTriangle}) = Int32\nDT.getpoint(pts::Vector{CustomPoint}, i::Int) = pts[i]","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Next, we define the actual counter. This will be a mutable struct.","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"mutable struct AlgorithmStats\n    orient_calls::Int\n    incircle_calls::Int\n    parallelorder_calls::Int\n    sameside_calls::Int\n    meet_calls::Int\n    added_triangles::Int\n    deleted_triangles::Int\nend\nAlgorithmStats() = AlgorithmStats(0, 0, 0, 0, 0, 0, 0)\nAlgorithmStats(opstats::AlgorithmStats) = AlgorithmStats(opstats.orient_calls, opstats.incircle_calls, opstats.parallelorder_calls, opstats.sameside_calls, opstats.meet_calls, opstats.added_triangles, opstats.deleted_triangles)\nnt = Base.Threads.nthreads()\nconst opstats = [AlgorithmStats() for _ in 1:nt]\nreset_opstats!(id=Base.Threads.threadid()) = (opstats[id] = AlgorithmStats())","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"The constant opstats is a vector of counters so that we can use multithreading. The methods we need to overwrite for this counter are:","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"function DT.add_to_triangles!(tri::Set{CustomTriangle}, triangle::CustomTriangle)\n    push!(tri, triangle)\n    opstats[Base.Threads.threadid()].added_triangles += 1\n    return nothing\nend\nfunction DT.delete_from_triangles!(tri::Set{CustomTriangle}, triangle::CustomTriangle)\n    delete!(tri, triangle)\n    opstats[Base.Threads.threadid()].deleted_triangles += 1\n    return nothing\nend\nfunction DT.orient_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint)\n    o = DT.orient_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r))\n    opstats[Base.Threads.threadid()].orient_calls += 1\n    return o\nend\nfunction DT.incircle_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)\n    o = DT.incircle_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))\n    opstats[Base.Threads.threadid()].incircle_calls += 1\n    return o\nend\nfunction DT.parallelorder_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)\n    o = DT.parallelorder_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))\n    opstats[Base.Threads.threadid()].parallelorder_calls += 1\n    return o\nend\nfunction DT.sameside_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint)\n    o = DT.sameside_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r))\n    opstats[Base.Threads.threadid()].sameside_calls += 1\n    return o\nend\nfunction DT.meet_predicate(p::CustomPoint, q::CustomPoint, r::CustomPoint, s::CustomPoint)\n    o = DT.meet_predicate(DT._getxy(p), DT._getxy(q), DT._getxy(r), DT._getxy(s))\n    opstats[Base.Threads.threadid()].meet_calls += 1\n    return o\nend","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Next, let's define the functions for summarising the simulations we'll perform, the simulation functions themselves, and a function for plotting results.","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"## Summary functions \nstruct AlgorithmStatsSummary\n    orient_calls::NTuple{2,Float64}\n    incircle_calls::NTuple{2,Float64}\n    parallelorder_calls::NTuple{2,Float64}\n    sameside_calls::NTuple{2,Float64}\n    meet_calls::NTuple{2,Float64}\n    added_triangles::NTuple{2,Float64}\n    deleted_triangles::NTuple{2,Float64}\n    function AlgorithmStatsSummary(sims::Vector{AlgorithmStats})\n        orient_calls = quantile([sim.orient_calls for sim in sims], (0.025, 0.975))\n        incircle_calls = quantile([sim.incircle_calls for sim in sims], (0.025, 0.975))\n        parallelorder_calls = quantile([sim.parallelorder_calls for sim in sims], (0.025, 0.975))\n        sameside_calls = quantile([sim.sameside_calls for sim in sims], (0.025, 0.975))\n        meet_calls = quantile([sim.meet_calls for sim in sims], (0.025, 0.975))\n        added_triangles = quantile([sim.added_triangles for sim in sims], (0.025, 0.975))\n        deleted_triangles = quantile([sim.deleted_triangles for sim in sims], (0.025, 0.975))\n        return new(orient_calls, incircle_calls, parallelorder_calls, sameside_calls, meet_calls, added_triangles, deleted_triangles)\n    end\nend\nsummarise_simulations(sims) = AlgorithmStatsSummary(sims)\n\n## Point generators \nfunction generate_random_points(npts)\n    pts = [CustomPoint(rand(), rand()) for _ in 1:npts]\n    return pts\nend\nfunction generate_structured_points(npts)\n    nx = isqrt(npts)\n    ny = isqrt(npts)\n    points = CustomPoint[]\n    for i in 1:nx\n        for j in 1:ny\n            x = (i - 1) / (nx - 1)\n            y = (j - 1) / (ny - 1)\n            push!(points, CustomPoint(x, y))\n        end\n    end\n    while length(points) < npts\n        push!(points, CustomPoint(rand(), rand()))\n    end\n    return points\nend\n\n## Simulation functions\nfunction simulate(npts; f=generate_random_points, edges=nothing)\n    reset_opstats!()\n    if f isa Function\n    pts = f(npts)\n    else \n        pts=f # later, when we look at constrained triangulations, we'll pass points and edges but not f as a function \n    end\n    triangulate(pts; TriangleType=CustomTriangle, edges=edges)\n    return AlgorithmStats(opstats[Base.Threads.threadid()])\nend\nfunction simulate(npts, nsims; f=generate_random_points, edges=nothing)\n    sim_results = Vector{AlgorithmStats}(undef, nsims)\n    for i in 1:nsims\n        sim_results[i] = simulate(npts; f, edges)\n    end\n    return sim_results, summarise_simulations(sim_results)\nend\nfunction simulate(npts::AbstractVector{Int}, nsims; f=generate_random_points, edges=nothing)\n    sim_results = Vector{Tuple{Vector{AlgorithmStats},AlgorithmStatsSummary}}(undef, length(npts))\n    Base.Threads.@threads :static for i in eachindex(npts)\n        n = npts[i]\n        sim_results[i] = simulate(n, nsims; f, edges)\n    end\n    return first.(sim_results), last.(sim_results)\nend\n\n## Complete plotting function\nconst alp = join('a':'z')\nfunction plot_fnc!(fig, i, j, statistic, title, simulation_results, simulation_summaries, npts, dolog=false)\n    scale = dolog ? log10 : identity\n    ax = Axis(fig[i, j], xlabel=L\"n\", ylabel=L\"$ $Number\", title=title, titlealign=:left, width=600, height=300, xscale=scale, yscale=scale)\n    scatters = NTuple{2,Int}[]\n    lower = Vector{Float64}(undef, length(npts))\n    upper = Vector{Float64}(undef, length(npts))\n    for (k, n) in enumerate(npts)\n        for sim in simulation_results[k]\n            push!(scatters, (n, getfield(sim, statistic)))\n        end\n        result = getfield(simulation_summaries[k], statistic)\n        lower[k] = result[1]\n        upper[k] = result[2]\n    end\n    scatter!(ax, scatters, color=:black, markersize=3)\n    band!(ax, npts, lower, upper, color=(:blue, 0.2), strokewidth=2)\nend\nfunction plot_fnc(npts, simulation_results, simulation_summaries)\n    fig = Figure(fontsize=36)\n    dolog = (true, false, false, false, false, false, false)\n    for (k, (f, dolog)) in enumerate(zip(fieldnames(AlgorithmStats), dolog))\n        title = L\"(%$(alp[k])):$ $ %$(f)\"\n        i, j = ceil(Int, k / 4), mod1(k, 4)\n        plot_fnc!(fig, i, j, f, title, simulation_results, simulation_summaries, npts, dolog)\n    end\n    resize_to_layout!(fig)\n    fig\nend\n\n## Analysis functions for constrained triangulations: We'll fix the number of points and vary the number of edges \nfunction get_random_vertices_and_constrained_edges(nverts1, nverts2, nedges, f)\n    ## To generate a random set of constrained edges, we get a random small triangulation, \n    ## and we just take the edges from that triangulation.\n    points = f(nverts1)\n    tri = triangulate(points)\n    edges = Set{NTuple{2,Int}}()\n    all_edges = collect(each_solid_edge(tri))\n    iter = 0\n    while length(edges) < nedges && iter < 10000\n        S = DT.random_edge(all_edges)\n        push!(edges, S)\n        iter += 1\n    end\n    ## Now get the rest of the points \n    while length(points) < nverts2\n        push!(points, CustomPoint(rand(), rand()))\n    end\n    return points, edges\nend\nfunction simulate_cdt(ne::AbstractVector{Int}, nsims; f=generate_random_points)\n    sim_results = Vector{Tuple{Vector{AlgorithmStats},AlgorithmStatsSummary}}(undef, length(ne))\n    Base.Threads.@threads :static for i in eachindex(ne)\n        points, edges = get_random_vertices_and_constrained_edges(500, 2000, ne[i], f)\n        sim_results[i] = simulate(ne[i], nsims; f=points, edges)\n    end\n    return first.(sim_results), last.(sim_results)\nend","category":"page"},{"location":"interface/counting/#The-Analysis","page":"Application: Counting Function Calls","title":"The Analysis","text":"","category":"section"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Now let's do the actual analysis and show the actual figures. For this analysis, we compare the results when using randomly distributed points, and when using point sets with many collinearities. It would be interesting to revisit these results when we later have methods for spatial sorting (#34).","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"First, let's look at the unconstrained triangulations.","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"npts = [ceil(Int, 10^x) for x in LinRange(1, 4, 250)] |> unique\nnsims = 10\nsimulation_results_random, simulation_summaries_random = simulate(npts, nsims; f=generate_random_points)\nsimulation_results_structured, simulation_summaries_structured = simulate(npts, nsims; f=generate_structured_points)\n\nfig_random = plot_fnc(npts, simulation_results_random, simulation_summaries_random)\nfig_structured = plot_fnc(npts, simulation_results_structured, simulation_summaries_structured)","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"<figure>\n    <img src='../figs/random.png', alt='Counting random unconstrained triangulation function calls'><br>\n</figure>","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"<figure>\n    <img src='../figs/structured.png', alt='Counting structured unconstrained triangulation function calls'><br>\n</figure>","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Of course, parallelorder_predicate is not called at any time as it is only used for computing constrained triangulations. We see that the number of orient_predicate calls grows exponentially with the number of points (note the log scales in (a)). The number of incircle_calls appears linear in n, as do the number of added and deleted triangles (which is probably clear from Euler's formula). Moreover, we see that there are no sameside_calls for the random point sets, but when we introduce many collinearities we have to spend a lot of time calling sameside_calls to resolve collinearities in the point location steps. The number of meet_calls is pretty similar between the two point set types, although we use call it more often in the structured case. (meet_predicate is used when classifying the type of an intersection when we start the point location step at a point on the boundary, allowing us to distinguish correctly between the exterior and the interior of the domain, and also between the boundary of the domain itself in the structured case.)","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Next, here are the results for the constrained triangulations, keeping the number of points fixed at 2000 and varying the number of edges (no boundary nodes).","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"ne = [ceil(Int, 10^x) for x in LinRange(0.3, 3, 270)] |> unique\nsimulation_results_random_cdt, simulation_summaries_random_cdt = simulate_cdt(ne, nsims; f=generate_random_points)\nsimulation_results_structured_cdt, simulation_summaries_structured_cdt = simulate_cdt(ne, nsims; f=generate_structured_points)\n\nfig_random_cdt = plot_fnc(ne, simulation_results_random_cdt, simulation_summaries_random_cdt)\nfig_structured_cdt = plot_fnc(ne, simulation_results_structured_cdt, simulation_summaries_structured_cdt)","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"<figure>\n    <img src='../figs/random_cdt.png', alt='Counting random constrained triangulation function calls'><br>\n</figure>","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"<figure>\n    <img src='../figs/structured_cdt.png', alt='Counting structured constrained triangulation function calls'><br>\n</figure>","category":"page"},{"location":"interface/counting/","page":"Application: Counting Function Calls","title":"Application: Counting Function Calls","text":"Remember that, in these plots, n is the number of edges. The results are pretty similar in this case. The number of orient calls is now linear in the number of constrained edges, despite it being exponential in the number of points. The other new result is parallelorder is called very few times, also being roughly linear in n.","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"triangulations/convex/#Convex-Polygons","page":"Convex Polygons","title":"Convex Polygons","text":"","category":"section"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"We have an algorithm available for computing the Delaunay triangulation of a convex polygon:","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"triangulate_convex ","category":"page"},{"location":"triangulations/convex/#DelaunayTriangulation.triangulate_convex","page":"Convex Polygons","title":"DelaunayTriangulation.triangulate_convex","text":"triangulate_convex(points, S;\n    IntegerType::Type{I}=Int,\n    EdgeType::Type{E}=NTuple{2,IntegerType},\n    TriangleType::Type{V}=NTuple{3,IntegerType},\n    EdgesType::Type{Es}=Set{EdgeType},\n    TrianglesType::Type{Ts}=Set{TriangleType},\n    rng::AbstractRNG=Random.default_rng(),\n    add_ghost_triangles=false,\n    add_convex_hull=false,\n    compute_centers=false,\n    delete_empty_features=false) where {I,E,V,Es,Ts}\n\nGiven some points and a counter-clockwise list of indices S for points in points  that define a convex polygon, triangulates it with Chew's algorithm.\n\nArguments\n\npoints::P: The set of points.\nS: A counter-clockwise list of vertices defining a convex polygon from the corresponding points in points.\n\nKeyword Arguments\n\nIntegerType::Type{I}=Int: The integer type to use for indexing. \nEdgeType::Type{E}=NTuple{2,IntegerType}: The type to use for representing edges. \nTriangleType::Type{V}=NTuple{3,IntegerType}: The type to use for representing triangles. \nEdgesType::Type{Es}=Set{EdgeType}: The type to use for representing collections of edges. \nTrianglesType::Type{Ts}=Set{TriangleType}: The type to use for representing collections of triangles. \nrepresentative_point_list = get_empty_representative_points(IntegerType, number_type(points)): The representative point list to use.    \nrng::AbstractRNG=Random.default_rng(): The RNG to use.\nadd_ghost_triangles=true: Whether to add the ghost triangles at the end of the triangulation. \nadd_convex_hull=true: Whether to populate the convex hull field of tri with S at the end of the triangulation.\ncompute_centers=true: Whether to recompute the RepresentativePointList at the end of the triangulation.\ndelete_empty_features=true: Whether to delete any empty neighbourhoods and adjacencies at the end of the triangulation. \n\nOutputs\n\nReturns a Triangulation of the convex polygon.\n\n\n\n\n\n","category":"function"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"The function takes as input some set of points mathcal P and a corresponding sequence of indices v_1 ldots v_n, in counter-clockwise order, defining some convex polygon and returns the polygon's Delaunay triangulation. Note that the keyword arguments here differ from triangulate. Here is an example of triangulate_convex in action.","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"using DelaunayTriangulation \nusing CairoMakie\np1 = [10.0, 12.0]\np2 = [7.0, 11.0]\np3 = [8.0, 6.0]\np4 = [10.0, 3.0]\np5 = [14.0, 5.0]\np6 = [15.0, 10.0]\np7 = [13.0, 12.0]\npts = [p1, p2, p3, p4, p5, p6, p7]\nS = collect(1:7)\ntri = triangulate_convex(pts, S)\nfig, ax, sc = triplot(tri; plot_convex_hull=false)","category":"page"},{"location":"triangulations/convex/","page":"Convex Polygons","title":"Convex Polygons","text":"<figure>\n    <img src='../figs/convex_triangulation_example.png', alt='Triangulation'><br>\n</figure>","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/convex_hull/#Convex-Hull","page":"Convex Hull","title":"Convex Hull","text":"","category":"section"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"We represent convex hulls using a ConvexHull type, which is simply a type containing points and indices:","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"ConvexHull","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.ConvexHull","page":"Convex Hull","title":"DelaunayTriangulation.ConvexHull","text":"ConvexHull{P,I}\n\nStruct storing the results for a convex hull.\n\nFields\n\npoints::P\n\nThe complete set of points.\n\nindices::I\n\nIndices of points in points corresponding to the convex hull, in counter-clockwise order,  and indices[begin] == indices[end].\n\n\n\n\n\n","category":"type"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"For a triangulation, convex hulls are obtained from the unconstrained form, but if they need to be reconstructed then we can do so with the monotone chain algorithm.","category":"page"},{"location":"data_structures/convex_hull/","page":"Convex Hull","title":"Convex Hull","text":"convex_hull(::Any)","category":"page"},{"location":"data_structures/convex_hull/#DelaunayTriangulation.convex_hull-Tuple{Any}","page":"Convex Hull","title":"DelaunayTriangulation.convex_hull","text":"convex_hull(points; IntegerType::Type{I}=Int) where {I}\n\nComputes the convex hull of points using Graham's scan. Returns a ConvexHull object.\n\nNote that if there are a trio of points on the convex hull that are collinear, they will  all be included, instead of only taking the endpoints of the collinear points.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/graph/#Graph","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"To make it possible to iterate over all points that share an edge with a given vertex, we have a Graph struct that we define as follows:","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"struct Graph{I}\n    graph::UndirectedGraph{I}\n    function Graph{I}() where {I}\n        G = UndirectedGraph{I}()\n        return new{I}(G)\n    end\n    Graph() = Graph{Int}()\n    Graph(G::UndirectedGraph{I}) where {I} = new{I}(G)\nend","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Note that this graph is undirected. ","category":"page"},{"location":"data_structures/graph/","page":"Graph","title":"Graph","text":"Graph \nget_graph(::Graph)\nget_edges(::Graph)\nget_vertices(::Graph)\neach_vertex(::Graph)\nget_neighbours(::Graph)\nget_neighbours(::Graph, ::Any)\nnum_neighbours(::Graph, ::Any)\nnum_edges(::Graph)\nnum_vertices(::Graph)\nadd_vertex!(::Graph{I}, ::Vararg{I,N}) where {I,N}\nadd_neighbour!(::Graph{I}, ::I, ::I) where {I}\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\nadd_triangle!(::Graph, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,V<:Integer,Ts<:Graph{I}}\ndelete_triangle!(::Graph, ::Any)\ndelete_neighbour!(::Graph, ::Any, ::Any)\ndelete_vertex!(::Graph, ::Any)\ndelete_boundary_vertices_from_graph!(::Graph{I}) where {I}\nclear_empty_points!(::Graph)","category":"page"},{"location":"data_structures/graph/#DelaunayTriangulation.Graph","page":"Graph","title":"DelaunayTriangulation.Graph","text":"Graph{I}\n\nStruct for storing neighbourhood relationships that map vertices  to all other vertices that share an edge with that vertex.  The type I is the integer type.\n\nSee the docs for a description of how boundary edges  are handled.\n\nFields\n\ngraph::UndirectedGraph{I}\n\nThe UndirectedGraph that maps a vertex u to a list of edges, V, such that (u, v) is an edge of the triangulation for each  v in V. \n\nExtended help\n\nYou should not work with the graph field directly. We provide  the following functions for working with Graph, where G denotes  a Graph{I} type. (Type information in the function signatures  is omitted.)\n\nAccessors\n\nget_graph(G)\nget_vertices(G)\neach_vertex(G)\nget_edges(G)\nget_neighbours(G)\nget_neighbours(G, u)\n\nMutators\n\nadd_vertex!(G, u...)\nadd_neighbour!(G, u, v...)\nadd_triangle!(G, i, j, k) or add_triangle!(G, T)\nadd_triangle!(G, T...)\ndelete_triangle!(G, i, j, k) or delete_triangle!(G, T)\ndelete_triangle!(G, T...)\ndelete_neighbour!(G, u, v...)\ndelete_vertex!(G, u...)\ndelete_boundary_vertices_from_graph!(G)\nclear_empty_points!(G)\n\nMiscellaneous\n\nnum_edges(G)\nnum_neighbours(G, u)\nnum_vertices(G)\nhas_vertex(G, u)\nhas_boundary_vertices(G)\n\n\n\n\n\n","category":"type"},{"location":"data_structures/graph/#DelaunayTriangulation.get_graph-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_graph","text":"get_graph(G::Graph)\n\nReturns the field graph of G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_edges","text":"get_edges(G::Graph)\n\nReturns all the edges of the graph G. Edges  are unordered.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(G::Graph)\n\nGiven a graph, returns the current set of vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.each_vertex-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(G::Graph)\n\nGiven a graph, returns the current set of vertices.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph)\n\nReturns the set of neighbourhoods of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.get_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(G::Graph, u)\n\nReturns the neighbourhood of the points u of  the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_neighbours-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(G::Graph, u)\n\nReturns the number of neighbours of the point u  of the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.num_edges","text":"num_edges(G::Graph)\n\nReturns the number of edges G. The edges  (i, j) and (j, i) will only be counted once.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.num_vertices-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(G::Graph)\n\nReturns the number of vertices in the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_vertex!-Union{Tuple{N}, Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, Vararg{I, N}}} where {I, N}","page":"Graph","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., adds these  vertices into G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_neighbour!-Union{Tuple{I}, Tuple{DelaunayTriangulation.Graph{I}, I, I}} where I","page":"Graph","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(G::Graph, u, v...)\n\nGiven a graph G, adds v... into the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, adds the triangle (i, j, k) into G. In particular, the  indices (i, j, k) are added into G, and the indices are all in each other's  neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(G::Graph, T...)\n\nAdds the triangles T... into the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, V<:Integer, Ts<:DelaunayTriangulation.Graph{I}}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, i, j, k)\n\nGiven a graph G, deletes the triangle (i, j, k) deletes G. In particular, the  indices (i, j, k) will no longer be neighbours of each other.\n\nnote: Note\nBe careful with using this function - you could have a triangle (j, i, ℓ), say,  which will also be affected since the graph is undirected. Note also  that the vertices (i, j, k) will not be removed - only the neighbourhoods  are affected.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(G::Graph, T...)\n\nDeletes the triangles T... from the graph G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_neighbour!-Tuple{DelaunayTriangulation.Graph, Any, Any}","page":"Graph","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(G::Graph, u, v...)\n\nGiven a graph G and a vertex u, deletes the vertices v... from the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_vertex!-Tuple{DelaunayTriangulation.Graph, Any}","page":"Graph","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(G::Graph, u...)\n\nGiven a graph G and vertices u..., deletes the vertices from G.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Union{Tuple{DelaunayTriangulation.Graph{I}}, Tuple{I}} where I","page":"Graph","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(G::Graph{I}) where {I}\n\nGiven a graph G, deletes all the boundary indices from G, i.e.  all u such that u ≤ -1.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/graph/#DelaunayTriangulation.clear_empty_points!-Tuple{DelaunayTriangulation.Graph}","page":"Graph","title":"DelaunayTriangulation.clear_empty_points!","text":"clear_empty_points!(G::Graph)\n\nGiven a graph, deletes any points that have empty neighbourhoods.\n\n\n\n\n\n","category":"method"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"predicates/#Predicates","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The predicates that we use in this package are all built from ExactPredicates.jl, avoiding degeneracies from predicates owing to floating point arithmetic. The results from predicates are based on certificates, coming from a Certificate type defined with EnumX.jl. The definition of this is below.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Certificate","category":"page"},{"location":"predicates/#DelaunayTriangulation.Certificate","page":"Predicates","title":"DelaunayTriangulation.Certificate","text":"Certificate\n\nAn Enum type that represents results from a geometric predicate. Below we provide a list of available certificates,  along with the function that can be used for testing if a given Certificate matches that certificate.\n\nInside: is_inside\nDegenerate: is_degenerate\nOutside: is_outside\nOn: is_on\nLeft: is_left\nRight: is_right\nPositivelyOriented: is_positively_oriented\nNegativelyOriented: is_negatively_oriented\nCollinear: is_collinear\nNone: is_none or has_no_intersections\nSingle: is_single or has_one_intersection\nMultiple: is_multiple or has_multiple_intersections\nTouching: is_touching\nLegal: is_legal\nIllegal: is_illegal\nCloser: is_closer\nFurther: is_further\nEquidistant: is_equidistant\nObtuse: is_obtuse\nAcute: is_acute\nRight: is_right\nSuccessfulInsertion: is_successful_insertion\nFailedInsertion: is_failed_insertion\nPrecisionFailure: is_precision_failure\nEncroachmentFailure: is_encroachment_failure\n\n\n\n\n\n","category":"module"},{"location":"predicates/#General","page":"Predicates","title":"General","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some general predicates. The core ones that all other predicates are based on are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"orient_predicate\nincircle_predicate \nparallelorder_predicate","category":"page"},{"location":"predicates/#DelaunayTriangulation.orient_predicate","page":"Predicates","title":"DelaunayTriangulation.orient_predicate","text":"orient_predicate(p, q, r)\n\nReturns ExactPredicates.orient(p, q, r), in particular we return:\n\n1: (p, q, r) is positively oriented.\n0: (p, q, r) is collinear / degenerate. \n-1: (p, q, r) is negatively oriented.\n\nnote: Note\nThe orient predicate is defined by the determinant textorient(p q r) = textsgn det beginvmatrix p_x  p_y  1  q_x  q_y  1  r_x  r_y  1 endvmatrix = textsgn det beginvmatrix p_x-r_x  p_y-r_y  q_x-r_x  q_y-r_y endvmatrix\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.incircle_predicate","page":"Predicates","title":"DelaunayTriangulation.incircle_predicate","text":"incircle_predicate(a, b, c, p)\n\nReturns ExactPredicates.incircle(a, b, c, p), in particular we return: \n\n1: If p is inside the circle defined by (a, b, c).\n0: If p is on the circle defined by (a, b, c).\n-1: If p is outside the circle defined by (a, b, c).\n\nnote: Note\nThe incircle predicate is defined by the determinant textincircle(a b c d) = textsgn det beginvmatrix a_x  a_y  a_x^2 + a_y^2  1  b_x  b_y  b_x62 + b_y^2  1  c_x  c_y  c_x^2 + c_y^2  1  d_x  d_y  d_x^2 + d_y^2  1 endvmatrix = textsgn det beginvmatrix a_x - d_x  a_y - d_y  (a_x - d_x)^2 + (a_y - d_y)^2  b_x - d_x  b_y - d_y  (b_x - d_x)^2 + (b_y - d_y)^2  c_x - d_x  c_y - d_y  (c_x - d_x)^2 + (c_y - d_y)^2 endvmatrix\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.parallelorder_predicate","page":"Predicates","title":"DelaunayTriangulation.parallelorder_predicate","text":"parallelorder_predicate(a, b, p, q)\n\nReturns ExactPredicates.parallelorder(a, b, p, q), in particular we return:\n\n1: q is closer to the line (a, b) than p.\n0: p and q are equidistant from the line (a, b).\n-1: p is closer to the line (a, b) than q.\n\nnote: Note\nThe parallelorder predicate is the same as orient_predicate(b-a, q-p, 0).\n\n\n\n\n\n","category":"function"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"In code, these predicates could be defined by (the actual definition with ExactPredicates.jl is much more involved):","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"_det(a, b, c, d) = a * d - b * c\n_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion \nfunction orient_predicate(a, b, c)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    o = _det(ax - cx, ay - cy, bx - cx, by - cy)\n    return Int(sign(o)) # need Int for xor\nend\nfunction incircle_predicate(a, b, c, d)\n    ax, ay = getxy(a)\n    bx, by = getxy(b)\n    cx, cy = getxy(c)\n    dx, dy = getxy(d)\n    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,\n        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,\n        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)\n    return Int(sign(o)) # need Int for xor\nend\nfunction parallelorder_predicate(a, b, p, q)\n    return orient_predicate(b .- a, q .- p, (0.0, 0.0))\nend","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"You could use this as a reference if you want to disconnect from using ExactPredicates.jl (or e.g. use the predicates also defined in GeometricalPredicates.jl). This could be useful if you are not too worried about robustness (although you should typically care about this, so be careful - proceed at your own peril) and just want fast code.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"The other predicates are:","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"sameside_predicate\nopposite_signs\nmeet_predicate \ntriangle_orientation(::Any, ::Any, ::Any)\npoint_position_relative_to_circle(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Any, ::Any, ::Any)\npoint_closest_to_line(::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Any, ::Any, ::Any)\nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_oriented_outer_halfplane(::Any, ::Any, ::Any)\nis_legal(::Any, ::Any, ::Any, ::Any)\ntriangle_line_segment_intersection(::Any, ::Any, ::Any, ::Any, ::Any)","category":"page"},{"location":"predicates/#DelaunayTriangulation.sameside_predicate","page":"Predicates","title":"DelaunayTriangulation.sameside_predicate","text":"sameside_predicate(a, b, p)\n\nReturns ExactPredicates.sameside(p, a, b) (but we redefine it here).\n\nnote: Note\nThe difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.opposite_signs","page":"Predicates","title":"DelaunayTriangulation.opposite_signs","text":"opposite_signs(x,y)\n\nFrom ExactPredicates.jl, returns true if x and y have opposite signs, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.meet_predicate","page":"Predicates","title":"DelaunayTriangulation.meet_predicate","text":"meet_predicate(p, q, a, b)\n\nReturns ExactPredicates.meet(p, q, a, b)  (but we redefine it here).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(p, q, r)\n\nGiven a triangle with coordinates (p, q, r), computes its orientation, returning:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circle","text":"point_position_relative_to_circle(a, b, c, p)\n\nGiven a circle through the coordinates (a, b, c), assumed to be positively oriented,  computes the position of p relative to the circle. In particular, returns:\n\nCertificate.Inside: p is inside the circle.\nCertificate.On: p is on the circle. \nCertificate.Outside: p is outside the triangle.\n\nSee also incircle_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(a, b, p)\n\nGiven a point p and the oriented line (a, b), computes the position  of p relative to the line, returning:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line. \n\nSee also orient_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_closest_to_line-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(a, b, p, q)\n\nGiven a line ℓ through a and b, tests if p is closer to ℓ than q is, returning:\n\nCertificate.Closer: p is closer to ℓ.\nCertificate:Further: q is closer to ℓ.\nCertificate.Equidistant: p and q are the same distance from ℓ.\n\nIt is assumed that p and q are to the left of ℓ.\n\nnote: Note\nNote that this function is same as computing numerical values for o₁ = orient(a, p, b) and o₂ = orient(a, q, b) (the determinants, not the signs) and seeing if o₁ < o₂. If indeed o₁ < o₂, then p is closer to ℓ then q. We cannot obtain values for  o₁ and o₂ such that the difference o₁ - o₂ is reliable, but notice that, letting  ∧ denote the exterior product, o₁ = (a - b) ∧ (p - b) and o₂ = (a - b) ∧ (q - b). Thus, o₁ - o₂ = (a - b) ∧ (p - q) = orient(b - a, p - q, 0). These differences b - a and p - q cannot be computed reliably, but we can use the relationship between orient  and parallelorder_predicate to write  orient(b - a, p - q, 0) = parallelorder(a, b, q, p). Thus, o₁ < o₂ if parallelorder(a, b, q, p) == -1.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(a, b, p)\n\nGiven a point p and the line segment (a, b), assuming p  to be collinear with a and b, computes the position of p relative to the line segment. In particular, returns:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\nSee also sameside_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(p, q, a, b)\n\nGiven the coordinates (p, q) and (a, b) defining two line segments,  tests the number of intersections between the two segments. In particular,  we return:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point. \nCertificate.Touching: One of the endpoints is on [a, b], but there are no other intersections.\n\nSee also meet_predicate.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(a, b, c, p)\n\nGiven a positively oriented triangle with coordinates (a, b, c), computes the  position of p relative to the triangle. In particular, returns: \n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane","text":"point_position_relative_to_oriented_outer_halfplane(a, b, p)\n\nGiven an edge with coordinates (a, b) and a point p,  tests the position of p relative to the oriented outer halfplane defined  by (a, b). The returned values are:\n\nCert.Outside: p is outside of the oriented outer halfplane, meaning to the right of the line (a, b) or collinear with a and b but not on the line segment (a, b).\nCert.On: p is on the line segment [a, b].\nCert.Inside: p is inside of the oriented outer halfplane, meaning to the left of the line (a, b).\n\nnote: Note\nThe oriented outer halfplane is the union of the open halfplane defined by the region to the left of the oriented line (a, b), and the open line segment (a, b). \n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_legal-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_legal","text":"is_legal(p, q, r, s)\n\nGiven an edge pq, incident to two triangles pqr and qps, tests  if the edge pq is legal, i.e. if s is not inside the triangle through  p, q, and r.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(p, q, r, a, b)\n\nGiven a triangle (p, q, r) and a line segment (a, b), tests if (a, b) intersects the triangle's interior. Returns:\n\nCert.Inside: (a, b) is entirely inside (p, q, r).\nCert.Single: (a, b) has one endpoint inside (p, q, r), and the other is outside.\nCert.Outside: (a, b) is entirely outside (p, q, r).\nCert.Touching: (a, b) is on (p, q, r)'s boundary, but not in its interior.\nCert.Multiple: (a, b) passes entirely through (p, q, r). This includes the case where a point is on the boundary of (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Boundaries-and-Ghosts","page":"Predicates","title":"Boundaries and Ghosts","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list some predicates for working with boundaries and ghost triangles. ","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"is_boundary_index \nis_boundary_edge(::Any, ::Adjacent)\nis_boundary_triangle(::Any, ::Any, ::Any, ::Any)\nis_ghost_edge\nis_ghost_triangle \nis_interior_curve \nis_outer_boundary_index(::Any, ::Any)\nis_outer_ghost_triangle(::Any, ::Any, ::Any, ::Any)\nis_outer_ghost_edge(::Any, ::Any, ::Any)\nis_outer_boundary_node(::Any, ::Graph{I}, ::Any) where {I}\nis_boundary_node(::Any, ::Graph{I}, ::Any) where {I}\nedge_exists(::I) where {I}\nedge_exists(::Any, ::Adjacent{I, E}) where {I, E}\nhas_ghost_triangles(::Adjacent{I, E}, ::Any) where {I, E}","category":"page"},{"location":"predicates/#DelaunayTriangulation.is_boundary_index","page":"Predicates","title":"DelaunayTriangulation.is_boundary_index","text":"is_boundary_index(i::I) where {I}\n\nGiven an index i, returns i ≤ I(BoundaryIndex). \n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(ij, adj::Adjacent)\nis_boundary_edge(i, j, adj::Adjacent{I,E}) where {I,E}\n\nTests if the edge (i, j) is a boundary edge, meaning get_adjacent(adj, i, j)  is a boundary index.\n\nnote: Note\nThe orientation of (i, j) is important: even if (i, j) is an edge  on the boundary, if there is a triangle (i, j, k) in the triangulation then (i, j) is not a boundary edge but (j, i) would be.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(i, j, k, adj)\nis_boundary_triangle(T, adj)\n\nGiven a triangle T = (i, j, k) and an adjacent map adj, returns true if T is a boundary triangle. \n\nnote: Note\nA boundary triangle is still part of the triangulation, but it has at least one edge that forms part of the boundary (so that at least one of the edges (u, v) satisfies  is_boundary_edge(v, u, adj)). This is similar to, but not the same as, a ghost triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_ghost_edge","page":"Predicates","title":"DelaunayTriangulation.is_ghost_edge","text":"is_ghost_edge(i, j)\n\nGiven an edge (i, j), returns true if (i, j) is a ghost edge. \n\nnote: Note\nA ghost edge is an edge in which either is_boundary_index(i) or is_boundary_index(j) is true.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_ghost_triangle","page":"Predicates","title":"DelaunayTriangulation.is_ghost_triangle","text":"is_ghost_triangle(i, j, k)\nis_ghost_triangle(T)\n\nGiven a triangle T = (i, j, k), returns true if T is a  ghost triangle and false otherwise. \n\nnote: Note\nA ghost triangle is one in which any of the vertices (i, j, k) are a boundary index, as tested via is_boundary_index.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_interior_curve","page":"Predicates","title":"DelaunayTriangulation.is_interior_curve","text":"is_interior_curve(i)\nis_interior_curve(i, boundary_map)\n\nGiven an index i, tests if the curve is an interior curve, i.e. if i > 1. Alternatively,  if a boundary_map is provided from construct_boundary_map, i should be a boundary map so that is_interior_curve(j) is tested, where j = get_curve_index(boundary_map, i).\n\n\n\n\n\n","category":"function"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(i, boundary_map)\n\nGiven an index i and a boundary_map from construct_boundary_map, tests if the index is a boundary index referring to the outermost boundary.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_triangle-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_triangle","text":"is_outer_ghost_triangle(i, j, k, boundary_map)\n\nGiven a ghost triangle (i, j, k) and a boundary map boundary_map from construct_boundary_map, tests if the ghost triangle is on the outermost boundary (true) or on an interior boundary (false).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_ghost_edge-Tuple{Any, Any, Any}","page":"Predicates","title":"DelaunayTriangulation.is_outer_ghost_edge","text":"is_outer_ghost_edge(i, j, boundary_map)\n\nGiven a ghost edge (i, j) and a boundary map boundary_map from construct_boundary_map, tests if the ghost edge is attached to the outermost boundary (true) or on an interior boundary (false).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I","page":"Predicates","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}\n\nTests if i is a node appearing on the outermost boundary. \n\nArguments\n\ni: The node to test. \ngraph::Graph: The graph. \nboundary_index_ranges: A dictionary from construct_boundary_index_ranges.\n\nOutputs\n\nis_outer_boundary_node: A Boolean indicating whether i is a node on the outermost boundary.\n\nSee also is_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.is_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I","page":"Predicates","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}\n\nTests if i is a node appearing on the boundary. \n\nArguments\n\ni: The node to test. \ngraph::Graph: The graph. \nboundary_index_ranges: A dictionary from construct_boundary_index_ranges.\n\nOutputs\n\nis_boundary_node: A Boolean indicating whether i is a node on the boundary.\nboundary_index: The boundary index of the boundary to which i belongs. If there is no such boundary, boundary_index = I(DefaultAdjacentValue).\n\nSee also is_outer_boundary_node.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Tuple{I} where I","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(i::I) where {I}\n\nReturns i ≠ I(DefaultAdjacentValue).\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(i, j, adj::Adjacent{I,E}) where {I,E}\nedge_exists(ij, adj::Adjacent{I,E}) where {I,E}\n\nTests if the edge ij = (i, j) exists in the triangulation corresponding to the Adjacent map adj.\n\nSee also edge_exists(::I) where I.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}","page":"Predicates","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(adj::Adjacent{I,E}, adj2v) where {I,E}\n\nTests if the triangle represented by the Adjacent map adj and the Adjacent2Vertex map adj2v contains ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#Index-and-Ghost-Handling","page":"Predicates","title":"Index and Ghost Handling","text":"","category":"section"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"Below we list methods for working with predicates that are used when we provide indices for points rather than points directly.","category":"page"},{"location":"predicates/","page":"Predicates","title":"Predicates","text":"triangle_orientation(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_circumcircle(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)\npoint_closest_to_line(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Any, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Any, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::AbstractDict)\ntriangle_line_segment_intersection(::Any, ::Any, ::Any, ::Any, ::Any, ::Any)","category":"page"},{"location":"predicates/#DelaunayTriangulation.triangle_orientation-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(i, j, k, pts, representative_point_list, boundary_map)\ntriangle_orientation(T, pts, representative_point_list, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices corresponding to points in pts, computes the orientation of the triangle, using boundary_map from construct_boundary_map to map boundary indices to their corresponding points in representative_point_list. We return:\n\nCertificate.PositivelyOriented: The triangle is positively oriented.\nCertificate.Degenerate: The triangle is degenerate, meaning the coordinates are collinear. \nCertificate.NegativelyOriented: The triangle is negatively oriented.\n\nnote: Note\nA test is also made for the case that is_outer_ghost_triangle(T): If  T  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly. In case the boundary  index corresponds to an interior curve, this flip is not necessary.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{7, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(i, j, k, ℓ, pts, representative_point_list, boundary_map)\npoint_position_relative_to_circumcircle(T, ℓ, pts, representative_point_list, boundary_map)\n\nTests if the ℓth point of pts is inside the circumcircle of the triangle T = (i, j, k), using the boundary_map to map  boundary indices to their corresponding points in representative_point_list, returning:\n\nCertificate.Outside: pₗ is outside of the circumcircle.\nCertificate.On: pₗ is on the circumcircle.\nCertificate.Inside: pₗ is inside the circumcircle.\n\nnote: Note\nA test is also made for the case that is_ghost_triangle(T): When T is a ghost triangle, one of its indices is a boundary index, say i. Since this vertex  is treated as being out at infinity, the circumcircle degenerates into the line through the other two vertices and out to infinity in that direction.  Thus, we test that the ℓth point is inside this circumcircle by seeing if it is in the oriented outer halfplane defined by the other two vertices,  accomplished via point_position_relative_to_oriented_outer_halfplane.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_line-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(i, j, u, pts, representative_point_list, boundary_map)\n\nComputes the position of the uth point of pts relative to the line through the ith and jth points,  respectively, of pts. Boundary indices are mapped to their corresponding points in representative_point_list via  the boundary_map argument from construct_boundary_map. The returned values are:\n\nCertificate.Left: p is to the left of the line. \nCertificate.Collinear: p is on the line.\nCertificate.Right: p is to the right of the line,\n\nwhere p is the uth point of pts.\n\nnote: Note\nIf is_outer_ghost_edge(i, j, boundary_map), the orientation of the line is flipped as the point corresponding to the boundary index will be a centroid which swaps the orientation.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_closest_to_line-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(i, j, u, v, pts)\n\nLet a, b, p, q be the points corresponding to the indices i, j, u, v, respectively, in pts, and let ℓ be the oriented line through a and b. This function tests if p is closer to ℓ than q is, returning:\n\nCertificate.Closer: p is closer to ℓ.\nCertificate:Further: q is closer to ℓ.\nCertificate.Equidistant: p and q are the same distance from ℓ.\n\nnote: Note\nIt is assumed that p and q are to the left of ℓ.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}","page":"Predicates","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(i, j, u, pts)\n\nGiven indices i, j, and u corresponding to points a, b, and p in pts, respectively, computes the position  of p relative to the oriented line segment (a, b), assuming that the three points are collinear. The returned values are:\n\nCertificate.On: p is on the line segment, meaning between a and b.\nCertificate.Degenerate: Either p == a or p == b, i.e. p is one of the endpoints. \nCertificate.Left: p is off and to the left of the line segment.\nCertificate.Right: p is off and to the right of the line segment.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}","page":"Predicates","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(u, v, i, j, pts)\n\nLet u, v, i, and j be indices corresponding to points p, q, a, and b, respectively, in pts. This  function tests the number of intersections between the two line segments (p, q) and (a, b), returning:\n\nCertificate.None: The line segments do not meet at any points. \nCertificate.Multiple: The closed line segments [p, q] and [a, b] meet in one or several points. \nCertificate.Single: The open line segments (p, q) and (a, b) meet in a single point.\nCertificate.On: One of the endpoints is on [a, b], but there are no other intersections.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, Any, AbstractDict}","page":"Predicates","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(i, j, k, u, pts, representative_point_list, boundary_map)\npoint_position_relative_to_triangle(T, u, pts, representative_point_list, boundary_map)\n\nGiven a triangle T = (i, j, k), with indices referring to points in pts, computes the position of u, corresponding to a point p, relative to T, with  any boundary indices mapped to their corresponding representative points in representative_point_list  via the boundary_map argument from construct_boundary_map. The returned values are:\n\nCertificate.Outside: p is outside of the triangle. \nCertificate.On: p is on one of the edges. \nCertificate.Inside: p is inside the triangle.\n\n\n\n\n\n","category":"method"},{"location":"predicates/#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{6, Any}","page":"Predicates","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(i, j, k, u, v, pts)\n\nGiven a triangle (i, j, k) and a line segment (u, v), with indices corresponding to points in pts, tests if (u, v)  intersects the triangle's interior. Letting (p, q, r) be the coordinates  corresponding to the triangle's vertices, and (a, b) those for the edge's  vertices, returns:\n\nCert.Inside: (a, b) is entirely inside (p, q, r).\nCert.Single: (a, b) has one endpoint inside (p, q, r), and the other is outside.\nCert.Outside: (a, b) is entirely outside (p, q, r).\nCert.Touching: (a, b) is on (p, q, r)'s boundary, but not in its interior.\nCert.Multiple: (a, b) passes entirely through (p, q, r). This includes the case where a point is on the boundary of (p, q, r).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/statistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"We provide an interface for computing statistics of a triangulation using statistics. (If it is important to you, note that the methods used for computing these statistics do not use adaptive floating point arithmetic unfortunately.)","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"IndividualTriangleStatistics \nTriangulationStatistics","category":"page"},{"location":"data_structures/statistics/#DelaunayTriangulation.IndividualTriangleStatistics","page":"Statistics","title":"DelaunayTriangulation.IndividualTriangleStatistics","text":"IndividualTriangleStatistics{T}\n\nStatistics for a single triangle.\n\nFields\n\narea: The area of the triangle.\nlengths: The sorted lengths of the edges of the triangle.\ncircumcenter: The circumcenter of the triangle.\ncircumradius: The circumradius of the triangle.\nangles: The sorted angles of the triangle.\nradius_edge_ratio: The radius-edge ratio of the triangle.\nedge_midpoints: The midpoints of the edges of the triangle.\naspect_ratio: The aspect ratio of the triangle.\ninradius: The inradius of the triangle.\nperimeter: The perimeter of the triangle.\ncentroid: The centroid of the triangle.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/statistics/#DelaunayTriangulation.TriangulationStatistics","page":"Statistics","title":"DelaunayTriangulation.TriangulationStatistics","text":"TriangulationStatistics{T,V,I}\n\nStatistics for a triangulation.\n\nThe constructor for this is statistics(tri::Triangulation).\n\nFields\n\nnum_vertices: The number of vertices in the triangulation.\nnum_solid_vertices: The number of solid vertices in the triangulation.\nnum_ghost_vertices: The number of ghost vertices in the triangulation.\nnum_edges: The number of edges in the triangulation.\nnum_solid_edges: The number of solid edges in the triangulation.\nnum_ghost_edges: The number of ghost edges in the triangulation.\nnum_triangles: The number of triangles in the triangulation.\nnum_solid_triangles: The number of solid triangles in the triangulation.\nnum_ghost_triangles: The number of ghost triangles in the triangulation.\nnum_constrained_boundary_edges: The number of constrained boundary edges in the triangulation.\nnum_constrained_interior_edges: The number of constrained interior edges in the triangulation.\nnum_constrained_edges: The number of constrained edges in the triangulation.\nnum_convex_hull_points: The number of points on the convex hull of the triangulation.\nsmallest_angle: The smallest angle in the triangulation.\nlargest_angle: The largest angle in the triangulation.\nsmallest_area: The smallest area in the triangulation.\nlargest_area: The largest area in the triangulation.\nsmallest_radius_edge_ratio: The smallest radius-edge ratio in the triangulation.\nlargest_radius_edge_ratio: The largest radius-edge ratio in the triangulation.\ntotal_area: The total area of the triangulation.\nindividual_statistics: A dictionary mapping triangles to their individual statistics.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"For example:","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"p1 = (0.0, 0.0)\np2 = (1.0, 0.0)\np3 = (1.0, 1.0)\np4 = (0.0, 1.0)\npts = [p1, p2, p3, p4]\ntri = triangulate(pts)","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"julia> stats = statistics(tri)\nDelaunay Triangulation Statistics.\n   Triangulation area: 1.0\n   Number of vertices: 5\n   Number of solid vertices: 4\n   Number of ghost vertices: 1\n   Number of edges: 9\n   Number of solid edges: 5\n   Number of ghost edges: 4\n   Number of triangles: 2\n   Number of solid triangles: 2\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 4\n   Smallest angle: 45.0°\n   Largest angle: 90.0°\n   Smallest area: 0.5\n   Largest area: 0.5\n   Smallest radius-edge ratio: 0.7071067811865476\n   Largest radius-edge ratio: 0.7071067811865476","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"stats = refine!(tri, max_area = 1e-2) # refine! computes and returns stats = statistics(tri) post-refinement","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"julia> stats\nDelaunay Triangulation Statistics.\n   Triangulation area: 0.9999999999999999\n   Number of vertices: 98\n   Number of solid vertices: 97\n   Number of ghost vertices: 1\n   Number of edges: 288\n   Number of solid edges: 256\n   Number of ghost edges: 32\n   Number of triangles: 160\n   Number of solid triangles: 160\n   Number of ghost triangles: 0\n   Number of constrained boundary edges: 0\n   Number of constrained interior edges: 0\n   Number of constrained edges: 0\n   Number of convex hull points: 32\n   Smallest angle: 30.231153476251915°\n   Largest angle: 113.40705209438516°\n   Smallest area: 0.0038884849847605116\n   Largest area: 0.0098765990101033\n   Smallest radius-edge ratio: 0.5799214659156856\n   Largest radius-edge ratio: 0.9930687672569417","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"All the relevant docstrings for working with these structs are below.","category":"page"},{"location":"data_structures/statistics/","page":"Statistics","title":"Statistics","text":"get_all_stat\nnum_vertices(::TriangulationStatistics)\nnum_solid_vertices(::TriangulationStatistics)\nnum_ghost_vertices(::TriangulationStatistics)\nnum_edges(::TriangulationStatistics)\nnum_solid_edges(::TriangulationStatistics)\nnum_ghost_edges(::TriangulationStatistics)\nnum_triangles(::TriangulationStatistics)\nnum_solid_triangles(::TriangulationStatistics)\nnum_ghost_triangles(::TriangulationStatistics)\nnum_constrained_boundary_edges(::TriangulationStatistics)\nnum_constrained_interior_edges(::TriangulationStatistics)\nnum_constrained_edges(::TriangulationStatistics)\nnum_convex_hull_points(::TriangulationStatistics)\nget_smallest_angle(::TriangulationStatistics)\nget_largest_angle(::TriangulationStatistics)\nget_smallest_area(::TriangulationStatistics)\nget_largest_area(::TriangulationStatistics)\nget_smallest_radius_edge_ratio(::TriangulationStatistics)\nget_largest_radius_edge_ratio(::TriangulationStatistics)\nget_total_area(::TriangulationStatistics)\nget_individual_statistics(::TriangulationStatistics)\nget_minimum_angle(::TriangulationStatistics, ::Any)\nget_maximum_angle(::TriangulationStatistics, ::Any)\nget_median_angle(::TriangulationStatistics, ::Any)\nget_area(::TriangulationStatistics, ::Any)\nget_lengths(::TriangulationStatistics, ::Any)\nget_circumcenter(::TriangulationStatistics, ::Any)\nget_circumradius(::TriangulationStatistics, ::Any)\nget_angles(::TriangulationStatistics, ::Any)\nget_radius_edge_ratio(::TriangulationStatistics, ::Any)\nget_edge_midpoints(::TriangulationStatistics, ::Any)\nget_aspect_ratio(::TriangulationStatistics, ::Any)\nget_inradius(::TriangulationStatistics, ::Any)\nget_perimeter(::TriangulationStatistics, ::Any)\nget_centroid(::TriangulationStatistics, ::Any)","category":"page"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_all_stat","page":"Statistics","title":"DelaunayTriangulation.get_all_stat","text":"get_all_stat(stats::TriangulationStatistics, stat::Symbol)\n\nReturns all of the values of the statistic stat for all triangles in the triangulation statistics stats. The possible  values for stat come from IndividualTriangleStatistics, namely:\n\narea\nlengths\ncircumcenter\ncircumradius\nangles\nradius_edge_ratio\nedge_midpoints\naspect_ratio\ninradius\nperimeter\ncentroid\n\n\n\n\n\n","category":"function"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(stats::TriangulationStatistics)\n\nReturns the num_vertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_vertices-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_edges","text":"num_edges(stats::TriangulationStatistics)\n\nReturns the num_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(stats::TriangulationStatistics)\n\nReturns the numsolidedges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(stats::TriangulationStatistics)\n\nReturns the numghostedges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(stats::TriangulationStatistics)\n\nReturns the num_triangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_solid_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(stats::TriangulationStatistics)\n\nReturns the numsolidtriangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_ghost_triangles-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(stats::TriangulationStatistics)\n\nReturns the numghosttriangles field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_boundary_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_boundary_edges","text":"num_constrained_boundary_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainedboundary_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_interior_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_interior_edges","text":"num_constrained_interior_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainedinterior_edges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_constrained_edges-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_constrained_edges","text":"num_constrained_edges(stats::TriangulationStatistics)\n\nReturns the numconstrainededges field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.num_convex_hull_points-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.num_convex_hull_points","text":"num_convex_hull_points(stats::TriangulationStatistics)\n\nReturns the numconvexhull_points field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_angle-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_angle","text":"get_smallest_angle(stats::TriangulationStatistics)\n\nReturns the smallest_angle field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_angle-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_angle","text":"get_largest_angle(stats::TriangulationStatistics)\n\nReturns the largest_angle field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_area","text":"get_smallest_area(stats::TriangulationStatistics)\n\nReturns the smallest_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_area","text":"get_largest_area(stats::TriangulationStatistics)\n\nReturns the largest_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_smallest_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_smallest_radius_edge_ratio","text":"get_smallest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the smallestradiusedge_ratio field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_largest_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_largest_radius_edge_ratio","text":"get_largest_radius_edge_ratio(stats::TriangulationStatistics)\n\nReturns the largestradiusedge_ratio field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_total_area-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_total_area","text":"get_total_area(stats::TriangulationStatistics)\n\nReturns the total_area field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_individual_statistics-Tuple{DelaunayTriangulation.TriangulationStatistics}","page":"Statistics","title":"DelaunayTriangulation.get_individual_statistics","text":"get_individual_statistics(stats::TriangulationStatistics)\n\nReturns the individual_statistics field from the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_minimum_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_minimum_angle","text":"get_minimum_angle(stats::TriangulationStatistics, T)\n\nReturns the smallest angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_maximum_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_maximum_angle","text":"get_maximum_angle(stats::TriangulationStatistics, T)\n\nReturns the largest angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_median_angle-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_median_angle","text":"get_median_angle(stats::TriangulationStatistics, T)\n\nReturns the median angle in the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_area-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_area","text":"get_area(stats::TriangulationStatistics, T)\n\nReturns the area field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_lengths-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_lengths","text":"get_lengths(stats::TriangulationStatistics, T)\n\nReturns the lengths field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_circumcenter-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_circumcenter","text":"get_circumcenter(stats::TriangulationStatistics, T)\n\nReturns the circumcenter field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_circumradius-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_circumradius","text":"get_circumradius(stats::TriangulationStatistics, T)\n\nReturns the circumradius field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_angles-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_angles","text":"get_angles(stats::TriangulationStatistics, T)\n\nReturns the angles field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_radius_edge_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_radius_edge_ratio","text":"get_radius_edge_ratio(stats::TriangulationStatistics, T)\n\nReturns the radiusedgeratio field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_edge_midpoints-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_edge_midpoints","text":"get_edge_midpoints(stats::TriangulationStatistics, T)\n\nReturns the edge_midpoints field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_aspect_ratio-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_aspect_ratio","text":"get_aspect_ratio(stats::TriangulationStatistics, T)\n\nReturns the aspect_ratio field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_inradius-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_inradius","text":"get_inradius(stats::TriangulationStatistics, T)\n\nReturns the inradius field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_perimeter-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_perimeter","text":"get_perimeter(stats::TriangulationStatistics, T)\n\nReturns the perimeter field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/statistics/#DelaunayTriangulation.get_centroid-Tuple{DelaunayTriangulation.TriangulationStatistics, Any}","page":"Statistics","title":"DelaunayTriangulation.get_centroid","text":"get_centroid(stats::TriangulationStatistics, T)\n\nReturns the centroid field from the individual triangle statistics for the triangle T in the triangulation statistics stats.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"interface/triangles/#Individual-Triangles","page":"Triangles","title":"Individual Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"Triangles are assumed to be of the form (i, j, k), with positive orientation, but we allow for customisation in the way these indices are represented. The following methods are used for working with triangles. First, we list the methods that must be defined, and then methods that extend these former methods. ","category":"page"},{"location":"interface/triangles/#Necessary-Methods","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"construct_triangle \ngeti \ngetj \ngetk \ninteger_type ","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.construct_triangle","page":"Triangles","title":"DelaunayTriangulation.construct_triangle","text":"construct_triangle(::Type{T}, i, j, k) where {T}\n\nConstructs a triangle with indices (i, j, k) with the  type T. The following methods are currently defined:\n\nconstruct_triangle(::Type{NTuple{3, I}}, i, j, k) where {I} \nconstruct_triangle(::Type{A}, i, j, k) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.geti","page":"Triangles","title":"DelaunayTriangulation.geti","text":"geti(T::F) where {F}\n\nFrom a triangle T, extract the ith index, i.e. the first.  The following methods are currently defined: \n\ngeti(T::NTuple{3, I})\ngeti(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getj","page":"Triangles","title":"DelaunayTriangulation.getj","text":"getj(T::F) where {F}\n\nFrom a triangle T, extract the jth index, i.e. the second.  The following methods are currently defined: \n\ngetj(T::NTuple{3, I})\ngetj(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.getk","page":"Triangles","title":"DelaunayTriangulation.getk","text":"getk(T::F) where {F}\n\nFrom a triangle T, extract the kth index, i.e. the third.  The following methods are currently defined: \n\ngetk(T::NTuple{3, I})\ngetk(T::A) where {I,A<:AbstractVector{I}}\n\nYou can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.integer_type","page":"Triangles","title":"DelaunayTriangulation.integer_type","text":"integer_type(::Type{T}) where {T}\n\nReturns the integer type used for representnig a triangle with indices  (i, j, k) with the type T. The following methods are currently defined:\n\ninteger_type(::Type{NTuple{N, I}}) where {N, I} \ninteger_type(::Type{A}) where {I, A <: AbstractVector{I}}\n\nYou can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Generic-Methods","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"indices \ntriangle_edges\nrotate_triangle \nconstruct_positively_oriented_triangle(::Type{V}, ::Any, ::Any, ::Any, ::Any) where {V}\ncompare_triangles \nsort_triangle","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.indices","page":"Triangles","title":"DelaunayTriangulation.indices","text":"indices(T)\n\nReturns a tuple (i, j, k) containing the indices of the triangle T. The  indices are obtained using geti, getj, and getk.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_edges","page":"Triangles","title":"DelaunayTriangulation.triangle_edges","text":"triangle_edges(T)\ntriangle_edges(i, j, k)\n\nReturns an iterator over each edge of the triangle T. In particular,  returns ((geti(T), getj(T)), (getj(T), getk(T)), (getk(T), geti(T))). The latter method uses the indices directly.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.rotate_triangle","page":"Triangles","title":"DelaunayTriangulation.rotate_triangle","text":"rotate_triangle(T::V, i) where {V}\n\nGiven a triangle T, rotates the indices an amount i. In particular, if T = (i, j, k):\n\ni = 0: Returns (i, j, k).\ni = 1: Returns (j, k, i).\ni = 2: Returns (k, i, j).\nOtherwise, return rotate_triangle(T, i % 3).\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Vararg{Any, 4}}} where V","page":"Triangles","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(::Type{V}, i, j, k, points) where {V}\n\nGiven a triangle type V, indices (i, j, k) corresponding to points in points,  returns either construct_triangle(V, i, j, k) or construct_triangle(V, j, i, k), whichever is not negatively oriented.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangles","page":"Triangles","title":"DelaunayTriangulation.compare_triangles","text":"compare_triangles(T, V)\n\nTests if the triangle T is equal to the triangle V, with equality  defined on the indices. In particular, compare_triangles((i, j, k), (i, j, k)), compare_triangles((i, j, k), (j, k, i)), and compare_triangles((i, j, k), (k, i, j)) are all true.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangle","page":"Triangles","title":"DelaunayTriangulation.sort_triangle","text":"sort_triangle(T::V) where {V}\n\nGiven a triangle T = (i, j, k), sorts it so that the first index is the smallest, maintaining  the orientation of T.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#Collection-of-Triangles","page":"Triangles","title":"Collection of Triangles","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"A collection of triangles simply stores many triangles, and the collection itself must be mutable so that triangles can be added and deleted. The following methods are used for working with collections of triangles. First, we list the methods that must be defined, and then methods that extend these former methods.","category":"page"},{"location":"interface/triangles/#Necessary-Methods-2","page":"Triangles","title":"Necessary Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"initialise_triangles \ntriangle_type \nnum_triangles \nadd_to_triangles! \ndelete_from_triangles!\neach_triangle \nremove_duplicate_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.initialise_triangles","page":"Triangles","title":"DelaunayTriangulation.initialise_triangles","text":"initialise_triangles(::Type{S})\n\nFor a given type S for some collection (e.g. a AbstractSet), returns an empty instance of that collection. The only method defined is\n\ninitialise_triangles(::Type{S}) where {T, S <: AbstractSet{T}}\ninitialise_triangles(::Type{V}) where {T,V<:AbstractVector{T}}\n\nwhich returns a Set{T}(). You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.triangle_type","page":"Triangles","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(::Type{S}) where {S}\n\nFor a given type S representing a collection of triangles,  returns the type of triangle used inside S, e.g. NTuple{3, Int} if S = AbstractSet{NTuple{3, Int}}. The only methods defined are\n\ntriangle_type(::Type{S}) where {T, S <: AbstractSet{T}}\ntriangle_type(::Type{A}) where {T, A <: AbstractVector{E}}\n\nwhich returns T. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.num_triangles","page":"Triangles","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(T::S) where {S}\n\nGiven a collection of triangles T, returns the number of triangles  in T. The only method currently defined is \n\nnum_triangles(T::AbstractSet)\nnum_triangles(T::AbstractVector)\n\nwhich returns length(T). You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_to_triangles!","page":"Triangles","title":"DelaunayTriangulation.add_to_triangles!","text":"add_to_triangles!(T::S, V) where {S}\n\nGiven a collection of triangles T, pushes V into it. The only  methods currently defined are\n\nadd_to_triangles!(T::AbstractSet{F}, V::F) where {F}\nadd_to_triangles!(T::AbstractSet{F}, V) where {F}\n\nwhich simply call push!(T, V). The latter method reconstructs V  using [indices] and construct_triangle. You can extend this function   as you need. \n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.delete_from_triangles!","page":"Triangles","title":"DelaunayTriangulation.delete_from_triangles!","text":"delete_from_triangles!(V::S, T::F) where {S}\n\nGiven a collection of triangles V of type S, containing  triangles of type F, deletes the triangle T from V.  The only method currently defined is \n\ndelete_from_triangles!(V::AbstractSet{F}, T::F) where {F}.\n\nwhich just calls delete! on V. The function already assumes that T  is already in V, and that T doesn't need to be rotated at all.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.each_triangle","page":"Triangles","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(V::F) where {F}\n\nFor a given collection of triangles V, returns an iterator that  goes over each triangle in the collection. The methods currently  defined are \n\neach_triangle(V::AbstractSet)\neach_triangle(V::AbstractMatrix)\neach_triangle(V::AbstractVector)\n\nwith the first method simply returning V, the second returning  eachcol(V), and the third returning V. You can extend this function as you need.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.remove_duplicate_triangles","page":"Triangles","title":"DelaunayTriangulation.remove_duplicate_triangles","text":"remove_duplicate_triangles(T::Ts) where {Ts}\n\nRemoves duplicate triangles from T. This procedure also sorts the triangles  so that the first index of each triangle is the smallest. Orientations are  preserved.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"You must also provide definitions for Base.in and Base.sizehint! for your type. You need Base.unique! to use remove_duplicate_triangles, unless your collection is a Set. Note also that Triangulations also define each_solid_triangle and each_ghost_triangle.","category":"page"},{"location":"interface/triangles/#Generic-Methods-2","page":"Triangles","title":"Generic Methods","text":"","category":"section"},{"location":"interface/triangles/","page":"Triangles","title":"Triangles","text":"contains_triangle \nadd_triangle!(::Any, ::Vararg{F, N}) where {F, N}\nadd_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ndelete_triangle!(::Any, ::Vararg{F, N}) where {F, N}\ndelete_triangle!(::Ts, ::Integer, ::Integer, ::Integer) where {Ts}\ncompare_triangle_collections \nsort_triangles","category":"page"},{"location":"interface/triangles/#DelaunayTriangulation.contains_triangle","page":"Triangles","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(T::F, V::S) where {F, S}\n\nGiven a collection of triangles V of type S, containing triangles  of type F, checks if V includes the triangle T. In particular,  the returned value is \n\n(rotate_triangle(T, m), true)\n\nif V includes the triangle T, and m is the integer such that  rotate_triangle(T, m) is the form of T that V contains. If there  is no such m, the returned value is simply \n\n(T, false).\n\nTo use this function, your type needs to only have a definition for T ∈ V for  testing specific rotations of a triangle. This function then performs the checks  by checking T, then rotate_triangle(T, 1), then rotate_triangle(T, 2), and if none of those succeed just returns  (T, false). You can extend this function as you need. We also define\n\ncontains_triangle(i, j, k, V::Ts) where {Ts},\n\nand this method just calls the two-argument method after constructing  the triangle with construct_triangle.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T, V...)\n\nGiven a collection of triangles T, adds all the triangles V... into it.  To extend this method to other collections, see add_to_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, adds the triangle (i, j, k) into it.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(V, T...)\n\nGiven a collection of triangles V, deletes all the triangles T... from it.  Checks are made for rotated forms of T that V includes. For example, if  T = (i, j, k) but V contains (j, k, i), then (j, k, i) will be deleted. The function also checks to see if the triangle is in V at all prior to deleting it. To extend this method to other collections, see delete_from_triangles!.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts","page":"Triangles","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}\n\nGiven a collection of triangles T, deletes the triangle (i, j, k) from it.  Checks are made to see if T needs to be rotated, or if (i, j, k) is in T  at all.\n\n\n\n\n\n","category":"method"},{"location":"interface/triangles/#DelaunayTriangulation.compare_triangle_collections","page":"Triangles","title":"DelaunayTriangulation.compare_triangle_collections","text":"compare_triangle_collections(T, V)\n\nGiven two collections of triangles T and V, tests if they are equal, with  equality defined according to compare_triangles.\n\n\n\n\n\n","category":"function"},{"location":"interface/triangles/#DelaunayTriangulation.sort_triangles","page":"Triangles","title":"DelaunayTriangulation.sort_triangles","text":"sort_triangles(T::Ts) where {Ts}\n\nSorts the triangles in the collection T so that each triangle's first vertex  has the smallest value. The orientation of each triangle is preserved.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/triangulation/#Triangulation","page":"Triangulation","title":"Triangulation","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"The most important structure of the package is the Triangulation data structure. Its complete definition is given below, and then afterwards we give all the docstrings for methods that are useful for working with triangulations.","category":"page"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"Triangulation","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.Triangulation","page":"Triangulation","title":"DelaunayTriangulation.Triangulation","text":"Triangulation{P,Ts,I,E,Es,BN,BNM,B,BIR,BPL}\n\nStruct representing a Delaunay triangulation, as constructed via e.g. triangulate or generate_mesh.\n\nFields\n\npoints::P\n\nThe points used to construct the triangulation. Do note that this is  not necessarly the same as the set of points appearing in the triangulation, as could happen  e.g. if some points were deleted from the triangulation. If that is what you need,  then see each_vertex.\n\ntriangles::Ts\n\nThe triangles in the triangulation, all given with positive orientation. This field can include  ghost triangles. If you don't want ghost triangles, see each_solid_triangle.\n\nadjacent::Adjacent{I, E}\n\nThe Adjacent map.\n\nadjacent2vertex::Adjacent2Vertex{I,Es,E}\n\nThe Adjacent2Vertex map.\n\ngraph::Graph{I}\n\nThe Graph. \n\nboundary_nodes::BN\n\nThe boundary nodes in the triangulation that you provide, matching the specification given in the  documentation.\n\nboundary_edge_map::BNM\n\nThis is a Dict that maps all of the boundary edges to their position  in boundary_nodes. See also construct_boundary_edge_map.\n\nboundary_index_ranges::BIR\n\nThis is an OrderedDict that maps a boundary index to a range of all other boundary indices  that the corresponding boundary curve could correspond to. For example, for a curve with  four segments, there are four possible boundary indices that a segment could correspond to.  See also construct_boundary_index_ranges.\n\nconstrained_edges::Es\n\nThis is the set of extra edges added into the triangulation that you have provided. This will not include any of the other constrained edges from boundary_nodes.\n\nall_constrained_edges::Es\n\nThis is the set of all constrained edges appearing in the triangulation, essentially  given as the union of constrained_edges and boundary_nodes. This is different from  the constrained_edges field as it contains edges from both of these fields, e.g.  there might be an edge in constrained_edges that is not yet in the triangulation,  but it will definitely not appear in all_constrained_edges.\n\nconvex_hull::ConvexHull{P,Vector{I}}\n\nThe ConvexHull of points. See also convex_hull.\n\nrepresentative_point_list::RPL\n\nThe Dict of points giving representative points for each boundary curve, or for the  convex hull if boundary_nodes is empty. These representative points are used for interpreting  ghost vertices.\n\nConstructors\n\nThere are several ways to construct this struct directly, although in most cases  you should be using triangulate or generate_mesh.\n\nDefault Constructor\n\nThe default constructor is available, i.e. \n\nTriangulation(\n    points,\n    triangles,\n    adjacent,\n    adjacent2vertex,\n    graph,\n    boundary_nodes,\n    boundary_edge_map,\n    boundary_map,\n    boundary_index_ranges,\n    constrained_edges,\n    all_constrained_edges,\n    convex_hull,\n    representative_point_list\n)\n\nEmpty Triangulation\n\nAn empty triangulation can be initalised with the following method, \n\nTriangulation(points;\n    IntegerType=Int,\n    EdgeType=NTuple{2,IntegerType},\n    TriangleType=NTuple{3,IntegerType},\n    EdgesType=Set{EdgeType},\n    TrianglesType=Set{TriangleType},\n    boundary_nodes=IntegerType[],\n    constrained_edges=initialise_edges(EdgesType),\n    representative_point_list=get_empty_representative_points(IntegerType, number_type(points))\n)\n\nTriangulation From an Existing Mesh\n\nA method is available from constructing a mesh from an existing set of points,  triangles, and boundary nodes, mainly existing for the purpose of generate_mesh:\n\nTriangulation(points, triangles, boundary_nodes;\n    IntegerType=Int,\n    EdgeType=NTuple{2,IntegerType},\n    TriangleType=NTuple{3,IntegerType},\n    EdgesType=Set{EdgeType},\n    TrianglesType=Set{TriangleType},\n    add_ghost_triangles=false\n)\n\nwith add_ghost_triangles calling add_ghost_triangles! at the end of the constructor.\n\nWrapping a Triangulation with constrainededgepoints\n\nThis method is used in triangulate for wrapping a triangulation with a set of constraints:\n\nremake_triangulation_with_constraints(triangulation, edges, boundary_nodes)\n\nwhich returns (bn_map, bn_range, tri), where bn_map is the boundary_map that isn't yet added, bn_range is the boundary_index_range that isn't yet added either, and tri is the wrapped  triangulation that includes the constrained edges and the boundary_nodes. Note that  either edges or boundary_nodes can be nothing.\n\nThis can be used together with the method\n\nreplace_boundary_dict_information(triangulation, bn_map, bn_range)\n\nwhich returns a new triangulation with the boundary_map and boundary_index_range replaced, completing the wrapper.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"Each field has its own accessor: ","category":"page"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_points(::Triangulation) \nget_triangles(::Triangulation)\nget_adjacent(::Triangulation)\nget_adjacent2vertex(::Triangulation)\nget_graph(::Triangulation)\nget_boundary_nodes(::Triangulation)\nget_boundary_edge_map(::Triangulation)\nget_boundary_map(::Triangulation)\nget_boundary_index_ranges(::Triangulation)\nget_constrained_edges(::Triangulation)\nget_all_constrained_edges(::Triangulation)\nget_convex_hull(::Triangulation)\nget_representative_point_list(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_points","text":"get_points(tri::Triangulation)\n\nReturns the points field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_triangles","text":"get_triangles(tri::Triangulation)\n\nReturns the triangles field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri::Triangulation)\n\nReturns the adjacent field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation)\n\nReturns the adjacent2vertex field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_graph-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_graph","text":"get_graph(tri::Triangulation)\n\nReturns the graph field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(tri::Triangulation)\n\nReturns the boundary_nodes field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation)\n\nReturns the boundaryedgemap field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_map-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_map","text":"get_boundary_map(tri::Triangulation)\n\nReturns the boundary_map field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_index_ranges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_index_ranges","text":"get_boundary_index_ranges(tri::Triangulation)\n\nReturns the boundaryindexranges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_constrained_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_constrained_edges","text":"get_constrained_edges(tri::Triangulation)\n\nReturns the constrained_edges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_all_constrained_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_all_constrained_edges","text":"get_all_constrained_edges(tri::Triangulation)\n\nReturns the allconstrainededges field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull","text":"get_convex_hull(tri::Triangulation)\n\nReturns the convex_hull field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_representative_point_list-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_representative_point_list","text":"get_representative_point_list(tri::Triangulation)\n\nReturns the representativepointlist field from the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"There are several useful methods available for working with triangulations. We split these into several sections. ","category":"page"},{"location":"data_structures/triangulation/#Adjacent-Methods","page":"Triangulation","title":"Adjacent Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_adjacent(::Triangulation, ::Any)\nadd_adjacent!(::Triangulation, ::Any, ::Any)\ndelete_adjacent!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(tri, uv; check_existence=Val(has_multiple_segments(tri)))\nget_adjacent(tri, u, v; check_existence=Val(has_multiple_segments(tri)))\n\nReturns get_adjacent(tri, uv; check_existence) or get_adjacent(tri, u, v; check_existence).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(tri::Triangulation, uv, w)\nadd_adjacent!(tri::Triangulation, u, v, w)\n\nCalls add_adjacent!(get_adjacent(tri), uv, w) or add_adjacent!(get_adjacent(tri), u, v, w), adding the edge uv = (u, v) to the adjacent map of tri with corresponding vertex w.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(tri::Triangulation, uv)\ndelete_adjacent!(tri::Triangulation, u, v)\n\nCalls delete_adjacent!(get_adjacent(tri), uv) or delete_adjacent!(get_adjacent(tri), u, v), removing the edge uv = (u, v) from the adjacent map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Adjacent2Vertex-Methods","page":"Triangulation","title":"Adjacent2Vertex Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_adjacent2vertex(::Triangulation, ::Any)\nadd_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any, ::Any)\ndelete_adjacent2vertex!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_adjacent2vertex-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(tri::Triangulation, w)\n\nReturns get_adjacent2vertex(get_adjacent2vertex(tri), w), the edges (u, v) in tri  that are adjacent to w.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(tri::Triangulation, w, uv)\nadd_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nCalls add_adjacent2vertex!(get_adjacent2vertex(tri), w, uv) or add_adjacent2vertex!(get_adjacent2vertex(tri), w, u, v), pushing the edge uv = (u, v) into get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w, uv)\ndelete_adjacent2vertex!(tri::Triangulation, w, u, v)\n\nCalls delete_adjacent2vertex!(get_adjacent2vertex(tri), w, uv) or delete_adjacent2vertex!(get_adjacent2vertex(tri), w, u, v), deleting the edge uv = (u, v) from get_adjacent2vertex(tri, w).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(tri::Triangulation, w)\n\nCalls delete_adjacent2vertex!(get_adjacent2vertex(tri), w), deleting the vertex w from get_adjacent2vertex(tri).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Boundary-Nodes-Methods","page":"Triangulation","title":"Boundary Nodes Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"has_multiple_curves(::Triangulation)\nhas_multiple_segments(::Triangulation)\nnum_curves(::Triangulation)\nnum_segments(::Triangulation)\nget_boundary_nodes(::Triangulation, ::Any)\nmap_boundary_index(::Triangulation, ::Any)\nget_curve_index(::Triangulation, ::Any)\nget_segment_index(::Triangulation, ::Any)\nnum_outer_boundary_segments(::Triangulation)\nget_right_boundary_node(::Triangulation, ::Any, ::Any)\nget_left_boundary_node(::Triangulation, ::Any, ::Any)\nget_boundary_index_range(::Triangulation, ::Any)\nget_boundary_edge_map(::Triangulation, ::Any)\ninsert_boundary_node!(::Triangulation, ::Any, ::Any)\nsplit_boundary_edge!(::Triangulation, ::Any, ::Any)\nsplit_boundary_edge_at_collinear_segments!(::Triangulation, ::Any)\ncontains_boundary_edge(::Triangulation, ::Any)\nmerge_constrained_edges(::Any, ::Any, ::Es) where {Es}\nget_all_boundary_nodes(::Triangulation)\nall_boundary_indices(::Triangulation)\ndelete_boundary_node!(::Triangulation, ::Any)\nmerge_boundary_node!(::Triangulation, ::Any, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_curves","text":"has_multiple_curves(tri::Triangulation)\n\nReturns has_multiple_curves(get_boundary_nodes(tri)), testing if tri's boundary is  comprised of multiple curves.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_multiple_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_multiple_segments","text":"has_multiple_segments(tri::Triangulation)\n\nReturns has_multiple_segments(get_boundary_nodes(tri)), testing if tri's boundary is  comprised of multiple segments.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_curves-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_curves","text":"num_curves(tri::Triangulation)\n\nReturns num_curves(get_boundary_nodes(tri)), the number of curves in tri's boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_segments","text":"num_segments(tri::Triangulation)\n\nReturns num_segments(get_boundary_nodes(tri)), the number of segments in tri's boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_nodes-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_nodes","text":"get_boundary_nodes(bn, mnℓ...)\n\nGet the boundary nodes from bn corresponding to the specified indices.  See getboundarynodes.\n\n\n\n\n\nget_boundary_nodes(tri::Triangulation, mnℓ...)\n\nReturns get_boundary_nodes(get_boundary_nodes(tri), mnℓ...).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.map_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.map_boundary_index","text":"map_boundary_index(tri::Triangulation, i)\n\nReturns map_boundary_index(get_boundary_map(tri), i), mapping the boundary index i to the corresponding index in the boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_curve_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_curve_index","text":"get_curve_index(tri::Triangulation, i)\n\nReturns get_curve_index(get_boundary_map(tri), i), the curve corresponding to the boundary index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_segment_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_segment_index","text":"get_segment_index(tri::Triangulation, i)\n\nReturns get_segment_index(get_boundary_map(tri), i), the segment corresponding to the boundary  index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_outer_boundary_segments-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_outer_boundary_segments","text":"num_outer_boundary_segments(tri::Triangulation)\n\nReturns num_outer_boundary_segments(get_boundary_nodes(tri)), returns the number of boundary segments on the  outermost boundary.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_right_boundary_node","text":"get_right_boundary_node(tri::Triangulation, k, boundary_index)\n\nReturns get_right_boundary_node(get_adjacent(tri), k, boundary_index, get_boundary_index_ranges(tri), Val(has_multiple_segments(tri))),  the node to the right of the boundary node k. It is assumed that k is on the part of the boundary of tri with index boundary_index.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_left_boundary_node","text":"get_left_boundary_node(tri::Triangulation, k, boundary_index)\n\nReturns get_left_boundary_node(get_adjacent(tri), k, boundary_index, get_boundary_index_ranges(tri), Val(has_multiple_segments(tri))), the node to the left of the boundary node k. It is assumed that k is on the part of the boundary of tri with index boundary_index.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_index_range-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_index_range","text":"get_boundary_index_range(tri::Triangulation, i)\n\nReturns map_boundary_index(get_boundary_index_ranges(tri), i), the list of boundary indices belonging to the curve corresponding  to the boundary index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_boundary_edge_map-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_boundary_edge_map","text":"get_boundary_edge_map(tri::Triangulation, ij)\nget_boundary_edge_map(tri::Triangulation, i, j)\n\nReturns get_boundary_edge_map(get_boundary_nodes(tri), ij) or get_boundary_edge_map(get_boundary_nodes(tri), construct_edge(edge_type(tri), i, j)), returning a Tuple pos such that get_boundary_nodes(get_boundary_nodes(tri, pos[1]), pos[2]) is the edge ij = (i, j).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.insert_boundary_node!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.insert_boundary_node!","text":"insert_boundary_node!(tri::Triangulation, pos, node)\n\nCalls insert_boundary_node!(get_boundary_nodes(tri), pos, node), splitting the boundary node at pos at node.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_boundary_edge!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_boundary_edge!","text":"split_boundary_edge!(tri::Triangulation, edge, node)\nsplit_boundary_edge!(tri::Triangulation, i, j, node)\n\nGiven a triangulation tri, an edge = (i, j), and a node on edge, this function splits the boundary edge into two edges   edge = (i, node) and (node, j), updating tri.boundary_nodes and tri.boundary_edge_map accordingly.\n\nSee also split_boundary_edge_at_collinear_segments!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_boundary_edge_at_collinear_segments!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_boundary_edge_at_collinear_segments!","text":"split_boundary_edge_at_collinear_segments!(tri::Triangulation, collinear_segments)\n\nGiven a triangulation tri and a list of collinear segments collinear_segments, assumed to represent a  boundary edge (initial(first(collinear_segments)), terminal(last(collinear_segments))), splits  the edge at the collinear_segments and updates tri.boundary_nodes and tri.boundary_edge_map accordingly.\n\nSee also split_boundary_edge!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_boundary_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_boundary_edge","text":"contains_boundary_edge(tri::Triangulation, e)\ncontains_boundary_edge(tri::Triangulation, i, j)\n\nTests if the triangulation tri has the constrained boundary edge e = (i, j), returning e ∈ keys(get_boundary_edge_map(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.merge_constrained_edges-Union{Tuple{Es}, Tuple{Any, Any, Es}} where Es","page":"Triangulation","title":"DelaunayTriangulation.merge_constrained_edges","text":"merge_constrained_edges(bn_map, boundary_nodes, constrained_edges::Es)\nmerge_constrained_edges(tri::Triangulation, bn_map=get_boundary_map(tri))\n\nMerges the boundary edges, defined via boundary_nodes or get_boundary_nodes(tri), and the constrained_edges into a single collection. bn_map is used to iterate  over all the boundary edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_all_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_all_boundary_nodes","text":"get_all_boundary_nodes(tri::Triangulation)\n\nReturns a Set of all the boundary nodes in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.all_boundary_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.all_boundary_indices","text":"all_boundary_indices(tri::Triangulation)\n\nReturns all the boundary indices in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_boundary_node!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.delete_boundary_node!","text":"delete_boundary_node!(tri::Triangulation, pos)\n\nCalls delete_boundary_node!(get_boundary_nodes(tri), pos), deleting the boundary node at pos.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Convex-Hull-Methods","page":"Triangulation","title":"Convex Hull Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_convex_hull_indices(::Triangulation)\nconvex_hull!(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_convex_hull_indices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_convex_hull_indices","text":"get_convex_hull_indices(tri::Triangulation)\n\nCalls get_indices(get_convex_hull(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.convex_hull!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.convex_hull!","text":"convex_hull!(tri::Triangulation; reconstruct=is_constrained(tri))\n\nComputes the convex hull of the points included in the triangulation tri. If reconstruct,  then the method in convex_hull will be used, whereas if !reconstruct then the triangulation's  boundary is extracted to get the convex hull directly. Note that this latter method fails  if there are any constrained edges on the boundary of tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Edges-Methods","page":"Triangulation","title":"Edges Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"edge_type(::Triangulation{P,Ts,I,E}) where {P,Ts,I,E}\nnum_edges(::Triangulation)\neach_edge(::Triangulation)\neach_constrained_edge(::Triangulation)\ncontains_constrained_edge(::Triangulation, ::Any)\nnum_ghost_edges(::Triangulation)\nnum_solid_edges(::Triangulation)\neach_solid_edge\neach_ghost_edge \nsort_edge_by_degree(::Triangulation, ::Any)\nsplit_constrained_edge!(::Triangulation, ::Any, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_type-Union{Tuple{Triangulation{P, Ts, I, E}}, Tuple{E}, Tuple{I}, Tuple{Ts}, Tuple{P}} where {P, Ts, I, E}","page":"Triangulation","title":"DelaunayTriangulation.edge_type","text":"edge_type(tri::Triangulation)\n\nReturns the type used for representing edges in tri.\n\n\n\n\n\nedge_type(vor::VoronoiTessellation)\n\nReturns the type of the edges in the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_edges","text":"num_edges(tri::Triangulation)\n\nReturns num_edges(get_graph(tri)), the number of edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_edge-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_edge","text":"each_edge(tri::Triangulation)\n\nReturns get_edges(get_graph(tri)). This iterator over the edges could include ghost edges.\n\nSee also each_solid_edge and each_ghost_edge\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_constrained_edge-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_constrained_edge","text":"each_constrained_edge(tri::Triangulation)\n\nReturns each_edge(get_all_constrained_edges(tri)), an iterator over all constrained_edges  (including all constrained boundary edges)`.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_constrained_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_constrained_edge","text":"contains_constrained_edge(tri::Triangulation, e)\ncontains_constrained_edge(tri::Triangulation, i, j)\n\nTests if tri contains the constrained edge e = (i, j) (or reverse_edge(e) = (j, i)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_edges","text":"num_ghost_edges(tri::Triangulation)\n\nReturns the number of ghost edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_solid_edges","text":"num_solid_edges(tri::Triangulation)\n\nReturns the number of solid edges in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_edge","page":"Triangulation","title":"DelaunayTriangulation.each_solid_edge","text":"each_solid_edge(tri)\n\nReturns an iterator over all solid edges of the triangulation tri, i.e.  over all edges that are not ghost edges.\n\nSee also each_edge and each_ghost_edge.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_edge","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_edge","text":"each_ghost_edge(tri)\n\nReturns an iterator over all ghost edges of the triangulation tri, i.e. over all edges that have a boundary index as one of its indices.\n\nSee also each_edge and each_solid_edge.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.sort_edge_by_degree-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.sort_edge_by_degree","text":"sort_edge_by_degree(tri::Triangulation, e)\n\nReturns sort_edge_by_degree(e, get_graph(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.split_constrained_edge!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.split_constrained_edge!","text":"split_constrained_edge!(tri::Triangulation, constrained_edge, collinear_segments)\n\nCalls split_constrained_edge!(get_constrained_edges(tri), constrained_edge, collinear_segments), splitting  the constrained_edge which is assumed to represent the union of the collinear_segments so that  we instead store those collinear_segments.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Graph-Methods","page":"Triangulation","title":"Graph Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_edges(::Triangulation)\nget_vertices(::Triangulation)\nget_neighbours(::Triangulation)\nget_neighbours(::Triangulation, ::Any)\nadd_vertex!(::Triangulation, ::Vararg{Any})\nnum_neighbours(::Triangulation, ::Any)\nadd_neighbour!(::Triangulation, ::Any, ::Vararg{Any})\ndelete_neighbour!(::Triangulation, ::Any, ::Vararg{Any})\ndelete_vertex!(::Triangulation, ::Vararg{Any})\ndelete_boundary_vertices_from_graph!(::Triangulation)\neach_vertex(::Triangulation)\nnum_vertices(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_edges-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_edges","text":"get_graph(tri::Triangulation)\n\nReturns get_edges(get_graph(tri)).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_vertices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_vertices","text":"get_vertices(tri::Triangulation)\n\nReturns get_vertices(get_graph(tri)), giving all vertices present in the triangulation.  This will include ghost vertices. \n\nSee also each_vertex, each_solid_vertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation)\n\nReturns get_neighbours(get_graph(tri)), the set of neighbourhoods in the triangulation tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_neighbours-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_neighbours","text":"get_neighbours(tri::Triangulation, u)\n\nReturns get_neighbours(get_graph(tri), u), the set of neighbours of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.add_vertex!","text":"add_vertex!(tri::Triangulation, u...)\n\nCalls add_vertex!(get_graph(tri), u...), adding the vertex u into tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_neighbours-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.num_neighbours","text":"num_neighbours(tri::Triangulation, u)\n\nReturns num_neighbours(get_graph(tri), u), the number of neighbours of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.add_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.add_neighbour!","text":"add_neighbour!(tri::Triangulation, u, v...)\n\nCalls add_neighbour!(get_graph(tri), u, v...), adding each v into the neighbourhood of each u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_neighbour!-Tuple{Triangulation, Any, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.delete_neighbour!","text":"delete_neighbour!(tri::Triangulation, u, v...)\n\nCalls delete_neighbour!(get_graph(tri), u, v...), deleting each v from the neighbourhood of u.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_vertex!-Tuple{Triangulation, Vararg{Any}}","page":"Triangulation","title":"DelaunayTriangulation.delete_vertex!","text":"delete_vertex!(tri::Triangulation, u...)\n\nCalls delete_vertex!(get_graph(tri), u...), deleting each vertex u from tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.delete_boundary_vertices_from_graph!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.delete_boundary_vertices_from_graph!","text":"delete_boundary_vertices_from_graph!(tri::Triangulation)\n\nCalls delete_boundary_vertices_from_graph!(get_graph(tri)), deleting all ghost vertices  from the graph.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_vertex-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_vertex","text":"each_vertex(tri::Triangulation)\n\nReturns each_vertex(get_graph(tri)), an iterator over all vertices present  in the triangulation.\n\nwarning: Warning\nThis iterator will include ghost vertices. If you want to exclude these,  see each_solid_vertex. Alternatively, if you only want ghost vertices,  see each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_vertices-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_vertices","text":"num_vertices(tri::Triangulation)\n\nReturns num_vertices(get_graph(tri)), the number of vertices in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Points-Methods","page":"Triangulation","title":"Points Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"get_point(::Triangulation, ::Any)\neach_point_index(::Triangulation)\neach_point(::Triangulation)\nnum_points(::Triangulation)\npush_point!(::Triangulation, ::Any, ::Any)\neach_solid_vertex \neach_ghost_vertex\nnum_solid_vertices \nnum_ghost_vertices","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_point-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_point","text":"get_point(tri::Triangulation, i...)\n\nReturns the ith point of `tri. Boundary indices are automatically handled.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point_index-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point_index","text":"each_point_index(tri::Triangulation)\n\nReturns an iterator over the indices of the points of tri.\n\nSee also each_vertex, `eachsolidvertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_point-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_point","text":"each_point(tri::Triangulation)\n\nReturns an iterator over the points of tri. \n\nSee also each_vertex, `eachsolidvertex and each_ghost_vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_points-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_points","text":"num_points(tri::Triangulation)\n\nReturns the number of points of tri.\n\nnote: Note\nNote that this is just the size of get_points(tri), but if there are some missing points then this will not match the number in the triangulation itself.  Use num_vertices to get the number of vertices in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.push_point!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.push_point!","text":"push_point!(tri::Triangulation, x, y) = push_point!(get_points(tri), x, y)\npush_point!(tri::Triangulation, p) = push_point!(get_points(tri), p)\n\nPushes the point p = (x, y) into get_points(tri0.\n\nnote: Note\nThis does not add the point p into the triangulation itself. See add_point! for this.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_vertex","page":"Triangulation","title":"DelaunayTriangulation.each_solid_vertex","text":"each_solid_vertex(tri::Triangulation)\n\nReturns an iterator over the solid vertices in the triangulation tri, i.e.  those that are not ghost vertices.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_vertex","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_vertex","text":"each_ghost_vertex(tri::Triangulation)\n\nReturns an iterator over the ghost vertices in the triangulation tri.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_vertices","page":"Triangulation","title":"DelaunayTriangulation.num_solid_vertices","text":"num_solid_vertices(tri::Triangulation)\n\nReturns the number of solid vertices of tri.\n\n\n\n\n\nnum_solid_vertices(stats::TriangulationStatistics)\n\nReturns the numsolidvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_vertices","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_vertices","text":"num_ghost_vertices(tri::Trianngulation)\n\nReturns the number of ghost vertices of tri.\n\n\n\n\n\nnum_ghost_vertices(stats::TriangulationStatistics)\n\nReturns the numghostvertices field from the triangulation statistics stats.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#Triangles-Methods","page":"Triangulation","title":"Triangles Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"triangle_type(::Triangulation{P,Ts}) where {P,Ts}\nnum_triangles(::Triangulation)\neach_triangle(::Triangulation)\ncontains_triangle(::Triangulation, ::Any)\nconstruct_positively_oriented_triangle(::Triangulation, ::Any, ::Any, ::Any)\nnum_ghost_triangles(::Triangulation)\nnum_solid_triangles(::Triangulation)\neach_solid_triangle \neach_ghost_triangle","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_type-Union{Tuple{Triangulation{P, Ts}}, Tuple{Ts}, Tuple{P}} where {P, Ts}","page":"Triangulation","title":"DelaunayTriangulation.triangle_type","text":"triangle_type(tri::Triangulation)\n\nReturns the type used for representing triangles in tri.\n\n\n\n\n\ntriangle_type(vor::VoronoiTessellation)\n\nReturns the type of the triangles used in the triangulation underlying the Voronoi tessellation vor.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_triangles","text":"num_triangles(tri::Triangulation) = num_triangles(get_triangles(tri))\n\nReturns the number of triangles in tri, including ghost triangles.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_triangle-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.each_triangle","text":"each_triangle(tri::Triangulation)\n\nReturns an iterator over each triangle in tri. This iterator could include ghost triangles. \n\nSee also each_solid_triangle and each_ghost_triangle.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.contains_triangle-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.contains_triangle","text":"contains_triangle(tri::Triangulation, T)\ncontains_triangle(tri::Triangulation, i, j, k)\n\nTests if tri contains the triangle T.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.construct_positively_oriented_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.construct_positively_oriented_triangle","text":"construct_positively_oriented_triangle(tri::Triangulation, i, j, k)\n\nConstructs a triangle T with vertices (i, j, k) in tri such that T is  positively oriented.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_ghost_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_ghost_triangles","text":"num_ghost_triangles(tri::Triangulation)\n\nReturns the number of ghost triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.num_solid_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.num_solid_triangles","text":"num_solid_triangles(tri::Triangulation)\n\nReturns the number of solid triangles in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_solid_triangle","page":"Triangulation","title":"DelaunayTriangulation.each_solid_triangle","text":"each_solid_triangle(tri)\n\nReturns an iterator over all triangles of tri that are not ghost triangles.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#DelaunayTriangulation.each_ghost_triangle","page":"Triangulation","title":"DelaunayTriangulation.each_ghost_triangle","text":"each_ghost_triangle(tri)\n\nReturns an iterator over all triangles of tri that are ghost triangles.\n\n\n\n\n\n","category":"function"},{"location":"data_structures/triangulation/#Predicates-Methods","page":"Triangulation","title":"Predicates Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"is_boundary_edge(::Triangulation, ::Any)\nis_boundary_triangle(::Triangulation, ::Any, ::Any, ::Any)\ntriangle_orientation(::Triangulation, ::Any, ::Any, ::Any)\npoint_position_relative_to_circumcircle(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_line(::Triangulation, ::Any, ::Any, ::Any)\npoint_closest_to_line(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_on_line_segment(::Triangulation, ::Any, ::Any, ::Any)\nline_segment_intersection_type(::Triangulation, ::Any, ::Any, ::Any, ::Any)\npoint_position_relative_to_triangle(::Triangulation, ::Any, ::Any, ::Any, ::Any)\ntriangle_line_segment_intersection(::Triangulation, ::Any, ::Any, ::Any, ::Any, ::Any)\nis_outer_boundary_index(::Triangulation, ::Any)\nis_outer_boundary_node(::Triangulation, ::Any)\nis_boundary_node(::Triangulation, ::Any)\nedge_exists(::Triangulation, ::Any, ::Any)\nhas_ghost_triangles(::Triangulation)\nhas_boundary_nodes(::Triangulation)\nis_legal(::Triangulation, ::Any, ::Any)\nfind_edge(::Triangulation, ::Any, ::Any)\nis_constrained(::Triangulation)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_edge-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_edge","text":"is_boundary_edge(tri::Triangulation, ij)\nis_boundary_edge(tri::Triangulation, i, j)\n\nReturns is_boundary_edge(ij, get_adjacent(tri)) or is_boundary_edge(i, j, get_adjacent(tri)), respectively, testing if ij = (i, j) belongs to the boundary of the triangulation tri, i.e. (j, i) adjoins a ghost vertex.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_triangle-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_triangle","text":"is_boundary_triangle(tri::Triangulation, i, j, k)\nis_boundary_triangle(tri::Triangulation, T)\n\nReturns is_boundary_triangle(i, j, k, get_adjacent(tri)) or is_boundary_triangle(T, get_adjacent(tri)), testing if at least one of the edges (u, v) of T = (i, j, k) satisfies is_boundary_edge(tri, u, v).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_orientation-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.triangle_orientation","text":"triangle_orientation(tri::Triangulation, i, j, k)\ntriangle_orientation(tri::Triangulation, T)\n\nComputes the orientation of the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_circumcircle-Tuple{Triangulation, Vararg{Any, 4}}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_circumcircle","text":"point_position_relative_to_circumcircle(tri::Triangulation, i, j, k, ℓ)\npoint_position_relative_to_circumcircle(tri::Triangulation, T, ℓ)\n\nComputes the position of the ℓth point of tri relative to the circumcircle of the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_line-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_line","text":"point_position_relative_to_line(tri::Triangulation, i, j, u)\n\nComputes the position of the uth point of tri relative to the line segment with indices (i, j) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_closest_to_line-Tuple{Triangulation, Vararg{Any, 4}}","page":"Triangulation","title":"DelaunayTriangulation.point_closest_to_line","text":"point_closest_to_line(tri::Triangulation, i, j, u, v)\n\nTests which of the points u or v is closest to the line segment with indices (i, j) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_on_line_segment-Tuple{Triangulation, Any, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.point_position_on_line_segment","text":"point_position_on_line_segment(tri::Triangulation, i, j, u)\n\nGiven vertices i, j, and u that are collinear, computes the position of u  on the line segment (i, j).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.line_segment_intersection_type-Tuple{Triangulation, Vararg{Any, 4}}","page":"Triangulation","title":"DelaunayTriangulation.line_segment_intersection_type","text":"line_segment_intersection_type(tri::Triangulation, i, j, u, v)\n\nGiven two lines with indices (i, j) and (u, v), respectively, in tri, computes the number of  intersections.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Triangulation, Vararg{Any, 4}}","page":"Triangulation","title":"DelaunayTriangulation.point_position_relative_to_triangle","text":"point_position_relative_to_triangle(tri::Triangulation, i, j, k, u)\npoint_position_relative_to_triangle(tri::Triangulation, T, u)\n\nComputes the position of the uth point of tri relative to the triangle T = (i, j, k) in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.triangle_line_segment_intersection-Tuple{Triangulation, Vararg{Any, 5}}","page":"Triangulation","title":"DelaunayTriangulation.triangle_line_segment_intersection","text":"triangle_line_segment_intersection(tri::Triangulation, i, j, k, u, v)\ntriangle_line_segment_intersection(tri::Triangulation, T, e)\n\nComputes the type of the intersection of the triangle T = (i, j, k) in tri with the line segment e = (u, v).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_index-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_index","text":"is_outer_boundary_index(tri::Triangulation, i)\n\nReturns true if is_boundary_index(i) and this boundary index i corresponds to the outermost boundary of tri.  Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_outer_boundary_node","text":"is_outer_boundary_node(tri::Triangulation, i)\n\nReturns true if i is a boundary node belonging to the outermost boundary of tri. Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_boundary_node-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_boundary_node","text":"is_boundary_node(tri::Triangulation, i)\n\nReturns true if i is a node belonging to any boundary of tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.edge_exists-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.edge_exists","text":"edge_exists(tri::Triangulation, i, j)\nedge_exists(tri::Triangulation, ij)\n\nReturns true if the edge (i, j) exists in tri, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_ghost_triangles-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_ghost_triangles","text":"has_ghost_triangles(tri::Triangulation)\n\nReturns true if tri has ghost triangles, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.has_boundary_nodes-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.has_boundary_nodes","text":"has_boundary_nodes(tri::Triangulation)\n\nReturns true if tri has boundary nodes, and false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_legal-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.is_legal","text":"is_legal(tri::Triangulation, i, j)\n\nReturns true if the edge (i, j) is legal in tri, and false otherwise. We also define  constrained edges to be legal, as are ghost edges.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.find_edge-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.find_edge","text":"find_edge(tri::Triangulation, T, ℓ)\n\nGiven a point ℓ that is on an edge of the triangle T in tri, returns the  edge that ℓ is on. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.is_constrained-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.is_constrained","text":"is_constrained(tri::Triangulation, i, j)\n\nReturns true if tri has any constrained edges, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#Representative-Points-Methods","page":"Triangulation","title":"Representative Points Methods","text":"","category":"section"},{"location":"data_structures/triangulation/","page":"Triangulation","title":"Triangulation","text":"compute_representative_points!(::Triangulation)\nget_representative_point_coordinates(::Triangulation, ::Any)\nreset_representative_points!(::Triangulation)\nupdate_centroid_after_addition!(::Triangulation, ::Any, ::Any)\nupdate_centroid_after_deletion!(::Triangulation, ::Any, ::Any)\nnew_representative_point!(::Triangulation, ::Any)","category":"page"},{"location":"data_structures/triangulation/#DelaunayTriangulation.compute_representative_points!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.compute_representative_points!","text":"compute_representative_points!(tri::Triangulation; use_convex_hull=!has_multiple_segments(tri) && num_boundary_edges(get_boundary_nodes(tri)) == 0)\n\nUpdates get_representative_point_list(tri) to match the current position of the boundaries. If there are no boundary nodes, use_convex_hull instead represents them using the indices of the convex hull.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.get_representative_point_coordinates-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.get_representative_point_coordinates","text":"get_representative_point_coordinates(tri::Triangulation, i)\n\nReturns the coordinates of the ith representative point in tri.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.reset_representative_points!-Tuple{Triangulation}","page":"Triangulation","title":"DelaunayTriangulation.reset_representative_points!","text":"reset_representative_points!(tri::Triangulation)\n\nResets get_representative_point_list(tri).\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.update_centroid_after_addition!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.update_centroid_after_addition!","text":"update_centroid_after_addition!(tri::Triangulation, i, p)\n\nAfter the point p has been added into tri, this updates the ith representative point in  get_representative_point_list(tri), treating it as if it were a centroid.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.update_centroid_after_deletion!-Tuple{Triangulation, Any, Any}","page":"Triangulation","title":"DelaunayTriangulation.update_centroid_after_deletion!","text":"update_centroid_after_deletion!(tri::Triangulation, i, p)\n\nAfter the point p has been deleted from tri, this updates the ith representative point in get_representative_point_list(tri), treating it as if it were a centroid.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/triangulation/#DelaunayTriangulation.new_representative_point!-Tuple{Triangulation, Any}","page":"Triangulation","title":"DelaunayTriangulation.new_representative_point!","text":"new_representative_point!(tri::Triangulation, i)\n\nAdds a new representative point to get_representative_point_list(tri) with index i.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent/#Adjacent","page":"Adjacent","title":"Adjacent","text":"","category":"section"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"The Adjacent map is used for mapping edges to vertices that together form a positively oriented triangle. The definition of the Adjacent map is below:","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"struct Adjacent{I,E}\n    adjacent::DefaultDict{E,I,I}\n    function Adjacent{I,E}() where {I,E}\n        A = DefaultDict{E,I,I}(I(DefaultAdjacentValue))\n        adj = new{I,E}(A)\n        return adj\n    end\n    Adjacent(adj::DefaultDict{E,I,I}) where {I,E} = new{I,E}(adj)\nend","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"We list the complete docstring for Adjacent below, along with individual docstrings for methods for working with Adjacent.","category":"page"},{"location":"data_structures/adjacent/","page":"Adjacent","title":"Adjacent","text":"Adjacent\nget_adjacent(::Adjacent)\nget_adjacent(::Adjacent{I, E}, ::E) where {I, E, V}\nadd_adjacent!(::Adjacent, ::Any, ::Any)\ndelete_adjacent!(::Adjacent, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\nadd_triangle!(::Adjacent, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}\ndelete_triangle!(::Adjacent, ::Any)","category":"page"},{"location":"data_structures/adjacent/#DelaunayTriangulation.Adjacent","page":"Adjacent","title":"DelaunayTriangulation.Adjacent","text":"Adjacent{I,E}\n\nStruct for storing adjacency relationships for mapping edges to vertices that  together form a positively oriented triangle in an associated triangulation.  The type I is the integer type used, while E is the edge type.\n\nSee the docs for a description of how boundary edges are handled.\n\nSee also Adjacent2Vertex.\n\nFields\n\nadjacent::Dict{E,I}\n\nThe Dict used for storing the edges (the keys) and the associated vertices  (the values). If (u, v) is not a valid edge, then w = get_adjacent(adjacent, u, v) returns 0 (this value is defined in DefaultAdjacentValue). Otherwise, (u, v, w) is a positively oriented triangle.\n\nConstructors\n\nThe adjacent map can be constructed in two ways:\n\nAdjacent{I, E}() where {I, E}\n\nCreates an empty map.\n\nAdjacent(adj::Dict{E,I,I}) where {E,I,I}\n\nCreates an adjacent map from an existing Dict.\n\nExtended help\n\nYou should not work with the adjacent field directly. We provide the following  functions for working with Adjacent, where adj denotes an Adjacent{I, E} type. (Type information in the function signatures is omitted.)\n\nAccessors\n\nget_adjacent(adj)\nget_adjacent(adj, uv) or get_adjacent(adj, u, v)\n\nIn the latter methods, you can also use the keyword argument check_existence to  declare whether to check that the edge exists. This would be used if you need  to be careful about different boundary indices on the same boundary curve. The  default value is Val(false), meaning this isn't checked.\n\nMutators\n\nadd_adjacent!(adj, uv, w) or add_adjacent!(adj, u, v, w)\ndelete_adjacent!(adj, uv) or delete_adjacent!(adj, u, v)\nadd_triangle!(adj, i, j, k) or add_triangle!(adj, T)\nadd_triangle!(adj, T...)\ndelete_triangle!(adj, i, j, k) or delete_triangle!(adj, T)\ndelete_triangle!(adj, T...)\n\nIteration\n\nYou can also iterate over Adjacent maps the same way as you would  with a Dict, e.g.\n\nfor (edge, vertex) in adj \n    get_adjacent(adj, edge) == vertex \nend\n\nwarning: Multiple boundary segments\nNote that in the case that you have multiple boundary indices, this iteration  may not be safe the iteration doesn't make use of get_adjacent, which  knows how to handle boundary indices properly (if you have just a single  boundary, do not worry).\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent)\n\nGiven the adjacent map adj, returns the adjacent field.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Union{Tuple{V}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E, V}","page":"Adjacent","title":"DelaunayTriangulation.get_adjacent","text":"get_adjacent(adj::Adjacent{I,E}, uv::E; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\nget_adjacent(adj::Adjacent{I,E}, u, v; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}\n\nGiven the adjacent map adj and an edge (u, v), returns the vertex w  such that (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\nIn the case of a ghost edge, check_existence = Val(true) may be useful in case the  boundary curve has multiple segments, meaning multiple boundary indices could correspond  to the same same curve. If this is the case, then boundary_index_ranges should also be a Dict from construct_boundary_index_ranges, so that all possible valid boundary indices can be checked.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_adjacent!","text":"add_adjacent!(adj::Adjacent, uv, w)\nadd_adjacent!(adj::Adjacent{I,E}, u, v, w) where {I,E}\n\nGiven the adjacent map adj, an edge (u, v), and a vertex w, adds  the edge (u, v) with corresponding value w into the adjacent map  so that (u, v, w) is a positively oriented triangle in the  underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_adjacent!","text":"delete_adjacent!(adj::Adjacent, uv)\ndelete_adjacent!(adj::Adjacent{I,E}, u, v) where {I,E}\n\nGiven the adjacent map adj and an edge (u, v), deletes the  edge (u, v) from the adjacent map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  adds that triangle into the adjacent map. In particular, adds the edges (i, j), (j, k), and (k, i) into adj with corresponding values k, i, and j,  respectively.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., adds the  triangles into adj. See also add_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent{I, E}}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, i, j, k)\n\nGiven an adjacent map adj and indices (i, j, k) representing some triangle,  deletes that triangle into the adjacent map. In particular, deletes the edges (i, j), (j, k), and (k, i) from adj.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}","page":"Adjacent","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent, T...)\n\nGiven an adjacent map adj and triangles T..., deletes the  triangles from adj. See also delete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V<:Integer,Ts<:Adjacent{I,E}}.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"data_structures/adjacent2vertex/#Adjacent2Vertex","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"","category":"section"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"The Adjacent2Vertex map is closely related to the Adjacent map. Instead of mapping edges to vertices that together form positively oriented triangles, we map vertices to all edges that will form a positively oriented triangle with that vertex. The definition is simply via a Dict:","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"struct Adjacent2Vertex{I,Es,E}\n    adjacent2vertex::Dict{I,Es}\n    function Adjacent2Vertex{I,Es,E}() where {I,Es,E}\n        D = Dict{I,Es}()\n        TA2V = new{I,Es,E}(D)\n        return TA2V\n    end\n    Adjacent2Vertex(adj2v::Dict{I,Es}) where {I,Es} = new{I,Es,edge_type(Es)}(adj2v)\nend","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"A complete list of methods used for working with this struct, along with the struct's docstring itself, is shown below.","category":"page"},{"location":"data_structures/adjacent2vertex/","page":"Adjacent2Vertex","title":"Adjacent2Vertex","text":"Adjacent2Vertex \nget_adjacent2vertex(::Adjacent2Vertex)\nget_adjacent2vertex(::Adjacent2Vertex, ::Any)\nadd_adjacent2vertex!(::Adjacent2Vertex{I,Es,E}, ::Any, ::Any) where {I,Es,E}\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any, ::Any)\ndelete_adjacent2vertex!(::Adjacent2Vertex, ::Any)\nadd_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\nadd_triangle!(::Adjacent2Vertex, ::Any)\ndelete_triangle!(::Ts, ::V, ::V, ::V) where {I,Es,E,V<:Integer,Ts<:Adjacent2Vertex{I,Es,E}}\ndelete_triangle!(::Adjacent2Vertex, ::Any)\nclear_empty_keys!(::Adjacent2Vertex)","category":"page"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex","page":"Adjacent2Vertex","title":"DelaunayTriangulation.Adjacent2Vertex","text":"Adjacent2Vertex{I, Es, E}\n\nStruct for storing adjacency relationships for mapping vertices to  all other edges that together form a positively oriented triangle  in an associated triangulation. The type I is the integer type  used, Es is the type used for representing a collection of edges,  and E is the type for a single edge.\n\nSee the docs for a description of how boundary edges  are handled.\n\nSee also Adjacent.\n\nFields\n\nadjacent2vertex::Dict{I, Es}\n\nThe Dict used for storing the vertices (the keys) and the associated  collection of edges (the values). In particular, if w is a vertex,  then (u, v, w) is a positively oriented triangle for each  (u, v) in adjacent2vertex[w].\n\nConstructors\n\nThe adjacent2vertex map can be constructed in two ways:\n\nAdjacent2Vertex{I,Es,E}()\n\nCreates an empty map.\n\nAdjacent2Vertex(adj2v::Dict{I,E}) where {I,Es}\n\nCreates an adjacent2vertex map from an existing Dict. The type E is obtained from  edge_type(Es).\n\nExtended help\n\nYou should not work with the adjacent2vertex field directory. We provide the  following functions for working with Adjacent2Vertex, where adj2v  denotes an Adjacent2Vertex{I,Es,E} type. (Type information in the  function signatures is omitted.)\n\nAccessors\n\nget_adjacent2vertex(adj2v)\nget_adjacent2vertex(adj2v, w)\n\nMutators\n\nadd_adjacent2vertex!(adj2v, w, uv) or add_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w, uv) or delete_adjacent2vertex!(adj2v, w, u, v)\ndelete_adjacent2vertex!(adj2v, w)\nadd_triangle!(adj2v, i, j, k) or add_triangle!(adj2v, T)\nadd_triangle!(adj2v, T...)\ndelete_triangle!(adj2v, i, j, k) or delete_triangle!(adj2v, T)\ndelete_triangle!(adj2v, T...)\nclear_empty_keys!(adj2v)\n\nIteration\n\nYou can also iterate over Adjacent2Vertex maps the same way as you would  with a Dict, e.g. if adj is a corresponding Adjacent map,\n\nfor (vertex, edge_list) in adj2v \n    for edge in each_edge(edge_list)\n        get_adjacent(adj, edge) == vertex \n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex)\n\nReturns the adjacent2vertex field from the adjacent2vertex map adj2v.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.get_adjacent2vertex-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.get_adjacent2vertex","text":"get_adjacent2vertex(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, returns the set of  edges associated with the vertex w, i.e. the set of edges (u, v) such that  (u, v, w) is a positively oriented triangle in the underlying triangulation.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_adjacent2vertex!-Union{Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent2Vertex{I, Es, E}, Any, Any}} where {I, Es, E}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_adjacent2vertex!","text":"add_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, uv) where {I,Es,E}\nadd_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), adds  the edge (u, v) into the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w, uv)\ndelete_adjacent2vertex!(adj2v::Adjacent2Vertex{I,Es,E}, w, u, v) where {I,Es,E}\n\nGiven the adjacent2vertex map adj2v, a vertex w, and an edge (u, v), deletes  the edge (u, v) from the set of edges associated with the vertex w in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_adjacent2vertex!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_adjacent2vertex!","text":"delete_adjacent2vertex!(adj2v::Adjacent2Vertex, w)\n\nGiven the adjacent2vertex map adj2v and a vertex w, deletes  the key w from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, adds that triangle from the  map. In particular, adds the edges (i, j), (j, k), and (k, i)  into the set of edges associated with the vertices k, i, and j, respectively, in the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.add_triangle!","text":"add_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent map adj2v and triangles T..., adds the  triangles into adj2v. See also add_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{Es}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, Es, E, V<:Integer, Ts<:DelaunayTriangulation.Adjacent2Vertex{I, Es, E}}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj2v::Adjacent2Vertex, i, j, k)\n\nGiven an adjacent2vertex map adj2v and indices (i, j, k)  representing some triangle, deletes that triangle from the  map. In particular, deletes the edges (i, j), (j, k), and (k, i)  from the set of edges associated with the vertices k, i, and j, respectively, from the map.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent2Vertex, Any}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.delete_triangle!","text":"delete_triangle!(adj::Adjacent2Vertex, T...)\n\nGiven an adjacent2vertex map adj2v and triangles T..., deletes the  triangles from adj2v. See also delete_triangle!.\n\n\n\n\n\n","category":"method"},{"location":"data_structures/adjacent2vertex/#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent2Vertex}","page":"Adjacent2Vertex","title":"DelaunayTriangulation.clear_empty_keys!","text":"clear_empty_keys!(adj2v::Adjacent2Vertex)\n\nGiven an Adjacent2Vertex map adj2v, removes  any keys that map to empty sets.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"#DelaunayTriangulation","page":"Home","title":"DelaunayTriangulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DelaunayTriangulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for computing Delaunay triangulations of planar point sets. We support both unconstrained and constrained Delaunay triangulations, as well as mesh refinement with Rupper's algorithm. We also support Voronoi tessellations, clipped Voronoi tessellations, and central Voronoi tessellations; for these latter two cases, the triangulation is treated as constrained with the convex hull edges, but we do not support general boundary constraints for tessellations - if you do know about this, get in touch!","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface for computing  constrained Delaunay triangulations with Gmsh is also available if needed; see the Gmsh discussion in the sidebar. Unconstrained Delaunay triangulations are computed with the Bowyer-Watson algorithm, and constrained Delaunay triangulations are computed with the incremental algorithm given by https://doi.org/10.1016/j.comgeo.2015.04.006.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure that the triangulations are robust to degeneracies, we use ExactPredicates.jl for all geometrical predicates. The results from these predicates are handled through a Certificate module, as outlined in the predicates section in the sidebar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Much of the work in this package is derived from the book Delaunay Mesh Generation by Cheng, Dey, and Shewchuk (2013).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the short-term plans for future features are outlined in the issues page, two important ones being:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clipped Voronoi tessellations on general domains.\nSpatial sorting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"But we also have some long-term plans, like","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supporting curved boundaries. This is a bit complex since the boundary node interface must be extended to support not only segments, but general forms such as splines, while not slowing down the code in general for straight lines.\nEfficient reconstruction of a perturbed unconstrained or constrained triangulations, using e.g. star-splaying (that currently only works on unconstrained).\nWeighted Delaunay triangulations. These are not actually that complicated, but I just don't have plans to do it yet. Solutions to Exercise 2 of the Delaunay Mesh Generation book above in Chapter 4 would also be useful here.\nAnisotropic mesh generation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One other feature would be three-dimensional Delaunay tetrahedralisation as a replacement for TetGen, just as this package (hopefully) can be used as a replacement for the Triangle software. This is definitely the furthest away, but it is something I'm interested in eventually giving my (very limited) time to.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"CurrentModule = DelaunayTriangulation","category":"page"},{"location":"tri_algs/bowyer/#Bowyer-Watson-Algorithm","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"","category":"section"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"Here we will give a description of the Bowyer-Watson algorithm. This algorithm is the algorithm used by triangulate.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"The main idea behind the algorithm is to insert points one at a time, deleting triangles at each step whose circumcircles contain the point to be inserted, then repairing the cavity. We give the procedure in steps below.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"First, using initialise_bowyer_watson, we need to define the initial triangle. This triangle will be the first three points in the provided point_order (which is, by default, just a random permutation of the point indices - see the point_order keyword argument in triangulate_bowyer_watson and the get_point_order function). If these first three points are collinear, we do a circular shift of the point order until we get a non-degenerate triangle. See get_initial_triangle. At this step, we also reset the representative points field of the triangulation and initialise it with DelaunayTriangulation.BoundaryIndex mapping to the centroid of this initial triangle.\nOnce the initial triangle is selected, we move into _triangulate_bowyer_watson, where we loop over each point and add it in one at a time. In this loop, we start by selecting the initial point to start the jump and march algorithm at, making use of select_initial_point. Since points are added in one at a time, and a user's insertion order may often have points that are close together both in the order and in space, the try_last_inserted_point keyword argument is useful here in case we can start right next to the new point. With this point selected, we move into actually adding the point via add_point_bowyer_watson!.\nThe add_point_bowyer_watson! starts by using jump_and_march to find a triangle containing the point. The idea is to then find all triangles whose circumcircles, i.e. the circle through the three points of the triangle, contain this new point. These points need to be deleted since, by definition, these triangles are no longer Delaunay. This is done via a depth-first search, where we take the triangle we are currently in and step over its three edges into three new triangles, done via the recursive function dig_cavity!. If the new triangle also contains the point in its circumcircle, we delete it also, and we keep stepping. We stop at any triangles that don't contain the point in its circumcircle. Once we have stopped, we take the edge we did not step over and connect it with the new point, giving us a new triangle. \nStill in add_point_bowyer_watson!, an important case to consider is when the point we find is directly on the triangle we found. This does not cause any problems with dig_cavity!, but it may cause issues with how we update the boundary, so not only do we check if the point is on the triangle, but we also check that the triangle is either a boundary triangle or a ghost triangle (meaning the edge is on the boundary). If this is the case, then we find the edge of the triangle that the point is on with find_edge, and split the edge in half at the point, placing the new point correctly on the boundary and giving two new triangles.\nLastly, still in add_point_bowyer_watson!, we use update_centroid_after_addition! to update the centroid of the points with the new point.\nSteps 2–5 are repeated for each new point, until we have finally added all points. Once this is done, we compute the convex hull of the points with convex_hull!, stepping over the boundary using the ghost triangles from the triangulation to get all the boundary nodes efficiently.\nNext, if the keyword argument recompute_representative_point is true, we can give a better representative point for the central part of the domain than the centroid by computing the pole of inaccessibility. This is done with compute_representative_points!.\nFinally, to clean up, we can delete all ghost triangles (if the keyword argument delete_ghosts is true) with delete_ghost_triangles!. Then, if the keyword argument delete_empty_features is true, we can delete all keys from the Adjacent map that map to empty values with clear_empty_features!, which would also clean up empty sets from the Adjacent2Vertex map and empty neighbourhoods from the Graph.","category":"page"},{"location":"tri_algs/bowyer/#Modifications-for-a-constrained-Delaunay-triangulation","page":"Bowyer-Watson Algorithm","title":"Modifications for a constrained Delaunay triangulation","text":"","category":"section"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"The Bowyer-Watson algorithm requires two modifications for adding points into a constrained Delaunay triangulation. The modifications are:","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"Avoid walking over any constrained edges when performing the depth-first search.\nIf a point is added onto a constrained segment, split the segment in two and perform the depth-first search on each side of the segment.","category":"page"},{"location":"tri_algs/bowyer/","page":"Bowyer-Watson Algorithm","title":"Bowyer-Watson Algorithm","text":"With just these two modifications, the algorithm works.","category":"page"}]
}
