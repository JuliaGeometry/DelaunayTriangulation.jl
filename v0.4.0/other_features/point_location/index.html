<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Point Location · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/other_features/point_location/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li class="is-active"><a class="tocitem" href>Point Location</a><ul class="internal"><li><a class="tocitem" href="#The-Main-Method"><span>The Main Method</span></a></li><li><a class="tocitem" href="#Basic-Description-of-the-Algorithm"><span>Basic Description of the Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Other Features</a></li><li class="is-active"><a href>Point Location</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Point Location</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/other_features/point_location.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Point-Location"><a class="docs-heading-anchor" href="#Point-Location">Point Location</a><a id="Point-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Location" title="Permalink"></a></h1><p>The most expensive step for building a Delaunay triangulation is the point location step, wherein we need to find a triangle that contains a given point. The code for this turns out to be very complicated so that we can correctly handle points outside of the domain, inside interior holes, collinear with other points, on the corner, etc. The main function that handles all of this is <code>jump_and_march</code>, derived from the jump-and-march algorithm of Mücke, Saias, and Zhu (1999). We also provide a method that simply searches over all triangles, given below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.brute_force_search" href="#DelaunayTriangulation.brute_force_search"><code>DelaunayTriangulation.brute_force_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brute_force_search(tri::Triangulation, q)</code></pre><p>Given a point <code>q</code>, finds the triangle in the triangulation <code>tri</code> containing it by  searching over all triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/data_structures/triangulation.jl#L1158-L1163">source</a></section><section><div><pre><code class="nohighlight hljs">brute_force_search(T, r, pts, boundary_map)</code></pre><p>Given a collection of triangles <code>T</code>, a point <code>r</code>, a collection of points  <code>pts</code>, and a boundary map handling the mapping of boundary indices from  <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, returns the triangle in <code>T</code> containing <code>r</code>  by searching over all triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/brute_force.jl#L1-L8">source</a></section></article><h2 id="The-Main-Method"><a class="docs-heading-anchor" href="#The-Main-Method">The Main Method</a><a id="The-Main-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Main-Method" title="Permalink"></a></h2><p>Below we list docstrings for the main jump and march algorithm.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.jump_and_march" href="#DelaunayTriangulation.jump_and_march"><code>DelaunayTriangulation.jump_and_march</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jump_and_march(tri::Triangulation, q;
    m=default_num_samples(num_points(tri)),
    point_indices=each_point_index(tri),
    try_points=(),
    k=select_initial_point(get_points(tri), q; m, point_indices, try_points),
    check_existence::C=Val(has_multiple_segments(tri)),
    rng::AbstractRNG=Random.default_rng())</code></pre><p>Using the jump and march algorithm, finds the triangle in the triangulation <code>tri</code> containing the  query point <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: The <a href="../../data_structures/triangulation/#DelaunayTriangulation.Triangulation"><code>Triangulation</code></a>.</li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m=default_num_samples(num_points(pts))</code>: The number of samples to use when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>point_indices</code>: The indices for the points. Only relevant if <code>k</code> is not specified. </li><li><code>try_points=()</code>: Extra points to try when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>k=select_initial_point(pts, q; m, point_indices, try_points)</code>: Where to start the algorithm.</li><li><code>check_existence::C=Val(has_multiple_segments(tri))</code>: Whether to check that the edge exists when using <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns the triangle <code>V</code> containing the query point <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/data_structures/triangulation.jl#L1165-L1190">source</a></section><section><div><pre><code class="nohighlight hljs">jump_and_march(pts, adj, adj2v, graph::Graph{I}, boundary_index_ranges, boundary_map, q;
    m=default_num_samples(num_points(pts)),
    point_indices=each_point_index(pts),
    try_points=(),
    k=select_initial_point(pts, q; m, point_indices, try_points),
    TriangleType::Type{V}=NTuple{3,I},
    check_existence::C=Val(has_multiple_segments(boundary_map)),
    rng::AbstractRNG = Random.default_rng()) where {I,V,C}</code></pre><p>Using the jump and march algorithm, finds the triangle in the triangulation containing the  query point <code>q</code>.</p><p>If your triangulation does not have ghost triangles, and the point <code>q</code> is outside of the triangulation,  this function may fail to terminate. You may like to add ghost triangles in this case (using  <a href="../../operations/#DelaunayTriangulation.add_ghost_triangles!-Tuple{Triangulation}"><code>add_ghost_triangles!</code></a>), noting that there is no actual triangle that <code>q</code> is inside  when it is outside of the triangulation unless ghost triangles are present. </p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points.</li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph::Graph{I}</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>boundary_index_ranges</code>: The <code>Dict</code> mapping boundary indices to ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>boundary_map</code>: The boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> handling the mapping of boundary indices. </li><li><code>q</code>: The query point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>m=default_num_samples(num_points(pts))</code>: The number of samples to use when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>point_indices</code>: The indices for the points. Only relevant if <code>k</code> is not specified. </li><li><code>try_points=()</code>: Extra points to try when sampling an initial point from <a href="#DelaunayTriangulation.select_initial_point"><code>select_initial_point</code></a>. Only relevant if <code>k</code> is not specified. </li><li><code>k=select_initial_point(pts, q; m, point_indices, try_points)</code>: Where to start the algorithm.</li><li><code>TriangleType::Type{V}=NTuple{3,I}</code>: The type used for representing the triangles. </li><li><code>check_existence::C=Val(has_multiple_segments(boundary_map))</code>: Whether to check that the edge exists when using <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns the triangle <code>V</code> containing the query point <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/jump_and_march.jl#L54-L90">source</a></section></article><p>The variant of the jump and march algorithm for points outside of the triangle is also accessed via the <code>jump_and_march</code>, calling into <code>exterior_jump_and_march</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.exterior_jump_and_march" href="#DelaunayTriangulation.exterior_jump_and_march"><code>DelaunayTriangulation.exterior_jump_and_march</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exterior_jump_and_march(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E}</code></pre><p>Given a collection of points <code>pts</code>, an <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code>, a <code>Dict</code> mapping boundary indices to ranges from  <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, a boundary map  from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, a vertex <code>k</code>, and a point <code>q</code> outside of  the triangulation, returns the edge <code>(i, j)</code> such that the ghost triangle  <code>(i, j, -1)</code> contains <code>q</code>. </p><p>The <code>check_existence</code> argument is used to check that the edge exists when using <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>,  helping to correct for incorrect boundary indices in the presence of multiple boundary segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</p><p>The result is meaningless if <code>q</code> is inside of the triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/jump_and_march.jl#L1-L14">source</a></section></article><p>You should not need to call into this method directly.</p><p>The core complexity of the algorithm comes from having to find the direction of the point from an initial search point. The docstrings for some of these initialisers are given below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.select_initial_point" href="#DelaunayTriangulation.select_initial_point"><code>DelaunayTriangulation.select_initial_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_initial_point(pts, q;
point_indices=each_point_index(pts),
m=default_num_samples(length(point_indices)),
try_points=(),
rng::AbstractRNG = Random.default_rng())</code></pre><p>Given a collection of points and a point <code>q</code>, select <code>m</code> random points from <code>pts</code>  and return the index <code>i</code> that corresponds a point <code>get_point(pts, i)</code> closest to <code>q</code>,  out of all indices in <code>point_indices</code> and <code>try_points</code>. The indices are randomly  selected from <code>point_indices</code>, but you can guarantee points to try using  <code>try_points</code>. </p><p>If <code>q</code> is an integer, then the point compared to becomes <code>get_point(pts, q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/initialisers.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.select_initial_triangle_interior_node" href="#DelaunayTriangulation.select_initial_triangle_interior_node"><code>DelaunayTriangulation.select_initial_triangle_interior_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_initial_triangle_interior_node(pts, adj::Adjacent, adj2v::Adjacent2Vertex, boundary_map, k, q, boundary_index_ranges, check_existence::V = Val(has_multiple_segments(boundary_map)), rng::AbstractRNG = Random.default_rng()) where {V}</code></pre><p>Selects an initial triangle for the jump-and-march algorithm, starting from a point with index <code>k</code> and  searching for the point <code>q</code>. The point <code>q</code> should be contained within the outermost boundary (interior  holes are fine), and <code>k</code> should not be a point on the outer boundary.</p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points. </li><li><code>adj</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>adj2v</code>: The <a href="../../data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map.</li><li><code>boundary_map</code>: The map taking boundary indices to their boundary segment location. See <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The index of the point in <code>pts</code> that we are starting at.</li><li><code>q</code>: The point being searched for.</li><li><code>boundary_index_ranges</code>: The <code>Dict</code> handling the mapping of boundary indices from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence::V=Val(has_multiple_segments(boundary_map)))</code>: Checks for different possible boundary indices when there are multiple segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>p</code>: The <code>k</code>th point in <code>pts</code>. </li><li><code>i, j</code>: These are indices defining the edge of a triangle including the point <code>p</code>, such that <code>i</code> is to the left of the line <code>pq</code> and <code>j</code> is to the right of <code>pq</code>.</li><li><code>pᵢ, pⱼ</code>: The points in <code>pts</code> corresponding to the indices in <code>i</code> and <code>j</code>, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/initialisers.jl#L103-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges" href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_adjacent_boundary_edges(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, check_existence::V = Val(has_multiple_segments(boundary_map))) where {I,E,V}</code></pre><p>Given a collection of points <code>pts</code>, an <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adjacent</code>, a list of boundary index ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, a boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, an outer boundary point <code>k</code>, and a query point <code>q</code>,  checks the edges adjacent to <code>k</code> along the outer boundary for <code>q</code>.</p><p>The <code>check_existence</code> argument is the same keyword argument from <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, and is needed when you use multiple segments in your boundary.</p><p>See also <a href="#DelaunayTriangulation.search_down_adjacent_boundary_edges"><code>search_down_adjacent_boundary_edges</code></a>, which uses this function to determine an initial direction  to search along a straight boundary in case <code>q</code> is collinear with it.</p><p>The possible returned values are: </p><ul><li><code>(Certificate.Outside, Certificate.Outside, k)</code></li></ul><p>Here, the point <code>q</code> is not collinear with either of the adjacent boundary edges.</p><ul><li><code>(Certificate.Right, C, r)</code>, where <code>C</code> is either <code>Certificate.On</code> or <code>Certificate.Right</code> and <code>r</code> is the vertex to the right of <code>k</code>, i.e. <code>get_adjacent(adj, k, -1)</code></li></ul><p>This output means that <code>q</code> is collinear with the edge to the right of <code>k</code>. <code>C = Certificate.On</code>  means it is on this edge, while <code>C = Certificate.Right</code> means that <code>q</code> is to the right of this edge.</p><ul><li><code>(Certificate.Left, C, ℓ)</code>, where <code>C</code> is either <code>Certificate.On</code> or <code>Certificate.Left</code> and <code>ℓ</code> is the vertex to the left of <code>k</code>, i.e. <code>get_adjacent(adj, -1, k)</code></li></ul><p>This output means that <code>q</code> is collinear with the edge to the left of <code>k</code>. <code>C = Certificate.On</code>  means it is on this edge, while <code>C = Certificate.Left</code> means that <code>q</code> is to the left of this edge.</p><p>In these two outputs above, <code>C</code> could also mean <code>Certificate.Degenerate</code>, which means that <code>q</code> is <code>get_point(pts, r)</code> or <code>get_point(pts, ℓ)</code>,  respectively.</p><p>In addition to these three returned values, the fourth and fifth returned values are <code>(right_cert, left_cert)</code>, which give the  position of <code>q</code> relative to the edges <code>(p, p_right)</code> and <code>(p, p_left)</code>, respectively, where <code>p_right</code> is the point on the boundary  to the right and <code>p_left</code> is the point on the boundary to the left of <code>p</code>. These returned values are useful in case we need  to go to <a href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node"><code>check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code></a>, since we can reuse these certificates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/initialisers.jl#L182-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.search_down_adjacent_boundary_edges" href="#DelaunayTriangulation.search_down_adjacent_boundary_edges"><code>DelaunayTriangulation.search_down_adjacent_boundary_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_down_adjacent_boundary_edges(pts, adj::Adjacent{I,E}, boundary_index_ranges, boundary_map, k, q, direction, q_pos, next_vertex, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E,V}</code></pre><p>Given a collection of points <code>pts</code>, an <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code>, a list of boundary index ranges from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, a boundary map from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, an outer boundary index  <code>k</code> for a point in <code>pts</code>, a point <code>q</code> being searched for, a <code>direction</code> giving the direction of <code>q</code> from <code>get_point(pts, k)</code>, a certificate for the position of q from this point, and the next vertex in the direction of <code>q</code> (these last three arguments  coming from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>), walks down the edges that <code>q</code> is  collinear with until an edge is found that <code>q</code> is on or until finding that <code>q</code> is outside of the triangulation. </p><p>The returned value takes the form <code>(cert, u, v, w)</code>, with <code>cert = Certificate.On</code> if <code>q</code> is on the edge <code>(u, v)</code> and  <code>cert = Certificate.Outside</code> if <code>q</code> is outside of the triangulation. If <code>is_on(cert)</code>, then <code>(u, v, w)</code> is a positively  oriented triangle with <code>q</code> on the edge <code>(u, v)</code>. Otherwise, <code>(u, v, w)</code> is a ghost triangle that should be close to <code>q</code>.</p><p>The <code>check_existence</code> argument is the same keyword argument from <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>, and is needed when you use multiple segments in your boundary.</p><p>Note that this function relies on the assumption that the geometry is convex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/initialisers.jl#L249-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node" href="#DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node"><code>DelaunayTriangulation.check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_for_intersections_with_interior_edges_adjacent_to_boundary_node(pts, adj::Adjacent{I,E}, graph::Graph{I}, boundary_index_ranges, boundary_map, k, q, right_cert, left_cert, check_existence::V=Val(has_multiple_segments(boundary_map))) where {I,E,V}</code></pre><p>Checks if the line connecting the <code>k</code>th point of <code>pts</code> to <code>q</code> intersects any of the edges neighbouring the boundary node <code>k</code>.</p><p>This function should only be used after <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>, and currently is only guaranteed  to work on convex geometries. </p><p><strong>Arguments</strong></p><ul><li><code>pts</code>: The collection of points. </li><li><code>adj::Adjacent{I,E}</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph::Graph{I}</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>boundary_index_ranges</code>: The boundary index range mapping from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>boundary_map</code>: The map that handles the mapping of boundary indices to boundary segments. Sse <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>.</li><li><code>k</code>: The boundary node.</li><li><code>q</code>: The point we are searching for. </li><li><code>right_cert</code>: A certificate giving the position of <code>q</code> to the right of the <code>k</code>th point. This comes from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>left_cert</code>: A certificate giving the position of <code>q</code> to the left of the <code>k</code>th point. This comes from <a href="#DelaunayTriangulation.check_for_intersections_with_adjacent_boundary_edges"><code>check_for_intersections_with_adjacent_boundary_edges</code></a>.</li><li><code>check_existence::V=Val(has_multiple_segments(boundary_nodes)))</code>: Checks for different possible boundary indices when there are multiple segments. See <a href="../../data_structures/adjacent/#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>get_adjacent</code></a>.</li></ul><p><strong>Outputs</strong></p><p>There are several possible forms for the returned values. These are listed below, letting <code>p</code> be the <code>k</code>th point, <code>pᵢ</code> the point corresponding to  the index <code>i</code>, and <code>pⱼ</code> the point corresponding to the index <code>j</code>:</p><ul><li><code>(i, j, Certificate.Single, Certificate.Outside)</code></li></ul><p>The line <code>pq</code> intersects the edge <code>pᵢpⱼ</code>, and <code>(j, i, k)</code> is a positively oriented triangle. In particular, pᵢ is left of <code>pq</code> and <code>pⱼ</code> is right of <code>pq</code>.</p><ul><li><code>(i, j, Certificate.None, Certificate.Inside)</code></li></ul><p>The point <code>q</code> is inside the positively oriented triangle <code>(i, j, k)</code>.</p><ul><li><code>(zero(I), zero(I), Cert.None, Cert.Outside)</code></li></ul><p>The point <code>q</code> is outside of the triangulation.</p><ul><li><code>(i, j, Cert.On, Cert.Inside)</code></li></ul><p>The point <code>q</code> is on the edge <code>pᵢpⱼ</code>, and so is inside the positively oriented triangle <code>(i, j, k)</code>.</p><ul><li><code>(i, j, Cert.Right, Cert.Outside)</code></li></ul><p>The point <code>q</code> is collinear with the edge <code>pᵢpⱼ</code>, but is off of it and further into the triangulation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/point_location/initialisers.jl#L313-L352">source</a></section></article><h2 id="Basic-Description-of-the-Algorithm"><a class="docs-heading-anchor" href="#Basic-Description-of-the-Algorithm">Basic Description of the Algorithm</a><a id="Basic-Description-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Description-of-the-Algorithm" title="Permalink"></a></h2><p>Let us give a basic description of what <code>jump_and_march</code> does.</p><p>First, using <code>select_initial_point</code>, an initial point to start the algorithm is selected. This function samples some number <span>$m$</span> of points, and then selects the point that is closest to the query point <span>$q$</span>.</p><p>Let the initially selected point be <span>$p_k$</span>. We break the discussion into two cases, where <span>$p_k$</span> is an interior point and <span>$p_k$</span> is a point on the boundary.</p><p>If <span>$p_k$</span> is not a point on the boundary, then it is possible to completely rotate around the point searching for a triangle such that line <span>$\overrightarrow{p_kq}$</span> intersects an edge of the triangle. This will give us an edge <span>$e_{ij}$</span> that <span>$\overrightarrow{p_kq}$</span> intersects, and we will put <span>$p_i$</span> to the left of <span>$\overrightarrow{p_kq}$</span> and <span>$p_j$</span> to the right. The function that handles this selection is <code>select_initial_triangle_interior_node</code>, which starts by handling the case of collinear edges and then rotates around. </p><p>Now suppose that <span>$p_k$</span> is a point on the outer boundary. There are several possibilities in this case. First, <span>$\overrightarrow{p_kq}$</span> might intersect a neighbouring boundary edge; secondly, <span>$\overrightarrow{p_kq}$</span> could intersect a neighbouring interior edge; thirdly, <span>$\overrightarrow{p_kq}$</span> could point away from the boundary, meaning <span>$q$</span> is outside of the boundary. The function starts by checking the neighbouring boundary edges, done via <code>check_for_intersections_with_adjacent_boundary_edges</code>, making use of <code>get_right_boundary_node</code> and <code>get_left_boundary_node</code> to obtain the neighbouring boundary nodes. If we find that <span>$\overrightarrow{p_kq}$</span> does intersect a neighbouring boundary edge, then we can search down adjacent boundary edges via <code>search_down_adjacent_boundary_edges</code> until we either find an edge that <span>$q$</span> is on, or until we identify that <span>$q$</span> is outside of the triangulation – this function assumes the domain is convex, as triangulations being built are. If <span>$q$</span> is outside of the triangulation, then we can use the exterior variant of the jump and march algorithm, <code>exterior_jump_and_march</code>, to find the ghost triangle containing <span>$q$</span>. This functon simply rotates around the boundary until we find two ghost edges enclosing the point <span>$q$</span>. Now let us assume we did not find a neighbouring boundary edge that intersects <span>$\overrightarrow{p_kq}$</span>. When this happens, we need to check the neighbouring interior edges, done via <code>check_for_intersections_with_interior_edges_adjacent_to_boundary_node</code>, which just rotates around the edges until we find an intersection. If we have still not found any intersection then, again assuming convexity, <span>$q$</span> must be outside of the triangulation and so we use <code>exterior_jump_and_march</code>.</p><p>Now, if the algorithm is still going, then we need to start marching along the triangulation from <span>$p_k$</span> towards <span>$q$</span>. The idea is to keep marching, keeping <span>$p_i$</span> and <span>$p_j$</span> to the left and right of <span>$\overrightarrow{p_kq}$</span>, respectively, until we find a case where <span>$p_ip_jq$</span> is no longer a positively oriented triangle. When this happens, it must mean that we have passed <span>$q$</span>, and so we have found the triangle. </p><p>Let us describe how this marching is done in more detail. First, we need to be careful of boundary indices, first checking for an outer boundary index. If we have found an outer boundary index, then we have marched into the boundary, and so <span>$q$</span> will be outside of the domain, meaning we go into <code>exterior_jump_and_march</code>. If this is not the case, then we march using <code>get_adjacent</code> to step onto the next triangle from a given edge <span>$e_{ij}$</span>. Then, checking the positions of the new points relative to <span>$\overrightarrow{p_kq}$</span> and rearranging accordingly, we can step forward. We keep doing this until we get a negatively oriented triangle <span>$p_ip_jq$</span>. Unfortunately, this loop could terminate even if <span>$q$</span> is not in the found triangle, which can occasionally happen if <span>$p_ip_jq$</span> is a degenerate triangle. In this case, we just restart the jump and march algorithm. This latter worry is a very rare concern and does not alter the runtime in any significant manner.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../boundary_handling/">« Ghost Triangles and Boundary Handling</a><a class="docs-footer-nextpage" href="../pole_of_inaccessibility/">Pole of Inaccessibility and Polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 February 2023 01:31">Thursday 23 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
