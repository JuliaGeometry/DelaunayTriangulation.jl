<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Points · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/points/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Ghost Triangles and Boundary Handling</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/representative/">Representative Coordinates</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li><a class="tocitem" href="../triangles/">Triangles</a></li><li><a class="tocitem" href="../edges/">Edges</a></li><li class="is-active"><a class="tocitem" href>Points</a><ul class="internal"><li><a class="tocitem" href="#Individual-Points"><span>Individual Points</span></a></li><li><a class="tocitem" href="#Collection-of-Points"><span>Collection of Points</span></a></li></ul></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Points</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Points</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/points.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Individual-Points"><a class="docs-heading-anchor" href="#Individual-Points">Individual Points</a><a id="Individual-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Points" title="Permalink"></a></h2><p>Points are assumed to take the form <code>(x, y)</code>, but we allow for customisation in how we represent these points. The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods"><a class="docs-heading-anchor" href="#Necessary-Methods">Necessary Methods</a><a id="Necessary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getx" href="#DelaunayTriangulation.getx"><code>DelaunayTriangulation.getx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getx(p::P) where {P}</code></pre><p>Given a point <code>p</code>, returns the <code>x</code>-coordinate. The  only methods currently defined are</p><pre><code class="nohighlight hljs">getx(p::NTuple{N,T}) where {N,T}
getx(p::AbstractVector)</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.gety" href="#DelaunayTriangulation.gety"><code>DelaunayTriangulation.gety</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gety(p::P) where {P}</code></pre><p>Given a point <code>p</code>, returns the <code>y</code>-coordinate. The  only methods currently defined are</p><pre><code class="nohighlight hljs">gety(p::NTuple{N,T}) where {N,T}
gety(p::AbstractVector)</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L19-L29">source</a></section></article><h3 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getxy" href="#DelaunayTriangulation.getxy"><code>DelaunayTriangulation.getxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getxy(p)</code></pre><p>Given a point <code>p</code>, returns <code>(getx(p), gety(p))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L37-L41">source</a></section></article><h2 id="Collection-of-Points"><a class="docs-heading-anchor" href="#Collection-of-Points">Collection of Points</a><a id="Collection-of-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-Points" title="Permalink"></a></h2><p>A collection of points simply store many points. It does not need to be mutable (this may change in the future if we support mesh refinement, but it will only be needed in that case). The following methods are used, where we first list the methods that must be defined and then methods that extend these former methods. </p><h3 id="Necessary-Methods-2"><a class="docs-heading-anchor" href="#Necessary-Methods-2">Necessary Methods</a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getpoint" href="#DelaunayTriangulation.getpoint"><code>DelaunayTriangulation.getpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpoint(pts::P, i)</code></pre><p>Given a collection of points <code>pts</code>, returns a <code>Tuple</code>  of the <code>x</code> and <code>y</code> coordinates of the <code>i</code>th point in  the collection. The methods currently defined are </p><pre><code class="nohighlight hljs">getpoint(pts::AbstractVector, i)
getpoint(pts::AbstractMatrix, i)</code></pre><p>You can extend this function as you need. </p><p>It is assumed that whenever <code>i</code> is not an integer, <code>i</code> is meant to be  a point, so <code>(getx(i), gety(i))</code> would be returned in that case. This  makes it easier to use some predicates without having to know the index  of the point, simply passing the point directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L44-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point_index" href="#DelaunayTriangulation.each_point_index"><code>DelaunayTriangulation.each_point_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_point_index(pts::P) where {P}</code></pre><p>Given a collection of points <code>pts</code>, returns an iterator  over the indices of the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_point_index(pts::AbstractVector)
each_point_index(pts::AbstractMatrix)</code></pre><p>with the first returning <code>eachindex(pts)</code> and the second  returning <code>axes(pts, 2)</code>. You can extend this function  as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L130-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_point" href="#DelaunayTriangulation.each_point"><code>DelaunayTriangulation.each_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_point(pts::P) where {p}</code></pre><p>For a given collection of points <code>p</code>, returns an iterator that  goes over each point in the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_point(pts::AbstractVector)
each_point(pts::AbstractMatrix)</code></pre><p>with the first method simply returning <code>pts</code>, and the second returning  <code>eachcol(pts)</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L151-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_points" href="#DelaunayTriangulation.num_points"><code>DelaunayTriangulation.num_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_points(pts)</code></pre><p>Returns the number of points in <code>pts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.number_type" href="#DelaunayTriangulation.number_type"><code>DelaunayTriangulation.number_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_type(::Triangulation{P}) where {P}</code></pre><p>Given a triangulation <code>tri</code>, returns the type used for representing  individual coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/data_structures/triangulation.jl#L1199-L1204">source</a></section><section><div><pre><code class="nohighlight hljs">number_type(x)</code></pre><p>Given a container <code>x</code>, returns the number type used for storing coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/utils.jl#L7-L11">source</a></section></article><h3 id="Generic-Methods-2"><a class="docs-heading-anchor" href="#Generic-Methods-2">Generic Methods</a><a class="docs-heading-anchor-permalink" href="#Generic-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_point" href="#DelaunayTriangulation.get_point"><code>DelaunayTriangulation.get_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_point(pts::P, i...)</code></pre><p>Given a collection of points <code>pts</code>, returns the points  corresponding to the indices in <code>i...</code>. This simply  calls <a href="#DelaunayTriangulation.getpoint"><code>getpoint</code></a> - you do not need to  extend this method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.points_are_unique" href="#DelaunayTriangulation.points_are_unique"><code>DelaunayTriangulation.points_are_unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points_are_unique(pts)</code></pre><p>Returns <code>true</code> if <code>pts</code> has no duplicate points, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.lexicographic_order" href="#DelaunayTriangulation.lexicographic_order"><code>DelaunayTriangulation.lexicographic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lexicographic_order(pts)</code></pre><p>Returns a set of indices <code>idx</code> that gives the lexicographic ordering  of the set of points <code>pts</code>, i.e. sorting by <code>x</code> and then sorting points  with duplicate <code>x</code>-coordinates by <code>y</code>. The implementation is simply </p><pre><code class="nohighlight hljs">lexicographic_order(pts) = (sortperm ∘ collect ∘ each_point)(pts)</code></pre><p>which you might want to specialise for an easier representation of your  points <code>pts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/a3366c090a36bea21edbcf6b4deee4fa1174d2e5/src/interfaces/points.jl#L199-L210">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../edges/">« Edges</a><a class="docs-footer-nextpage" href="../boundary_nodes/">Boundary Nodes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 February 2023 01:31">Thursday 23 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
