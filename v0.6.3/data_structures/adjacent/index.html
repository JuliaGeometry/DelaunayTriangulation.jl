<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adjacent · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/data_structures/adjacent/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li><li><a class="tocitem" href="../../tessellations/plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li class="is-active"><a class="tocitem" href>Adjacent</a></li><li><a class="tocitem" href="../adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../graph/">Graph</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../triangulation/">Triangulation</a></li><li><a class="tocitem" href="../statistics/">Statistics</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Data Structures</a></li><li class="is-active"><a href>Adjacent</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adjacent</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/data_structures/adjacent.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Adjacent"><a class="docs-heading-anchor" href="#Adjacent">Adjacent</a><a id="Adjacent-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacent" title="Permalink"></a></h1><p>The <code>Adjacent</code> map is used for mapping edges to vertices that together form a positively oriented triangle. The definition of the <code>Adjacent</code> map is below:</p><pre><code class="language-julia hljs">struct Adjacent{I,E}
    adjacent::DefaultDict{E,I,I}
    function Adjacent{I,E}() where {I,E}
        A = DefaultDict{E,I,I}(I(DefaultAdjacentValue))
        adj = new{I,E}(A)
        return adj
    end
    Adjacent(adj::DefaultDict{E,I,I}) where {I,E} = new{I,E}(adj)
end</code></pre><p>We use a <code>DefaultDict</code> from DataStructures.jl for storing these relationships. We need to use a <code>DefaultDict</code> rather than a <code>Dict</code> so that we more efficiently check if an edge exists, simply seeing if <code>get_adjacent(adj, u, v)</code> returns a <code>DefaultAdjacentValue</code> (see the <code>edge_exists</code> function). We list the complete docstring for <code>Adjacent</code> below, along with individual docstrings for methods for working with <code>Adjacent</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.Adjacent" href="#DelaunayTriangulation.Adjacent"><code>DelaunayTriangulation.Adjacent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Adjacent{I,E}</code></pre><p>Struct for storing adjacency relationships for mapping edges to vertices that  together form a positively oriented triangle in an associated triangulation.  The type <code>I</code> is the integer type used, while <code>E</code> is the edge type.</p><p>See the docs for a description of how boundary edges are handled.</p><p>See also <a href="../adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>adjacent::DefaultDict{E,I,I}</code></li></ul><p>The <code>Dict</code> used for storing the edges (the keys) and the associated vertices  (the values). If <code>(u, v)</code> is not a valid edge, then <code>w = adjacent[(u, v)]</code> returns <code>0</code> (this value is defined in <code>DefaultAdjacentValue</code>). Otherwise, <code>(u, v, w)</code> is a positively oriented triangle.</p><p><strong>Constructors</strong></p><p>The adjacent map can be constructed in two ways:</p><ul><li><code>Adjacent{I, E}() where {I, E}</code></li></ul><p>Creates an empty map.</p><ul><li><code>Adjacent(adj::DefaultDict{E,I,I}) where {E,I,I}</code></li></ul><p>Creates an adjacent map from an existing <code>DefaultDict</code>.</p><p><strong>Extended help</strong></p><p>You should not work with the <code>adjacent</code> field directly. We provide the following  functions for working with <code>Adjacent</code>, where <code>adj</code> denotes an <code>Adjacent{I, E}</code> type. (Type information in the function signatures is omitted.)</p><p><strong>Accessors</strong></p><ul><li><code>get_adjacent(adj)</code></li><li><code>get_adjacent(adj, uv)</code> or <code>get_adjacent(adj, u, v)</code></li></ul><p>In the latter methods, you can also use the keyword argument <code>check_existence</code> to  declare whether to check that the edge exists. This would be used if you need  to be careful about different boundary indices on the same boundary curve. The  default value is <code>Val(false)</code>, meaning this isn&#39;t checked.</p><p><strong>Mutators</strong></p><ul><li><code>add_adjacent!(adj, uv, w)</code> or <code>add_adjacent!(adj, u, v, w)</code></li><li><code>delete_adjacent!(adj, uv)</code> or <code>delete_adjacent!(adj, u, v)</code></li><li><code>add_triangle!(adj, i, j, k)</code> or <code>add_triangle!(adj, T)</code></li><li><code>add_triangle!(adj, T...)</code></li><li><code>delete_triangle!(adj, i, j, k)</code> or <code>delete_triangle!(adj, T)</code></li><li><code>delete_triangle!(adj, T...)</code></li><li><code>clear_empty_keys!(adj)</code></li></ul><p><strong>Iteration</strong></p><p>You can also iterate over <code>Adjacent</code> maps the same way as you would  with a <code>Dict</code>, e.g.</p><pre><code class="language-julia hljs">for (edge, vertex) in adj 
    get_adjacent(adj, edge) == vertex 
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Multiple boundary segments</header><div class="admonition-body"><p>Note that in the case that you have multiple boundary indices, this iteration  may not be safe the iteration doesn&#39;t make use of <code>get_adjacent</code>, which  knows how to handle boundary indices properly (if you have just a single  boundary, do not worry).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L1-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}" href="#DelaunayTriangulation.get_adjacent-Tuple{DelaunayTriangulation.Adjacent}"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(adj::Adjacent)</code></pre><p>Given the adjacent map <code>adj</code>, returns the <code>adjacent</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_adjacent-Union{Tuple{V}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E, V}" href="#DelaunayTriangulation.get_adjacent-Union{Tuple{V}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, E}} where {I, E, V}"><code>DelaunayTriangulation.get_adjacent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adjacent(adj::Adjacent{I,E}, uv::E; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}
get_adjacent(adj::Adjacent{I,E}, u, v; check_existence::V = Val(false), boundary_index_ranges=nothing) where {I,E,V}</code></pre><p>Given the adjacent map <code>adj</code> and an edge <code>(u, v)</code>, returns the vertex <code>w</code>  such that <code>(u, v, w)</code> is a positively oriented triangle in the underlying triangulation.</p><p>In the case of a ghost edge, <code>check_existence = Val(true)</code> may be useful in case the  boundary curve has multiple segments, meaning multiple boundary indices could correspond  to the same same curve. If this is the case, then <code>boundary_index_ranges</code> should also be a <code>Dict</code> from <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>, so that all possible valid boundary indices can be checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}" href="#DelaunayTriangulation.add_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any, Any}"><code>DelaunayTriangulation.add_adjacent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_adjacent!(adj::Adjacent, uv, w)
add_adjacent!(adj::Adjacent{I,E}, u, v, w) where {I,E}</code></pre><p>Given the adjacent map <code>adj</code>, an edge <code>(u, v)</code>, and a vertex <code>w</code>, adds  the edge <code>(u, v)</code> with corresponding value <code>w</code> into the adjacent map  so that <code>(u, v, w)</code> is a positively oriented triangle in the  underlying triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}" href="#DelaunayTriangulation.delete_adjacent!-Tuple{DelaunayTriangulation.Adjacent, Any}"><code>DelaunayTriangulation.delete_adjacent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_adjacent!(adj::Adjacent, uv)
delete_adjacent!(adj::Adjacent{I,E}, u, v) where {I,E}</code></pre><p>Given the adjacent map <code>adj</code> and an edge <code>(u, v)</code>, deletes the  edge <code>(u, v)</code> from the adjacent map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}" href="#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>DelaunayTriangulation.add_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_triangle!(adj::Adjacent, i, j, k)</code></pre><p>Given an adjacent map <code>adj</code> and indices <code>(i, j, k)</code> representing some triangle,  adds that triangle into the adjacent map. In particular, adds the edges <code>(i, j)</code>, <code>(j, k)</code>, and <code>(k, i)</code> into <code>adj</code> with corresponding values <code>k</code>, <code>i</code>, and <code>j</code>,  respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L174-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}" href="#DelaunayTriangulation.add_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}"><code>DelaunayTriangulation.add_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_triangle!(adj::Adjacent, T...)</code></pre><p>Given an adjacent map <code>adj</code> and triangles <code>T...</code>, adds the  triangles into <code>adj</code>. See also <a href="#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>add_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V&lt;:Integer,Ts&lt;:Adjacent{I,E}}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}" href="#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>DelaunayTriangulation.delete_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_triangle!(adj::Adjacent, i, j, k)</code></pre><p>Given an adjacent map <code>adj</code> and indices <code>(i, j, k)</code> representing some triangle,  deletes that triangle into the adjacent map. In particular, deletes the edges <code>(i, j)</code>, <code>(j, k)</code>, and <code>(k, i)</code> from <code>adj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L207-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}" href="#DelaunayTriangulation.delete_triangle!-Tuple{DelaunayTriangulation.Adjacent, Any}"><code>DelaunayTriangulation.delete_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_triangle!(adj::Adjacent, T...)</code></pre><p>Given an adjacent map <code>adj</code> and triangles <code>T...</code>, deletes the  triangles from <code>adj</code>. See also <a href="#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{V}, Tuple{E}, Tuple{I}, Tuple{Ts, V, V, V}} where {I, E, V&lt;:Integer, Ts&lt;:DelaunayTriangulation.Adjacent{I, E}}"><code>delete_triangle!(::Ts, ::V, ::V, ::V) where {I,E,V&lt;:Integer,Ts&lt;:Adjacent{I,E}}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent}" href="#DelaunayTriangulation.clear_empty_keys!-Tuple{DelaunayTriangulation.Adjacent}"><code>DelaunayTriangulation.clear_empty_keys!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_empty_keys!(adj::Adjacent)</code></pre><p>Given an <a href="#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code>, removes any edges that  map to 0`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/37438a16c544bad67e4142ee18ffc56ed7d01f2a/src/data_structures/adjacent.jl#L243-L248">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../boundary_handling/">« Boundary Handling</a><a class="docs-footer-nextpage" href="../adjacent2vertex/">Adjacent2Vertex »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 11 May 2023 01:19">Thursday 11 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
