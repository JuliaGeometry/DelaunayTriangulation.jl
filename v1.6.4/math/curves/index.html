<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Curves · DelaunayTriangulation.jl</title><meta name="title" content="Curves · DelaunayTriangulation.jl"/><meta property="og:title" content="Curves · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Curves · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curves/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curves/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/math/curves/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/weighted/">Weighted Triangulations</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-11" type="checkbox"/><label class="tocitem" for="menuitem-2-11"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li><li><a class="tocitem" href="../../tutorials/clipped_polygon/">Clipping to a Generic Convex Polygon</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/power/">Power Diagrams</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../refinement/">Mesh Refinement</a></li><li class="is-active"><a class="tocitem" href>Curves</a><ul class="internal"><li><a class="tocitem" href="#AbstractParametricCurve"><span>AbstractParametricCurve</span></a></li><li><a class="tocitem" href="#LineSegment"><span>LineSegment</span></a></li><li><a class="tocitem" href="#CircularArc"><span>CircularArc</span></a></li><li><a class="tocitem" href="#EllipticalArc"><span>EllipticalArc</span></a></li><li><a class="tocitem" href="#BezierCurve"><span>BezierCurve</span></a></li><li><a class="tocitem" href="#BSpline"><span>BSpline</span></a></li><li><a class="tocitem" href="#CatmullRomSpline"><span>CatmullRomSpline</span></a></li></ul></li><li><a class="tocitem" href="../curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../weighted/">Weighted Delaunay Triangulations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../power/">Power Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Curves</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Curves</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/math/curves.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Curves"><a class="docs-heading-anchor" href="#Curves">Curves</a><a id="Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Curves" title="Permalink"></a></h1><p>In this section we discuss the mathematics behind the curves we provide in this package, and the operations that we perform on curves.</p><h2 id="AbstractParametricCurve"><a class="docs-heading-anchor" href="#AbstractParametricCurve">AbstractParametricCurve</a><a id="AbstractParametricCurve-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractParametricCurve" title="Permalink"></a></h2><p>Before we get into the curves themselves, let us first discuss what we need from a parametric curve, i.e. for a curve subtyping <a href="#AbstractParametricCurve"><code>AbstractParametricCurve</code></a>. We let <span>$\vb r \colon [0, 1] \to \mathbb R^2$</span> denote a parametric curve, and we always assume the curve to be non-intersecting (except at the endpoints) and three times continuously differentiable. For the discussion below, there may be some curves which take a simpler approach than the general approach described, and this will be indicated later when we discuss these specific curves. </p><h3 id="Arc-length"><a class="docs-heading-anchor" href="#Arc-length">Arc length</a><a id="Arc-length-1"></a><a class="docs-heading-anchor-permalink" href="#Arc-length" title="Permalink"></a></h3><p>One important quantity to compute is the arc length over some interval <span>$t_1 \leq t \leq t_2$</span> along the curve. In general, this is given by the integral</p><p class="math-container">\[s(t_1, t_2) = \int_{t_1}^{t_2} \|\vb r&#39;(t)\| \, \mathrm dt,\]</p><p>which is typically computed using numerical integration. In this package, we use Gauss-Legendre quadrature so that</p><p class="math-container">\[s(t_1, t_2) \approx \frac{t_2 - t_1}{2} \sum_{i=1}^n w_i \left\|\vb r&#39;\left(\frac{t_2 - t_1}{2}\xi_i + \frac{t_1 + t_2}{2}\right)\right\|,\]</p><p>where <span>$\xi_i$</span> are the nodes and <span>$w_i$</span> are the weights of the Gauss-Legendre quadrature rule, and <span>$n$</span> are the number of nodes in use. We use <span>$n = 250$</span> for all integrals in this package.</p><h3 id="Curvature"><a class="docs-heading-anchor" href="#Curvature">Curvature</a><a id="Curvature-1"></a><a class="docs-heading-anchor-permalink" href="#Curvature" title="Permalink"></a></h3><p>The curvature of a curve describes how much the curve deviates from a straight line at a given point. It is defined as </p><p class="math-container">\[\kappa(t) = \frac{\|\vb r&#39;(t) \times \vb r&#39;&#39;(t)\|}{\|\vb r&#39;(t)\|^3},\]</p><p>where <span>$\times$</span> denotes the cross product; in <span>$\mathbb R^2$</span>, we are defining <span>$\vb u \times \vb v = u_1v_2 - u_2v_1$</span>. Writing <span>$\vb r(t) = (x(t), y(t))$</span>, this can be written as </p><p class="math-container">\[\kappa(t) = \frac{x&#39;(t)y&#39;&#39;(t) - y&#39;(t)x&#39;&#39;(t)}{(x&#39;(t)^2 + y&#39;(t)^2)^{3/2}}.\]</p><h3 id="Total-variation"><a class="docs-heading-anchor" href="#Total-variation">Total variation</a><a id="Total-variation-1"></a><a class="docs-heading-anchor-permalink" href="#Total-variation" title="Permalink"></a></h3><p>The total variation of <span>$\vb r(t)$</span> over <span>$t_1 \leq t \leq t_2$</span> is defined as the total absolute change in the tangent angle, which we can write as</p><p class="math-container">\[TV(t_1, t_2) = \int_{C(t_1, t_2)} |\mathrm d\theta|,\]</p><p>where <span>$\theta$</span> is the tangent angle of the curve, and <span>$C(t_1, t_2)$</span> is the curve segment from <span>$t_1$</span> to <span>$t_2$</span>. This is also called the total absolute curvature, since <span>$|\mathrm d\theta| = |\kappa(s)|\mathrm ds$</span> (treating <span>$s$</span> as the arc length parameter). Thus,</p><p class="math-container">\[TV(t_1, t_2) = \int_{t_1}^{t_2} |\kappa(t)|\|\vb r&#39;(t)\|\, \mathrm dt,\]</p><p>where we have used <span>$\mathrm ds = \|\vb r&#39;(t)\|\, \mathrm dt$</span>. We evaluate this using numerical integration just as we did for arc length, writing</p><p class="math-container">\[TV(t_1, t_2) \approx \frac{t_2 - t_1}{2} \sum_{i=1}^n w_i \left|\kappa\left(\frac{t_2 - t_1}{2}\xi_i + \frac{t_1 + t_2}{2}\right)\right|\left\|\vb r&#39;\left(\frac{t_2 - t_1}{2}\xi_i + \frac{t_1 + t_2}{2}\right)\right\|.\]</p><p>The reason that total variation is important is that it gives a measure of how much the curve is bending over the interval <span>$t_1 \leq t \leq t_2$</span>, meaning we can use the total variation to assess how many edges are needed to give a reasonable piecewise linear approximation to the curve.</p><p>There is a way to evaluate <span>$TV(t_1, t_2)$</span> without computing the integral. By default, any new <code>AbstractParametricCurve</code> will do so, but for the curves we have implemented in this package we apply the following idea. First, note that the total variation <span>$TV(t_1, t_2)$</span> over some curve where the curve&#39;s orientation is monotone is simply the angle between the tangent vectors at the endpoints. To see this, note that since the orientation is monotone the angle <span>$\theta$</span> is monotone, and so the total change in the angle is simply the difference in the angles at the endpoints. With this idea, we take <span>$C(t_1, t_2)$</span> and write <span>$C(t_1, t_2) = \cup_{i=1}^m C_i$</span> where <span>$C_i \cap C_j = \emptyset$</span> for <span>$i \neq j$</span> and <span>$C_i$</span> is a curve segment where the orientation is monotone. Thus, the integral can be evaluated by simply summing the angles between the tangent vectors at the endpoints of each <span>$C_i$</span>.</p><p>One complication with the above approach is that actually finding the <span>$C_i$</span> can be difficult. To do so, we need to understand where the curve&#39;s orientation changes. There are five cases where this can occur that we list below, letting <span>$t^*$</span> be a point where the orientation changes and <span>$\vb r(t) = (x(t), y(t))$</span>:</p><ol><li>Horizontal turning point: <span>$x&#39;(t^*) = 0$</span>.</li><li>Vertical turning point: <span>$y&#39;(t^*) = 0$</span>.</li><li>Horizontal inflection point: <span>$x&#39;&#39;(t^*) = 0$</span> and <span>$x&#39;&#39;&#39;(t^*) \neq 0$</span>.</li><li>Vertical inflection point: <span>$y&#39;&#39;(t^*) = 0$</span> and <span>$y&#39;&#39;&#39;(t^*) \neq 0$</span>.</li><li>Inflection point: <span>$\kappa(t^*) = 0$</span>.</li></ol><p>These cases do not have to occur simultaneously - any of them is sufficient to potentially cause a change in orientation; in our implementation, for cases 3 and 4 we do not check whether <span>$x&#39;&#39;&#39;(t^*)$</span> or <span>$y&#39;&#39;&#39;(t^*)$</span> is zero. Note that the first four conditions together are not necessarily needed for finding these monotone pieces, but they guarantee that the change in orientation is at most <span>$\pi/2$</span>, making it easier to compute the total change in orientation (since a change in orientation of <span>$\beta$</span> could also be <span>$2\pi - \beta$</span> if <span>$\beta &gt; \pi/2$</span>). To find these points <span>$t^*$</span>, we use Newton&#39;s method on all of the respective functions. So, when initialising a curve that uses this approach, we first find all <span>$t^* \in [0, 1]$</span> where any of these changes occur, and order them so that <span>$0 \leq t_1^* \leq \cdots \leq t_m^* \leq 1$</span>. These values define the monotone pieces that the curve is split into. An example of these <em>orientation markers</em> <span>$t^*$</span> is shown below, where we show the markers on the curve using red dots.</p><img src="ca6821c4.png" alt="Example block output"/><p>There are many orientation markers on this curve. Only two of these come from <span>$\kappa(t) = 0$</span>, with all the others coming from <span>$x&#39;, y&#39;, x&#39;&#39;$</span>, and <span>$y&#39;&#39;$</span>, as we can see from the graphs shown.</p><h3 id="Point-on-a-curve-closest-to-a-point"><a class="docs-heading-anchor" href="#Point-on-a-curve-closest-to-a-point">Point on a curve closest to a point</a><a id="Point-on-a-curve-closest-to-a-point-1"></a><a class="docs-heading-anchor-permalink" href="#Point-on-a-curve-closest-to-a-point" title="Permalink"></a></h3><p>An important problem is finding the point on a curve <span>$\vb r(t)$</span> that is closest to a given point <span>$p$</span>. Our generic approach to this relies on there being a lookup table for <span>$\vb r(t)$</span> which stores the values <span>$\vb r(t_i)$</span> for <span>$i=1,2,\ldots,n$</span>, where <span>$t_i = (i-1)/(n-1)$</span> to allow for binary search to be used. </p><p>The approach starts by computing <span>$(i, \delta^2)$</span>, where <span>$i$</span> is the index so that the point <span>$q = \vb r(t_i)$</span> in the lookup table is closest to <span>$p$</span>, and <span>$\delta = \|p - q\|$</span>. We can then apply binary search in the following way to find an approximation to the closest point on <span>$\vb r(t)$</span> closest to <span>$p$</span> up to some tolerance <span>$\varepsilon$</span> (<span>$\varepsilon = 10^{-12}$</span> in this package); in what follows, we assume <span>$1 &lt; i &lt; n$</span>, but these boundary cases can be handled in a similar way:</p><ol><li>First, let <span>$t_\ell = t_{i-1}$</span>, <span>$t_c = t_i$</span>, and <span>$t_r = t_{i+1}$</span>, and compute <span>$w = t_r - t_\ell$</span>. If <span>$w &lt; \varepsilon$</span>, then we are done, otherwise we go to step 2.</li><li>Compute <span>$t_{\ell c} = (t_\ell + t_c) / 2$</span>, <span>$t_{cr} = (t_c + t_r) / 2$</span>, <span>$\delta_{\ell c} = \|p - \vb r(t_{\ell c})\|$</span>, and <span>$\delta_{cr} = \|p - \vb r(t_{cr})\|$</span>. If <span>$\delta_{\ell c} &lt; \delta_{c r}$</span>, then we choose the left-middle to be the new center point, replacing <span>$t_r$</span> with <span>$t_c$</span> and <span>$t_c$</span> with <span>$t_{\ell c}$</span>. Otherwise, we choose the right-middle to be the new center point, replacing <span>$t_\ell$</span> with <span>$t_c$</span> and <span>$t_c$</span> with <span>$t_{cr}$</span>. We then go back to step 1 with <span>$w = t_r - t_\ell$</span>.</li></ol><p>Once the above procedure converges, the final value of <span>$t_c$</span> gives the point on <span>$\vb r(t)$</span> that is closest to <span>$p$</span>, i.e. <span>$\vb r(t_c)$</span> is the approximation to the closest point on <span>$\vb r(t)$</span> to <span>$p$</span>. </p><p>An example of this procedure is shown below: The point of interest is shown in red, and the lookup points are shown in blue. The lookup point closest to the point of interest is shown via the green line, which defines <span>$t_\ell \leq t_c \leq t_r$</span>, and the magenta line shows the section of the curve corresponding to this interval <span>$[t_\ell, t_r]$</span>. The black dot shows the closest point on the curve to the point of interest. The binary search for this problem would start by shrinking into the interval <span>$[t_c, t_r]$</span>, replacing <span>$t_c$</span> by <span>$(t_c + t_r)/2$</span>, since <span>$p$</span> is closer to that side of <span>$t_c$</span> than to <span>$[t_\ell, t_c]$</span>.</p><img src="7230b61a.png" alt="Example block output"/><h3 id="Position-of-a-point-relative-to-a-curve"><a class="docs-heading-anchor" href="#Position-of-a-point-relative-to-a-curve">Position of a point relative to a curve</a><a id="Position-of-a-point-relative-to-a-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Position-of-a-point-relative-to-a-curve" title="Permalink"></a></h3><p>It is important that we know how to find the position of a point <span>$p$</span> relative to some curve <span>$\vb r(t)$</span>, meaning whether <span>$p$</span> is left or right of <span>$\vb r(t)$</span>. The approach we take for this is relatively simple:</p><ol><li>First, find <span>$t^*$</span> so that <span>$q = \vb r(t^*)$</span> is the closest point on <span>$\vb r(t)$</span> to <span>$p$</span>.</li><li>Compute <span>$T = \vb r&#39;(t^*)$</span> and construct the line segment <span>$L$</span> that connects <span>$q$</span> and <span>$T$</span>.</li><li>The position of <span>$p$</span> is then determined by the position of <span>$p$</span> relative to <span>$L$</span>.</li></ol><p>In the example below, <span>$p$</span> would be right of the curve as it is to the right of the tangent vector <span>$T$</span>.</p><img src="6b6c0b99.png" alt="Example block output"/><h3 id="Computing-equidistant-splits"><a class="docs-heading-anchor" href="#Computing-equidistant-splits">Computing equidistant splits</a><a id="Computing-equidistant-splits-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-equidistant-splits" title="Permalink"></a></h3><p>We may want to split a curve between two points <span>$t_1 \leq t \leq t_2$</span> at a point <span>$t^*$</span> such that <span>$s(t_1, t^*) = s(t^*, t_2)$</span>. This is done using a simple bisection method:</p><ol><li>Compute <span>$s_{12} = s(a, b)$</span>, let <span>$s = s_{12} / 2$</span>, and set <span>$t = (a + t_2) / 2$</span>, where <span>$a = t_1$</span>.</li><li>For 100 iterations, do: Compute <span>$s&#39; = s(a, t)$</span>. If <span>$|s&#39; - s| &lt; \varepsilon_1$</span> or <span>$|b - a| &lt; \varepsilon_2$</span>, then break and return <span>$t = t^*$</span>. Otherwise, replace <span>$t_1$</span> with <span>$t$</span> if <span>$s&#39; &lt; s$</span>, and replace <span>$t_2$</span> with <span>$t$</span> otherwise. Finally, let <span>$t = (t_1 + t_2) / 2$</span> and continue iterating.</li><li>Return <span>$t$</span> as the equidistant split point.</li></ol><h3 id="Computing-equivariation-splits"><a class="docs-heading-anchor" href="#Computing-equivariation-splits">Computing equivariation splits</a><a id="Computing-equivariation-splits-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-equivariation-splits" title="Permalink"></a></h3><p>Another important operation is the computation of a point <span>$t$</span> that splits a given curve <span>$\vb r(t)$</span> between two points <span>$t_1 \leq t \leq t_2$</span> at a point <span>$t^*$</span> such that <span>$TV(t_1, t^*) = TV(t^*, t_2)$</span>. This is called an equivariation split, and is useful as it gives a way to divide a curve into two halves in a more natural way than using, say, an equidistant split which might not be as appropriate a split for certain curves. The computation of <span>$t^*$</span> is done using a simple bisection method that follows the exact same approach as for equidistant splits, except that instead of computing arc length we compute the total variation, and we initialise <span>$t$</span> as the equidistant split rather than the midpoint of the interval.</p><h3 id="Computing-the-inverse-of-a-curve"><a class="docs-heading-anchor" href="#Computing-the-inverse-of-a-curve">Computing the inverse of a curve</a><a id="Computing-the-inverse-of-a-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-inverse-of-a-curve" title="Permalink"></a></h3><p>We often need to find the point <span>$t$</span> that corresponds to a point <span>$q$</span> on a curve <span>$\vb r(t)$</span>. This is done by simply finding the closest point on the curve to <span>$q$</span> and returning the parameter value of that point.</p><h3 id="Computing-the-angle-between-two-curves"><a class="docs-heading-anchor" href="#Computing-the-angle-between-two-curves">Computing the angle between two curves</a><a id="Computing-the-angle-between-two-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-angle-between-two-curves" title="Permalink"></a></h3><p>Given two curves <span>$\vb r_1$</span> and <span>$\vb r_2$</span>, a problem of interest is to consider the angle between them at some point <span>$t$</span>. This is done by computing the tangent vectors at the point <span>$t$</span> for both curves, and then computing the angle between these two tangent vectors. Computing these angles is needed during mesh refinement, since we need to protect against small angles.</p><h3 id="Computing-the-intersection-of-a-curve-with-a-circle"><a class="docs-heading-anchor" href="#Computing-the-intersection-of-a-curve-with-a-circle">Computing the intersection of a curve with a circle</a><a id="Computing-the-intersection-of-a-curve-with-a-circle-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-intersection-of-a-curve-with-a-circle" title="Permalink"></a></h3><p>For mesh refinement we need to use concentric circular shells to protect against small angles. For curves, this means that we need to know how to compute the intersection of a circle with a given curve. In particular, given a circle of radius <span>$r$</span> centered at <span>$\vb r(t_1)$</span>, we need to find the first intersection <span>$t^*$</span> of the curve with the circle, where <span>$t_1 \leq t \leq t_2$</span>, assuming that such an intersection exists. </p><p>The procedure for this problem starts by computing an interval <span>$[t_i, t_j]$</span> to be used for computing <span>$t^*$</span> using a bisection method. To find <span>$t_i$</span> and <span>$t_j$</span>, we initially set <span>$t_i = t_1$</span> and <span>$t_j = t_2$</span>. Then, for <span>$n = 1, 2, \ldots, 500$</span>: Compute <span>$t_n = t_1 + (n - 1)(t_2 - t_1)/(500 - 1)$</span> and let <span>$q = \vb r(t_n)$</span>. If <span>$\|p - q\| &gt; r$</span> we set <span>$t_j = t_n$</span> and return <span>$[t_i, t_j]$</span>, else we set <span>$t_i = t_n$</span> and continue. There is also a method for finding <span>$[t_i, t_j]$</span> using a lookup table, but we do not describe that here. Once we have this interval <span>$[t_i, t_j]$</span>, a bisection method is used to find <span>$t^*$</span>, remembering that we are trying to solve <span>$\|\vb r(t) - \vb r(t^*)\| = r$</span>. An example of such an intersection is shown below. The red curve shows the portion of the curve over an interval <span>$[t_1, t_2]$</span>, and the green circle shows the circle of radius <span>$r$</span> centered at a point <span>$\vb r(t_1)$</span>. The blue point shows the first intersection of the curve with the circle. The other intersection is ignored as it is not on the red portion.</p><img src="3e4a461b.png" alt="Example block output"/><h2 id="LineSegment"><a class="docs-heading-anchor" href="#LineSegment">LineSegment</a><a id="LineSegment-1"></a><a class="docs-heading-anchor-permalink" href="#LineSegment" title="Permalink"></a></h2><p>Now we discuss in detail all the curves we provide in this package, starting with <a href="#LineSegment"><code>LineSegment</code></a>. We represent line segments as oriented segments between points <span>$p$</span> and <span>$q$</span> parametrised by <span>$\vb r(t) = p + t(q-p)$</span> for <span>$0 \leq t \leq 1$</span>. The implementation of the above operations for <code>LineSegment</code> is straightforward, and we do not discuss them here.</p><h2 id="CircularArc"><a class="docs-heading-anchor" href="#CircularArc">CircularArc</a><a id="CircularArc-1"></a><a class="docs-heading-anchor-permalink" href="#CircularArc" title="Permalink"></a></h2><p>The curve <a href="#CircularArc"><code>CircularArc</code></a> is for representing a circular arc, meaning a part of a circle with radius <span>$r$</span> and center <span>$\vb c$</span> spanning some angle <span>$\theta_1 \leq \theta \leq \theta_2$</span>, parametrised over <span>$0 \leq t \leq 1$</span>. We parametrise this arc using </p><p class="math-container">\[\vb r(t) = \vb c + r(\cos \theta_t, \sin \theta_t),\]</p><p>where <span>$\theta_t = \theta_1 + t\Delta\theta$</span> and <span>$\Delta\theta=\theta_2-\theta_1$</span>.  With this parametrisation, we also have</p><p class="math-container">\[\begin{aligned}
\vb r&#39;(t) &amp;= \left(-r\Delta\theta \sin \theta_t, r\Delta\theta \cos \theta_t\right), \\
\vb r&#39;&#39;(t) &amp;= \left(r\Delta\theta^2 cos \theta_t, r\Delta\theta^2 \sin\theta_t\right).
\end{aligned}\]</p><p>In addition:</p><ul><li>To determine the position of a point relative to the circle, we simply use the <code>in_circle</code> predicate. </li><li>The arc length <span>$s(t_1, t_2)$</span> is simply <span>$s(t_1, t_2) = r|\Delta\theta|(t_2-t_1)$</span>.</li><li>The curvature is <span>$\kappa(t) = \text{sgn}(\Delta\theta) / r$</span>.</li><li>The total variation is <span>$TV(t_1, t_2) = |\Delta\theta|(t_2 - t_1)$</span>.</li><li>The equidistant and equivariation splits are both <span>$t^* = (t_1 + t_2) / 2$</span>.</li><li>Given a point <span>$p$</span> on the circle, its inverse is <span>$t^* = (\theta - \theta_1) / \Delta \theta$</span>, where <span>$\theta = \arctan(p_y - c_y, p_x - c_x)$</span>. If <span>$t^* &lt; 0$</span>, the inverse is instead <span>$t^* + 2\pi/|\Delta\theta|$</span>; if <span>$t^* &gt; 1$</span>, the inverse is instead <span>$t^* - 2\pi/|\Delta\theta|$</span>.</li></ul><h2 id="EllipticalArc"><a class="docs-heading-anchor" href="#EllipticalArc">EllipticalArc</a><a id="EllipticalArc-1"></a><a class="docs-heading-anchor-permalink" href="#EllipticalArc" title="Permalink"></a></h2><p>An <a href="#EllipticalArc"><code>EllipticalArc</code></a> is used to represent an arc of an ellipse, defined by a center <span>$\vb c$</span>, horizontal radius <span>$\alpha$</span>, vertical radius <span>$\beta$</span>, a rotation angle <span>$\theta$</span>, a start angle <span>$\theta_1$</span> (as measured from the center), and a final angle <span>$\theta_2$</span>. We define <span>$\Delta\theta=\theta_2-\theta_1$</span>. The parametrisation of this arc is</p><p class="math-container">\[\vb r(t) = \begin{bmatrix} c_x + \alpha \cos(\theta_t) \cos \theta - \beta \sin(\theta_t) \sin \theta \\ c_y + \alpha \cos(\theta_t) \sin \theta + \beta \sin(\theta_t) \cos \theta \end{bmatrix},\]</p><p>where <span>$\theta_t = \theta_1 + t\Delta\theta$</span>. The derivatives of <span>$\vb r(t)$</span> are given by</p><p class="math-container">\[\begin{aligned}
\vb r&#39;(t) &amp;= \Delta\theta\begin{bmatrix} -\alpha \sin(\theta_t)\cos\theta-\beta \cos(\theta_t)\sin\theta \\ -\alpha\sin(\theta_t)\sin\theta+\beta\cos(\theta_t)\cos\theta\end{bmatrix}, \\
\vb r&#39;&#39;(t) &amp;= \Delta\theta^2 \begin{bmatrix} -\alpha\cos(\theta_t)+\beta\sin(\theta_t)\sin\theta \\ -\alpha\cos(\theta_t)\sin\theta-\beta\sin(\theta_t)\cos\theta \end{bmatrix}.
\end{aligned}\]</p><p>The curvature is given by</p><p class="math-container">\[\kappa(t) = \text{sgn}(\Delta\theta)\frac{\alpha\beta}{\left(\alpha^2\sin^2(\theta_t)+\beta^2\cos^2(\theta_t)\right)^{3/2}}.\]</p><p>The total variation is easily computed by simply taking the angle between the tangent vectors at the endpoints since the orientation is monotone.</p><p>To determine the position of a point relative to the arc, we transform into coordinates where the ellipse becomes a unit circle and consider the position of the transformed coordinates. In particular, for a point <span>$p = (x, y)$</span>, we transform it into </p><p class="math-container">\[p&#39; = \left(\frac{(x - c_x)\cos \theta + (y - c_y) \sin \theta}{\alpha}, \frac{-(x - c_x)\sin \theta + (y - c_y) \cos \theta}{\beta}\right),\]</p><p>and then compare it to the unit circle.</p><p>The inverse of a point <span>$p$</span> is computed as follows. First, compute</p><p class="math-container">\[(x&#39;, y&#39;) = \left(\frac{(p_x - c_x)\cos\theta + (p_y - c_y)\sin\theta}{\alpha}, \frac{-(p_x-c_x)\sin\theta+(p_y-c_y)\cos\theta}{\beta}\right),\]</p><p>and then <span>$t&#39; = \arctan(y&#39;, x&#39;)$</span> modulo <span>$2\pi$</span>. Finally, <span>$t^* = (t&#39; - \theta_1) / \Delta\theta$</span>; if <span>$t^* &lt; 0$</span>, the inverse is instead <span>$t^* + 2\pi/|\Delta\theta|$</span>; if <span>$t^* &gt; 1$</span>, the inverse is instead <span>$t^* - 2\pi/|\Delta\theta|$</span>.</p><h2 id="BezierCurve"><a class="docs-heading-anchor" href="#BezierCurve">BezierCurve</a><a id="BezierCurve-1"></a><a class="docs-heading-anchor-permalink" href="#BezierCurve" title="Permalink"></a></h2><p>The next curve we discuss is the <a href="#BezierCurve"><code>BezierCurve</code></a>. Bézier curves are curves that are defined by a set of control points. They are not interpolating curves, but their shape can be highly controlled using the control points. A great resource on Bézier curves is <a href="https://pomax.github.io/bezierinfo/">this primer</a>. The precise definition of Bézier curves will not be delved into here. </p><p>To write down the parametrisation of a Bézier curve, let the control points be <span>$\vb p_1, \ldots, \vb p_n$</span>. Our parametrisation is then</p><p class="math-container">\[\vb r(t) = \sum_{i=0}^{n-1} \binom{n-1}{i}(1-t)^{n-1-i}t^i\vb p_{i+1}.\]</p><p>This is not the form we use to evaluate <span>$\vb r(t)$</span>, though. Instead, de Casteljau&#39;s algorithm is used to evaluate the curve, a recursive algorithm for evaluating <span>$\vb r(t)$</span>.</p><p>To differentiate <span>$\vb r(t)$</span>, we can use the fact that the derivative of an <span>$(n-1)$</span>th degree Bézier curve (our curve is of degree <span>$n-1$</span>) is an <span>$(n-2)$</span>th degree Bézier curve with control points <span>$\vb p_{i+1} - \vb p_i$</span>. Thus, differentiating <span>$\vb r(t)$</span> is the same as applying de Casteljau&#39;s algorithm to an <span>$(n-2)$</span>th degree Bézier curve with control points  <span>$\vb p_{i+1} - \vb p_i$</span>. The same is true for twice and thrice differentiating <span>$\vb r(t)$</span>; for the second derivatives the control points are <span>$\vb p_{i+2} - 2\vb p_{i+1} + \vb p_i$</span>, and for the third derivatives the control points are <span>$\vb p_{i+3} - 3\vb p_{i+2} + 3\vb p_{i+1} - \vb p_i$</span>.</p><p>For all the other operations, we use the generic approaches previously described, as Bézier curves do not lend themselves nicely to simple formulas for these operations.</p><h2 id="BSpline"><a class="docs-heading-anchor" href="#BSpline">BSpline</a><a id="BSpline-1"></a><a class="docs-heading-anchor-permalink" href="#BSpline" title="Permalink"></a></h2><p>The next curve we discuss is the <a href="#BSpline"><code>BSpline</code></a>. B-splines are controlled by a set of control points and a set of knots. They are not interpolating curves. In our implementation, we do not allow for general knots to be provided, and the spline always goes through the first and last points, but not any of the intermediate points. Rather than go through the precise definition here, you are better off reading for example <a href="https://pomax.github.io/bezierinfo/#bsplines">this section of the primer here</a>, or <a href="https://link.springer.com/book/10.1007/978-3-642-97385-7"><em>The NURBs Book</em></a> by Piegl and Tiller (1997).</p><p>For our implementation, you just need to know that we use de Boor&#39;s algorithm for evaluating a B-spline. Similarly, since the derivative of a B-spline is just another B-spline, we can use de Boor&#39;s algorithm to differentiate a B-spline, and similarly for its second and third derivatives. For all the other operations we use the generic approaches previously described just as we did for Bézier curves.</p><h2 id="CatmullRomSpline"><a class="docs-heading-anchor" href="#CatmullRomSpline">CatmullRomSpline</a><a id="CatmullRomSpline-1"></a><a class="docs-heading-anchor-permalink" href="#CatmullRomSpline" title="Permalink"></a></h2><p>We now discuss Catmull-Rom splines, which is an interpolating spline defined by a set of piecewise cubic polynomials. To discuss these splines, we need to consider the Catmull-Rom spline defined by a set of four points <span>$\vb p_0, \vb p_1, \vb p_2, \vb p_3$</span>. This is a cubic polynomial of the form <span>$\vb q(t) = \vb a t^3 + \vb b t^2 + \vb c t + \vb d$</span> over <span>$0 \leq t \leq 1$</span> that interpolates the four points, but is drawn only between <span>$\vb p_2$</span> and <span>$\vb p_3$</span> with <span>$\vb q(0) = \vb p_1$</span> and <span>$\vb q(1) = \vb p_2$</span>. We also define two parameters <span>$\alpha$</span> and <span>$\tau$</span> that define the type of the parametrisation and the tightness of the spline, respectively; <span>$\alpha = 0$</span> is called a uniform parmetrisation, <span>$\alpha = 1/2$</span> is called a centripetal parametrisation, and <span>$\alpha = 1$</span> is called a chordal parametrisation. Increasing <span>$\tau$</span> makes the spline tighter, and <span>$\tau = 1$</span> turns the spline into a piecewise linear curve. In this package, we only directly support <span>$\alpha=1/2$</span> and <span>$\tau=0$</span>.</p><p>Using these control points and parameters, following <a href="https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html">this article</a>, we can compute the coefficients of our polynomial as follows:</p><p class="math-container">\[\begin{aligned}
\vb m_1 &amp;= (1 - \tau) (t_2 - t_1) \left(\frac{\vb p_1 - \vb p_0}{t_1 - t_0} - \frac{\vb p_2 - \vb p_0}{t_2 - t_0} + \frac{\vb p_2 - \vb p_1}{t_2 - t_1}\right), \\
\vb m_2 &amp;= (1 - \tau) (t_2 - t_1) \left(\frac{\vb p_2 - \vb p_1}{t_2 - t_1} - \frac{\vb p_3 - \vb p_1}{t_3 - t_1} + \frac{\vb p_3 - \vb p_2}{t_3 - t_2}\right), \\
\vb a &amp;= 2(\vb p_1 - \vb p_2) + \vb m_1 + \vb m_2, \\
\vb b &amp;= -3(\vb p_1 - \vb p_2) - 2\vb m_1 - \vb m_2, \\
\vb c &amp;= \vb m_1, \\
\vb d &amp;= \vb p_1,
\end{aligned}\]</p><p>where <span>$t_i = t_{i-1} + \|\vb p_i - \vb p_{i-1}\|^\alpha$</span> and <span>$t_0=0$</span> for <span>$i=1,2,3$</span>.</p><p>Using this definition of a Catmull-Rom spline through four points, we can generalise it to a set of <span>$n$</span> control points <span>$\vb p_1,\ldots,\vb p_n$</span>. Firstly, since a Catmull-Rom spline through four points only draws through the inner two points, if we want the spline to interpolate through all of the control points then we need to define two new control points <span>$\vb p_0$</span> and <span>$\vb p_{n+1}$</span> so that <span>$\vb p_1$</span> and <span>$\vb p_n$</span> are included in the interior of some spline segment (if the spline is closed so that <span>$\vb p_1 = \vb p_n$</span>, no new points are needed). Using ideas from <a href="https://github.com/JeffreySarnoff/CatmullRom.jl">CatmullRom.jl</a>, we define <span>$\vb p_0$</span> as follows: We reflect <span>$x_2$</span>, the <span>$x$</span> coordinate of <span>$\vb p_2$</span>, left of <span>$x_1$</span> to a point <span>$x = x_1 - (x_2 - x_1) = 2x_1 - x_2$</span>. We then need to find the point <span>$y$</span> that best suits the spline at this point <span>$x$</span>. We do this using rational interpolation, specifically Thiele&#39;s quartic rational interpolant. If the resulting <span>$y$</span> is not finite, we use the cubic rational interpolant and, if that fails, we use quadratic interpolation. If <span>$x_1 = x_2$</span>, we instead apply this idea to <span>$y$</span>. We then set <span>$\vb p_0 = (x, y)$</span>, and apply the same ideas to <span>$\vb p_{n+1}$</span>.</p><p>We now have a set of control points <span>$\vb p_0, \vb p_1, \ldots, \vb p_n, \vb p_{n+1}$</span>, and are interested in a Catmull-Rom spline that interpolates through <span>$\vb p_1,\ldots,\vb p_n$</span>. To evlauate the spline <span>$\vb r(t)$</span>, we start by defining the knots <span>$t_i&#39;= t_{i-1}&#39; + \|\vb p_i - \vb p_{i-1}\|^\alpha$</span>, where <span>$t_1&#39;=0$</span>, and then set <span>$t_i = t_i&#39;/t_n$</span> so that <span>$0 \leq t_i \leq 1$</span>. We then find the knot interval <span>$[t_j, t_{j+1}]$</span> that contains <span>$t$</span>, and map <span>$t$</span> into this interval using <span>$t = (t - t_j)/(t_{j+1} - t_j)$</span>. Next, we construct the Catmull-Rom spline segment through <span>$\vb p_{j-1}$</span>, <span>$\vb p_j$</span>, <span>$\vb p_{j+1}$</span>, and <span>$\vb p_{j+2}$</span>, and evaluate this segment at <span>$t$</span> to get <span>$\vb r(t)$</span>.</p><p>To differentiate <span>$\vb r(t)$</span>, we apply similar ideas as above except that we differentiate the Catmull-Rom spline segment through <span>$\vb p_{j-1}$</span>, <span>$\vb p_j$</span>, <span>$\vb p_{j+1}$</span>, and <span>$\vb p_{j+2}$</span>, and evaluate this derivative at <span>$t$</span> to get <span>$\vb r&#39;(t)$</span> (after multiplying by <span>$1/(t_{j+1} - t_j)$</span>). Similar ideas apply for computing <span>$\vb r&#39;&#39;(t)$</span> and <span>$\vb r&#39;&#39;&#39;(t)$</span>.</p><p>To compute the arc length <span>$s(t_1, t_2)$</span>, we store the arc lengths of each spline segment (computed using numerical integration) to quickly compute the arc length across any segments entirely covered in <span>$t_1 \leq t \leq t_2$</span>, and then use numerical integration for any remaining segments not completely covered.</p><p>For the remaining operations, we use the generic approaches previously described.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../refinement/">« Mesh Refinement</a><a class="docs-footer-nextpage" href="../curve_bounded/">Triangulating Curve-Bounded Domains »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 19 January 2025 12:58">Sunday 19 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
