<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Triangles · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/interface/triangles/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li><li><a class="tocitem" href="../../tessellations/plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/">General and Defaults</a></li><li class="is-active"><a class="tocitem" href>Triangles</a><ul class="internal"><li><a class="tocitem" href="#Individual-Triangles"><span>Individual Triangles</span></a></li><li><a class="tocitem" href="#Collection-of-Triangles"><span>Collection of Triangles</span></a></li></ul></li><li><a class="tocitem" href="../edges/">Edges</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Primitive Interfaces</a></li><li class="is-active"><a href>Triangles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Triangles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/interface/triangles.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Individual-Triangles"><a class="docs-heading-anchor" href="#Individual-Triangles">Individual Triangles</a><a id="Individual-Triangles-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Triangles" title="Permalink"></a></h2><p>Triangles are assumed to be of the form <code>(i, j, k)</code>, with positive orientation, but we allow for customisation in the way these indices are represented. The following methods are used for working with triangles. First, we list the methods that must be defined, and then methods that extend these former methods. </p><h3 id="Necessary-Methods"><a class="docs-heading-anchor" href="#Necessary-Methods">Necessary Methods</a><a id="Necessary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_triangle" href="#DelaunayTriangulation.construct_triangle"><code>DelaunayTriangulation.construct_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_triangle(::Type{T}, i, j, k) where {T}</code></pre><p>Constructs a triangle with indices <code>(i, j, k)</code> with the  type <code>T</code>. The following methods are currently defined:</p><pre><code class="nohighlight hljs">construct_triangle(::Type{NTuple{3, I}}, i, j, k) where {I} 
construct_triangle(::Type{A}, i, j, k) where {I, A &lt;: AbstractVector{I}}</code></pre><p>You can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.geti" href="#DelaunayTriangulation.geti"><code>DelaunayTriangulation.geti</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geti(T::F) where {F}</code></pre><p>From a triangle <code>T</code>, extract the <code>i</code>th index, i.e. the first.  The following methods are currently defined: </p><pre><code class="nohighlight hljs">geti(T::NTuple{3, I})
geti(T::A) where {I,A&lt;:AbstractVector{I}}</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getj" href="#DelaunayTriangulation.getj"><code>DelaunayTriangulation.getj</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getj(T::F) where {F}</code></pre><p>From a triangle <code>T</code>, extract the <code>j</code>th index, i.e. the second.  The following methods are currently defined: </p><pre><code class="nohighlight hljs">getj(T::NTuple{3, I})
getj(T::A) where {I,A&lt;:AbstractVector{I}}</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.getk" href="#DelaunayTriangulation.getk"><code>DelaunayTriangulation.getk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getk(T::F) where {F}</code></pre><p>From a triangle <code>T</code>, extract the <code>k</code>th index, i.e. the third.  The following methods are currently defined: </p><pre><code class="nohighlight hljs">getk(T::NTuple{3, I})
getk(T::A) where {I,A&lt;:AbstractVector{I}}</code></pre><p>You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.integer_type" href="#DelaunayTriangulation.integer_type"><code>DelaunayTriangulation.integer_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integer_type(::Type{T}) where {T}</code></pre><p>Returns the integer type used for representnig a triangle with indices  <code>(i, j, k)</code> with the type <code>T</code>. The following methods are currently defined:</p><pre><code class="nohighlight hljs">integer_type(::Type{NTuple{N, I}}) where {N, I} 
integer_type(::Type{A}) where {I, A &lt;: AbstractVector{I}}</code></pre><p>You can extend this function as you need, ensuring you define it  on the type rather than on an instance of the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L87-L98">source</a></section></article><h3 id="Generic-Methods"><a class="docs-heading-anchor" href="#Generic-Methods">Generic Methods</a><a id="Generic-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.indices" href="#DelaunayTriangulation.indices"><code>DelaunayTriangulation.indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indices(T)</code></pre><p>Returns a tuple <code>(i, j, k)</code> containing the indices of the triangle <code>T</code>. The  indices are obtained using <a href="#DelaunayTriangulation.geti"><code>geti</code></a>, <a href="#DelaunayTriangulation.getj"><code>getj</code></a>, and <a href="#DelaunayTriangulation.getk"><code>getk</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_edges" href="#DelaunayTriangulation.triangle_edges"><code>DelaunayTriangulation.triangle_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangle_edges(T)
triangle_edges(i, j, k)</code></pre><p>Returns an iterator over each edge of the triangle <code>T</code>. In particular,  returns <code>((geti(T), getj(T)), (getj(T), getk(T)), (getk(T), geti(T)))</code>. The latter method uses the indices directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.rotate_triangle" href="#DelaunayTriangulation.rotate_triangle"><code>DelaunayTriangulation.rotate_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_triangle(T::V, i) where {V}</code></pre><p>Given a triangle <code>T</code>, rotates the indices an amount <code>i</code>. In particular, if <code>T = (i, j, k)</code>:</p><ul><li><code>i = 0</code>: Returns <code>(i, j, k)</code>.</li><li><code>i = 1</code>: Returns <code>(j, k, i)</code>.</li><li><code>i = 2</code>: Returns <code>(k, i, j)</code>.</li><li>Otherwise, return <code>rotate_triangle(T, i % 3)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Vararg{Any, 4}}} where V" href="#DelaunayTriangulation.construct_positively_oriented_triangle-Union{Tuple{V}, Tuple{Type{V}, Vararg{Any, 4}}} where V"><code>DelaunayTriangulation.construct_positively_oriented_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_positively_oriented_triangle(::Type{V}, i, j, k, points) where {V}</code></pre><p>Given a triangle type <code>V</code>, indices <code>(i, j, k)</code> corresponding to points in <code>points</code>,  returns either <code>construct_triangle(V, i, j, k)</code> or <code>construct_triangle(V, j, i, k)</code>, whichever is not negatively oriented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.compare_triangles" href="#DelaunayTriangulation.compare_triangles"><code>DelaunayTriangulation.compare_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_triangles(T, V)</code></pre><p>Tests if the triangle <code>T</code> is equal to the triangle <code>V</code>, with equality  defined on the indices. In particular, <code>compare_triangles((i, j, k), (i, j, k))</code>, <code>compare_triangles((i, j, k), (j, k, i))</code>, and <code>compare_triangles((i, j, k), (k, i, j))</code> are all true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.sort_triangle" href="#DelaunayTriangulation.sort_triangle"><code>DelaunayTriangulation.sort_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort_triangle(T::V) where {V}</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, sorts it so that the first index is the smallest, maintaining  the orientation of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L285-L290">source</a></section></article><h2 id="Collection-of-Triangles"><a class="docs-heading-anchor" href="#Collection-of-Triangles">Collection of Triangles</a><a id="Collection-of-Triangles-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-Triangles" title="Permalink"></a></h2><p>A collection of triangles simply stores many triangles, and the collection itself must be mutable so that triangles can be added and deleted. The following methods are used for working with collections of triangles. First, we list the methods that must be defined, and then methods that extend these former methods.</p><h3 id="Necessary-Methods-2"><a class="docs-heading-anchor" href="#Necessary-Methods-2">Necessary Methods</a><a class="docs-heading-anchor-permalink" href="#Necessary-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.initialise_triangles" href="#DelaunayTriangulation.initialise_triangles"><code>DelaunayTriangulation.initialise_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialise_triangles(::Type{S})</code></pre><p>For a given type <code>S</code> for some collection (e.g. a <code>AbstractSet</code>), returns an empty instance of that collection. The only method defined is</p><pre><code class="nohighlight hljs">initialise_triangles(::Type{S}) where {T, S &lt;: AbstractSet{T}}
initialise_triangles(::Type{V}) where {T,V&lt;:AbstractVector{T}}</code></pre><p>which returns a <code>Set{T}()</code>. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L176-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_type" href="#DelaunayTriangulation.triangle_type"><code>DelaunayTriangulation.triangle_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangle_type(::Type{S}) where {S}</code></pre><p>For a given type <code>S</code> representing a collection of triangles,  returns the type of triangle used inside <code>S</code>, e.g. <code>NTuple{3, Int}</code> if <code>S = AbstractSet{NTuple{3, Int}}</code>. The only methods defined are</p><pre><code class="nohighlight hljs">triangle_type(::Type{S}) where {T, S &lt;: AbstractSet{T}}
triangle_type(::Type{A}) where {T, A &lt;: AbstractVector{E}}</code></pre><p>which returns <code>T</code>. You can extend this function as you need, making sure  you extend it for the type rather than for instances of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L195-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.num_triangles" href="#DelaunayTriangulation.num_triangles"><code>DelaunayTriangulation.num_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_triangles(T::S) where {S}</code></pre><p>Given a collection of triangles <code>T</code>, returns the number of triangles  in <code>T</code>. The only method currently defined is </p><pre><code class="nohighlight hljs">num_triangles(T::AbstractSet)
num_triangles(T::AbstractVector)</code></pre><p>which returns <code>length(T)</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L215-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_to_triangles!" href="#DelaunayTriangulation.add_to_triangles!"><code>DelaunayTriangulation.add_to_triangles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_triangles!(T::S, V) where {S}</code></pre><p>Given a collection of triangles <code>T</code>, pushes <code>V</code> into it. The only  methods currently defined are</p><pre><code class="nohighlight hljs">add_to_triangles!(T::AbstractSet{F}, V::F) where {F}
add_to_triangles!(T::AbstractSet{F}, V) where {F}</code></pre><p>which simply call <code>push!(T, V)</code>. The latter method reconstructs <code>V</code>  using [<code>indices</code>] and <a href="#DelaunayTriangulation.construct_triangle"><code>construct_triangle</code></a>. You can extend this function   as you need. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_from_triangles!" href="#DelaunayTriangulation.delete_from_triangles!"><code>DelaunayTriangulation.delete_from_triangles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_from_triangles!(V::S, T::F) where {S}</code></pre><p>Given a collection of triangles <code>V</code> of type <code>S</code>, containing  triangles of type <code>F</code>, deletes the triangle <code>T</code> from <code>V</code>.  The only method currently defined is </p><pre><code class="nohighlight hljs">delete_from_triangles!(V::AbstractSet{F}, T::F) where {F}.</code></pre><p>which just calls <code>delete!</code> on <code>V</code>. The function already assumes that <code>T</code>  is already in <code>V</code>, and that <code>T</code> doesn&#39;t need to be rotated at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L357-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.each_triangle" href="#DelaunayTriangulation.each_triangle"><code>DelaunayTriangulation.each_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">each_triangle(V::F) where {F}</code></pre><p>For a given collection of triangles <code>V</code>, returns an iterator that  goes over each triangle in the collection. The methods currently  defined are </p><pre><code class="nohighlight hljs">each_triangle(V::AbstractSet)
each_triangle(V::AbstractMatrix)
each_triangle(V::AbstractVector)</code></pre><p>with the first method simply returning <code>V</code>, the second returning  <code>eachcol(V)</code>, and the third returning <code>V</code>. You can extend this function as you need.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L411-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.remove_duplicate_triangles" href="#DelaunayTriangulation.remove_duplicate_triangles"><code>DelaunayTriangulation.remove_duplicate_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_duplicate_triangles(T::Ts) where {Ts}</code></pre><p>Removes duplicate triangles from <code>T</code>. This procedure also sorts the triangles  so that the first index of each triangle is the smallest. Orientations are  preserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L463-L469">source</a></section></article><p>You must also provide definitions for <code>Base.in</code> and <code>Base.sizehint!</code> for your type. You need <code>Base.unique!</code> to use <code>remove_duplicate_triangles</code>, unless your collection is a <code>Set</code>. Note also that <code>Triangulation</code>s also define <code>each_solid_triangle</code> and <code>each_ghost_triangle</code>.</p><h3 id="Generic-Methods-2"><a class="docs-heading-anchor" href="#Generic-Methods-2">Generic Methods</a><a class="docs-heading-anchor-permalink" href="#Generic-Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.contains_triangle" href="#DelaunayTriangulation.contains_triangle"><code>DelaunayTriangulation.contains_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains_triangle(T::F, V::S) where {F, S}</code></pre><p>Given a collection of triangles <code>V</code> of type <code>S</code>, containing triangles  of type <code>F</code>, checks if <code>V</code> includes the triangle <code>T</code>. In particular,  the returned value is </p><pre><code class="nohighlight hljs">(rotate_triangle(T, m), true)</code></pre><p>if <code>V</code> includes the triangle <code>T</code>, and <code>m</code> is the integer such that  <code>rotate_triangle(T, m)</code> is the form of <code>T</code> that <code>V</code> contains. If there  is no such <code>m</code>, the returned value is simply </p><pre><code class="nohighlight hljs">(T, false).</code></pre><p>To use this function, your type needs to only have a definition for <code>T ∈ V</code> for  testing specific rotations of a triangle. This function then performs the checks  by checking <code>T</code>, then <code>rotate_triangle(T, 1)</code>, then <code>rotate_triangle(T, 2)</code>, and if none of those succeed just returns  <code>(T, false)</code>. You can extend this function as you need. We also define</p><pre><code class="nohighlight hljs">contains_triangle(i, j, k, V::Ts) where {Ts},</code></pre><p>and this method just calls the two-argument method after constructing  the triangle with <a href="#DelaunayTriangulation.construct_triangle"><code>construct_triangle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L233-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}" href="#DelaunayTriangulation.add_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}"><code>DelaunayTriangulation.add_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_triangle!(T, V...)</code></pre><p>Given a collection of triangles <code>T</code>, adds all the triangles <code>V...</code> into it.  To extend this method to other collections, see <a href="#DelaunayTriangulation.add_to_triangles!"><code>add_to_triangles!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts" href="#DelaunayTriangulation.add_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts"><code>DelaunayTriangulation.add_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}</code></pre><p>Given a collection of triangles <code>T</code>, adds the triangle <code>(i, j, k)</code> into it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}" href="#DelaunayTriangulation.delete_triangle!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Vararg{F, N}}} where {F, N}"><code>DelaunayTriangulation.delete_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_triangle!(V, T...)</code></pre><p>Given a collection of triangles <code>V</code>, deletes all the triangles <code>T...</code> from it.  Checks are made for rotated forms of <code>T</code> that <code>V</code> includes. For example, if  <code>T = (i, j, k)</code> but <code>V</code> contains <code>(j, k, i)</code>, then <code>(j, k, i)</code> will be deleted. The function also checks to see if the triangle is in <code>V</code> at all prior to deleting it. To extend this method to other collections, see <a href="#DelaunayTriangulation.delete_from_triangles!"><code>delete_from_triangles!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L378-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts" href="#DelaunayTriangulation.delete_triangle!-Union{Tuple{Ts}, Tuple{Ts, Integer, Integer, Integer}} where Ts"><code>DelaunayTriangulation.delete_triangle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_triangle!(T::Ts, i::Integer, j::Integer, k::Integer) where {Ts}</code></pre><p>Given a collection of triangles <code>T</code>, deletes the triangle <code>(i, j, k)</code> from it.  Checks are made to see if <code>T</code> needs to be rotated, or if <code>(i, j, k)</code> is in <code>T</code>  at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L395-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.compare_triangle_collections" href="#DelaunayTriangulation.compare_triangle_collections"><code>DelaunayTriangulation.compare_triangle_collections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_triangle_collections(T, V)</code></pre><p>Given two collections of triangles <code>T</code> and <code>V</code>, tests if they are equal, with  equality defined according to <a href="#DelaunayTriangulation.compare_triangles"><code>compare_triangles</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L433-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.sort_triangles" href="#DelaunayTriangulation.sort_triangles"><code>DelaunayTriangulation.sort_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort_triangles(T::Ts) where {Ts}</code></pre><p>Sorts the triangles in the collection <code>T</code> so that each triangle&#39;s first vertex  has the smallest value. The orientation of each triangle is preserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/interfaces/triangles.jl#L448-L453">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« General and Defaults</a><a class="docs-footer-nextpage" href="../edges/">Edges »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 24 May 2023 01:49">Wednesday 24 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
