<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Chew&#39;s Algorithm for Triangulating Convex Polygons · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/tri_algs/convex/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/plotting/">Plotting</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li><li><a class="tocitem" href="../../tessellations/plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li><li><a class="tocitem" href="../../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../bowyer/">Bowyer-Watson Algorithm</a></li><li class="is-active"><a class="tocitem" href>Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Triangulation Algorithms</a></li><li class="is-active"><a href>Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/tri_algs/convex.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Chew&#39;s-Algorithm-for-Triangulating-Convex-Polygons"><a class="docs-heading-anchor" href="#Chew&#39;s-Algorithm-for-Triangulating-Convex-Polygons">Chew&#39;s Algorithm for Triangulating Convex Polygons</a><a id="Chew&#39;s-Algorithm-for-Triangulating-Convex-Polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Chew&#39;s-Algorithm-for-Triangulating-Convex-Polygons" title="Permalink"></a></h1><p>Our algorithm for triangulating convex polygons comes from L. Paul Chew&#39;s &quot;Building Voronoi diagrams for convex polygons in linear expected time&quot; back in 1990, following the presentation of it in the book <em>Delaunay Mesh Generation</em> by Cheng, Dey, and Shewchuk (2013). The idea is that we can utilise the neighbour information already provided by the definition of a polygon to avoid the point location step, which turns out to be the most expensive step when computing triangulations normally. This algorithm is mainly used so that we can delete vertices from a Delaunay triangulation - see the referenced book for more detail.</p><p>A basic overview of the algorithm is as follows: Let us suppose that <span>$S$</span> is a sequence that lists the <span>$k$</span> vertices of some convex polygon in counterclockwise order, say <span>$S = \{v_1, \ldots, v_k\}$</span>, as obtained via <code>get_surrounding_polygon</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_surrounding_polygon" href="#DelaunayTriangulation.get_surrounding_polygon"><code>DelaunayTriangulation.get_surrounding_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(vor::VoronoiTessellation, i)</code></pre><p>Gets the polygon surrounding the generator with index <code>i</code> in <code>vor</code>. You shouldn&#39;t need  to use this, see <a href="../../data_structures/voronoi/#DelaunayTriangulation.get_polygon-Tuple{VoronoiTessellation, Any}"><code>get_polygon</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/data_structures/voronoi/voronoi.jl#L492-L497">source</a></section><section><div><pre><code class="nohighlight hljs">get_surronding_polygon(tri, u; skip_boundary_indices=false)</code></pre><p>Returns the set of neighbours of <code>u</code> in counter-clockwise order. If <code>skip_boundary_indices</code> is <code>true</code>, then boundary indices are not included in the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/operations/delete_point.jl#L138-L142">source</a></section><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}</code></pre><p>Given a point <code>u</code>, returns a vector <code>S</code> which gives a counter-clockwise sequence of the neighbours of <code>u</code>. </p><p><strong>Arguments</strong></p><ul><li><code>adj::Adjacent{I,E}</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph::Graph</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>u</code>: The vertex.</li><li><code>boundary_index_ranges</code>: The output of <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence::C</code>: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>skip_boundary_indices=false</code>: Whether to remove all boundary indices from the result at the end.</li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: The surrounding polygon.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>When <code>u</code> is an outer boundary index, the returned polygon is clockwise.</li><li>When <code>u</code> is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/35f3b1bed7c58b7ba8d3669b1931ad5b0716e274/src/utils.jl#L213-L235">source</a></section></article><p>To improve the complexity of our algorithm, we should randomise the insertion order for the polygon vertices to reduce the work needed, noting that the average degree of a vertex in a triangulation should typically be around six. So, we construct some permutation <span>$\pi$</span> of <span>$\{1, \ldots, k\}$</span> that will define how we insert the points, taking the first three vertices <span>$\pi_1, \pi_2, \pi_3$</span> as our initial triangle. Then, using the Bowyer-Watson algorithm, we can add in points one at a time, simply walking along the polygon to find triangles rather than the jump and march algorithm used in our main Bowyer-Watson algorithm. Note that when we add some vertex <span>$u$</span>, only one edge can separate it from the triangulation&#39;s interior, else the polygon wouldn&#39;t be convex. Hence, when <span>$u$</span> is inserted, we just take the union of this disk with all other triangles whose open circumdisks contain <span>$u$</span>. This will give us our triangulation.</p><p>Let us now describe the algorithm in more detail. The main complexity in the algorithm comes in from devising a smart way for avoiding point location. This is done with backward analysis, where instead of imagining points in one at a time, we think about what happens if we delete vertices one at a time. Suppose we have a vertex <span>$u$</span> with neighbours <span>$v$</span> and <span>$w$</span>. When we delete <span>$u$</span>, the only way to reform the poylgon and keep it convex is to join <span>$v$</span> and <span>$w$</span>, i.e. a deletion of a vertex also implies a new edge from its neighbours. This edge is exactly what we need for point location: the edge we need is simply the edge from a point&#39;s neighbours, thus allowing us to skip the jump and march algorithm. With this knowledge, we construct a circularly-, doubly-linked list of our polygon vertices, called <span>$\mathcal N$</span> (next) and <span>$\mathcal P$</span> (previous) for the two neighbours of each vertex, and then we imagine deleting vertices one at a time by simply editing this linked list. The steps are as follows:</p><ol><li>First, take <span>$S = \{v_1, \ldots, v_k\}$</span> and a permutation <span>$\pi$</span> of <span>$\{1,\ldots,k\}$</span>.</li><li>Next, compute <span>$\mathcal N = \{2, 3, \ldots, 1\}$</span> and <span>$\mathcal P = \{k, 1, \ldots, k-1\}$</span>.</li><li>Then, from <span>$i=k$</span> down to <span>$i=4$</span>:  a. To delete <span>$v_{\pi_i}$</span> from the polygon, we can set <span>$\mathcal N[\mathcal P(\pi_i)] \mapsfrom \mathcal N(\pi_i)$</span> and <span>$\mathcal P[\mathcal N(\pi_i)] = \mathcal P(\pi_i)$</span>, i.e. just connect the two neighbours together.</li><li>Now, start the triangulation with the initial triangle through <span>$(v_{\pi_1}$</span>, <span>$v_{\mathcal N(\pi_1)}$</span>, <span>$v_{\mathcal P(\pi_1)}$</span>. If this triangle is degenerate, just repeat the above steps until you find a non-degenerate triangular.</li><li>Now that we have our initial triangle, we can start adding points in. So, for <span>$i = 4$</span> up to <span>$i = k$</span>:  a. Call the routine <span>$\mathcal C(v_{\pi_i}, v_{\mathcal N(\pi_i)}, v_{\mathcal P(\pi_i)})$</span> to insert <span>$v_{\pi_i}$</span>, defined below.</li></ol><p>This routine <span>$\mathcal C(u, v, w)$</span> is defined as follows:</p><ol><li>First, take <span>$x = \mathcal A(w, v)$</span> where <span>$\mathcal A$</span> is the adjacent map. With this definition, the triangle <span>$wvx$</span> is opposite the ede <span>$vw$</span> from <span>$u$</span>.</li><li>It is possible that <span>$x$</span> is not on the polygon, i.e. <span>$x$</span> might be <span>$\emptyset$</span> or, if this algorithm is being used for deleting a vertex so that the polygon is embedded inside a larger triangulation, <span>$x$</span> could be a vertex away from the polygon, so we must check that <span>$x \in S$</span>. Moreover, we must check that <span>$x$</span> is actually inside the triangle through <span>$u$</span>, <span>$v$</span>, and <span>$w$</span>. If these two conditions hold, then the triangles <span>$uvw$</span> and <span>$wvx$</span> must not be Delaunay, so delete the triangle <span>$wvx$</span>, and continue stepping through the triangulation by calling <span>$\mathcal C(u, v, x)$</span> and <span>$\mathcal C(u, x, w)$</span> so that more non-Delaunay triangles can be identified and deleted.</li><li>If the two conditions in the last step did not hold, we start this third step (otherwise, return in step 2 above). These two conditions holding mean that <span>$vw$</span> is still a Delaunay edge, so we can edge the triangle <span>$uvw$</span> into the triangle.</li></ol><p>With this routine and the steps for the original algorithm, we can triangulate convex polygons.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bowyer/">« Bowyer-Watson Algorithm</a><a class="docs-footer-nextpage" href="../constrained/">Constrained Triangulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 24 May 2023 01:49">Wednesday 24 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
