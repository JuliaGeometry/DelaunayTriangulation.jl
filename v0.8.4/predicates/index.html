<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predicates · DelaunayTriangulation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/predicates/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../interface/edges/">Edges</a></li><li><a class="tocitem" href="../interface/points/">Points</a></li><li><a class="tocitem" href="../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../interface/example/">Example</a></li><li><a class="tocitem" href="../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li class="is-active"><a class="tocitem" href>Predicates</a><ul class="internal"><li><a class="tocitem" href="#General"><span>General</span></a></li><li><a class="tocitem" href="#Boundaries-and-Ghosts"><span>Boundaries and Ghosts</span></a></li><li><a class="tocitem" href="#Index-and-Ghost-Handling"><span>Index and Ghost Handling</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Predicates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predicates</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/predicates.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Predicates"><a class="docs-heading-anchor" href="#Predicates">Predicates</a><a id="Predicates-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates" title="Permalink"></a></h1><p>The predicates that we use in this package are all built from ExactPredicates.jl, avoiding degeneracies from predicates owing to floating point arithmetic. The results from predicates are based on certificates, coming from a <code>Certificate</code> type defined with EnumX.jl. The definition of this is below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.Certificate" href="#DelaunayTriangulation.Certificate"><code>DelaunayTriangulation.Certificate</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Certificate</code></pre><p>An <code>Enum</code> type that represents results from a geometric predicate. Below we provide a list of available certificates,  along with the function that can be used for testing if a given <code>Certificate</code> matches that <code>certificate</code>.</p><ul><li><code>Inside</code>: <code>is_inside</code></li><li><code>Degenerate</code>: <code>is_degenerate</code></li><li><code>Outside</code>: <code>is_outside</code></li><li><code>On</code>: <code>is_on</code></li><li><code>Left</code>: <code>is_left</code></li><li><code>Right</code>: <code>is_right</code></li><li><code>PositivelyOriented</code>: <code>is_positively_oriented</code></li><li><code>NegativelyOriented</code>: <code>is_negatively_oriented</code></li><li><code>Collinear</code>: <code>is_collinear</code></li><li><code>None</code>: <code>is_none</code> or <code>has_no_intersections</code></li><li><code>Single</code>: <code>is_single</code> or <code>has_one_intersection</code></li><li><code>Multiple</code>: <code>is_multiple</code> or <code>has_multiple_intersections</code></li><li><code>Touching</code>: <code>is_touching</code></li><li><code>Legal</code>: <code>is_legal</code></li><li><code>Illegal</code>: <code>is_illegal</code></li><li><code>Closer</code>: <code>is_closer</code></li><li><code>Further</code>: <code>is_further</code></li><li><code>Equidistant</code>: <code>is_equidistant</code></li><li><code>Obtuse</code>: <code>is_obtuse</code></li><li><code>Acute</code>: <code>is_acute</code></li><li><code>Right</code>: <code>is_right</code></li><li><code>SuccessfulInsertion</code>: <code>is_successful_insertion</code></li><li><code>FailedInsertion</code>: <code>is_failed_insertion</code></li><li><code>PrecisionFailure</code>: <code>is_precision_failure</code></li><li><code>EncroachmentFailure</code>: <code>is_encroachment_failure</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/certificate.jl#L1-L32">source</a></section></article><h2 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h2><p>Below we list some general predicates. The core ones that all other predicates are based on are:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.orient_predicate" href="#DelaunayTriangulation.orient_predicate"><code>DelaunayTriangulation.orient_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orient_predicate(p, q, r)</code></pre><p>Returns <code>ExactPredicates.orient(p, q, r)</code>, in particular we return:</p><ul><li><code>1</code>: <code>(p, q, r)</code> is positively oriented.</li><li><code>0</code>: <code>(p, q, r)</code> is collinear / degenerate. </li><li><code>-1</code>: <code>(p, q, r)</code> is negatively oriented.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The orient predicate is defined by the determinant </p><p class="math-container">\[\text{orient}(p, q, r) = \text{sgn} \det \begin{vmatrix} p_x &amp; p_y &amp; 1 \\ q_x &amp; q_y &amp; 1 \\ r_x &amp; r_y &amp; 1 \end{vmatrix} = \text{sgn} \det \begin{vmatrix} p_x-r_x &amp; p_y-r_y \\ q_x-r_x &amp; q_y-r_y \end{vmatrix}.\]</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.incircle_predicate" href="#DelaunayTriangulation.incircle_predicate"><code>DelaunayTriangulation.incircle_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incircle_predicate(a, b, c, p)</code></pre><p>Returns <code>ExactPredicates.incircle(a, b, c, p)</code>, in particular we return: </p><ul><li><code>1</code>: If <code>p</code> is inside the circle defined by <code>(a, b, c)</code>.</li><li><code>0</code>: If <code>p</code> is on the circle defined by <code>(a, b, c)</code>.</li><li><code>-1</code>: If <code>p</code> is outside the circle defined by <code>(a, b, c)</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The incircle predicate is defined by the determinant </p><p class="math-container">\[\text{incircle}(a, b, c, d) = \text{sgn} \det \begin{vmatrix} a_x &amp; a_y &amp; a_x^2 + a_y^2 &amp; 1 \\ b_x &amp; b_y &amp; b_x62 + b_y^2 &amp; 1 \\ c_x &amp; c_y &amp; c_x^2 + c_y^2 &amp; 1 \\ d_x &amp; d_y &amp; d_x^2 + d_y^2 &amp; 1 \end{vmatrix} = \text{sgn} \det \begin{vmatrix} a_x - d_x &amp; a_y - d_y &amp; (a_x - d_x)^2 + (a_y - d_y)^2 \\ b_x - d_x &amp; b_y - d_y &amp; (b_x - d_x)^2 + (b_y - d_y)^2 \\ c_x - d_x &amp; c_y - d_y &amp; (c_x - d_x)^2 + (c_y - d_y)^2 \end{vmatrix}.\]</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.parallelorder_predicate" href="#DelaunayTriangulation.parallelorder_predicate"><code>DelaunayTriangulation.parallelorder_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallelorder_predicate(a, b, p, q)</code></pre><p>Returns <code>ExactPredicates.parallelorder(a, b, p, q)</code>, in particular we return:</p><ul><li><code>1</code>: <code>q</code> is closer to the line <code>(a, b)</code> than <code>p</code>.</li><li><code>0</code>: <code>p</code> and <code>q</code> are equidistant from the line <code>(a, b)</code>.</li><li><code>-1</code>: <code>p</code> is closer to the line <code>(a, b)</code> than <code>q</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parallelorder predicate is the same as <code>orient_predicate(b-a, q-p, 0)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L39-L51">source</a></section></article><p>In code, these predicates could be defined by (the actual definition with ExactPredicates.jl is much more involved):</p><pre><code class="language-julia hljs">_det(a, b, c, d) = a * d - b * c
_det(a, b, c, d, e, f, g, h, i) = a * _det(e, f, h, i) - d * _det(b, c, h, i) + g * _det(b, c, e, f) # cofactor expansion 
function orient_predicate(a, b, c)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    o = _det(ax - cx, ay - cy, bx - cx, by - cy)
    return Int(sign(o)) # need Int for xor
end
function incircle_predicate(a, b, c, d)
    ax, ay = getxy(a)
    bx, by = getxy(b)
    cx, cy = getxy(c)
    dx, dy = getxy(d)
    o = _det(ax - dx, ay - dy, (ax - dx)^2 + (ay - dy)^2,
        bx - dx, by - dy, (bx - dx)^2 + (by - dy)^2,
        cx - dx, cy - dy, (cx - dx)^2 + (cy - dy)^2)
    return Int(sign(o)) # need Int for xor
end
function parallelorder_predicate(a, b, p, q)
    return orient_predicate(b .- a, q .- p, (0.0, 0.0))
end</code></pre><p>You could use this as a reference if you want to disconnect from using ExactPredicates.jl (or e.g. use the predicates also defined in GeometricalPredicates.jl). This could be useful if you are not too worried about robustness (although you should typically care about this, so be careful - proceed at your own peril) and just want fast code.</p><p>The other predicates are:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.sameside_predicate" href="#DelaunayTriangulation.sameside_predicate"><code>DelaunayTriangulation.sameside_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sameside_predicate(a, b, p)</code></pre><p>Returns <code>ExactPredicates.sameside(p, a, b)</code> (but we redefine it here).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.opposite_signs" href="#DelaunayTriangulation.opposite_signs"><code>DelaunayTriangulation.opposite_signs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opposite_signs(x,y)</code></pre><p>From ExactPredicates.jl, returns <code>true</code> if <code>x</code> and <code>y</code> have opposite signs, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.meet_predicate" href="#DelaunayTriangulation.meet_predicate"><code>DelaunayTriangulation.meet_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meet_predicate(p, q, a, b)</code></pre><p>Returns <code>ExactPredicates.meet(p, q, a, b)</code>  (but we redefine it here).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.triangle_orientation-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation(p, q, r)</code></pre><p>Given a triangle with coordinates <code>(p, q, r)</code>, computes its orientation, returning:</p><ul><li><code>Certificate.PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Certificate.Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear. </li><li><code>Certificate.NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><p>See also <a href="#DelaunayTriangulation.orient_predicate"><code>orient_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circle-NTuple{4, Any}" href="#DelaunayTriangulation.point_position_relative_to_circle-NTuple{4, Any}"><code>DelaunayTriangulation.point_position_relative_to_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circle(a, b, c, p)</code></pre><p>Given a circle through the coordinates <code>(a, b, c)</code>, assumed to be positively oriented,  computes the position of <code>p</code> relative to the circle. In particular, returns:</p><ul><li><code>Certificate.Inside</code>: <code>p</code> is inside the circle.</li><li><code>Certificate.On</code>: <code>p</code> is on the circle. </li><li><code>Certificate.Outside</code>: <code>p</code> is outside the triangle.</li></ul><p>See also <a href="#DelaunayTriangulation.incircle_predicate"><code>incircle_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L129-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_line-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line(a, b, p)</code></pre><p>Given a point <code>p</code> and the oriented line <code>(a, b)</code>, computes the position  of <code>p</code> relative to the line, returning:</p><ul><li><code>Certificate.Left</code>: <code>p</code> is to the left of the line. </li><li><code>Certificate.Collinear</code>: <code>p</code> is on the line.</li><li><code>Certificate.Right</code>: <code>p</code> is to the right of the line. </li></ul><p>See also <a href="#DelaunayTriangulation.orient_predicate"><code>orient_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L146-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_closest_to_line-NTuple{4, Any}" href="#DelaunayTriangulation.point_closest_to_line-NTuple{4, Any}"><code>DelaunayTriangulation.point_closest_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_closest_to_line(a, b, p, q)</code></pre><p>Given a line <code>ℓ</code> through <code>a</code> and <code>b</code>, tests if <code>p</code> is closer to <code>ℓ</code> than <code>q</code> is, returning:</p><ul><li><code>Certificate.Closer</code>: <code>p</code> is closer to <code>ℓ</code>.</li><li><code>Certificate:Further</code>: <code>q</code> is closer to <code>ℓ</code>.</li><li><code>Certificate.Equidistant</code>: <code>p</code> and <code>q</code> are the same distance from <code>ℓ</code>.</li></ul><p>It is assumed that <code>p</code> and <code>q</code> are to the left of <code>ℓ</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that this function is same as computing numerical values for <code>o₁ = orient(a, p, b)</code> and <code>o₂ = orient(a, q, b)</code> (the determinants, not the signs) and seeing if <code>o₁ &lt; o₂</code>. If indeed <code>o₁ &lt; o₂</code>, then <code>p</code> is closer to <code>ℓ</code> then <code>q</code>. We cannot obtain values for  <code>o₁</code> and <code>o₂</code> such that the difference <code>o₁ - o₂</code> is reliable, but notice that, letting  <code>∧</code> denote the exterior product, <code>o₁ = (a - b) ∧ (p - b)</code> and <code>o₂ = (a - b) ∧ (q - b)</code>. Thus, <code>o₁ - o₂ = (a - b) ∧ (p - q) = orient(b - a, p - q, 0)</code>. These differences <code>b - a</code> and <code>p - q</code> cannot be computed reliably, but we can use the relationship between <code>orient</code>  and <a href="#DelaunayTriangulation.parallelorder_predicate"><code>parallelorder_predicate</code></a> to write  <code>orient(b - a, p - q, 0) = parallelorder(a, b, q, p)</code>. Thus, <code>o₁ &lt; o₂</code> if <code>parallelorder(a, b, q, p) == -1</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L163-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.point_position_on_line_segment-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(a, b, p)</code></pre><p>Given a point <code>p</code> and the line segment <code>(a, b)</code>, assuming <code>p</code>  to be collinear with <code>a</code> and <code>b</code>, computes the position of <code>p</code> relative to the line segment. In particular, returns:</p><ul><li><code>Certificate.On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Certificate.Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints. </li><li><code>Certificate.Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Certificate.Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul><p>See also <a href="#DelaunayTriangulation.sameside_predicate"><code>sameside_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L192-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}" href="#DelaunayTriangulation.line_segment_intersection_type-NTuple{4, Any}"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type(p, q, a, b)</code></pre><p>Given the coordinates <code>(p, q)</code> and <code>(a, b)</code> defining two line segments,  tests the number of intersections between the two segments. In particular,  we return:</p><ul><li><code>Certificate.None</code>: The line segments do not meet at any points. </li><li><code>Certificate.Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>Certificate.Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point. </li><li><code>Certificate.Touching</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul><p>See also <a href="#DelaunayTriangulation.meet_predicate"><code>meet_predicate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L217-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}" href="#DelaunayTriangulation.point_position_relative_to_triangle-NTuple{4, Any}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(a, b, c, p)</code></pre><p>Given a positively oriented triangle with coordinates <code>(a, b, c)</code>, computes the  position of <code>p</code> relative to the triangle. In particular, returns: </p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L269-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_oriented_outer_halfplane(a, b, p)</code></pre><p>Given an edge with coordinates <code>(a, b)</code> and a point <code>p</code>,  tests the position of <code>p</code> relative to the oriented outer halfplane defined  by <code>(a, b)</code>. The returned values are:</p><ul><li><code>Cert.Outside</code>: <code>p</code> is outside of the oriented outer halfplane, meaning to the right of the line <code>(a, b)</code> or collinear with <code>a</code> and <code>b</code> but not on the line segment <code>(a, b)</code>.</li><li><code>Cert.On</code>: <code>p</code> is on the line segment <code>[a, b]</code>.</li><li><code>Cert.Inside</code>: <code>p</code> is inside of the oriented outer halfplane, meaning to the left of the line <code>(a, b)</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The oriented outer halfplane is the union of the open halfplane defined by the region to the left of the oriented line <code>(a, b)</code>, and the open line segment <code>(a, b)</code>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L298-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_legal-NTuple{4, Any}" href="#DelaunayTriangulation.is_legal-NTuple{4, Any}"><code>DelaunayTriangulation.is_legal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_legal(p, q, r, s)</code></pre><p>Given an edge <code>pq</code>, incident to two triangles <code>pqr</code> and <code>qps</code>, tests  if the edge <code>pq</code> is legal, i.e. if <code>s</code> is not inside the triangle through  <code>p</code>, <code>q</code>, and <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_line_segment_intersection-NTuple{5, Any}" href="#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{5, Any}"><code>DelaunayTriangulation.triangle_line_segment_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_line_segment_intersection(p, q, r, a, b)</code></pre><p>Given a triangle <code>(p, q, r)</code> and a line segment <code>(a, b)</code>, tests if <code>(a, b)</code> intersects the triangle&#39;s interior. Returns:</p><ul><li><code>Cert.Inside</code>: <code>(a, b)</code> is entirely inside <code>(p, q, r)</code>.</li><li><code>Cert.Single</code>: <code>(a, b)</code> has one endpoint inside <code>(p, q, r)</code>, and the other is outside.</li><li><code>Cert.Outside</code>: <code>(a, b)</code> is entirely outside <code>(p, q, r)</code>.</li><li><code>Cert.Touching</code>: <code>(a, b)</code> is on <code>(p, q, r)</code>&#39;s boundary, but not in its interior.</li><li><code>Cert.Multiple</code>: <code>(a, b)</code> passes entirely through <code>(p, q, r)</code>. This includes the case where a point is on the boundary of <code>(p, q, r)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/general.jl#L346-L357">source</a></section></article><h2 id="Boundaries-and-Ghosts"><a class="docs-heading-anchor" href="#Boundaries-and-Ghosts">Boundaries and Ghosts</a><a id="Boundaries-and-Ghosts-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries-and-Ghosts" title="Permalink"></a></h2><p>Below we list some predicates for working with boundaries and ghost triangles. </p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_index" href="#DelaunayTriangulation.is_boundary_index"><code>DelaunayTriangulation.is_boundary_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_boundary_index(i::I) where {I}</code></pre><p>Given an index <code>i</code>, returns <code>i ≤ I(BoundaryIndex)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}" href="#DelaunayTriangulation.is_boundary_edge-Tuple{Any, DelaunayTriangulation.Adjacent}"><code>DelaunayTriangulation.is_boundary_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_edge(ij, adj::Adjacent)
is_boundary_edge(i, j, adj::Adjacent{I,E}) where {I,E}</code></pre><p>Tests if the edge <code>(i, j)</code> is a boundary edge, meaning <code>get_adjacent(adj, i, j)</code>  is a boundary index.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The orientation of <code>(i, j)</code> is important: even if <code>(i, j)</code> is an edge  on the boundary, if there is a triangle <code>(i, j, k)</code> in the triangulation then <code>(i, j)</code> is not a boundary edge but <code>(j, i)</code> would be.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L9-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}" href="#DelaunayTriangulation.is_boundary_triangle-NTuple{4, Any}"><code>DelaunayTriangulation.is_boundary_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_triangle(i, j, k, adj)
is_boundary_triangle(T, adj)</code></pre><p>Given a triangle <code>T = (i, j, k)</code> and an adjacent map <code>adj</code>, returns <code>true</code> if <code>T</code> is a boundary triangle. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A boundary triangle is still part of the triangulation, but it has at least one edge that forms part of the boundary (so that at least one of the edges <code>(u, v)</code> satisfies  <code>is_boundary_edge(v, u, adj)</code>). This is similar to, but not the same as, a ghost triangle.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_edge" href="#DelaunayTriangulation.is_ghost_edge"><code>DelaunayTriangulation.is_ghost_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_edge(i, j)</code></pre><p>Given an edge <code>(i, j)</code>, returns <code>true</code> if <code>(i, j)</code> is a ghost edge. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A ghost edge is an edge in which either <code>is_boundary_index(i)</code> or <code>is_boundary_index(j)</code> is true.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_triangle" href="#DelaunayTriangulation.is_ghost_triangle"><code>DelaunayTriangulation.is_ghost_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_triangle(i, j, k)
is_ghost_triangle(T)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, returns <code>true</code> if <code>T</code> is a  ghost triangle and <code>false</code> otherwise. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A ghost triangle is one in which any of the vertices <code>(i, j, k)</code> are a boundary index, as tested via <a href="#DelaunayTriangulation.is_boundary_index"><code>is_boundary_index</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_interior_curve" href="#DelaunayTriangulation.is_interior_curve"><code>DelaunayTriangulation.is_interior_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_interior_curve(i)
is_interior_curve(i, boundary_map)</code></pre><p>Given an index <code>i</code>, tests if the curve is an interior curve, i.e. if <code>i &gt; 1</code>. Alternatively,  if a <code>boundary_map</code> is provided from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, <code>i</code> should be a boundary map so that <code>is_interior_curve(j)</code> is tested, where <code>j = get_curve_index(boundary_map, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}" href="#DelaunayTriangulation.is_outer_boundary_index-Tuple{Any, Any}"><code>DelaunayTriangulation.is_outer_boundary_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_index(i, boundary_map)</code></pre><p>Given an index <code>i</code> and a <code>boundary_map</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, tests if the index is a boundary index referring to the outermost boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_ghost_triangle-NTuple{4, Any}" href="#DelaunayTriangulation.is_outer_ghost_triangle-NTuple{4, Any}"><code>DelaunayTriangulation.is_outer_ghost_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_ghost_triangle(i, j, k, boundary_map)</code></pre><p>Given a ghost triangle <code>(i, j, k)</code> and a boundary map <code>boundary_map</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, tests if the ghost triangle is on the outermost boundary (<code>true</code>) or on an interior boundary (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_ghost_edge-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.is_outer_ghost_edge-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.is_outer_ghost_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_ghost_edge(i, j, boundary_map)</code></pre><p>Given a ghost edge <code>(i, j)</code> and a boundary map <code>boundary_map</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>, tests if the ghost edge is attached to the outermost boundary (<code>true</code>) or on an interior boundary (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I" href="#DelaunayTriangulation.is_outer_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I"><code>DelaunayTriangulation.is_outer_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_outer_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}</code></pre><p>Tests if <code>i</code> is a node appearing on the outermost boundary. </p><p><strong>Arguments</strong></p><ul><li><code>i</code>: The node to test. </li><li><code>graph::Graph</code>: The graph. </li><li><code>boundary_index_ranges</code>: A dictionary from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>is_outer_boundary_node</code>: A Boolean indicating whether <code>i</code> is a node on the outermost boundary.</li></ul><p>See also <a href="../data_structures/triangulation/#DelaunayTriangulation.is_boundary_node-Tuple{Triangulation, Any}"><code>is_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L130-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I" href="#DelaunayTriangulation.is_boundary_node-Union{Tuple{I}, Tuple{Any, DelaunayTriangulation.Graph{I}, Any}} where I"><code>DelaunayTriangulation.is_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_boundary_node(i, graph::Graph{I}, boundary_index_ranges) where {I}</code></pre><p>Tests if <code>i</code> is a node appearing on the boundary. </p><p><strong>Arguments</strong></p><ul><li><code>i</code>: The node to test. </li><li><code>graph::Graph</code>: The graph. </li><li><code>boundary_index_ranges</code>: A dictionary from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>is_boundary_node</code>: A Boolean indicating whether <code>i</code> is a node on the boundary.</li><li><code>boundary_index</code>: The boundary index of the boundary to which <code>i</code> belongs. If there is no such boundary, <code>boundary_index = I(DefaultAdjacentValue)</code>.</li></ul><p>See also <a href="../data_structures/triangulation/#DelaunayTriangulation.is_outer_boundary_node-Tuple{Triangulation, Any}"><code>is_outer_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L153-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_exists-Tuple{I} where I" href="#DelaunayTriangulation.edge_exists-Tuple{I} where I"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_exists(i::I) where {I}</code></pre><p>Returns <code>i ≠ I(DefaultAdjacentValue)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}" href="#DelaunayTriangulation.edge_exists-Union{Tuple{E}, Tuple{I}, Tuple{Any, DelaunayTriangulation.Adjacent{I, E}}} where {I, E}"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edge_exists(i, j, adj::Adjacent{I,E}) where {I,E}
edge_exists(ij, adj::Adjacent{I,E}) where {I,E}</code></pre><p>Tests if the edge <code>ij = (i, j)</code> exists in the triangulation corresponding to the <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code>.</p><p>See also <a href="#DelaunayTriangulation.edge_exists-Tuple{I} where I"><code>edge_exists(::I) where I</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L185-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}" href="#DelaunayTriangulation.has_ghost_triangles-Union{Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any}} where {I, E}"><code>DelaunayTriangulation.has_ghost_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_ghost_triangles(adj::Adjacent{I,E}, adj2v) where {I,E}</code></pre><p>Tests if the triangle represented by the <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map <code>adj</code> and the <a href="../data_structures/adjacent2vertex/#DelaunayTriangulation.Adjacent2Vertex"><code>Adjacent2Vertex</code></a> map <code>adj2v</code> contains ghost triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/boundaries_and_ghosts.jl#L202-L206">source</a></section></article><h2 id="Index-and-Ghost-Handling"><a class="docs-heading-anchor" href="#Index-and-Ghost-Handling">Index and Ghost Handling</a><a id="Index-and-Ghost-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Index-and-Ghost-Handling" title="Permalink"></a></h2><p>Below we list methods for working with predicates that are used when we provide indices for points rather than points directly.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation-NTuple{6, Any}" href="#DelaunayTriangulation.triangle_orientation-NTuple{6, Any}"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation(i, j, k, pts, representative_point_list, boundary_map)
triangle_orientation(T, pts, representative_point_list, boundary_map)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, with indices corresponding to points in <code>pts</code>, computes the orientation of the triangle, using <code>boundary_map</code> from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a> to map boundary indices to their corresponding points in <code>representative_point_list</code>. We return:</p><ul><li><code>Certificate.PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Certificate.Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear. </li><li><code>Certificate.NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A test is also made for the case that <code>is_outer_ghost_triangle(T)</code>: If  <code>T</code>  is a ghost triangle, then the index corresponding to a boundary index  points to a centroid, in which case one of the edges has its orientation  flipped. This case will also be handled correctly. In case the boundary  index corresponds to an interior curve, this flip is not necessary.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{7, Any}" href="#DelaunayTriangulation.point_position_relative_to_circumcircle-NTuple{7, Any}"><code>DelaunayTriangulation.point_position_relative_to_circumcircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circumcircle(i, j, k, ℓ, pts, representative_point_list, boundary_map)
point_position_relative_to_circumcircle(T, ℓ, pts, representative_point_list, boundary_map)</code></pre><p>Tests if the <code>ℓ</code>th point of <code>pts</code> is inside the circumcircle of the triangle <code>T = (i, j, k)</code>, using the <code>boundary_map</code> to map  boundary indices to their corresponding points in <code>representative_point_list</code>, returning:</p><ul><li><code>Certificate.Outside</code>: <code>pₗ</code> is outside of the circumcircle.</li><li><code>Certificate.On</code>: <code>pₗ</code> is on the circumcircle.</li><li><code>Certificate.Inside</code>: <code>pₗ</code> is inside the circumcircle.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A test is also made for the case that <code>is_ghost_triangle(T)</code>: When <code>T</code> is a ghost triangle, one of its indices is a boundary index, say <code>i</code>. Since this vertex  is treated as being out at infinity, the circumcircle degenerates into the line through the other two vertices and out to infinity in that direction.  Thus, we test that the <code>ℓ</code>th point is inside this circumcircle by seeing if it is in the oriented outer halfplane defined by the other two vertices,  accomplished via <a href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane-Tuple{Any, Any, Any}"><code>point_position_relative_to_oriented_outer_halfplane</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L34-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line-NTuple{6, Any}" href="#DelaunayTriangulation.point_position_relative_to_line-NTuple{6, Any}"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line(i, j, u, pts, representative_point_list, boundary_map)</code></pre><p>Computes the position of the <code>u</code>th point of <code>pts</code> relative to the line through the <code>i</code>th and <code>j</code>th points,  respectively, of <code>pts</code>. Boundary indices are mapped to their corresponding points in <code>representative_point_list</code> via  the <code>boundary_map</code> argument from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>. The returned values are:</p><ul><li><code>Certificate.Left</code>: <code>p</code> is to the left of the line. </li><li><code>Certificate.Collinear</code>: <code>p</code> is on the line.</li><li><code>Certificate.Right</code>: <code>p</code> is to the right of the line,</li></ul><p>where <code>p</code> is the <code>u</code>th point of <code>pts</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>is_outer_ghost_edge(i, j, boundary_map)</code>, the orientation of the line is flipped as the point corresponding to the boundary index will be a centroid which swaps the orientation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L68-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_closest_to_line-NTuple{5, Any}" href="#DelaunayTriangulation.point_closest_to_line-NTuple{5, Any}"><code>DelaunayTriangulation.point_closest_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_closest_to_line(i, j, u, v, pts)</code></pre><p>Let <code>a, b, p, q</code> be the points corresponding to the indices <code>i, j, u, v</code>, respectively, in <code>pts</code>, and let <code>ℓ</code> be the oriented line through <code>a</code> and <code>b</code>. This function tests if <code>p</code> is closer to <code>ℓ</code> than <code>q</code> is, returning:</p><ul><li><code>Certificate.Closer</code>: <code>p</code> is closer to <code>ℓ</code>.</li><li><code>Certificate:Further</code>: <code>q</code> is closer to <code>ℓ</code>.</li><li><code>Certificate.Equidistant</code>: <code>p</code> and <code>q</code> are the same distance from <code>ℓ</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is assumed that <code>p</code> and <code>q</code> are to the left of <code>ℓ</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}" href="#DelaunayTriangulation.point_position_on_line_segment-NTuple{4, Any}"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(i, j, u, pts)</code></pre><p>Given indices <code>i</code>, <code>j</code>, and <code>u</code> corresponding to points <code>a</code>, <code>b</code>, and <code>p</code> in <code>pts</code>, respectively, computes the position  of <code>p</code> relative to the oriented line segment <code>(a, b)</code>, assuming that the three points are collinear. The returned values are:</p><ul><li><code>Certificate.On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Certificate.Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints. </li><li><code>Certificate.Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Certificate.Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L114-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}" href="#DelaunayTriangulation.line_segment_intersection_type-NTuple{5, Any}"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type(u, v, i, j, pts)</code></pre><p>Let <code>u</code>, <code>v</code>, <code>i</code>, and <code>j</code> be indices corresponding to points <code>p</code>, <code>q</code>, <code>a</code>, and <code>b</code>, respectively, in <code>pts</code>. This  function tests the number of intersections between the two line segments <code>(p, q)</code> and <code>(a, b)</code>, returning:</p><ul><li><code>Certificate.None</code>: The line segments do not meet at any points. </li><li><code>Certificate.Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>Certificate.Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point.</li><li><code>Certificate.On</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, Any, AbstractDict}" href="#DelaunayTriangulation.point_position_relative_to_triangle-Tuple{Any, Any, Any, Any, Any, Any, AbstractDict}"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle(i, j, k, u, pts, representative_point_list, boundary_map)
point_position_relative_to_triangle(T, u, pts, representative_point_list, boundary_map)</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, with indices referring to points in <code>pts</code>, computes the position of <code>u</code>, corresponding to a point <code>p</code>, relative to <code>T</code>, with  any boundary indices mapped to their corresponding representative points in <code>representative_point_list</code>  via the <code>boundary_map</code> argument from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_map"><code>construct_boundary_map</code></a>. The returned values are:</p><ul><li><code>Certificate.Outside</code>: <code>p</code> is outside of the triangle. </li><li><code>Certificate.On</code>: <code>p</code> is on one of the edges. </li><li><code>Certificate.Inside</code>: <code>p</code> is inside the triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L146-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangle_line_segment_intersection-NTuple{6, Any}" href="#DelaunayTriangulation.triangle_line_segment_intersection-NTuple{6, Any}"><code>DelaunayTriangulation.triangle_line_segment_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangle_line_segment_intersection(i, j, k, u, v, pts)</code></pre><p>Given a triangle <code>(i, j, k)</code> and a line segment <code>(u, v)</code>, with indices corresponding to points in <code>pts</code>, tests if <code>(u, v)</code>  intersects the triangle&#39;s interior. Letting <code>(p, q, r)</code> be the coordinates  corresponding to the triangle&#39;s vertices, and <code>(a, b)</code> those for the edge&#39;s  vertices, returns:</p><ul><li><code>Cert.Inside</code>: <code>(a, b)</code> is entirely inside <code>(p, q, r)</code>.</li><li><code>Cert.Single</code>: <code>(a, b)</code> has one endpoint inside <code>(p, q, r)</code>, and the other is outside.</li><li><code>Cert.Outside</code>: <code>(a, b)</code> is entirely outside <code>(p, q, r)</code>.</li><li><code>Cert.Touching</code>: <code>(a, b)</code> is on <code>(p, q, r)</code>&#39;s boundary, but not in its interior.</li><li><code>Cert.Multiple</code>: <code>(a, b)</code> passes entirely through <code>(p, q, r)</code>. This includes the case where a point is on the boundary of <code>(p, q, r)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/6197a3ce4d52ee06fd12b959440ba64cf5784586/src/predicates/index_and_ghost_handling.jl#L190-L204">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/counting/">« Application: Counting Function Calls</a><a class="docs-footer-nextpage" href="../utils/">Other Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 11 August 2023 13:06">Friday 11 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
