<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Other Utilities · DelaunayTriangulation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/utils/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../interface/edges/">Edges</a></li><li><a class="tocitem" href="../interface/points/">Points</a></li><li><a class="tocitem" href="../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../interface/example/">Example</a></li><li><a class="tocitem" href="../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../predicates/">Predicates</a></li><li class="is-active"><a class="tocitem" href>Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../tri_algs/bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../tri_algs/convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../tri_algs/constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Other Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Other Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/utils.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Other-Utilities"><a class="docs-heading-anchor" href="#Other-Utilities">Other Utilities</a><a id="Other-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Utilities" title="Permalink"></a></h1><p>Here are some docstrings for other utility functions.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_true" href="#DelaunayTriangulation.is_true"><code>DelaunayTriangulation.is_true</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_true(b)</code></pre><p>Returns <code>true</code> if <code>b</code> is <code>true</code>, <code>Val{true}</code>, or <code>Val(true)</code>. Returns <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_boundary_index" href="#DelaunayTriangulation.get_boundary_index"><code>DelaunayTriangulation.get_boundary_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_boundary_index(i, j, k)
get_boundary_index(i, j)</code></pre><p>Given three indices <code>i</code>, <code>j</code>, and <code>k</code>, returns the index corresponding to a boundary index. If no boundary index is provided, an <code>ArgumentError</code> is thrown. Similarly for the second method, which takes two indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.rotate_ghost_triangle_to_standard_form" href="#DelaunayTriangulation.rotate_ghost_triangle_to_standard_form"><code>DelaunayTriangulation.rotate_ghost_triangle_to_standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_ghost_triangle_to_standard_form(i, j, k)
rotate_ghost_triangle_to_standard_form(T::V) where {V}</code></pre><p>Given a triangle <code>T = (i, j, k)</code>, rotates it to a new triangle <code>T′ = (u, v, w)</code> such that <code>w</code> is a boundary index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_right_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}" href="#DelaunayTriangulation.get_right_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}"><code>DelaunayTriangulation.get_right_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_right_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}</code></pre><p>Returns the node on the boundary that is to the right of <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj::Adjacent</code>: The <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>k</code>: The boundary node index.</li><li><code>boundary_index</code>: The boundary index corresponding to the curve.</li><li><code>boundary_index_ranges</code>: The boundary index ranges from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence::C</code>: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The node on the boundary to the right of <code>k</code>.</li></ul><p>See also <a href="../data_structures/triangulation/#DelaunayTriangulation.get_left_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_left_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L86-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_left_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}" href="#DelaunayTriangulation.get_left_boundary_node-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, Any, Any, Any, C}} where {I, E, C}"><code>DelaunayTriangulation.get_left_boundary_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_left_boundary_node(adj::Adjacent{I,E}, k, boundary_index, boundary_index_ranges, check_existence::C) where {I,E,C}</code></pre><p>Returns the node on the boundary that is to the left of <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj::Adjacent</code>: The <a href="../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>k</code>: The boundary node index.</li><li><code>boundary_index</code>: The boundary index corresponding to the curve.</li><li><code>boundary_index_ranges</code>: The boundary index ranges from <a href="../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence::C</code>: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The node on the boundary to the left of <code>k</code>.</li></ul><p>See also <a href="../data_structures/triangulation/#DelaunayTriangulation.get_right_boundary_node-Tuple{Triangulation, Any, Any}"><code>get_right_boundary_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L117-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.find_edge-Tuple{Any, Any, Any}" href="#DelaunayTriangulation.find_edge-Tuple{Any, Any, Any}"><code>DelaunayTriangulation.find_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_edge(T, points, ℓ)</code></pre><p>Given a triangle <code>T</code> with indices corresponding to <code>points</code>, returns the edge of <code>T</code> that contains the point <code>ℓ</code>. It is assumed that the point <code>ℓ</code> is on an edge of <code>T</code>. If this is not the case, an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.choose_uvw" href="#DelaunayTriangulation.choose_uvw"><code>DelaunayTriangulation.choose_uvw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choose_uvw(e1, e2, e3, u, v, w)</code></pre><p>Choose values for <code>(u, v, w)</code> based on the Booleans <code>(e1, e2, e3)</code>,  assuming only one is true. The three cases are: </p><ul><li>If <code>e1</code>, returns <code>(u, v, w)</code>.</li><li>If <code>e2</code>, returns <code>(v, w, u)</code>.</li><li>If <code>e3</code>, returns <code>(w, u, v)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L166-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_circular" href="#DelaunayTriangulation.is_circular"><code>DelaunayTriangulation.is_circular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_circular(A)</code></pre><p>Tests if <code>A[begin] == A[end]</code>. Also returns <code>true</code> if <code>A</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.circular_equality" href="#DelaunayTriangulation.circular_equality"><code>DelaunayTriangulation.circular_equality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circular_equality(A, B, by = isequal)</code></pre><p>Tests if the arrays <code>A</code> and <code>B</code> are equal up to a circular shift, assuming <code>A</code>  and <code>B</code> are circular. The function <code>by</code> is used to test equality of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_surrounding_polygon-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, DelaunayTriangulation.Graph, Any, Any, C}} where {I, E, C}" href="#DelaunayTriangulation.get_surrounding_polygon-Union{Tuple{C}, Tuple{E}, Tuple{I}, Tuple{DelaunayTriangulation.Adjacent{I, E}, DelaunayTriangulation.Graph, Any, Any, C}} where {I, E, C}"><code>DelaunayTriangulation.get_surrounding_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_surrounding_polygon(adj::Adjacent{I,E}, graph::Graph, u, boundary_index_ranges, check_existence::C; skip_boundary_indices=false) where {I,E,C}</code></pre><p>Given a point <code>u</code>, returns a vector <code>S</code> which gives a counter-clockwise sequence of the neighbours of <code>u</code>. </p><p><strong>Arguments</strong></p><ul><li><code>adj::Adjacent{I,E}</code>: The <a href="../../data_structures/adjacent/#DelaunayTriangulation.Adjacent"><code>Adjacent</code></a> map.</li><li><code>graph::Graph</code>: The <a href="../../data_structures/graph/#DelaunayTriangulation.Graph"><code>Graph</code></a>.</li><li><code>u</code>: The vertex.</li><li><code>boundary_index_ranges</code>: The output of <a href="../../interface/boundary_nodes/#DelaunayTriangulation.construct_boundary_index_ranges"><code>construct_boundary_index_ranges</code></a>.</li><li><code>check_existence::C</code>: Whether to check over all boundary indices, in case there are multiple segments and thus multiple possible boundary indices on the boundary.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>skip_boundary_indices=false</code>: Whether to remove all boundary indices from the result at the end.</li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: The surrounding polygon.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>When <code>u</code> is an outer boundary index, the returned polygon is clockwise.</li><li>When <code>u</code> is a boundary vertex and you do not have ghost triangles, then this function may return an invalid polygon.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L213-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.sort_edge_by_degree-Union{Tuple{E}, Tuple{E, DelaunayTriangulation.Graph}} where E" href="#DelaunayTriangulation.sort_edge_by_degree-Union{Tuple{E}, Tuple{E, DelaunayTriangulation.Graph}} where E"><code>DelaunayTriangulation.sort_edge_by_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_edge_by_degree(e::E, graph::Graph)</code></pre><p>Given an edge <code>e</code> of a <code>graph</code>, say <code>e = (u, v)</code>, returns:</p><ul><li>If <code>deg(u) ≤ deg(v)</code>, returns <code>e</code>;</li><li>If <code>deg(u) &gt; deg(v)</code>, returns <code>(v, u)</code>.</li></ul><p>In particular, <code>e</code> is sorted so that <code>initial(e)</code> is the vertex of <code>e</code>  with the smallest degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L268-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.split_constrained_edge!-Union{Tuple{E}, Tuple{Any, E, Any}} where E" href="#DelaunayTriangulation.split_constrained_edge!-Union{Tuple{E}, Tuple{Any, E, Any}} where E"><code>DelaunayTriangulation.split_constrained_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_constrained_edge!(constrained_edges, constrained_edge::E, collinear_segments) where {E}</code></pre><p>Splits the <code>constrained_edge</code> at the segments in <code>collinear_segments</code>, updating <code>constrained_edges</code> accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E" href="#DelaunayTriangulation.fix_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E"><code>DelaunayTriangulation.fix_segments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_segments!(segments::AbstractVector{E}, bad_indices) where {E}</code></pre><p>Fixes the overlapping segments in <code>segments</code>, referred to via <code>bad_indices</code>.</p><p><strong>Example</strong></p><p>For example, if we had </p><pre><code class="language-julia-repl hljs">julia&gt; c = [(2, 15), (2, 28), (2, 41)]</code></pre><p>then these edges come from connecting the start of a constrained segment with a point that  it goes through, but they are not actual segments in the triangulation (because they  all start with 2). So, using <code>bad_indices = [1, 2, 3]</code>, the function mutates <code>c</code>  to give </p><pre><code class="language-julia-repl hljs">julia&gt; bad_indices = [1, 2, 3]
julia&gt; fix_segments!(c, bad_indices)
julia&gt; c
3-element Vector{Tuple{Int, Int}}:
 (2, 15)
 (15, 28)
 (28, 41)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L312-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E" href="#DelaunayTriangulation.connect_segments!-Union{Tuple{AbstractVector{E}}, Tuple{E}} where E"><code>DelaunayTriangulation.connect_segments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connect_segments!(segments::AbstractVector{E}) where {E}</code></pre><p>Given an ordered vector of <code>segments</code>, mutates so that the endpoints connect, preserving order.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; C = [(7, 12), (12, 17), (17, 22), (32, 37), (37, 42), (42, 47)];

julia&gt; DelaunayTriangulation.connect_segments!(C);

julia&gt; C
7-element Vector{Tuple{Int, Int}}:
 (7, 12)
 (12, 17)
 (17, 22)
 (32, 37)
 (37, 42)
 (42, 47)
 (22, 32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L353-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E" href="#DelaunayTriangulation.extend_segments!-Union{Tuple{E}, Tuple{AbstractVector{E}, Any}} where E"><code>DelaunayTriangulation.extend_segments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_segments!(segments::AbstractVector{E}, constrained_edge) where {E}</code></pre><p>Given an ordered vector of <code>segments</code>, ensures that they also represent the  replacement of <code>constrained_edge</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; segments = [(2, 7), (7, 12), (12, 49)];
julia&gt; constrained_edge = (1, 68);
julia&gt; extend_segments!(segments, constrained_edge);
julia&gt; segments
5-element Vector{Tuple{Int, Int}}:
 (1, 2)
 (2, 7)
 (7, 12)
 (12, 49)
 (49, 68)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L396-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.convert_boundary_points_to_indices-Union{Tuple{AAA}, Tuple{AA}, Tuple{A}, Tuple{F}, Tuple{AAA, AAA}} where {F&lt;:Number, A&lt;:AbstractVector{F}, AA&lt;:AbstractVector{A}, AAA&lt;:AbstractVector{AA}}" href="#DelaunayTriangulation.convert_boundary_points_to_indices-Union{Tuple{AAA}, Tuple{AA}, Tuple{A}, Tuple{F}, Tuple{AAA, AAA}} where {F&lt;:Number, A&lt;:AbstractVector{F}, AA&lt;:AbstractVector{A}, AAA&lt;:AbstractVector{AA}}"><code>DelaunayTriangulation.convert_boundary_points_to_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_boundary_points_to_indices(x, y; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)
convert_boundary_points_to_indices(xy; existing_points = NTuple{2, Float64}[], check_args=true, adjust=true)</code></pre><p>Given some points <code>(x, y)</code> representing a boundary, or <code>xy</code> giving the points combined rather than separated, converts their representation into a set of  indices corresponding to each boundary. The points should match the specification of a boundary  defined in the documentation. These points also get appended onto the set of points given by the  <code>existing_points</code> keyword argument, which should be used if you have a pre-existing set of points.</p><p>The returned value is <code>(nodes, points)</code>, with <code>nodes</code> the indices and <code>points</code> the modified  <code>existing_points</code> (which are mutated in-place also).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L430-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_ordinal_suffix" href="#DelaunayTriangulation.get_ordinal_suffix"><code>DelaunayTriangulation.get_ordinal_suffix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ordinal_suffix(i)</code></pre><p>Returns the ordinal suffix for the given integer <code>i</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_ordinal_suffix(1)
&quot;st&quot;
julia&gt; get_ordinal_suffix(2)
&quot;nd&quot;
julia&gt; get_ordinal_suffix(3)
&quot;rd&quot;    
julia&gt; get_ordinal_suffix(4)
&quot;th&quot;
julia&gt; get_ordinal_suffix(11)
&quot;th&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L506-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.check_args" href="#DelaunayTriangulation.check_args"><code>DelaunayTriangulation.check_args</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_args(points, boundary_nodes)</code></pre><p>Checks the arguments <code>points</code> and <code>boundary_nodes</code> to make sure that they are valid. If they are not, an error is thrown. This function is called by <code>triangulate</code> if the <code>check_args</code> keyword argument is set to <code>true</code>. If you are sure that your arguments are valid, you can set this keyword argument to <code>false</code> to speed up the triangulation process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L540-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.min_max" href="#DelaunayTriangulation.min_max"><code>DelaunayTriangulation.min_max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_max(a, b)</code></pre><p>Returns <code>(min(a, b), max(a, b))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L595-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.min_med_max" href="#DelaunayTriangulation.min_med_max"><code>DelaunayTriangulation.min_med_max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_med_max(a, b, c)</code></pre><p>Returns <code>(min(a, b, c), med(a, b, c), max(a, b, c)), where</code>med(a, b, c)<code>is the value that is neither</code>min(a, b, c)<code>or</code>max(a, b, c)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L608-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.balanced_power_of_two_ternary_split" href="#DelaunayTriangulation.balanced_power_of_two_ternary_split"><code>DelaunayTriangulation.balanced_power_of_two_ternary_split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">balanced_power_of_two_ternary_split(ℓ)</code></pre><p>Compute the the power of two that is closest  to <code>ℓ/3</code> or to <code>ℓ/1.5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L621-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.balanced_power_of_two_quarternary_split" href="#DelaunayTriangulation.balanced_power_of_two_quarternary_split"><code>DelaunayTriangulation.balanced_power_of_two_quarternary_split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">balanced_power_of_two_quarternary_split(ℓ)</code></pre><p>Compute the the power of two that is closest to <code>ℓ/4</code> or to <code>ℓ/0.5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L638-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.segment_vertices_adjoin_other_segments" href="#DelaunayTriangulation.segment_vertices_adjoin_other_segments"><code>DelaunayTriangulation.segment_vertices_adjoin_other_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segment_vertices_adjoin_other_segments(tri::Triangulation, e)</code></pre><p>Test if the segment <code>e</code>&#39;s vertices adjoin other segments. Returns:</p><ul><li><code>0</code>: No vertex adjoins another segment.</li><li><code>1</code>: One vertex adjoins another segment.</li><li><code>2</code>: Both vertices adjoin another segment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L667-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.edge_lies_on_two_distinct_segments" href="#DelaunayTriangulation.edge_lies_on_two_distinct_segments"><code>DelaunayTriangulation.edge_lies_on_two_distinct_segments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_lies_on_two_distinct_segments(tri::Triangulation, e)</code></pre><p>Tests if the edge <code>(i, j)</code> lies on two distinct segments. The returned value is:</p><ul><li><code>(true, common_vertex)</code>: If <code>e</code> lies on two distinct segments, and the common vertex is <code>common_vertex</code>.</li><li><code>(false, 0)</code>: Otherwise.</li></ul><p>If there are multiple common vertices. In this case, the function returns the vertex that is closest to <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L698-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.get_shared_vertex" href="#DelaunayTriangulation.get_shared_vertex"><code>DelaunayTriangulation.get_shared_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_shared_vertex(e, f)</code></pre><p>Given two edges <code>e</code> and <code>f</code>, returns the vertex that they share, or <code>DefaultAdjacentValue</code> if they do not share a vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L827-L831">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>convert_to_boundary_index</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_neighbouring_boundary_edges</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_last_boundary_index" href="#DelaunayTriangulation.is_last_boundary_index"><code>DelaunayTriangulation.is_last_boundary_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_last_boundary_index(cell, i)</code></pre><p>Returns <code>true</code> if the index <code>cell[i]</code> is the last boundary index in the cell <code>cell</code>, assuming they come as a chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L784-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.is_first_boundary_index" href="#DelaunayTriangulation.is_first_boundary_index"><code>DelaunayTriangulation.is_first_boundary_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_first_boundary_index(cell, i)</code></pre><p>Returns <code>true</code> if the index <code>cell[i]</code> is the first boundary index in the cell <code>cell</code>, assuming they come as a chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L774-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.previndex_circular" href="#DelaunayTriangulation.previndex_circular"><code>DelaunayTriangulation.previndex_circular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">previndex_circular(C, i)</code></pre><p>Returns the previous index in the collection <code>C</code> before <code>i</code>, wrapping around to the second-last index if <code>i</code> is the first  index, assuming that <code>is_circular(C)</code> so that <code>C[begin] == C[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L764-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.nextindex_circular" href="#DelaunayTriangulation.nextindex_circular"><code>DelaunayTriangulation.nextindex_circular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nextindex_circular(C, i)</code></pre><p>Returns the next index in the collection <code>C</code> after <code>i</code>, wrapping around to the first index if <code>i</code> is the last index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L755-L759">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_first_boundary_index</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_last_boundary_index</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_neighbouring_boundary_edges</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.convert_to_boundary_edge" href="#DelaunayTriangulation.convert_to_boundary_edge"><code>DelaunayTriangulation.convert_to_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_to_boundary_edge(vorn::VoronoiTessellation, e)</code></pre><p>Converts the edge <code>e</code> in the triangulation of <code>vorn</code> to a boundary edge so that <code>get_adjacent(vorn, e)</code> is a boundary index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/data_structures/voronoi/voronoi.jl#L582-L586">source</a></section><section><div><pre><code class="nohighlight hljs">convert_to_boundary_edge(tri::Triangulation, e)</code></pre><p>Given an edge <code>e</code>, returns the edge that is on the boundary, oriented so that <code>get_adjacent(tri, v)</code> is a boundary index, where <code>v</code> is the edge returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L813-L818">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_shared_vertex</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle" href="#DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle"><code>DelaunayTriangulation.replace_boundary_triangle_with_ghost_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_boundary_triangle_with_ghost_triangle(tri, V)</code></pre><p>Given a triangulation <code>tri</code> and a boundary triangle <code>V</code>, returns the ghost triangle associated with the boundary edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L845-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.iterated_neighbourhood" href="#DelaunayTriangulation.iterated_neighbourhood"><code>DelaunayTriangulation.iterated_neighbourhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterated_neighbourhood(tri, i, d)</code></pre><p>Computes the <code>d</code>-times iterated neighbourhood of <code>i</code> in the triangulation <code>tri</code>. In particular, this returns all indices that are within <code>d</code> edges of <code>i</code>, excluding <code>i</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L858-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.f64_getxy" href="#DelaunayTriangulation.f64_getxy"><code>DelaunayTriangulation.f64_getxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f64_getxy(p)</code></pre><p>Returns the coordinates of the point <code>p</code> as <code>Float64</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/9be4b4ba1109510cded0063db294e9b1d9f77d64/src/utils.jl#L893-L897">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../predicates/">« Predicates</a><a class="docs-footer-nextpage" href="../tri_algs/bowyer/">Bowyer-Watson Algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 August 2023 08:20">Tuesday 1 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
