<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bowyer-Watson Algorithm · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/tri_algs/bowyer/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li><li><a class="tocitem" href="../../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li class="is-active"><a class="tocitem" href>Bowyer-Watson Algorithm</a><ul class="internal"><li><a class="tocitem" href="#Modifications-for-a-constrained-Delaunay-triangulation"><span>Modifications for a constrained Delaunay triangulation</span></a></li></ul></li><li><a class="tocitem" href="../convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../constrained/">Constrained Triangulations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Triangulation Algorithms</a></li><li class="is-active"><a href>Bowyer-Watson Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bowyer-Watson Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/tri_algs/bowyer.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bowyer-Watson-Algorithm"><a class="docs-heading-anchor" href="#Bowyer-Watson-Algorithm">Bowyer-Watson Algorithm</a><a id="Bowyer-Watson-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Bowyer-Watson-Algorithm" title="Permalink"></a></h1><p>Here we will give a description of the Bowyer-Watson algorithm. This algorithm is the algorithm used by <code>triangulate</code>.</p><p>The main idea behind the algorithm is to insert points one at a time, deleting triangles at each step whose circumcircles contain the point to be inserted, then repairing the cavity. We give the procedure in steps below.</p><ol><li>First, using <code>initialise_bowyer_watson</code>, we need to define the initial triangle. This triangle will be the first three points in the provided <code>point_order</code> (which is, by default, just a random permutation of the point indices - see the <code>point_order</code> keyword argument in <code>triangulate_bowyer_watson</code> and the <code>get_point_order</code> function). If these first three points are collinear, we do a circular shift of the point order until we get a non-degenerate triangle. See <code>get_initial_triangle</code>. At this step, we also reset the representative points field of the triangulation and initialise it with <code>DelaunayTriangulation.BoundaryIndex</code> mapping to the centroid of this initial triangle.</li><li>Once the initial triangle is selected, we move into <code>_triangulate_bowyer_watson</code>, where we loop over each point and add it in one at a time. In this loop, we start by selecting the initial point to start the jump and march algorithm at, making use of <code>select_initial_point</code>. Since points are added in one at a time, and a user&#39;s insertion order may often have points that are close together both in the order and in space, the <code>try_last_inserted_point</code> keyword argument is useful here in case we can start right next to the new point. With this point selected, we move into actually adding the point via <code>add_point_bowyer_watson!</code>.</li><li>The <code>add_point_bowyer_watson!</code> starts by using <code>jump_and_march</code> to find a triangle containing the point. The idea is to then find all triangles whose circumcircles, i.e. the circle through the three points of the triangle, contain this new point. These points need to be deleted since, by definition, these triangles are no longer Delaunay. This is done via a depth-first search, where we take the triangle we are currently in and step over its three edges into three new triangles, done via the recursive function <code>dig_cavity!</code>. If the new triangle also contains the point in its circumcircle, we delete it also, and we keep stepping. We stop at any triangles that don&#39;t contain the point in its circumcircle. Once we have stopped, we take the edge we did not step over and connect it with the new point, giving us a new triangle. </li><li>Still in <code>add_point_bowyer_watson!</code>, an important case to consider is when the point we find is directly on the triangle we found. This does not cause any problems with <code>dig_cavity!</code>, but it may cause issues with how we update the boundary, so not only do we check if the point is on the triangle, but we also check that the triangle is either a boundary triangle or a ghost triangle (meaning the edge is on the boundary). If this is the case, then we find the edge of the triangle that the point is on with <code>find_edge</code>, and split the edge in half at the point, placing the new point correctly on the boundary and giving two new triangles.</li><li>Lastly, still in <code>add_point_bowyer_watson!</code>, we use <code>update_centroid_after_addition!</code> to update the centroid of the points with the new point.</li><li>Steps 2–5 are repeated for each new point, until we have finally added all points. Once this is done, we compute the convex hull of the points with <code>convex_hull!</code>, stepping over the boundary using the ghost triangles from the triangulation to get all the boundary nodes efficiently.</li><li>Next, if the keyword argument <code>recompute_representative_point</code> is true, we can give a better representative point for the central part of the domain than the centroid by computing the pole of inaccessibility. This is done with <code>compute_representative_points!</code>.</li><li>Finally, to clean up, we can delete all ghost triangles (if the keyword argument <code>delete_ghosts</code> is true) with <code>delete_ghost_triangles!</code>. Then, if the keyword argument <code>delete_empty_features</code> is true, we can delete all keys from the <code>Adjacent</code> map that map to empty values with <code>clear_empty_features!</code>, which would also clean up empty sets from the <code>Adjacent2Vertex</code> map and empty neighbourhoods from the <code>Graph</code>.</li></ol><h2 id="Modifications-for-a-constrained-Delaunay-triangulation"><a class="docs-heading-anchor" href="#Modifications-for-a-constrained-Delaunay-triangulation">Modifications for a constrained Delaunay triangulation</a><a id="Modifications-for-a-constrained-Delaunay-triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#Modifications-for-a-constrained-Delaunay-triangulation" title="Permalink"></a></h2><p>The Bowyer-Watson algorithm requires two modifications for adding points into a constrained Delaunay triangulation. The modifications are:</p><ol><li>Avoid walking over any constrained edges when performing the depth-first search.</li><li>If a point is added onto a constrained segment, split the segment in two and perform the depth-first search on each side of the segment.</li></ol><p>With just these two modifications, the algorithm works.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../utils/">« Other Utilities</a><a class="docs-footer-nextpage" href="../convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 4 August 2023 02:41">Friday 4 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
