<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constrained Triangulations · DelaunayTriangulation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/DelaunayTriangulation.jl/tri_algs/constrained/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Triangulations</span><ul><li><a class="tocitem" href="../../triangulations/unconstrained/">Unconstrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/constrained/">Constrained Triangulations</a></li><li><a class="tocitem" href="../../triangulations/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../triangulations/lattice/">Lattice</a></li><li><a class="tocitem" href="../../triangulations/gmsh/">Gmsh</a></li><li><a class="tocitem" href="../../triangulations/convex/">Convex Polygons</a></li></ul></li><li><span class="tocitem">Voronoi Tessellations</span><ul><li><a class="tocitem" href="../../tessellations/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tessellations/lloyd/">Centroidal Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../boundary_handling/">Boundary Handling</a></li><li><span class="tocitem">Data Structures</span><ul><li><a class="tocitem" href="../../data_structures/adjacent/">Adjacent</a></li><li><a class="tocitem" href="../../data_structures/adjacent2vertex/">Adjacent2Vertex</a></li><li><a class="tocitem" href="../../data_structures/graph/">Graph</a></li><li><a class="tocitem" href="../../data_structures/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../data_structures/triangulation/">Triangulation</a></li><li><a class="tocitem" href="../../data_structures/statistics/">Statistics</a></li><li><a class="tocitem" href="../../data_structures/voronoi/">Voronoi Tessellation</a></li></ul></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><span class="tocitem">Other Features</span><ul><li><a class="tocitem" href="../../other_features/point_location/">Point Location</a></li><li><a class="tocitem" href="../../other_features/pole_of_inaccessibility/">Pole of Inaccessibility and Polygons</a></li><li><a class="tocitem" href="../../other_features/convex_hull/">Convex Hull</a></li></ul></li><li><span class="tocitem">Primitive Interfaces</span><ul><li><a class="tocitem" href="../../interface/interface/">General and Defaults</a></li><li><a class="tocitem" href="../../interface/triangles/">Triangles</a></li><li><a class="tocitem" href="../../interface/edges/">Edges</a></li><li><a class="tocitem" href="../../interface/points/">Points</a></li><li><a class="tocitem" href="../../interface/boundary_nodes/">Boundary Nodes</a></li><li><a class="tocitem" href="../../interface/example/">Example</a></li><li><a class="tocitem" href="../../interface/counting/">Application: Counting Function Calls</a></li></ul></li><li><a class="tocitem" href="../../predicates/">Predicates</a></li><li><a class="tocitem" href="../../utils/">Other Utilities</a></li><li><span class="tocitem">Triangulation Algorithms</span><ul><li><a class="tocitem" href="../bowyer/">Bowyer-Watson Algorithm</a></li><li><a class="tocitem" href="../convex/">Chew&#39;s Algorithm for Triangulating Convex Polygons</a></li><li class="is-active"><a class="tocitem" href>Constrained Triangulations</a><ul class="internal"><li><a class="tocitem" href="#Segment-Location"><span>Segment Location</span></a></li><li><a class="tocitem" href="#Triangulating-the-Polygonal-Cavities"><span>Triangulating the Polygonal Cavities</span></a></li><li><a class="tocitem" href="#Excavating-Exterior-Faces"><span>Excavating Exterior Faces</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Triangulation Algorithms</a></li><li class="is-active"><a href>Constrained Triangulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constrained Triangulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/main/docs/src/tri_algs/constrained.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Constrained-Triangulations"><a class="docs-heading-anchor" href="#Constrained-Triangulations">Constrained Triangulations</a><a id="Constrained-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Triangulations" title="Permalink"></a></h1><p>Here we describe the algorithm used for computing a constrained triangulation. We assume that we have some point set <span>$\mathcal P$</span>, a set of edges <span>$\mathcal E$</span> to be inserted, and some boundary edges <span>$\mathcal B$</span>. The algorithm we implement is given <a href="https://doi.org/10.1016/j.comgeo.2015.04.006">here</a> and is built upon the basic idea of Chew&#39;s algorithm for triangulating convex polygons, namely solving the point location problem by deleting an associated cavity in a clever way.</p><p>First, suppose we have computed the unconstrained Delaunay triangulation <span>$\mathcal D\mathcal T(\mathcal P)$</span> of our point set. The algorithm for then computing the constrained Delaunay triangulation <span>$\mathcal D\mathcal T(\mathcal P, \mathcal E, \mathcal B)$</span> then works incrementally, inserting edges one at a time. Let us, then, describe the procedure for inserting some edge <span>$e \in \mathcal C$</span>, where <span>$\mathcal C = \mathcal E \cup \mathcal B$</span>. We break the discussion into sections. </p><h2 id="Segment-Location"><a class="docs-heading-anchor" href="#Segment-Location">Segment Location</a><a id="Segment-Location-1"></a><a class="docs-heading-anchor-permalink" href="#Segment-Location" title="Permalink"></a></h2><p>Similar to how in adding points into a triangulation the first step is point location, here the first step is <em>segment location</em>. Here, our aim is to find all triangles that intersect the edge <span>$e$</span>. This is easy to do if we simply remember that the jump-and-march algorithm walks through all triangles that  intersect an initial scan line until stopping: this is exactly what we want. So, what we have done is modify our jump-and-march code such that the history of triangles walked through is recorded. This information is recorded into a <code>PointLocationHistory</code> struct. With this, we also note that since the jump-and-march algorithm will require rotating around an initial point (one of the indices of <span>$e$</span>), we should want to minimise the number of triangles we may need to rate around. Thus, we rotate <span>$e$</span> such that its initial vertex is the one with the least degree, hence we have less triangles to rotate around initially, thus reducing the time spent searching. From here on, we let <span>$e$</span> be this rotated form. This segment location is handled via the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.locate_intersecting_triangles" href="#DelaunayTriangulation.locate_intersecting_triangles"><code>DelaunayTriangulation.locate_intersecting_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">locate_intersecting_triangles(tri::Triangulation, e, rotate=Val(true); rng::AbstractRNG=Random.default_rng()) where {C}</code></pre><p>Returns a list of triangles intersecting the segment <code>e</code> in <code>tri</code>. If <code>is_true(rotate)</code>,  then <code>e</code> will be sorted such that <code>initial(e)</code> has smaller degree in <code>tri</code> than <code>terminal(e)</code>.</p><p>More precisely, the returned values are:</p><ul><li><code>intersecting_triangles</code>: The triangles intersecting <code>e</code>.</li><li><code>collinear_segments</code>: Any segments collinear with <code>e</code>, giving in order of appearance.</li><li><code>left_vertices</code>: All vertices of <code>intersecting_triangles</code> appearing to the left of <code>e</code>.</li><li><code>right_vertices</code>: All vertices of <code>intersecting_triangles</code> appearing to the right of <code>e</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_location.jl#L1-L12">source</a></section></article><p>This function also returns information about any segments that are collinear with <code>e</code> and all vertices of the intersecting triangles to the left and to the right of <code>e</code>. For the collinear segments, these are processed via the functions <code>fix_segments!</code>, <code>connect_segments!</code>, and <code>extend_segments!</code>, breaking <code>e</code> into a smaller set of segments so that no segments are collinear anymore. We will assume that there are no collinear segments for simplicity. For the vertices to the left and to the right of <code>e</code>, these are needed as they define the outline of points to be deleted on each side of <code>e</code>, thus giving a polygonal cavity (possibly self-intersecting, but this detail doesn&#39;t actually matter) that we can triangulate individually. For example, consider the triangulation:</p><pre><code class="language-julia hljs">a = (0.0, 0.0)
b = (0.0, 1.0)
c = (0.0, 2.5)
d = (2.0, 0.0)
e = (6.0, 0.0)
f = (8.0, 0.0)
g = (8.0, 0.5)
h = (7.5, 1.0)
i = (4.0, 1.0)
j = (4.0, 2.5)
k = (8.0, 2.5)
pts = [a, b, c, d, e, f, g, h, i, j, k]
tri = triangulate(pts; delete_ghosts=false, randomise=false)
fig, ax, sc = triplot(tri)
lines!(ax, [get_point(tri, 2, 7)...], color=:blue, linewidth=2)</code></pre><figure>
    <img src='../figs/segment_example.png', alt='An edge through a triangulation'><br>
</figure><p>When we perform segment location on this example on the highlighted segment <code>(2, 7)</code>, we find:</p><pre><code class="language-julia-repl hljs">julia&gt; e = (2, 7)
(2, 7)

julia&gt; intersecting_triangles, collinear_segments, left_vertices, right_vertices = DelaunayTriangulation.locate_intersecting_triangles(tri, e);

julia&gt; intersecting_triangles
8-element Vector{Tuple{Int, Int, Int}}:
 (4, 3, 2)
 (3, 4, 10)
 (10, 4, 9)
 (9, 4, 5)
 (9, 5, 10)
 (10, 5, 8)
 (8, 5, 6)
 (8, 6, 7)

julia&gt; collinear_segments
Tuple{Int, Int}[]

julia&gt; left_vertices
7-element Vector{Int}:
  7
  8
 10
  9
 10
  3
  2

julia&gt; right_vertices
5-element Vector{Int}:
 2
 4
 5
 6
 7</code></pre><p>The intersecting triangles gives the triangles intersected by <code>e</code> in order of occurrence. For <code>left_vertices</code>, these are given in counter-clockwise order, with the left- and right-most elements being the indices of <code>e</code>. See that the vertex <code>10</code> is repeated in <code>left_vertices</code>. This is because the point <code>9</code> creates a sort of dangling edge in the polygonal cavity that we have to delete, and we need to somehow know to insert this point back into the triangulation. What we do, then, is to imagine an ant walking around the polygonal cavity. The ant will walk from <code>10</code> to <code>9</code>, but then it has to come back down to <code>10</code>, so we include it twice to represent these two visits. To see the cavity, let us delete these triangles:</p><pre><code class="language-julia hljs">DelaunayTriangulation.delete_intersected_triangles!(tri, intersecting_triangles)</code></pre><figure>
    <img src='../figs/segment_example_deleted_triangles.png', alt='An edge through a triangulation with excavated cavities'><br>
</figure><p>The polygonal cavities on each side of the blue segment are what we need to re-triangulate separately. Let us now describe this procedure.</p><h2 id="Triangulating-the-Polygonal-Cavities"><a class="docs-heading-anchor" href="#Triangulating-the-Polygonal-Cavities">Triangulating the Polygonal Cavities</a><a id="Triangulating-the-Polygonal-Cavities-1"></a><a class="docs-heading-anchor-permalink" href="#Triangulating-the-Polygonal-Cavities" title="Permalink"></a></h2><p>Now we need to triangulate each cavity. We will describe this only for the cavity above <code>(2, 7)</code> in the figure below, but the procedure is exactly the same for the other cavity. Let <span>$\mathcal V = (v_1, \ldots, v_m)$</span> be the sequence of vertices in counter-clockwise order around the cavity when we insert the segment <span>$e=(v_1,v_m)$</span>. In this case, <span>$\mathcal V = (7, 8, 10, 9, 10, 3, 2)$</span>. First, just like in Chew&#39;s algorithm, we need to build up a linked-list representing the cavity. This is done via the function </p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.prepare_vertex_linked_list" href="#DelaunayTriangulation.prepare_vertex_linked_list"><code>DelaunayTriangulation.prepare_vertex_linked_list</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepare_vertex_linked_list(V::AbstractArray{I}) where {I}</code></pre><p>Given a list of polygon vertices <code>V</code>, defines a linked list <code>(prev, next)</code> of polygon vertices so that <code>(prev[i], i, next[i])</code> define a trio of polygon vertices  in counter-clockwise order, and defines, and returns <code>shuffled_indices</code> which is currently  unshuffled.</p><p>The first and last entries of the returned values <code>(prev, next, shuffled_indices)</code> will  not be populated, instead being <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L60-L70">source</a></section></article><p>(Note: The algorithm given by Shewchuk and Brown linked above also allocates a <code>distance</code> array storing <code>orient</code> determinants for this preparation of the linked list, giving values proportional to the distance from <span>$e$</span>. This is not exactly robust for us, since we need to compute the sign of a difference of two determinants. In particular, let <span>$o_1$</span> and <span>$o_2$</span> be two robust estimates for an <code>orient</code> determinant. To determine if <code>o_1 &lt; o_2</code> is the same as defining a predicate for the sign of <code>o_1 - o_2</code>, but this is problematic as, while the computation of <code>o_1</code> and <code>o_2</code> may be reliable, their difference is not. Instead, we recompute this predicate in a robust manner each time, trading performance for robustness. This predicate is defined by <code>point_closest_to_line</code>.)</p><p>Once we have prepared the linked list, we need to delete vertices from it in a random order, corresponding to deleting vertices from the polygon in a random order. Like in Chew&#39;s algorithm, this is done in such a way that we can reverse the process and automatically get point location without ever needing the jump-and-march algorithm. This deletion is handled via <code>delete_polygon_vertices_in_random_order!</code> which simply loops over each vertex, calling <code>select_random_vertex</code> and <code>update_vertex_linked_list!</code> at each iteration:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_polygon_vertices_in_random_order!" href="#DelaunayTriangulation.delete_polygon_vertices_in_random_order!"><code>DelaunayTriangulation.delete_polygon_vertices_in_random_order!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_polygon_vertices_in_random_order!(tri::Triangulation, V, shuffled_indices, prev, next, u, v, rng::AbstractRNG=Random.default_rng())</code></pre><p>Given a triangulation <code>tri</code>, a vertex list <code>V</code>, a set of <code>shuffled_indices</code>, a linked list <code>(prev, next)</code> for the  poylgon vertices, and a segment <code>(u, v)</code> that was inserted in order to define the polygon <code>V</code>, deletes vertices of <code>V</code>, via their representation in <code>(prev, next, shuffled_indices)</code>, in a random order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.select_random_vertex" href="#DelaunayTriangulation.select_random_vertex"><code>DelaunayTriangulation.select_random_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_random_vertex(tri::Triangulation, V, shuffled_indices, prev, next, range, u, v, rng::AbstractRNG=Random.default_rng())</code></pre><p>Given a triangulation <code>tri</code>, a line through points with indices <code>u</code> and <code>v</code>, a shuffled set of  indices <code>shuffled_indices</code>, and a doubly-linked list <code>(prev, next)</code> of vertex indices,  selects a random vertex <code>j ∈ range</code> that is not closer to the line than both of its  neighbours. <code>V</code> is the original vertex list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.update_vertex_linked_list!" href="#DelaunayTriangulation.update_vertex_linked_list!"><code>DelaunayTriangulation.update_vertex_linked_list!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_vertex_linked_list!(shuffled_indices, prev, next, i, j)</code></pre><p>Let <code>π = shuffled_indices</code>. This function replaces <code>next[prev[π[j]]]</code> with <code>next[π[j]]</code>, <code>prev[next[π[j]]]</code> with <code>prev[π[j]]</code>, and interchanges <code>π[i]</code> and <code>π[j]</code>. This has the act  of deleting <code>V[π[j]]</code> from the polygon, where <code>V</code> is the list of polygon vertices of the  polygon being evacuated during segment insertion for a constrained triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L46-L53">source</a></section></article><p>An important note is that, while this insertion algorithm works even with dangling edges, self-intersections, etc., it does not work when a point has an interior angle exceeding 360 degrees. We can detect this case by finding a point in the polygon that is closer to <span>$e$</span> than its two neighbours, which is the only time such an interior angle is possible (see the paper for a proof). Thus, <code>select_random_vertex</code> actually keeps sampling vertices to delete in a random order until this is not the case, making use of <code>vertex_is_closer_than_neighbours</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.vertex_is_closer_than_neighbours" href="#DelaunayTriangulation.vertex_is_closer_than_neighbours"><code>DelaunayTriangulation.vertex_is_closer_than_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertex_is_closer_than_neighbours(tri::Triangulation, u, v, jᵢ, jᵢ₋₁, jᵢ₊₁)
vertex_is_closer_than_neighbours(tri::Triangulation, V, u, v, j, shuffled_indices, prev, next)</code></pre><p>Given a triangulation <code>tri</code> and a line through points with indices <code>u</code> and <code>v</code>, tests if the point with index <code>jᵢ</code> is closer to the line than those with index  <code>jᵢ₋₁</code> and <code>jᵢ₊₁</code>, assuming all these points are to the left of the line. The second  method extracts these latter two indices using the linked list <code>(prev, next)</code> of vertices  and a shuffled set of indices <code>shuffled_indices</code> together with the original vertex list <code>V</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is useful for constrained triangulations since the algorithm  used will not work if a point being inserted on the cavity has interior angle  of 360° or greater. This is possible only if a vertex is closer to the line than  its neighbours on the polygon.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L1-L17">source</a></section></article><p>Once this is all done, we ready to start triangulating the cavity. After adding an initial triangle from the three remaining vertices, we add points in one at a time, making use of a function <code>add_point_cavity_cdt!</code>. This function is defined by:</p><pre><code class="language-julia hljs">function add_point_cavity_cdt!(tri::Triangulation, u, v, w)
    x = get_adjacent(tri, w, v)
    if !edge_exists(x)
        insert_flag = true
    else
        p, q, r, s = get_point(tri, w, v, x, u) 
        incircle_test = point_position_relative_to_circle(p, q, r, s)
        orient_test = triangle_orientation(tri, u, v, w)
        insert_flag = !is_inside(incircle_test) &amp;&amp; is_positively_oriented(orient_test)
    end
    if insert_flag
        add_triangle!(tri, u, v, w; protect_boundary=true, update_ghost_edges=false)
    else
        delete_triangle!(tri, w, v, x; protect_boundary=true, update_ghost_edges=false)
        add_point_cavity_cdt!(tri, u, v, x)
        add_point_cavity_cdt!(tri, u, x, w)
    end
    return nothing
end</code></pre><p>In particular, <code>x = get_adjacent(tri, w, v)</code> is used to find the triangle on the other side of the edge <span>$vw$</span> from <span>$u$</span>, the point being inserted. The only way that <span>$wv$</span> should not be deleted is if the triangle <span>$wvx$</span> does not exist, as detected via <code>!edge_exists(x)</code>, or if <code>u</code> is not inside the circumcircle of <span>$wvx$</span> and <span>$u$</span> is on the correct side of the edge <span>$vw$</span>. This is detected by the computation of <code>insert_flag</code>. If <code>insert_flag</code>, just add the triangle. Otherwise, we need to delete the triangle <span>$wvx$</span> and <span>$uvw$</span> as they are no longer constrained Delaunay. This is done by flipping <span>$vw$</span> onto <span>$ux$</span>. Once we have done this for each point, we have successfuly triangulated the cavity. </p><p>This is all handled via the <code>triangulate_cavity_cdt</code> function:</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangulate_cavity_cdt" href="#DelaunayTriangulation.triangulate_cavity_cdt"><code>DelaunayTriangulation.triangulate_cavity_cdt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangulate_cavity_cdt(points, V;
    IntegerType::Type{I}=Int,
    EdgeType::Type{E}=NTuple{2,IntegerType},
    TriangleType::Type{Vs}=NTuple{3,IntegerType},
    EdgesType::Type{Es}=Set{EdgeType},
    TrianglesType::Type{Ts}=Set{TriangleType},
    rng::AbstractRNG=Random.default_rng()) where {I,E,Vs,Es,Ts}
triangulate_cavity_cdt(tri, V; rng::AbstractRNG=Random.default_rng())</code></pre><p>Triangulates the cavity, represented as a counter-clockwise list of  vertices <code>V</code> with indices corresponding to those in <code>points</code>,  left behind when deleting triangles intersected in a triangulation by an edge.  If a triangulation is provided, the points are used from that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/constrained_triangulation/segment_insertion.jl#L101-L115">source</a></section></article><p>For our example, what we find is (the triangulation <code>tri</code> was updated to put the missing triangles back in from the last piece of code, note):</p><pre><code class="language-julia hljs">julia&gt; add_edge!(tri, 2, 7) # calls triangulate_cavity_cdt on each cavity</code></pre><figure>
    <img src='../figs/segment_example_completed.png', alt='A constrained edge through a triangulation'><br>
</figure><p>Here we used <code>add_edge!(tri, 2, 7)</code>, which does all this pre-processing for us. Similarly, for adding many edges, the method </p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.triangulate_constrained!" href="#DelaunayTriangulation.triangulate_constrained!"><code>DelaunayTriangulation.triangulate_constrained!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangulate_constrained(tri::Triangulation; rng=Random.default_rng())</code></pre><p>Inserts all constrained edges and boundary edges into <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/triangulation/triangulate_constrained.jl#L1-L5">source</a></section></article><p>is useful (<code>triangulate</code> calls this internally).</p><h2 id="Excavating-Exterior-Faces"><a class="docs-heading-anchor" href="#Excavating-Exterior-Faces">Excavating Exterior Faces</a><a id="Excavating-Exterior-Faces-1"></a><a class="docs-heading-anchor-permalink" href="#Excavating-Exterior-Faces" title="Permalink"></a></h2><p>When we define boundary curves, we typically want to delete any points and triangles exterior to them. The logic of the method we use for this is simple. Basically, we &quot;plant&quot; a seed in an exterior face, and use it to infect other points in this exterior face, continuing this spread until all exterior faces are found. The function that performs this is <code>delete_holes!</code>, with relevant docstrings below.</p><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.delete_holes!" href="#DelaunayTriangulation.delete_holes!"><code>DelaunayTriangulation.delete_holes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_holes!(tri::Triangulation)</code></pre><p>Deletes all the exterior faces to the boundary nodes specified in the  triangulation <code>tri</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/operations/delete_holes.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelaunayTriangulation.has_interiors_within_interiors" href="#DelaunayTriangulation.has_interiors_within_interiors"><code>DelaunayTriangulation.has_interiors_within_interiors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_interiors_within_interiors(tri::Triangulation)</code></pre><p>Returns <code>true</code> if the triangulation has multiple curves and the first curve has a positive area and all other curves have negative areas, meaning there are some interior curves that are inside other interior curves. Returns <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/DelaunayTriangulation.jl/blob/aae9e303b34d63f560dce274efb50288e1e52e88/src/operations/delete_holes.jl#L20-L25">source</a></section></article><p>The points that we find are then processed one at a time, checking all adjoining triangles to see if their centroid is in the interior or exterior. Special case is taken at the boundary nodes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convex/">« Chew&#39;s Algorithm for Triangulating Convex Polygons</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 4 August 2023 02:41">Friday 4 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
