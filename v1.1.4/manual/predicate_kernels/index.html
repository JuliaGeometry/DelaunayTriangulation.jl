<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predicate Kernels · DelaunayTriangulation.jl</title><meta name="title" content="Predicate Kernels · DelaunayTriangulation.jl"/><meta property="og:title" content="Predicate Kernels · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Predicate Kernels · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/predicate_kernels/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/predicate_kernels/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/manual/predicate_kernels/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../voronoi_output/">Voronoi Tessellation Output</a></li><li class="is-active"><a class="tocitem" href>Predicate Kernels</a><ul class="internal"><li><a class="tocitem" href="#Why-use-robust-predicates?"><span>Why use robust predicates?</span></a></li><li><a class="tocitem" href="#Will-disabling-exact-predicates-give-me-better-performance?"><span>Will disabling exact predicates give me better performance?</span></a></li><li><a class="tocitem" href="#Can-I-check-if-my-computed-triangulation-is-valid?"><span>Can I check if my computed triangulation is valid?</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/overview/">Section Overview</a></li><li><a class="tocitem" href="../../api/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../api/triangulation/">Triangulations</a></li><li><a class="tocitem" href="../../api/operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../../api/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../api/convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../../api/curves/">Curves</a></li><li><a class="tocitem" href="../../api/iterators/">Iterators</a></li><li><a class="tocitem" href="../../api/point_location/">Point Location</a></li><li><a class="tocitem" href="../../api/predicates/">Predicates</a></li><li><a class="tocitem" href="../../api/statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../../api/primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../../api/other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Predicate Kernels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predicate Kernels</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/manual/predicate_kernels.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Predicate-Kernels"><a class="docs-heading-anchor" href="#Predicate-Kernels">Predicate Kernels</a><a id="Predicate-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Predicate-Kernels" title="Permalink"></a></h1><p>By default, this package uses adaptive arithmetic via <a href="https://github.com/JuliaGeometry/AdaptivePredicates.jl">AdaptivePredicates.jl</a> for computing predicates. In total, there are three different kernels offered for computing predicates:</p><ul><li><code>FastKernel()</code>: Predicates will be computed without any adaptive or exact arithmetic. </li><li><code>AdaptiveKernel()</code>: Predicates will be computed using adaptive arithmetic via <a href="https://github.com/JuliaGeometry/AdaptivePredicates.jl">AdaptivePredicates.jl</a>.</li><li><code>ExactKernel()</code>: Predicates will be computed using exact arithmetic via <a href="https://github.com/lairez/ExactPredicates.jl">ExactPredicates.jl</a>. </li></ul><p>There are clear strengths and weaknesses to each of these choices. To summarise them, here is when each kernel should be considered:</p><ul><li><code>FastKernel()</code>: This kernel can be safely used when you know that there are no collinear points or cocircular points in your data set. It may still work even in those cases, but it can not be safely relied upon. If you trust that there are no issues, this should be the kernel you use as it is the fastest. If you run into issues while using this kernel, please use try <code>AdaptiveKernel()</code>.</li><li><code>AdaptiveKernel()</code>: This is the kernel we use by default. It has performance that is reasonably close to what is offered by <code>FastKernel()</code>, except it also guarantees that predicates will return the correct result even with collinear points or cocircular points, or in other degenerate cases where one typically expects predicates to be problematic. If you are using <code>FastKernel()</code> and run into issues, this should be the next kernel you try.</li><li><code>ExactKernel()</code>: This is the slowest kernel, but it is the safest. This kernel works on a much wider range of numbers than <code>AdaptiveKernel()</code>, and is guaranteed to satisfy certain combinatorial properties such as <code>orient(a, b, c) == orient(b, c, a) == orient(c, a, b)</code>. I have not seen any examples  where <code>AdaptiveKernel()</code> fails but <code>ExactKernel()</code> works, though, so you should only consider using this kernel if you do actually encounter such a case, i.e. treat this kernel as a fallback for <code>AdaptiveKernel()</code>.</li></ul><p>We give a discussion below about why robust arithmetic is actually important, to help you understand these choices. A key point is that it is highly advised that you do not use <code>FastKernel()</code>.</p><h2 id="Why-use-robust-predicates?"><a class="docs-heading-anchor" href="#Why-use-robust-predicates?">Why use robust predicates?</a><a id="Why-use-robust-predicates?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-use-robust-predicates?" title="Permalink"></a></h2><p>Three great resources for understanding why we need robust predicates are</p><ol><li>Jonathan Shewchuk&#39;s paper on adaptive precision floating-point arithmetic <a href="https://doi.org/10.1007/PL00009321">here</a>.</li><li>Jonathan Shewchuk&#39;s lecture notes on geometric robustness <a href="https://people.eecs.berkeley.edu/~jrs/meshpapers/robnotes.pdf">here</a>.</li><li><a href="https://doi.org/10.1016/j.comgeo.2007.06.003">This paper</a> by Kettner et al. (2008) on some examples of issues with inexact arithmetic.</li></ol><p>We give a simple summary here. A big component of the algorithms used in this package are what are known as <em>geometric predicates</em>, some of these being:</p><ul><li><code>orient(p, q, r)</code>: Is <code>r</code> left, right, or on the line through <code>pq</code>?</li><li><code>incircle(p, q, r, s)</code>: Is <code>s</code> inside, outside, or on the circle through <code>p</code>, <code>q</code>, and <code>r</code>?</li></ul><p>These predicates can be computed using determinants:</p><p class="math-container">\[\begin{align*}
O_{pqr} &amp;:= \textrm{orient}(p, q, r) = \begin{vmatrix} p_x - r_x &amp; p_y - r_y \\ q_x - r_x &amp; q_y - r_y \end{vmatrix}, \\
C_{pqrs} &amp;:= \textrm{incircle}(p, q, r, s) = \begin{vmatrix} p_x - s_x &amp; p_y - s_y &amp; (p_x - s_x)^2 + (p_y - s_y)^2 \\ q_x - s_x &amp; q_y - s_y &amp; (q_x - s_x)^2 + (q_y - s_y)^2 \\ r_x - s_x &amp; r_y - s_y &amp; (r_x - s_x)^2 + (r_y - s_y)^2 \end{vmatrix}.
\end{align*}\]</p><p>The signs of these determinants <span>$O_{pqr}$</span> and <span>$C_{pqrs}$</span> are used to determinant the answers to the above questions. In inexact arithmetic, it is common that the sign picked is wrong when the determinants are close to zero. The consequences of this can be catastrophic:</p><ol><li>The algorithms may hang or crash.</li><li>The final triangulation may be completely invalid. For example, if a point is being added into a triangulation right onto an existing edge, then in exact arithmetic we would know to split the edge to the left and to the right. In inexact arithmetic, the point may be to the left of the edge but detected as being to the right of it, thus adding a triangle that crosses an edge.</li><li>You may encounter <code>BoundsError</code>s from bad <code>Adjacent</code> queries where a triangle is expected to exist but doesn&#39;t.</li></ol><p>Another issue is due to the fact that floating point arithmetic is not associative. In exact arithmetic, we would expect for example that </p><p class="math-container">\[O_{pqr} = O_{qrp} = O_{rpq},\]</p><p>but this is not true in floating point arithmetic. This causes issues with consistency - a point may be found to be both left and right of an edge depending on the order of the points given to the <code>orient</code> predicate, inevitably leading to an invalid triangulation. With the use of robust predicates, this property is guaranteed to hold, ensuring that all the predicate results are consistent with each other. (This identity does not always hold with adaptive arithmetic, although this is less problematic due to the design of the adaptive predicates; read Shewchuk&#39;s paper for more information.) This has the following consequence: <strong>Even if you think robust predicates are not necessary for you because none of your inputs are exact (for example), you still want them to guarantee consistency with predicates regardless of the input order</strong>.</p><h2 id="Will-disabling-exact-predicates-give-me-better-performance?"><a class="docs-heading-anchor" href="#Will-disabling-exact-predicates-give-me-better-performance?">Will disabling exact predicates give me better performance?</a><a id="Will-disabling-exact-predicates-give-me-better-performance?-1"></a><a class="docs-heading-anchor-permalink" href="#Will-disabling-exact-predicates-give-me-better-performance?" title="Permalink"></a></h2><p>It is also not even the case that using inexact predicates will give you better performance than if you were to use robust predicates. <code>AdaptiveKernel()</code>&#39;s performance is typically similar to <code>FastKernel()</code>, with the exception of queries on collinear points. This exception is irrelevant, though, as <code>FastKernel()</code> is not even  reliable when used on collinear points. <code>ExactKernel()</code> is a bit slower, but its performance is still not terrible compared to <code>FastKernel()</code> since ExactPredicates.jl uses clever filters that typically do as much work as <code>FastKernel()</code> or <code>AdaptiveKernel()</code> would. Thus, the only cases where performance is improved significantly using <code>FastKernel()</code> is exactly in the cases where you do not want to be using <code>FastKernel()</code>.</p><p>You should always benchmark your problems to see if using <code>FastKernel()</code> over the robust kernels <code>AdaptiveKernel()</code> or <code>ExactKernel()</code>, if you choose to do, will actually give you better performance.</p><h2 id="Can-I-check-if-my-computed-triangulation-is-valid?"><a class="docs-heading-anchor" href="#Can-I-check-if-my-computed-triangulation-is-valid?">Can I check if my computed triangulation is valid?</a><a id="Can-I-check-if-my-computed-triangulation-is-valid?-1"></a><a class="docs-heading-anchor-permalink" href="#Can-I-check-if-my-computed-triangulation-is-valid?" title="Permalink"></a></h2><p>When you are not using robust predicates, you may want to check if your computed triangulation is actually a valid Delaunay triangulation. We provide the function <code>DelaunayTriangulation.validate_triangulation</code> for this purpose. This functionality is quite slow to use and is not currently optimised or well-documented (contributions towards addressing these issues are welcome), but it will work. One important note is that this check does actually use predicates in certain areas, so this check is still not guaranteed to be 100% accurate without robust predicates (by default, <code>validate_triangulation</code> will use the <code>ExactKernel()</code> kernel). Here is an example of its use.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
tri = triangulate(rand(2, 50))
DelaunayTriangulation.validate_triangulation(tri)</code></pre><pre><code class="language-julia hljs">true</code></pre><pre><code class="language-julia hljs">T = first(each_solid_triangle(tri)) 
DelaunayTriangulation.delete_triangle!(tri, T) # break the triangulation for this example
DelaunayTriangulation.validate_triangulation(tri)</code></pre><pre><code class="language-julia hljs">The edge (12, 40) does not have two incident triangles.
The edge (12, 40) appears as an edge in the graph but it and its reverse are not both a key of the adjacent map.

false</code></pre><pre><code class="language-julia hljs">DelaunayTriangulation.validate_triangulation(tri; print_result = false)</code></pre><pre><code class="language-julia hljs">false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../voronoi_output/">« Voronoi Tessellation Output</a><a class="docs-footer-nextpage" href="../../api/overview/">Section Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Sunday 1 September 2024 18:03">Sunday 1 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
