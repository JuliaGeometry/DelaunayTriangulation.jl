<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predicates · DelaunayTriangulation.jl</title><meta name="title" content="Predicates · DelaunayTriangulation.jl"/><meta property="og:title" content="Predicates · DelaunayTriangulation.jl"/><meta property="twitter:title" content="Predicates · DelaunayTriangulation.jl"/><meta name="description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="twitter:description" content="Documentation for DelaunayTriangulation.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/predicates/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/predicates/"/><link rel="canonical" href="https://JuliaGeometry.github.io/DelaunayTriangulation.jl/api/predicates/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaunayTriangulation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/unconstrained/">Unconstrained Triangulations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Constrained Triangulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/constrained_edges/">Constrained Edges</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary/">Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_outer_boundary_segmented/">Segmented Outer Boundary</a></li><li><a class="tocitem" href="../../tutorials/constrained_multiply_connected/">Domain with Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_interior_within_interiors/">Domain with Interior Holes inside Interior Holes</a></li><li><a class="tocitem" href="../../tutorials/constrained_multipolygon/">Disjoint Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Triangulation Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/operations_vertex_insertion_deletion/">Vertex Insertion and Deletion</a></li><li><a class="tocitem" href="../../tutorials/operations_segment_insertion/">Edge Insertion</a></li><li><a class="tocitem" href="../../tutorials/operations_ghost_triangles/">Adding or Clearing Ghost Triangles</a></li><li><a class="tocitem" href="../../tutorials/operations_flip_edge/">Edge Flipping</a></li><li><a class="tocitem" href="../../tutorials/operations_legalise_edge/">Legalising an Edge</a></li><li><a class="tocitem" href="../../tutorials/operations_split_edge/">Edge Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_split_triangle/">Triangle Splitting</a></li><li><a class="tocitem" href="../../tutorials/operations_convex_hull_locking/">Locking and Unlocking the Convex Hull</a></li></ul></li><li><a class="tocitem" href="../../tutorials/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../tutorials/lattice/">Triangulating Rectangular Regions</a></li><li><a class="tocitem" href="../../tutorials/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../tutorials/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../tutorials/voronoi/">Voronoi Tessellations</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">Clipped Voronoi Tessellations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/clipped/">Clipping to the Convex Hull</a></li><li><a class="tocitem" href="../../tutorials/clipped_rectangle/">Clipping to a Rectangle</a></li></ul></li><li><a class="tocitem" href="../../tutorials/centroidal/">Centroidal Voronoi Tessellations</a></li><li><a class="tocitem" href="../../tutorials/point_location/">Point Location</a></li><li><a class="tocitem" href="../../tutorials/nearest/">Nearest Neighbour Queries</a></li><li><a class="tocitem" href="../../tutorials/convex_hull/">Convex Hulls</a></li><li><a class="tocitem" href="../../tutorials/pole_of_inaccessibility/">Pole of Inaccessibility</a></li><li><a class="tocitem" href="../../tutorials/point_in_polygon/">Point-in-Polygon Testing</a></li><li><a class="tocitem" href="../../tutorials/custom_primitive/">Using Custom Structs for Primitives and Boundaries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../manual/primitives/">Representing Primitives</a></li><li><a class="tocitem" href="../../manual/boundaries/">Representing Boundaries</a></li><li><a class="tocitem" href="../../manual/ghost_triangles/">Ghost (Negative) Vertices</a></li><li><a class="tocitem" href="../../manual/curve_bounded/">Defining Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../manual/predicates/">Geometrical Predicates</a></li><li><a class="tocitem" href="../../manual/triangulation_output/">Triangulation Output</a></li><li><a class="tocitem" href="../../manual/voronoi_output/">Voronoi Tessellation Output</a></li><li><a class="tocitem" href="../../manual/predicate_kernels/">Predicate Kernels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Section Overview</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../triangulation/">Triangulations</a></li><li><a class="tocitem" href="../operations/">Triangulation Operations</a></li><li><a class="tocitem" href="../voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../convex_hull/">Convex Hull</a></li><li><a class="tocitem" href="../curves/">Curves</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li><li><a class="tocitem" href="../point_location/">Point Location</a></li><li class="is-active"><a class="tocitem" href>Predicates</a><ul class="internal"><li><a class="tocitem" href="#Certificates"><span>Certificates</span></a></li><li><a class="tocitem" href="#Predicates-2"><span>Predicates</span></a></li></ul></li><li><a class="tocitem" href="../statistics/">Triangulation Statistics</a></li><li><a class="tocitem" href="../primitives/">Primitive Interfaces</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Extended Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../extended/overview/">Overview</a></li><li><a class="tocitem" href="../../extended/data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../extended/algorithms/">Algorithm Internals</a></li><li><a class="tocitem" href="../../extended/utils/">Utility Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Mathematical Details</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../math/overview/">Overview</a></li><li><a class="tocitem" href="../../math/delaunay/">Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/constrained/">Constrained Delaunay Triangulations</a></li><li><a class="tocitem" href="../../math/convex/">Triangulating Convex Polygons</a></li><li><a class="tocitem" href="../../math/refinement/">Mesh Refinement</a></li><li><a class="tocitem" href="../../math/curves/">Curves</a></li><li><a class="tocitem" href="../../math/curve_bounded/">Triangulating Curve-Bounded Domains</a></li><li><a class="tocitem" href="../../math/voronoi/">Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/clipped/">Clipped Voronoi Tessellations</a></li><li><a class="tocitem" href="../../math/centroidal/">Centroidal Voronoi Tessellations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Example Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../applications/overview/">Overview</a></li><li><a class="tocitem" href="../../applications/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../applications/cell_simulations/">Cellular Biology</a></li><li><a class="tocitem" href="../../applications/pde_discretisation/">Solving PDEs</a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Predicates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predicates</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/main/docs/src/api/predicates.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Predicates"><a class="docs-heading-anchor" href="#Predicates">Predicates</a><a id="Predicates-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates" title="Permalink"></a></h1><h2 id="Certificates"><a class="docs-heading-anchor" href="#Certificates">Certificates</a><a id="Certificates-1"></a><a class="docs-heading-anchor-permalink" href="#Certificates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.Certificate" href="#DelaunayTriangulation.Certificate"><code>DelaunayTriangulation.Certificate</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Certificate</code></pre><p>This is an <code>Enum</code> that defines certificates returned from predicates. The instances, and associated certifiers, are:</p><ul><li><code>Inside</code>: <code>is_inside</code></li><li><code>Degenerate</code>: <code>is_degenerate</code></li><li><code>Outside</code>: <code>is_outside</code></li><li><code>On</code>: <code>is_on</code></li><li><code>Left</code>: <code>is_left</code></li><li><code>Right</code>: <code>is_right</code></li><li><code>PositivelyOriented</code>: <code>is_positively_oriented</code></li><li><code>NegativelyOriented</code>: <code>is_negatively_oriented</code></li><li><code>Collinear</code>: <code>is_collinear</code></li><li><code>None</code>: <code>is_none</code> or <code>has_no_intersections</code></li><li><code>Single</code>: <code>is_single</code> or <code>has_one_intersection</code></li><li><code>Multiple</code>: <code>is_multiple</code> or <code>has_multiple_intersections</code></li><li><code>Touching</code>: <code>is_touching</code></li><li><code>Legal</code>: <code>is_legal</code></li><li><code>Illegal</code>: <code>is_illegal</code></li><li><code>Closer</code>: <code>is_closer</code></li><li><code>Further</code>: <code>is_further</code></li><li><code>Equidistant</code>: <code>is_equidistant</code></li><li><code>Obtuse</code>: <code>is_obtuse</code></li><li><code>Acute</code>: <code>is_acute</code></li><li><code>SuccessfulInsertion</code>: <code>is_successful_insertion</code></li><li><code>FailedInsertion</code>: <code>is_failed_insertion</code></li><li><code>PrecisionFailure</code>: <code>is_precision_failure</code></li><li><code>EncroachmentFailure</code>: <code>is_encroachment_failure</code></li><li><code>Above</code>: <code>is_above</code></li><li><code>Below</code>: <code>is_below</code></li><li><code>Visible</code>: <code>is_visible</code></li><li><code>Invisible</code>: <code>is_invisible</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_inside" href="#DelaunayTriangulation.is_inside"><code>DelaunayTriangulation.is_inside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_inside(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Inside</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_degenerate" href="#DelaunayTriangulation.is_degenerate"><code>DelaunayTriangulation.is_degenerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_degenerate(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Degenerate</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_outside" href="#DelaunayTriangulation.is_outside"><code>DelaunayTriangulation.is_outside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_outside(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Outside</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_on" href="#DelaunayTriangulation.is_on"><code>DelaunayTriangulation.is_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_on(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>On</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_left" href="#DelaunayTriangulation.is_left"><code>DelaunayTriangulation.is_left</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_left(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Left</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_right" href="#DelaunayTriangulation.is_right"><code>DelaunayTriangulation.is_right</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_right(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Right</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_positively_oriented" href="#DelaunayTriangulation.is_positively_oriented"><code>DelaunayTriangulation.is_positively_oriented</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_positively_oriented(tri::Triangulation, curve_index) -&gt; Bool</code></pre><p>Tests if the <code>curve_index</code>th curve in <code>tri</code> is positively oriented, returning <code>true</code> if so and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/boundary_nodes.jl#L228-L232">source</a></section><section><div><pre><code class="language-julia hljs">is_positively_oriented(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>PositivelyOriented</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_negatively_oriented" href="#DelaunayTriangulation.is_negatively_oriented"><code>DelaunayTriangulation.is_negatively_oriented</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_negatively_oriented(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>NegativelyOriented</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_collinear" href="#DelaunayTriangulation.is_collinear"><code>DelaunayTriangulation.is_collinear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_collinear(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Collinear</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_none" href="#DelaunayTriangulation.is_none"><code>DelaunayTriangulation.is_none</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_none(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>None</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_no_intersections" href="#DelaunayTriangulation.has_no_intersections"><code>DelaunayTriangulation.has_no_intersections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_no_intersections(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>None</code>, and <code>false</code> otherwise. Synonymous with <code>is_none</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_single" href="#DelaunayTriangulation.is_single"><code>DelaunayTriangulation.is_single</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_single(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Single</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_one_intersection" href="#DelaunayTriangulation.has_one_intersection"><code>DelaunayTriangulation.has_one_intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_one_intersection(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Single</code>, and <code>false</code> otherwise. Synonymous with <code>is_single</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_multiple" href="#DelaunayTriangulation.is_multiple"><code>DelaunayTriangulation.is_multiple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_multiple(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Multiple</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_intersections" href="#DelaunayTriangulation.has_multiple_intersections"><code>DelaunayTriangulation.has_multiple_intersections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_multiple_intersections(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Multiple</code>, and <code>false</code> otherwise. Synonymous with <code>is_multiple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_touching" href="#DelaunayTriangulation.is_touching"><code>DelaunayTriangulation.is_touching</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_touching(r1::BoundingBox, r2::BoundingBox) -&gt; Bool</code></pre><p>Tests whether <code>r1</code> and <code>r2</code> are touching, i.e. if they share a common boundary. This only considers interior touching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/trees/rtree.jl#L229-L233">source</a></section><section><div><pre><code class="language-julia hljs">is_touching(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Touching</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_illegal" href="#DelaunayTriangulation.is_illegal"><code>DelaunayTriangulation.is_illegal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_illegal(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Illegal</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_closer" href="#DelaunayTriangulation.is_closer"><code>DelaunayTriangulation.is_closer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_closer(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Closer</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_further" href="#DelaunayTriangulation.is_further"><code>DelaunayTriangulation.is_further</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_further(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Further</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_equidistant" href="#DelaunayTriangulation.is_equidistant"><code>DelaunayTriangulation.is_equidistant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_equidistant(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Equidistant</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_obtuse" href="#DelaunayTriangulation.is_obtuse"><code>DelaunayTriangulation.is_obtuse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_obtuse(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Obtuse</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_acute" href="#DelaunayTriangulation.is_acute"><code>DelaunayTriangulation.is_acute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_acute(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Acute</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_above" href="#DelaunayTriangulation.is_above"><code>DelaunayTriangulation.is_above</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_above(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Above</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_below" href="#DelaunayTriangulation.is_below"><code>DelaunayTriangulation.is_below</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_below(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>Below</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><h2 id="Predicates-2"><a class="docs-heading-anchor" href="#Predicates-2">Predicates</a><a class="docs-heading-anchor-permalink" href="#Predicates-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.AbstractPredicateKernel" href="#DelaunayTriangulation.AbstractPredicateKernel"><code>DelaunayTriangulation.AbstractPredicateKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPredicateKernel</code></pre><p>Abstract type for defining a method for computing predicates. The subtypes are:</p><ul><li><code>FastKernel</code>: Uses the determinant definitions of the predicates, with no adaptivity or exact arithmetic.</li><li><code>ExactKernel</code>: Uses ExactPredicates.jl.</li><li><code>AdaptiveKernel</code>: Uses AdaptivePredicates.jl.</li></ul><p>Please see the documentation for more information on the differences between these predicate types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.FastKernel" href="#DelaunayTriangulation.FastKernel"><code>DelaunayTriangulation.FastKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastKernel()</code></pre><p>Pass this to predicates to declare that determinant definitions of predicates should be used, avoiding adaptivity and exact arithmetic.</p><p>See also <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a> and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.ExactKernel" href="#DelaunayTriangulation.ExactKernel"><code>DelaunayTriangulation.ExactKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactKernel()</code></pre><p>Pass this to predicates to use ExactPredicates.jl for computing predicates.</p><p>See also <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a> and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.AdaptiveKernel" href="#DelaunayTriangulation.AdaptiveKernel"><code>DelaunayTriangulation.AdaptiveKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveKernel()</code></pre><p>Pass this to predicates to use AdaptivePredicates.jl for computing predicates.</p><p>See also <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a> and <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.orient_predicate" href="#DelaunayTriangulation.orient_predicate"><code>DelaunayTriangulation.orient_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orient_predicate([kernel::AbstractPredicateKernel,] p, q, r) -&gt; Integer</code></pre><p>Returns </p><ul><li><code>1</code>: <code>(p, q, r)</code> is positively oriented.</li><li><code>0</code>: <code>(p, q, r)</code> is collinear / degenerate.</li><li><code>-1</code>: <code>(p, q, r)</code> is negatively oriented.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L76-L88">source</a></section><section><div><pre><code class="language-julia hljs">orient_predicate([kernel::AbstractPredicateKernel,] p, q, r) -&gt; Integer</code></pre><p>Returns </p><ul><li><code>1</code>: <code>(p, q, r, s)</code> is positively oriented.</li><li><code>0</code>: <code>(p, q, r, s)</code> is collinear / degenerate.</li><li><code>-1</code>: <code>(p, q, r, s)</code> is negatively oriented.</li></ul><p>Here, a positively oriented tetrahedron <code>(p, q, r, s)</code> takes the form</p><pre><code class="nohighlight hljs">                               z.
                             .
                           ,/
                         s
                       ,/|&#39;\
                     ,/  |  &#39;\
                   ,/    &#39;.   &#39;\
                 ,/       |     &#39;\                 
               ,/         |       &#39;\              
              p-----------&#39;.--------q --&gt; x
               &#39;\.         |      ,/              
                  &#39;\.      |    ,/                 
                     &#39;\.   &#39;. ,/    
                        &#39;\. |/      
                           &#39;r       
                             &#39;\.</code></pre><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L98-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.incircle_predicate" href="#DelaunayTriangulation.incircle_predicate"><code>DelaunayTriangulation.incircle_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incircle_predicate([kernel::AbstractPredicateKernel,] a, b, c, p) -&gt; Integer</code></pre><p>Assuming that <code>(a, b, c)</code> is a positively oriented triangle, returns</p><ul><li><code>1</code>: If <code>p</code> is inside the circle defined by <code>(a, b, c)</code>.</li><li><code>0</code>: If <code>p</code> is on the circle defined by <code>(a, b, c)</code>.</li><li><code>-1</code>: If <code>p</code> is outside the circle defined by <code>(a, b, c)</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L139-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.parallelorder_predicate" href="#DelaunayTriangulation.parallelorder_predicate"><code>DelaunayTriangulation.parallelorder_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallelorder_predicate([kernel::AbstractPredicateKernel,] a, b, p, q) -&gt; Integer</code></pre><p>Returns</p><ul><li><code>1</code>: <code>q</code> is closer to the line <code>(a, b)</code> than <code>p</code>.</li><li><code>0</code>: <code>p</code> and <code>q</code> are equidistant from the line <code>(a, b)</code>.</li><li><code>-1</code>: <code>p</code> is closer to the line <code>(a, b)</code> than <code>q</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L161-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.angle_is_acute_predicate" href="#DelaunayTriangulation.angle_is_acute_predicate"><code>DelaunayTriangulation.angle_is_acute_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">angle_is_acute([kernel::AbstractPredicateKernel,] p, q, r)</code></pre><p>Tests if the angle opposite <code>(p, q)</code> in the triangle <code>(p, q, r)</code>,  meaning <code>∠prq</code>, is acute, returning:</p><ul><li><code>1</code>: <code>∠prq</code> is acute.</li><li><code>0</code>: <code>∠prq</code> is a right angle.</li><li><code>-1</code>: <code>∠prq</code> is obtuse.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L191-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.sameside_predicate" href="#DelaunayTriangulation.sameside_predicate"><code>DelaunayTriangulation.sameside_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sameside_predicate(a, b, p) -&gt; Integer</code></pre><p>Assuming all of <code>a, b, p</code> are collinear, returns</p><ul><li><code>1</code>: <code>a</code> and <code>b</code> are on the same side of <code>p</code> on the line.</li><li><code>0</code>: <code>a == p</code> or <code>b == p</code>.</li><li><code>-1</code>: <code>a</code> and <code>b</code> are on different sides of <code>p</code> on the line.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The difference in the argument order to ExactPredicates.jl is to match the convention that the  main point being tested is the last argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L228-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.meet_predicate" href="#DelaunayTriangulation.meet_predicate"><code>DelaunayTriangulation.meet_predicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meet_predicate([kernel::AbstractPredicateKernel], p, q, a, b) -&gt; Integer</code></pre><p>Returns</p><ul><li><code>1</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point.</li><li><code>0</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points. </li><li><code>-1</code>: Otherwise.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicate_definitions.jl#L255-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangle_orientation" href="#DelaunayTriangulation.triangle_orientation"><code>DelaunayTriangulation.triangle_orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k) -&gt; Certificate 
triangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T) -&gt; Certificate
triangle_orientation([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -&gt; Certificate</code></pre><p>Computes the orientation of the triangle <code>T = (i, j, k)</code> with correspondig coordinates <code>(p, q, r)</code>. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>PositivelyOriented</code>: The triangle is positively oriented.</li><li><code>Degenerate</code>: The triangle is degenerate, meaning the coordinates are collinear.</li><li><code>NegativelyOriented</code>: The triangle is negatively oriented.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circle" href="#DelaunayTriangulation.point_position_relative_to_circle"><code>DelaunayTriangulation.point_position_relative_to_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, c, p) -&gt; Certificate</code></pre><p>Given a circle through the coordinates <code>(a, b, c)</code>, assumed to be positively oriented, computes the position of <code>p</code> relative to the circle. Returns a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Inside</code>: <code>p</code> is inside the circle.</li><li><code>On</code>: <code>p</code> is on the circle.</li><li><code>Outside</code>: <code>p</code> is outside the triangle.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L36-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_line" href="#DelaunayTriangulation.point_position_relative_to_line"><code>DelaunayTriangulation.point_position_relative_to_line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p) -&gt; Certificate
point_position_relative_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, u) -&gt; Certificate</code></pre><p>Tests the position of <code>p</code> (or the vertex <code>u</code> of <code>tri</code>) relative to the edge <code>(a, b)</code> (or the edge with vertices <code>(i, j)</code> of <code>tri</code>), returning  a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is one of:</p><ul><li><code>Left</code>: <code>p</code> is to the left of the line.</li><li><code>Collinear</code>: <code>p</code> is on the line.</li><li><code>Right</code>: <code>p</code> is to the right of the line.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L56-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_closest_to_line" href="#DelaunayTriangulation.point_closest_to_line"><code>DelaunayTriangulation.point_closest_to_line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_closest_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p, q) -&gt; Certificate
point_closest_to_line([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, u, v) -&gt; Certificate</code></pre><p>Given a line <code>ℓ</code> through <code>(a, b)</code> (or through the vertices <code>(i, j)</code>), tests if <code>p</code> (or the vertex <code>u</code>) is closer to <code>ℓ</code> than <code>q</code> (or the vertex <code>v</code>), assuming that <code>p</code> and <code>q</code> are to the left of <code>ℓ</code>, returning a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is one of:</p><ul><li><code>Closer</code>: <code>p</code> is closer to <code>ℓ</code>.</li><li><code>Further</code>: <code>q</code> is closer to <code>ℓ</code>.</li><li><code>Equidistant</code>: <code>p</code> and <code>q</code> are the same distance from <code>ℓ</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_on_line_segment" href="#DelaunayTriangulation.point_position_on_line_segment"><code>DelaunayTriangulation.point_position_on_line_segment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_on_line_segment(a, b, p) -&gt; Certificate
point_position_on_line_segment(tri::Triangulation, i, j, u) -&gt; Certificate</code></pre><p>Given a point <code>p</code> (or vertex <code>u</code>) and the line segment <code>(a, b)</code> (or edge <code>(i, j)</code>), assuming <code>p</code> to be collinear with <code>a</code> and <code>b</code>, computes the position of <code>p</code> relative to the line segment. The returned value is a  <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a> which is one of:</p><ul><li><code>On</code>: <code>p</code> is on the line segment, meaning between <code>a</code> and <code>b</code>.</li><li><code>Degenerate</code>: Either <code>p == a</code> or <code>p == b</code>, i.e. <code>p</code> is one of the endpoints.</li><li><code>Left</code>: <code>p</code> is off and to the left of the line segment.</li><li><code>Right</code>: <code>p</code> is off and to the right of the line segment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.line_segment_intersection_type" href="#DelaunayTriangulation.line_segment_intersection_type"><code>DelaunayTriangulation.line_segment_intersection_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line_segment_intersection_type([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, a, b) -&gt; Certificate 
line_segment_intersection_type([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, u, v, i, j) -&gt; Certificate</code></pre><p>Given the coordinates <code>(p, q)</code> (or vertices <code>(u, v)</code>) and <code>(a, b)</code> (or vertices <code>(i, j)</code>) defining two line segments, tests the number of intersections between the two segments. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>None</code>: The line segments do not meet at any points.</li><li><code>Multiple</code>: The closed line segments <code>[p, q]</code> and <code>[a, b]</code> meet in one or several points.</li><li><code>Single</code>: The open line segments <code>(p, q)</code> and <code>(a, b)</code> meet in a single point.</li><li><code>Touching</code>: One of the endpoints is on <code>[a, b]</code>, but there are no other intersections.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L143-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_triangle" href="#DelaunayTriangulation.point_position_relative_to_triangle"><code>DelaunayTriangulation.point_position_relative_to_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, c, p) -&gt; Certificate
point_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, u) -&gt; Certificate
point_position_relative_to_triangle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, u) -&gt; Certificate</code></pre><p>Given a positively oriented triangle with coordinates <code>(a, b, c)</code> (or triangle <code>T = (i, j, k)</code> of <code>tri</code>), computes the position of <code>p</code> (or vertex <code>u</code>) relative to the triangle. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Outside</code>: <code>p</code> is outside of the triangle.</li><li><code>On</code>: <code>p</code> is on one of the edges.</li><li><code>Inside</code>: <code>p</code> is inside the triangle.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><div class="admonition is-info"><header class="admonition-header">Ghost triangles</header><div class="admonition-body"><p>If <code>T</code> is a ghost triangle, then it is not checked if the point is on any of the ghost edges,</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L204-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane" href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_oriented_outer_halfplane([kernel::AbstractPredicateKernel=AdaptiveKernel(),] a, b, p) -&gt; Certificate</code></pre><p>Given an edge with coordinates <code>(a, b)</code> and a point <code>p</code>,  tests the position of <code>p</code> relative to the oriented outer halfplane defined by <code>(a, b)</code>. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Outside</code>: <code>p</code> is outside of the oriented outer halfplane, meaning to the right of the line <code>(a, b)</code> or collinear with <code>a</code> and <code>b</code> but not on the line segment <code>(a, b)</code>.</li><li><code>On</code>: <code>p</code> is on the line segment <code>[a, b]</code>.</li><li><code>Inside</code>: <code>p</code> is inside of the oriented outer halfplane, meaning to the left of the line <code>(a, b)</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><p><strong>Extended help</strong></p><p>The oriented outer halfplane is the union of the open halfplane defined by the region to the left of the oriented line <code>(a, b)</code>, and the open line segment <code>(a, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L274-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_legal" href="#DelaunayTriangulation.is_legal"><code>DelaunayTriangulation.is_legal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_legal([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j) -&gt; Certificate 
is_legal([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r, s) -&gt; Certificate</code></pre><p>Tests if the edge <code>(p, q)</code> (or the edge <code>(i, j)</code> of <code>tri</code>) is legal, where the edge <code>(p, q)</code> is incident to two triangles <code>(p, q, r)</code> and <code>(q, p, s)</code>. In partiuclar, tests that <code>s</code> is not inside  the triangle through <code>(p, q, r)</code>. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Legal</code>: The edge <code>(p, q)</code> is legal.</li><li><code>Illegal</code>: The edge <code>(p, q)</code> is illegal.</li></ul><p>If the edge <code>(i, j)</code> is a segment of <code>tri</code> or is a ghost edge, then the edge is always legal.</p><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L309-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.triangle_line_segment_intersection" href="#DelaunayTriangulation.triangle_line_segment_intersection"><code>DelaunayTriangulation.triangle_line_segment_intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangle_line_segment_intersection([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r, a, b) -&gt; Certificate 
triangle_line_segment_intersection([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, u, v) -&gt; Certificate</code></pre><p>Classifies the intersection of the line segment <code>(a, b)</code> (or the edge <code>(u, v)</code> of <code>tri</code>) with the triangle <code>(p, q, r)</code> (or the triangle <code>(i, j, k)</code> of <code>tri</code>). The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Inside</code>: <code>(a, b)</code> is entirely inside <code>(p, q, r)</code>.</li><li><code>Single</code>: <code>(a, b)</code> has one endpoint inside <code>(p, q, r)</code>, and the other is outside.</li><li><code>Outside</code>: <code>(a, b)</code> is entirely outside <code>(p, q, r)</code>.</li><li><code>Touching</code>: <code>(a, b)</code> is on <code>(p, q, r)</code>&#39;s boundary, but not in its interior.</li><li><code>Multiple</code>: <code>(a, b)</code> passes entirely through <code>(p, q, r)</code>. This includes the case where a point is on the boundary of <code>(p, q, r)</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L353-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.find_edge" href="#DelaunayTriangulation.find_edge"><code>DelaunayTriangulation.find_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_edge([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, ℓ) -&gt; Edge</code></pre><p>Given a triangle <code>T = (i, j, k)</code> of <code>tri</code> and a vertex <code>ℓ</code> of <code>tri</code>, returns the edge of <code>T</code> that contains <code>ℓ</code>.  If no such edge exists, the edge <code>(k, i)</code> is returned. You can control the method for computing predicates  using the <code>kernel</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L513-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_circumcircle" href="#DelaunayTriangulation.point_position_relative_to_circumcircle"><code>DelaunayTriangulation.point_position_relative_to_circumcircle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_circumcircle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, ℓ) -&gt; Certificate
point_position_relative_to_circumcircle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, T, ℓ) -&gt; Certificate</code></pre><p>Tests the position of the vertex <code>ℓ</code> of <code>tri</code> relative to the circumcircle of the triangle <code>T = (i, j, k)</code>. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Outside</code>: <code>ℓ</code> is outside of the circumcircle of <code>T</code>.</li><li><code>On</code>: <code>ℓ</code> is on the circumcircle of <code>T</code>.</li><li><code>Inside</code>: <code>ℓ</code> is inside the circumcircle of <code>T</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><div class="admonition is-info"><header class="admonition-header">Ghost triangles</header><div class="admonition-body"><p>The circumcircle of a ghost triangle is defined as the oriented outer halfplane of the solid edge of the triangle. See <a href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>point_position_relative_to_oriented_outer_halfplane</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Weighted triangulations</header><div class="admonition-body"><p>If <code>tri</code> is a weighted triangulation, then an orientation test is instead applied, testing the orientation of the lifted companions of each point to determine if  <code>ℓ</code> is above or below the witness plane relative to <code>(i, j, k)</code>. For ghost triangles, the same rule applies, although if the vertex is on the solid edge of the ghost triangle then, in addition to checking <a href="#DelaunayTriangulation.point_position_relative_to_oriented_outer_halfplane"><code>point_position_relative_to_oriented_outer_halfplane</code></a>, we must check if the new vertex is not submerged by the adjoining solid triangle.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L535-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_witness_plane" href="#DelaunayTriangulation.point_position_relative_to_witness_plane"><code>DelaunayTriangulation.point_position_relative_to_witness_plane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_witness_plane([kernel::AbstractPredicateKernel=AdaptiveKernel(),] tri::Triangulation, i, j, k, ℓ) -&gt; Certificate</code></pre><p>Given a positively oriented triangle <code>T = (i, j, k)</code> of <code>tri</code> and a vertex <code>ℓ</code> of <code>tri</code>, returns the position of <code>ℓ</code> relative to the witness plane of <code>T</code>. The returned value is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Above</code>: <code>ℓ</code> is above the witness plane of <code>T</code>.</li><li><code>On</code>: <code>ℓ</code> is on the witness plane of <code>T</code>.</li><li><code>Below</code>: <code>ℓ</code> is below the witness plane of <code>T</code>.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><p><strong>Extended help</strong></p><p>The witness plane of a triangle is defined as the plane through the triangle <code>(i⁺, j⁺, k⁺)</code> where, for example, <code>pᵢ⁺ = (x, y, x^2 + y^2 - wᵢ)</code> is the lifted companion of <code>i</code>  and <code>(x, y)</code> are the coordinates of the <code>i</code>th vertex. Moreover, by the orientation of <code>ℓ</code> relative to this witness plane we are referring to <code>ℓ⁺</code>&#39;s position, not the plane point <code>ℓ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L586-L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.opposite_angle" href="#DelaunayTriangulation.opposite_angle"><code>DelaunayTriangulation.opposite_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opposite_angle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -&gt; Certificate</code></pre><p>Tests the angle opposite to the edge <code>(p, q)</code> in the triangle <code>(p, q, r)</code>, meaning <code>∠prq</code>. The returned value is a  <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Obtuse</code>: The angle opposite to <code>(p, q)</code> is obtuse.</li><li><code>Right</code>: The angle opposite to <code>(p, q)</code> is a right angle.</li><li><code>Acute</code>: The angle opposite to <code>(p, q)</code> is acute.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><div class="admonition is-info"><header class="admonition-header">Angle between two vectors</header><div class="admonition-body"><p>This function computes <code>(p - r) ⋅ (q - r)</code>. If you want the angle between vectors <code>a = pq</code> and <code>b = pr</code>, then you should use <code>opposite_angle(r, q, p) = (r - p) ⋅ (q - p)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L613-L631">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_diametral_circle" href="#DelaunayTriangulation.point_position_relative_to_diametral_circle"><code>DelaunayTriangulation.point_position_relative_to_diametral_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_diametral_circle([kernel::AbstractPredicateKernel=AdaptiveKernel(),] p, q, r) -&gt; Certificate</code></pre><p>Given an edge <code>(p, q)</code> and a point <code>r</code>, returns the position of <code>r</code> relative to the diametral circle of <code>(p, q)</code>. The returned value  is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Inside</code>: <code>r</code> is inside the diametral circle.</li><li><code>On</code>: <code>r</code> is on the diametral circle.</li><li><code>Outside</code>: <code>r</code> is outside the diametral circle.</li></ul><p>The <code>kernel</code> argument determines how this result is computed, and should be  one of <a href="#DelaunayTriangulation.ExactKernel"><code>ExactKernel</code></a>, <a href="#DelaunayTriangulation.FastKernel"><code>FastKernel</code></a>, and <a href="#DelaunayTriangulation.AdaptiveKernel"><code>AdaptiveKernel</code></a> (the default). See the documentation for more information about these choices.</p><p><strong>Extended help</strong></p><p>The check is done by noting that a point is in the diametral circle if, and only if, the angle at <code>r</code> is obtuse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L638-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.point_position_relative_to_diametral_lens" href="#DelaunayTriangulation.point_position_relative_to_diametral_lens"><code>DelaunayTriangulation.point_position_relative_to_diametral_lens</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_position_relative_to_diametral_lens(p, q, r, lens_angle=30.0) -&gt; Certificate</code></pre><p>Given an edge <code>(p, q)</code> and a point <code>r</code>, returns the position of <code>r</code> relative to the diametral lens of <code>(p, q)</code> with lens angle <code>lens_angle</code> (in degrees). The returned value  is a <a href="#DelaunayTriangulation.Certificate"><code>Certificate</code></a>, which is one of:</p><ul><li><code>Inside</code>: <code>r</code> is inside the diametral lens.</li><li><code>On</code>: <code>r</code> is on the diametral lens.</li><li><code>Outside</code>: <code>r</code> is outside the diametral lens.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function assumes that the lens angle is at most 45°.</p></div></div><p><strong>Extended help</strong></p><p>The diametral lens is slightly similar to a diametral circle. Let us first define the standard definition of a diametral lens, where <code>lens_angle = 30°</code>, and then we define its  generalisation. The standard definition was introduced by Shewchuk in 2002 in <a href="https://doi.org/10.1016/S0925-7721(01)00047-5">this paper</a>, and the generalisation was originally  described in Section 3.4 of Shewchuk&#39;s 1997 PhD thesis <a href="https://www.cs.cmu.edu/~quake-papers/delaunay-refinement.pdf">here</a> (as was the standard definition, of course).</p><p>Standard definition: Let the segment be <code>s ≔ (p, q)</code> and let <code>ℓ</code> be the perpendicular bisector of <code>s</code>. Define two circles <code>C⁺</code> and <code>C⁻</code> whose centers lie left and right  of <code>s</code>, respectively, both the same distance away from the midpoint <code>m = (p + q)/2</code>. By placing each disk a distance <code>|s|/(2√3)</code> away from <code>m</code> and extending the disks so that  they both touch <code>p</code> and <code>q</code>, meaning they each have radius <code>|s|/√3</code>, we obtain disks that touch <code>p</code> and <code>q</code> as well as the center of the other disk. The intersection of the two  disks defines the diametral lens. The lens angle associated with this lens is <code>30°</code>, as we could draw lines between <code>p</code> and <code>q</code> and the poles of the disks to form isosceles triangles  on each side, giving angles of <code>30°</code> at <code>p</code> and <code>q</code>.</p><p>Generalised definition: The generalisation of the above definition aims to generalise the lens angle to some angle <code>θ</code>. In particular, let us draw a line from <code>p</code> towards some point  <code>u</code> which is left of <code>s</code> and on the perpendicular bisector, where the line is at an angle <code>θ</code>. This defines a triplet of points <code>(p, q, u)</code> from which we can define a circle, and similarly for a point <code>v</code> right of <code>s</code>. The intersection of these two circles is the diametral lens with angle <code>θ</code>. We can also figure out how far <code>u</code> is along the perpendicular bisector, i.e. how far away it is from <code>(p + q)/2</code>, using basic trigonometry. Let <code>m = (p +  q)/2</code>, and consider the triangle <code>△pmu</code>. The side lengths of this triangle are <code>|pm| = |s|/2</code>, <code>|mu| ≔ b</code>, and <code>|up| ≔ c</code>. Let us first compute <code>c</code>.  We have <code>cos(θ) = |pm|/|up| = |s|/(2c)</code>, and so <code>c = |s|/(2cos(θ))</code>. So, <code>sin(θ) = |mu|/|up| = b/c</code>, which gives <code>b = csin(θ) = |s|sin(θ)/(2cos(θ)) = |s|tan(θ)/2</code>. So, <code>u</code> is a distance <code>|s|tan(θ)/2</code> from the midpoint. Notice that in the case <code>θ = 30°</code>, <code>tan(θ) = √3/3</code>, giving <code>b = |s|√3/6 = |s|/(2√3)</code>, which is the same as the standard definition.</p><p>To test if a point <code>r</code> is inside the diametral lens with lens angle <code>θ°</code>, we simply have to check the angle  at that point, i.e. the angle at <code>r</code> in the triangle <code>pqr</code>. If this angle is greater than <code>180° - 2θ°</code>, then <code>r</code> is inside of the lens. This result  comes from <a href="https://doi.org/10.1016/S0925-7721(01)00047-5">Shewchuk (2002)</a>. Note that this is the same as a diametral circle in the case <code>θ° = 45°</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/predicates.jl#L667-L702">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_vertex" href="#DelaunayTriangulation.is_ghost_vertex"><code>DelaunayTriangulation.is_ghost_vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_vertex(i) -&gt; Bool</code></pre><p>Tests if <code>i</code> is a ghost vertex, meaning <code>i ≤ -1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_edge" href="#DelaunayTriangulation.is_boundary_edge"><code>DelaunayTriangulation.is_boundary_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_boundary_edge(tri::Triangulation, ij) -&gt; Bool
is_boundary_edge(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Tests if the edge <code>(i, j)</code> is a boundary edge of <code>tri</code>, meaning <code>(j, i)</code> adjoins a ghost vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_triangle" href="#DelaunayTriangulation.is_boundary_triangle"><code>DelaunayTriangulation.is_boundary_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_boundary_triangle(tri::Triangulation, T) -&gt; Bool
is_boundary_triangle(tri::Triangulation, i, j, k) -&gt; Bool</code></pre><p>Returns <code>true</code> if the triangle <code>T = (i, j, k)</code> of <code>tri</code> has an edge on the boundary, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_edge" href="#DelaunayTriangulation.is_ghost_edge"><code>DelaunayTriangulation.is_ghost_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_edge(ij) -&gt; Bool 
is_ghost_edge(i, j) -&gt; Bool</code></pre><p>Tests if the edge <code>(i, j)</code> is a ghost edge, meaning <code>i</code> or <code>j</code> is a ghost vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_ghost_triangle" href="#DelaunayTriangulation.is_ghost_triangle"><code>DelaunayTriangulation.is_ghost_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_ghost_triangle(T) -&gt; Bool
is_ghost_triangle(i, j, k) -&gt; Bool</code></pre><p>Tests if <code>T = (i, j, k)</code> is a ghost triangle, meaning <code>i</code>, <code>j</code> or <code>k</code> is a ghost vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_boundary_node" href="#DelaunayTriangulation.is_boundary_node"><code>DelaunayTriangulation.is_boundary_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_boundary_node(tri::Triangulation, i) -&gt; (Bool, Vertex)</code></pre><p>Tests if the vertex <code>i</code> is a boundary node of <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri::Triangulation</code>: The <a href="../../extended/data_structures/#Triangulation"><code>Triangulation</code></a>.</li><li><code>i</code>: The vertex to test. </li></ul><p><strong>Outputs</strong></p><ul><li><code>flag</code>: <code>true</code> if <code>i</code> is a boundary node, and <code>false</code> otherwise.</li><li><code>g</code>: Either the ghost vertex corresponding with the section that <code>i</code> lives on if <code>flag</code> is true, or 0 otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/boundaries_and_ghosts.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_segment" href="#DelaunayTriangulation.contains_segment"><code>DelaunayTriangulation.contains_segment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains_segment(tri::Triangulation, ij) -&gt; Bool 
contains_segment(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>(i, j)</code> is a segment in <code>tri</code>, and <code>false</code> otherwise. Both <code>(i, j)</code> and <code>(j, i)</code> are checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/segments.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.contains_triangle" href="#DelaunayTriangulation.contains_triangle"><code>DelaunayTriangulation.contains_triangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains_triangle(T, V) -&gt; (Triangle, Bool)</code></pre><p>Check if the collection of triangles <code>V</code> contains the triangle <code>T</code> up to rotation. The <code>Triangle</code> returned is the triangle in <code>V</code> that is equal to <code>T</code> up to rotation,  or <code>T</code> if no such triangle exists. The <code>Bool</code> is <code>true</code> if <code>V</code> contains <code>T</code>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; V = Set(((1, 2, 3), (4, 5, 6), (7, 8, 9)))
Set{Tuple{Int64, Int64, Int64}} with 3 elements:
  (7, 8, 9)
  (4, 5, 6)
  (1, 2, 3)

julia&gt; DelaunayTriangulation.contains_triangle((1, 2, 3), V)
((1, 2, 3), true)

julia&gt; DelaunayTriangulation.contains_triangle((2, 3, 1), V)
((1, 2, 3), true)

julia&gt; DelaunayTriangulation.contains_triangle((10, 18, 9), V)
((10, 18, 9), false)

julia&gt; DelaunayTriangulation.contains_triangle(9, 7, 8, V)
((7, 8, 9), true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/geometric_primitives/triangles.jl#L309-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.edge_exists" href="#DelaunayTriangulation.edge_exists"><code>DelaunayTriangulation.edge_exists</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_exists(tri::Triangulation, ij) -&gt; Bool 
edge_exists(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Tests if the edge <code>(i, j)</code> is in <code>tri</code>, returning <code>true</code> if so and <code>false</code> otherwise. </p><p>See also <a href="#DelaunayTriangulation.unoriented_edge_exists"><code>unoriented_edge_exists</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.unoriented_edge_exists" href="#DelaunayTriangulation.unoriented_edge_exists"><code>DelaunayTriangulation.unoriented_edge_exists</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unoriented_edge_exists(tri::Triangulation, ij) -&gt; Bool 
unoriented_edge_exists(tri::Triangulation, i, j) -&gt; Bool</code></pre><p>Tests if the unoriented edge <code>(i, j)</code> is in <code>tri</code>, returning <code>true</code> if so and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_ghost_triangles" href="#DelaunayTriangulation.has_ghost_triangles"><code>DelaunayTriangulation.has_ghost_triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_ghost_triangles(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has ghost triangles, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_constrained" href="#DelaunayTriangulation.is_constrained"><code>DelaunayTriangulation.is_constrained</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_constrained(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has constrained edges (segments), and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_curves" href="#DelaunayTriangulation.has_multiple_curves"><code>DelaunayTriangulation.has_multiple_curves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_multiple_curves(boundary_nodes) -&gt; Bool</code></pre><p>Check if <code>boundary_nodes</code> has multiple curves.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.has_multiple_curves([1, 2, 3, 1])
false

julia&gt; DelaunayTriangulation.has_multiple_curves([[1, 2, 3], [3, 4, 1]])
false

julia&gt; DelaunayTriangulation.has_multiple_curves([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/geometric_primitives/boundary_nodes.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_multiple_sections" href="#DelaunayTriangulation.has_multiple_sections"><code>DelaunayTriangulation.has_multiple_sections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_multiple_sections(boundary_nodes) -&gt; Bool</code></pre><p>Check if <code>boundary_nodes</code> has multiple sections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DelaunayTriangulation

julia&gt; DelaunayTriangulation.has_multiple_sections([1, 2, 3, 1])
false

julia&gt; DelaunayTriangulation.has_multiple_sections([[1, 2, 3], [3, 4, 1]])
true

julia&gt; DelaunayTriangulation.has_multiple_sections([[[1, 2, 3], [3, 4, 1]], [[5, 6, 7, 8, 5]]])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/geometric_primitives/boundary_nodes.jl#L45-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.has_boundary_nodes" href="#DelaunayTriangulation.has_boundary_nodes"><code>DelaunayTriangulation.has_boundary_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_boundary_nodes(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> has boundary nodes, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_weighted" href="#DelaunayTriangulation.is_weighted"><code>DelaunayTriangulation.is_weighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_weighted(weights) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>weights</code> represents a set of <code>weights</code> that are not all zero, and <code>false</code> otherwise. Note that even for vectors like <code>zeros(n)</code>, this will return <code>true</code>; by default, <code>false</code> is returned only for  <code>weights = ZeroWeight()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/weights.jl#L45-L51">source</a></section><section><div><pre><code class="language-julia hljs">is_weighted(tri::Triangulation) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>tri</code> is weighted, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/data_structures/triangulation/methods/checks.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_negativelyoriented" href="#DelaunayTriangulation.is_negativelyoriented"><code>DelaunayTriangulation.is_negativelyoriented</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_negativelyoriented(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>NegativelyOriented</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DelaunayTriangulation.is_positivelyoriented" href="#DelaunayTriangulation.is_positivelyoriented"><code>DelaunayTriangulation.is_positivelyoriented</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_positivelyoriented(cert::Certificate) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>cert</code> is <code>PositivelyOriented</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl/blob/551972e7a77f482bba631109dc33b9c78a5f4a8c/src/predicates/certificate.jl#L69-L73">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../point_location/">« Point Location</a><a class="docs-footer-nextpage" href="../statistics/">Triangulation Statistics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 29 July 2024 14:19">Monday 29 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
